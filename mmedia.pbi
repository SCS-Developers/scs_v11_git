; File: mmedia.pbi

EnableExplicit

Procedure addOutput(nOutputArrayIndex, sDesc.s, sSpeaker.s, nSpeakersFlag, nChans = 1, bIgnoreSpkrArrangement = #False, nFirstASIOChannel.l = 0)
  PROCNAMEC()

  If ArraySize(gaOutputArray()) < nOutputArrayIndex
    ReDim gaOutputArray(nOutputArrayIndex + 10)
  EndIf
  With gaOutputArray(nOutputArrayIndex)
    \sDesc = sDesc
    \sSpeaker = sSpeaker
    \nSpeakersFlag = nSpeakersFlag
    \nChans = nChans
    \bIgnoreSpkrArrangement = bIgnoreSpkrArrangement
    \nFirstASIOChannel = nFirstASIOChannel
  EndWith
  If nOutputArrayIndex > gnMaxOutputArrayIndex
    gnMaxOutputArrayIndex = nOutputArrayIndex
  EndIf
EndProcedure

Procedure buildOutputArray()
  PROCNAMEC()

  ReDim gaOutputArray(42)

  addOutput(0, "Left and Right (stereo)", "STEREO", 0, 2, #False, 0)
  addOutput(1, "Left (mono)", "LEFT(M)", #BASS_SPEAKER_FRONTLEFT, 1, #False, 0)    ; must include FRONT, as LEFT and RIGHT ignored without FRONT or a similar position
  addOutput(2, "Right (mono)", "RIGHT(M)", #BASS_SPEAKER_FRONTRIGHT, 1, #False, 1)
  addOutput(3, "5.1 Surround (6 channels)", "5.1SURROUND(6)", 0, 6)
  addOutput(4, "7.1 Surround (8 channels)", "7.1SURROUND(8)", 0, 8)
  addOutput(5, "Front (stereo)", "FRONT", #BASS_SPEAKER_FRONT, 2, #False, 0)
  addOutput(6, "Left-Front (mono)", "FRONTLEFT(M)", #BASS_SPEAKER_FRONTLEFT, 1, #False, 0)
  addOutput(7, "Right-Front (mono)", "FRONTRIGHT(M)", #BASS_SPEAKER_FRONTRIGHT, 1, #False, 1)
  addOutput(8, "Rear/Side (stereo)", "REAR", #BASS_SPEAKER_REAR, 2, #False, 2)
  addOutput(9, "Left-Rear/Side (mono)", "REARLEFT(M)", #BASS_SPEAKER_REARLEFT, 1, #False, 2)
  addOutput(10, "Right-Rear/Side (mono)", "REARRIGHT(M)", #BASS_SPEAKER_REARRIGHT, 1, #False, 3)
  addOutput(11, "5.1 Center & LFE (stereo)", "CENLFE", #BASS_SPEAKER_CENLFE, 2, #False, 4)
  addOutput(12, "5.1 Center (mono)", "CENTER(M)", #BASS_SPEAKER_CENTER, 1, #False, 4)
  addOutput(13, "5.1 LFE (mono)", "LFE(M)", #BASS_SPEAKER_LFE, 1, #False, 5)
  addOutput(14, "7.1 Rear Center (stereo)", "REAR2", #BASS_SPEAKER_REAR2, 2, #False, 6)
  addOutput(15, "7.1 Left-Rear Center (mono)", "REAR2LEFT(M)", #BASS_SPEAKER_REAR2LEFT, 1, #False, 6)
  addOutput(16, "7.1 Right-Rear Center (mono)", "REAR2RIGHT(M)", #BASS_SPEAKER_REAR2RIGHT, 1, #False, 7)
  addOutput(17, "Outputs 1/2 (stereo)", "OUTPUT1/2", BASS_SPEAKER_N(1), 2, #True, 0)
  addOutput(18, "Output 1 (mono)", "OUTPUT1(M)", BASS_SPEAKER_N(1) | #BASS_SPEAKER_LEFT, 1, #True, 0)
  addOutput(19, "Output 2 (mono)", "OUTPUT2(M)", BASS_SPEAKER_N(1) | #BASS_SPEAKER_RIGHT, 1, #True, 1)
  addOutput(20, "Outputs 3/4 (stereo)", "OUTPUT3/4", BASS_SPEAKER_N(2), 2, #True, 2)
  addOutput(21, "Output 3 (mono)", "OUTPUT3(M)", BASS_SPEAKER_N(2) | #BASS_SPEAKER_LEFT, 1, #True, 2)
  addOutput(22, "Output 4 (mono)", "OUTPUT4(M)", BASS_SPEAKER_N(2) | #BASS_SPEAKER_RIGHT, 1, #True, 3)
  addOutput(23, "Outputs 5/6 (stereo)", "OUTPUT5/6", BASS_SPEAKER_N(3), 2, #True, 4)
  addOutput(24, "Output 5 (mono)", "OUTPUT5(M)", BASS_SPEAKER_N(3) | #BASS_SPEAKER_LEFT, 1, #True, 4)
  addOutput(25, "Output 6 (mono)", "OUTPUT6(M)", BASS_SPEAKER_N(3) | #BASS_SPEAKER_RIGHT, 1, #True, 5)
  addOutput(26, "Outputs 7/8 (stereo)", "OUTPUT7/8", BASS_SPEAKER_N(4), 2, #True, 6)
  addOutput(27, "Output 7 (mono)", "OUTPUT7(M)", BASS_SPEAKER_N(4) | #BASS_SPEAKER_LEFT, 1, #True, 6)
  addOutput(28, "Output 8 (mono)", "OUTPUT8(M)", BASS_SPEAKER_N(4) | #BASS_SPEAKER_RIGHT, 1, #True, 7)
  addOutput(29, "Outputs 9/10 (stereo)", "OUTPUT9/10", BASS_SPEAKER_N(5), 2, #True, 8)
  addOutput(30, "Output 9 (mono)", "OUTPUT9(M)", BASS_SPEAKER_N(5) | #BASS_SPEAKER_LEFT, 1, #True, 8)
  addOutput(31, "Output 10 (mono)", "OUTPUT10(M)", BASS_SPEAKER_N(5) | #BASS_SPEAKER_RIGHT, 1, #True, 9)
  addOutput(32, "Outputs 11/12 (stereo)", "OUTPUT11/12", BASS_SPEAKER_N(6), 2, #True, 10)
  addOutput(33, "Output 11 (mono)", "OUTPUT11(M)", BASS_SPEAKER_N(6) | #BASS_SPEAKER_LEFT, 1, #True, 10)
  addOutput(34, "Output 12 (mono)", "OUTPUT12(M)", BASS_SPEAKER_N(6) | #BASS_SPEAKER_RIGHT, 1, #True, 11)
  addOutput(35, "Outputs 13/14 (stereo)", "OUTPUT13/14", BASS_SPEAKER_N(7), 2, #True, 12)
  addOutput(36, "Output 13 (mono)", "OUTPUT13(M)", BASS_SPEAKER_N(7) | #BASS_SPEAKER_LEFT, 1, #True, 12)
  addOutput(37, "Output 14 (mono)", "OUTPUT14(M)", BASS_SPEAKER_N(7) | #BASS_SPEAKER_RIGHT, 1, #True, 13)
  addOutput(38, "Outputs 15/16 (stereo)", "OUTPUT15/16", BASS_SPEAKER_N(8), 2, #True, 14)
  addOutput(39, "Output 15 (mono)", "OUTPUT15(M)", BASS_SPEAKER_N(8) | #BASS_SPEAKER_LEFT, 1, #True, 14)
  addOutput(40, "Output 16 (mono)", "OUTPUT16(M)", BASS_SPEAKER_N(8) | #BASS_SPEAKER_RIGHT, 1, #True, 15)
  addOutput(41, "Quadraphonic (4 channels)", "QUAD(4)", 0, 4)
  addOutput(42, "(Device not available)", "DEV_NA", 0, 0)
  
EndProcedure

Procedure.f calcBVLevel(pType, nTime, nPos, fOriginalBVLevel.f, fTargetBVLevel.f, fTrimFactor.f)
  PROCNAMEC()
  ; nTime = time of fade-in / fade-out / level change
  ; nPos  = position with that fade-in / fade-out / level change
  Protected fNewLevel.f, nWorkPos
  Protected dPos.d, dTime.d, dFactor.d, dDelta.d
  Protected nOrigSliderValue, nTargetSliderValue
  Static dBaseFadeTime.d
  Static dBaseFadeFactor.d
  
  CompilerIf #cTraceSetLevels
    debugMsg(sProcName, #SCS_START + ", pType=" + decodeFadeType(pType) + ", nTime=" + nTime + ", nPos=" + nPos + ", fOriginalBVLevel=" + traceLevel(fOriginalBVLevel) + ", fTargetBVLevel=" + traceLevel(fTargetBVLevel))
  CompilerEndIf
  
  grMMedia\bMMFinalSlide = #False
  
  ; if time of fade / level change is less than the timer interval then no point in calculating levels - just set level as target level and exit
  If nTime < gnTimerInterval
    ; debugMsg(sProcName, "nTime=" + nTime + ", gnTimerInterval=" + gnTimerInterval)
    ProcedureReturn fTargetBVLevel
  EndIf
  
  ; adjust pos if necessary to be used in calculations to be within the window gnTimerInterval to nTime
  nWorkPos = nPos
  If nWorkPos < gnTimerInterval
    nWorkPos = gnTimerInterval
  EndIf
  
  ; if at end of level change then set level as target level and exit
  If nWorkPos >= nTime
    grMMedia\bMMFinalSlide = #True
    ; debugMsg(sProcName, "nTime=" + nTime + ", nPos=" + nPos + ", nWorkPos=" + nWorkPos + ", grMMedia\bMMFinalSlide=" + strB(grMMedia\bMMFinalSlide))
    ProcedureReturn fTargetBVLevel
  EndIf
  
  dPos = nWorkPos     ; hold position as double
  dTime = nTime       ; hold time as double
  
  Select pType
    Case #SCS_FADE_LIN, #SCS_FADE_LIN_SE
      ; ------------------------------------------- linear
      ; debugMsg(sProcName, "-------- LIN")
      If fTargetBVLevel >= fOriginalBVLevel
        ; fading up / fading in
        dDelta = (fTargetBVLevel - fOriginalBVLevel) * dPos / dTime
        fNewLevel = fOriginalBVLevel + dDelta
        If fNewLevel > fTargetBVLevel
          fNewLevel = fTargetBVLevel
        EndIf
        ; debugMsg(sProcName, "-------- LIN fading in, fNewLevel=" + formatLevel(fNewLevel))
        
      Else
        ; fading down / fading out
        dDelta = (fOriginalBVLevel - fTargetBVLevel) * (dTime - dPos) / dTime
        fNewLevel = fTargetBVLevel + dDelta
        If fNewLevel > fOriginalBVLevel
          fNewLevel = fOriginalBVLevel
        EndIf
        ; debugMsg(sProcName, "-------- LIN fading out, fNewLevel=" + formatLevel(fNewLevel))
        
      EndIf
      
    Case #SCS_FADE_LOG, #SCS_FADE_LOG_SE
      ; ------------------------------------------- log
      ; debugMsg(sProcName, "-------- LOG")
      If dBaseFadeTime <> dTime
        dBaseFadeFactor = Log(gdTimerInterval / dTime) * -1
        dBaseFadeTime = dTime
      EndIf
      
      If fTargetBVLevel >= fOriginalBVLevel
        ; fading up / fading in
        dFactor = Log((dTime - dPos) / dTime) * -1
        dDelta = (fTargetBVLevel - fOriginalBVLevel) * dFactor / dBaseFadeFactor
        fNewLevel = fOriginalBVLevel + dDelta
        If fNewLevel > fTargetBVLevel
          fNewLevel = fTargetBVLevel
        EndIf
        ; debugMsg(sProcName, "-------- LOG fading in, dFactor=" + StrD(dFactor,4) + ", fNewLevel=" + formatLevel(fNewLevel))
        
      Else
        ; fading down / fading out
        dFactor = Log(dPos / dTime) * -1
        dDelta = (fOriginalBVLevel - fTargetBVLevel) * dFactor / dBaseFadeFactor
        fNewLevel = fTargetBVLevel + dDelta
        If fNewLevel > fOriginalBVLevel
          fNewLevel = fOriginalBVLevel
        EndIf
        ; debugMsg(sProcName, "-------- LOG fading out, dFactor=" + StrD(dFactor,4) + ", fNewLevel=" + formatLevel(fNewLevel))
        
      EndIf
      
    Case #SCS_FADE_STD
      ; ------------------------------------------- standard
      ; debugMsg(sProcName, "-------- STD")
      nOrigSliderValue = SLD_BVLevelToSliderValue(fOriginalBVLevel, fTrimFactor)
      nTargetSliderValue = SLD_BVLevelToSliderValue(fTargetBVLevel, fTrimFactor)
      ; debugMsg(sProcName, "nOrigSliderValue=" + nOrigSliderValue + ", nTargetSliderValue=" + nTargetSliderValue + ", dTime=" + StrD(dTime,3) + ", dPos=" + StrD(dPos,3))
      If nTargetSliderValue >= nOrigSliderValue
        ; fading up / fading in
        dDelta = (nTargetSliderValue - nOrigSliderValue) * dPos / dTime
        fNewLevel = SLD_SliderValueToBVLevel(nOrigSliderValue + dDelta, fTrimFactor)
        If fNewLevel > fTargetBVLevel
          fNewLevel = fTargetBVLevel
        EndIf
        ; debugMsg(sProcName, "-------- STD fading in, fNewLevel=" + formatLevel(fNewLevel))
        
      Else
        ; fading down / fading out
        ; Added 30Jun2020 11.8.3.2aj because the 'end sync' seems to occur about .25 second before the calculated end time, tested on a 4-second fade out
        If dTime > 1.5 And dTime >= dPos
          dTime - 0.25
        EndIf
        ; End added 30Jun2020 11.8.3.2aj
        dDelta = (nOrigSliderValue - nTargetSliderValue) * (dTime - dPos) / dTime
        fNewLevel = SLD_SliderValueToBVLevel(nTargetSliderValue + dDelta, fTrimFactor)
        If fNewLevel < fTargetBVLevel
          fNewLevel = fTargetBVLevel
        EndIf
        ; debugMsg(sProcName, "-------- STD fading out, nOrigSliderValue=" + nOrigSliderValue + ", nTargetSliderValue=" + nTargetSliderValue + ", dTime=" + dTime + ", dPos=" + dPos + ", dDelta=" + dDelta + ", fNewLevel=" + traceLevel(fNewLevel))
        
      EndIf
      
  EndSelect
  
  If fNewLevel <= grLevels\fMinBVLevel
    fNewLevel = #SCS_MINVOLUME_SINGLE
  ElseIf fNewLevel > grLevels\fMaxBVLevel
    fNewLevel = grLevels\fMaxBVLevel
  EndIf
  
  CompilerIf #cTraceSetLevels
    debugMsg(sProcName, #SCS_END + ", returning " + traceLevel(fNewLevel))
  CompilerEndIf
  ProcedureReturn fNewLevel
EndProcedure

Procedure.f calcPLLevel(pAudPtr, pDevice)
  PROCNAMECA(pAudPtr)
  Protected fWorkLevel1.f, fWorkLevel2.f, nLCCtrlSubPtr
  Protected nFadeInPos, nFadeOutPos, fMaxLevel.f
  Protected fTrimFactor.f
  Protected d
  Protected fNewPan.f
  Protected nReqdSubFadeOutTime

  fNewPan = #SCS_NOPANCHANGE_SINGLE
  
  With aAud(pAudPtr)
    d = pDevice
    fMaxLevel = \fAudPlayBVLevel[d]
    fTrimFactor = aSub(\nSubIndex)\fSubTrimFactor[d]
    If gbFadingEverything
      nReqdSubFadeOutTime = gnFadeEverythingTime
    Else
      nReqdSubFadeOutTime = aSub(\nSubIndex)\nPLCurrFadeOutTime
    EndIf
    
    CompilerIf #cTraceSetLevels
      debugMsg(sProcName, "pDevice=" + pDevice + ", \nAudState=" + decodeCueState(\nAudState) +
                          ", \nCurrFadeInTime=" + \nCurrFadeInTime + ", \nCurrFadeOutTime=" + \nCurrFadeOutTime +
                          ", fMaxLevel=" + formatLevel(fMaxLevel))
      debugMsg(sProcName, "aSub(" + getSubLabel(\nSubIndex) + ")\nPLCurrFadeInTime=" + aSub(\nSubIndex)\nPLCurrFadeInTime + ", \nPLCurrFadeOutTime=" + aSub(\nSubIndex)\nPLCurrFadeOutTime)
      If gbFadingEverything
        debugMsg(sProcName, "gbFadingEverything=" + strB(gbFadingEverything) + ", nReqdSubFadeOutTime=" + nReqdSubFadeOutTime + ", \bTimeFadeOutStartedSet=" + strB(\bTimeFadeOutStartedSet) +
                            ", \qTimeFadeOutStarted=" + traceTime(\qTimeFadeOutStarted))
      EndIf
    CompilerEndIf
    
    If (\nAudState = #SCS_CUE_PLAYING) Or ((\nAudState = #SCS_CUE_PL_READY) And (\nCurrFadeInTime <= 0))
      fWorkLevel1 = fMaxLevel ; \fBVLevel[d]
      
    ElseIf (\nAudState < #SCS_CUE_FADING_IN)  ; eg ready, or countdown
      If (\nCurrFadeInTime <= 0)
        fWorkLevel1 = fMaxLevel ; \fBVLevel[d]
      EndIf
      
    ElseIf \nAudState = #SCS_CUE_FADING_IN
      If \bTimeFadeInStartedSet
        nFadeInPos = (gqTimeNow - \qTimeFadeInStarted) - (\nTotalTimeOnPause - \nPreFadeInTimeOnPause)
      Else
        ; shouldn't get here
        nFadeInPos = 0 - (\nTotalTimeOnPause - \nPreFadeInTimeOnPause)
      EndIf
      fWorkLevel1 = calcBVLevel(#SCS_FADE_STD, aSub(\nSubIndex)\nPLCurrFadeInTime, nFadeInPos, #SCS_MINVOLUME_SINGLE, fMaxLevel, fTrimFactor)
      CompilerIf #cTraceSetLevels
        debugMsg(sProcName, "\nAudState=" + decodeCueState(\nAudState) + ", nFadeInPos=" + nFadeInPos + ", \qTimeFadeInStarted=" + traceTime(\qTimeFadeInStarted) + ", fWorkLevel1=" + formatLevel(fWorkLevel1))
      CompilerEndIf
      
    ElseIf \nAudState = #SCS_CUE_TRANS_FADING_IN
      If \bTimeFadeInStartedSet
        nFadeInPos = (gqTimeNow - \qTimeFadeInStarted) - (\nTotalTimeOnPause - \nPreFadeInTimeOnPause)
      Else
        ; shouldn't get here
        nFadeInPos = 0 - (\nTotalTimeOnPause - \nPreFadeInTimeOnPause)
      EndIf
      fWorkLevel1 = calcBVLevel(\nFadeInType, \nCurrFadeInTime, nFadeInPos, #SCS_MINVOLUME_SINGLE, fMaxLevel, fTrimFactor)
      CompilerIf #cTraceSetLevels
        debugMsg(sProcName, "\nAudState=" + decodeCueState(\nAudState) + ", nFadeInPos=" + nFadeInPos + ", \nCurrFadeInTime=" + \nCurrFadeInTime + ", fWorkLevel1=" + formatLevel(fWorkLevel1))
      CompilerEndIf
      
    ElseIf \nAudState = #SCS_CUE_TRANS_FADING_OUT
      If \bTimeFadeOutStartedSet
        nFadeOutPos = (gqTimeNow - \qTimeFadeOutStarted) - (\nTotalTimeOnPause - \nPreFadeOutTimeOnPause)
      Else
        ; shouldn't get here
        nFadeOutPos = 0 - (\nTotalTimeOnPause - \nPreFadeOutTimeOnPause)
      EndIf
      fWorkLevel1 = calcBVLevel(\nFadeOutType, \nCurrFadeOutTime, nFadeOutPos, \fBVLevelWhenFadeOutStarted[d], #SCS_MINVOLUME_SINGLE, fTrimFactor)
      CompilerIf #cTraceSetLevels
        debugMsg(sProcName, "\nAudState=" + decodeCueState(\nAudState) + ", nFadeOutPos=" + nFadeOutPos + ", \nCurrFadeOutTime=" + \nCurrFadeOutTime + ", fWorkLevel1=" + formatLevel(fWorkLevel1))
      CompilerEndIf
      
    ElseIf \nAudState = #SCS_CUE_FADING_OUT
      If \bTimeFadeOutStartedSet
        nFadeOutPos = (gqTimeNow - \qTimeFadeOutStarted) - (\nTotalTimeOnPause - \nPreFadeOutTimeOnPause)
      Else
        ; shouldn't get here
        nFadeOutPos = 0 - (\nTotalTimeOnPause - \nPreFadeOutTimeOnPause)
      EndIf
;       fWorkLevel1 = calcBVLevel(#SCS_FADE_STD, aSub(\nSubIndex)\nPLCurrFadeOutTime, nFadeOutPos, \fBVLevelWhenFadeOutStarted[d], #SCS_MINVOLUME_SINGLE, fTrimFactor)
;       CompilerIf #cTraceSetLevels
;         debugMsg(sProcName, "\nAudState=" + decodeCueState(\nAudState) + ", nFadeOutPos=" + nFadeOutPos +
;                             ", aSub(" + getSubLabel(\nSubIndex) + ")\nPLCurrFadeOutTime=" + aSub(\nSubIndex)\nPLCurrFadeOutTime + ", fWorkLevel1=" + formatLevel(fWorkLevel1))
;       CompilerEndIf
      fWorkLevel1 = calcBVLevel(#SCS_FADE_STD, nReqdSubFadeOutTime, nFadeOutPos, \fBVLevelWhenFadeOutStarted[d], #SCS_MINVOLUME_SINGLE, fTrimFactor)
      CompilerIf #cTraceSetLevels
        debugMsg(sProcName, "\nAudState=" + decodeCueState(\nAudState) + ", nFadeOutPos=" + nFadeOutPos + ", anReqdSubFadeOutTime=" + nReqdSubFadeOutTime + ", fWorkLevel1=" + formatLevel(fWorkLevel1))
      CompilerEndIf
      
    Else
      fWorkLevel1 = \fAudPlayBVLevel[d]
      
    EndIf
    
    If \bCueVolManual[d] = #False
      If fWorkLevel1 > fMaxLevel
        fWorkLevel1 = fMaxLevel
      EndIf
    EndIf
    
    nLCCtrlSubPtr = aSub(\nSubIndex)\nLCCtrlSubPtr
  EndWith

  If nLCCtrlSubPtr > 0
    ; calc level change level
    With aSub(nLCCtrlSubPtr)
      CompilerIf #cTraceSetLevels
        debugMsg(sProcName, "aSub(" + getSubLabel(nLCCtrlSubPtr) + ")\nSubState=" + decodeCueState(\nSubState))
      CompilerEndIf
      If \nSubState = #SCS_CUE_CHANGING_LEVEL
        fWorkLevel2 = calcBVLevel(\nLCType, \nLCTime[d], \nLCPosition[d], \fLCBVLevelWhenStarted[d], \fLCTargetBVLevel[d], fTrimFactor)
        aSub(aAud(pAudPtr)\nSubIndex)\fSubBVLevelNow[d] = fWorkLevel2
        CompilerIf #cTraceSetLevels
          debugMsg(sProcName, "aSub(" + getSubLabel(aAud(pAudPtr)\nSubIndex) + ")\fSubBVLevelNow[" + d + "]=" + traceLevel(aSub(aAud(pAudPtr)\nSubIndex)\fSubBVLevelNow[d]))
        CompilerEndIf
        If fWorkLevel2 > fWorkLevel1
          fWorkLevel2 = fWorkLevel1
        EndIf
        If \fLCReqdPan[d] <> \fLCPanWhenStarted[d]
          fNewPan = ((\fLCReqdPan[d] - \fLCPanWhenStarted[d]) * (\nLCPosition[d] / \nLCTime[d])) + \fLCPanWhenStarted[d]
          aSub(aAud(pAudPtr)\nSubIndex)\fSubPanNow[d] = fNewPan
        EndIf
      Else
        fWorkLevel2 = fWorkLevel1
      EndIf
    EndWith
  Else
    fWorkLevel2 = fWorkLevel1
  EndIf

  CompilerIf #cTraceSetLevels
    debugMsg(sProcName, "fWorkLevel1=" + traceLevel(fWorkLevel1) + ", fWorkLevel2=" + traceLevel(fWorkLevel2))
  CompilerEndIf
  ProcedureReturn fWorkLevel2

EndProcedure

Procedure.f calcPan(nTime, nPos, fOriginalPan.f, fTargetPan.f)
  PROCNAMEC()
  Protected fNewPan.f, nWorkPos
  Protected dPos.d, dTime.d, dFactor.d, dDelta.d

  ;debugMsg(sProcName, "pType=" & pType & ", nTime=" & nTime & ", nPos=" & nPos & ", fOriginalPan=" + fOriginalPan + ", fTargetPan=" + fTargetPan)

  ; if time of fade / pan change is less than the timer interval then no point in calculating levels - just set pan as target pan and exit
  If nTime < gnTimerInterval
    ;debugMsg(sProcName, "-- nTime < gnTimerInterval: calcPan=" & fTargetPan)
    ProcedureReturn fTargetPan
  EndIf

  ; adjust pos if necessary to be used in calculations to be within the window gnTimerInterval to nTime
  nWorkPos = nPos
  If nWorkPos < gnTimerInterval
    nWorkPos = gnTimerInterval
  EndIf

  ; if at end of pan change then set pan as target pan and exit
  If nWorkPos >= nTime
    ;debugMsg(sProcName, "-- end of pan change: calcPan=" & fTargetPan)
    ProcedureReturn fTargetPan
  EndIf

  dPos = nWorkPos     ; hold position as double
  dTime = nTime       ; hold time as double
  
  If fTargetPan >= fOriginalPan
    ; panning right
    dDelta = (fTargetPan - fOriginalPan) * dPos / dTime
    fNewPan = fOriginalPan + dDelta
    
    If fNewPan > fTargetPan
      fNewPan = fTargetPan
    EndIf
    
  Else
    ; panning left
    dDelta = (fOriginalPan - fTargetPan) * (dTime - dPos) / dTime
    fNewPan = fTargetPan + dDelta
    
    If fNewPan > fOriginalPan
      fNewPan = fOriginalPan
    EndIf
    
  EndIf
  
  If (fNewPan < #SCS_MINPAN_SINGLE) Or (fNewPan > #SCS_MAXPAN_SINGLE)
    fNewPan = #SCS_MAXPAN_SINGLE
  EndIf

  ProcedureReturn fNewPan
EndProcedure

Procedure mapAudLogicalDevsToPhysicalDevs(nAudioDriver)
  PROCNAMEC()
  
  debugMsg(sProcName, #SCS_START + ", nAudioDriver=" + decodeDriver(nAudioDriver))
  
  Select nAudioDriver
    Case #SCS_DRV_BASS_DS, #SCS_DRV_BASS_WASAPI, #SCS_DRV_BASS_ASIO
      mapAudLogicalDevsToPhysicalDevsForBASS(nAudioDriver)
      
    Case #SCS_DRV_SMS_ASIO
      mapAudLogicalDevsToPhysicalDevsForSMS(nAudioDriver)
      
  EndSelect
  
  mapVidAudLogicalDevsToPhysicalDevs()
  
  gbClearVUB4Update = #True
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure mapAudLogicalDevsToPhysicalDevsForBASS(nAudioDriver)
  PROCNAMEC()
  Protected d1, d2, k, bModalDisplayed
  Protected bFound
  Protected bCheckDevices
  Protected nNotFoundCount, sNotFoundString.s
  Protected nMousePointer
  Protected nReply, nResult
  Protected sPrompt.s, nFlags, sTitle.s, sCheckText.s, sButtons.s
  Protected bUsePrimary, nPrimaryPhysDevPtr
  Protected nFirstInitializedDevice
  Protected nNotInitializedCount, sNotInitializedString.s
  Protected bInitDevices
  Protected bUseFirst
  Protected nInitResult
  Protected sMsg.s
  Protected bDriverErrorFound
  Protected bQuit
  Protected sAlternativeDevice.s
  Protected sPrimaryDevice.s
  Protected sFirstInitializedDevice.s
  Protected bMidiNotFound
  Protected nSpeakerFlag, nSpeakerCount, nFirstOutputChannel
  Protected nDevMapPtr
  Protected nPass
  Protected nPhysicalDevPtr, sMyPhysicalDev.s
  
  debugMsg(sProcName, #SCS_START + ", nAudioDriver=" + decodeDriver(nAudioDriver))
  
  nDevMapPtr = grProd\nSelectedDevMapPtr
  If nDevMapPtr < 0
    ProcedureReturn
  EndIf
  
  bModalDisplayed = gbModalDisplayed
  gbInMapProdLogicalDevs = #True
  
  sPrimaryDevice = gaAudioDev(0)\sDesc
  ; if length of this name is too long for the "Use Primary Device" button, then truncate the description
  If Len(sPrimaryDevice) > Len("Primary Device   ")
    sPrimaryDevice = Trim(Left(sPrimaryDevice, Len("Primary Device"))) + "..."
  EndIf
  debugMsg(sProcName, "sPrimaryDevice=" + sPrimaryDevice)
  
  ; check all required devices exist
  bCheckDevices = #True
  bUsePrimary = #False
  While bCheckDevices
    nNotFoundCount = 0
    sNotFoundString = ""
    bMidiNotFound = #False
    
    d1 = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
    While d1 >= 0
      With grMaps\aDev(d1)
        If (\bExists) And (\nDevGrp = #SCS_DEVGRP_AUDIO_OUTPUT)
          If \sLogicalDev
            If \bIgnoreDevThisRun = #False
              bFound = #False
              debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\sLogicalDev=" + \sLogicalDev + ", \sPhysicalDev=" + \sPhysicalDev + ", \bDefaultDev=" + strB(\bDefaultDev) + ", \bReroutedToDefault=" + strB(\bReroutedToDefault) +
                                  ", nAudioDriver=" + decodeDriver(nAudioDriver))
              If \bDefaultDev Or \bReroutedToDefault
                bFound = #True
              Else
                For nPass = 1 To 2
                  For d2 = 0 To (gnPhysicalAudDevs-1)
                    ; debugMsg(sProcName, "gaAudioDev(" + d2 + ")\sDesc=" + gaAudioDev(d2)\sDesc + ", \nAudioDriver=" + decodeDriver(gaAudioDev(d2)\nAudioDriver))
                    If (comparePhysDevDescs(gaAudioDev(d2)\sDesc, \sPhysicalDev, nPass)) And (gaAudioDev(d2)\nAudioDriver = nAudioDriver)
                      bFound = #True
                      Break
                    EndIf
                  Next d2
                  If bFound
                    Break
                  EndIf
                Next nPass
              EndIf
              If bFound = #False
                If \sPhysicalDev
                  nNotFoundCount + 1
                  sNotFoundString + "|" + \sPhysicalDev + " (assigned To " + \sLogicalDev + ")"
                EndIf
              EndIf
            EndIf
          EndIf
        EndIf
        d1 = \nNextDevIndex
      EndWith
    Wend
    
    If nNotFoundCount = 0
      bCheckDevices = #False
    Else
      nMousePointer = GetMouseCursor()
      SetMouseCursorNormal()
      gbModalDisplayed = #True
      sPrompt = LangPars("DevMap", "DevsNotFound", decodeDevGrpL(#SCS_DEVGRP_AUDIO_OUTPUT)) + ":|" + sNotFoundString + "|"
      sTitle = GetFilePart(gsCueFile)
      debugMsg(sProcName, sTitle + ": " + sPrompt)
      sButtons = Lang("DevMap", "TryAgain") + "|" +
                 Lang("DevMap", "UsePrimary")
      ensureSplashNotOnTop()
      nReply = OptionRequester(0, 0, sTitle + "|" + sPrompt, sButtons, 200, #IDI_EXCLAMATION)
      gbModalDisplayed = bModalDisplayed
      SetMouseCursor(nMousePointer)
      Select nReply
        Case 1
          debugMsg(sProcName, "nReply='Try Again'")
          debugMsg(sProcName, "calling getAllPhysicalDevices()")
          getAllPhysicalDevices()
        Case 2
          debugMsg(sProcName, "nReply='Use Primary'")
          bUsePrimary = #True
          nPrimaryPhysDevPtr = getPrimaryPhysDevPtr(nAudioDriver)
          bCheckDevices = #False
          gbReloadAndDisplayDevsForProd = #True
      EndSelect
    EndIf
  Wend
  
  debugMsg(sProcName, "calling setLogicalDevsDerivedFields")
  setLogicalDevsDerivedFields()
  
  bInitDevices = #True
  bUseFirst = #False
  While bInitDevices
    nFirstInitializedDevice = -1
    nNotInitializedCount = 0
    sNotInitializedString = ""
    d1 = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
    While d1 >= 0
      With grMaps\aDev(d1)
        If (\bExists) And (\nDevGrp = #SCS_DEVGRP_AUDIO_OUTPUT)
          If Len(\sLogicalDev) = 0
            \sPhysicalDev = ""
            \nPhysicalDevPtr = -1
            \sSpeaker = ""
            \nBassDevice = -1
            \bBassASIO = #False
            \nBassASIODevice = -1
            \nMixerStreamPtr = -1
            \nReassignDevMapDevPtr = -1
            \bNoDevice = #False
            \bDefaultDev = #False
          Else
            If \bIgnoreDevThisRun
              \nBassDevice = 0  ; 'no sound' device
              \nNrOfDevOutputChans = 2
              debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\nNrOfDevOutputChans=" + \nNrOfDevOutputChans)
              \bNoSoundDevice = #True
              bFound = #True
            Else
              If \bReroutedToDefault
                sMyPhysicalDev = grMMedia\sDefAudDevDesc
              Else
                sMyPhysicalDev = \sPhysicalDev
              EndIf
              nPhysicalDevPtr = -1
              bFound = #False
              For nPass = 1 To 2
                For d2 = 0 To gnPhysicalAudDevs - 1
                  If (comparePhysDevDescs(gaAudioDev(d2)\sDesc, sMyPhysicalDev, nPass)) And (gaAudioDev(d2)\nAudioDriver = nAudioDriver)
                    bFound = #True
                    nPhysicalDevPtr = d2
                    Break
                  EndIf
                Next d2
                If bFound
                  Break
                EndIf
              Next nPass
              If nPhysicalDevPtr >= 0
                d2 = nPhysicalDevPtr
                \nPhysicalDevPtr = d2
                \nBassDevice = gaAudioDev(d2)\nBassDevice
                ; debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\nPhysicalDevPtr=" + \nPhysicalDevPtr + ", \nBassDevice=" + \nBassDevice)
                \bBassASIO = gaAudioDev(d2)\bASIO
                \nBassASIODevice = gaAudioDev(d2)\nDevBassASIODevice
                \nNrOfDevOutputChans = gaAudioDev(d2)\nOutputs
                ; debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\nNrOfDevOutputChans=" + \nNrOfDevOutputChans)
                \nNrOfInputChans = gaAudioDev(d2)\nInputs
                \bNoDevice = gaAudioDev(d2)\bNoDevice
                \bNoSoundDevice = gaAudioDev(d2)\bNoSoundDevice
                If gaAudioDev(d2)\bInitialized = #False
                  debugMsg(sProcName, "calling initDevice(" + d2 + ", #False) for " + \sLogicalDev)
                  nInitResult = initDevice(d2, #False)
                Else
                  nInitResult = #BASS_OK
                EndIf
                If nInitResult = #BASS_OK
                  If nFirstInitializedDevice = -1
                    nFirstInitializedDevice = d2
                  EndIf
                EndIf
                If \nNrOfDevOutputChans = 0
                  \nNrOfDevOutputChans = gaAudioDev(d2)\nSpeakers
                  debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\nNrOfDevOutputChans=" + \nNrOfDevOutputChans)
                EndIf
                If \nNrOfInputChans = 0
                  \nNrOfInputChans = 1
                EndIf
              EndIf
            EndIf
            If bFound
              \nFirstASIOChannel = -1
              \nLastASIOChannel = -1
              \nNrOfDevOutputChans = 0
              \sReassignPhysicalDev = ""
              \sReassignSpeaker = ""
              If \bBassASIO
                \nFirst1BasedOutputChan = getFirst1BasedChanFromRange(\s1BasedOutputRange)
                \nNrOfDevOutputChans = getNumChansFromRange(\s1BasedOutputRange)
                \nFirstASIOChannel = \nFirst1BasedOutputChan - 1
                \nLastASIOChannel = \nFirstASIOChannel + \nNrOfDevOutputChans - 1
              Else
                \nFirst1BasedOutputChan = getFirst1BasedChanFromRange(\s1BasedOutputRange)
                \nNrOfDevOutputChans = getNumChansFromRange(\s1BasedOutputRange)
              EndIf
              ; debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\sLogicalDev=" + \sLogicalDev + ", \nFirst1BasedOutputChan=" + \nFirst1BasedOutputChan + ", \nNrOfDevOutputChans=" + \nNrOfDevOutputChans)
            EndIf
            
            debugMsg(sProcName, "d1=" + d1 + ", \sPhysicalDev=" + \sPhysicalDev + ", bFound=" + strB(bFound) + ", nInitResult=" + nInitResult + ", bUseFirst=" + strB(bUseFirst))
            
            If bFound = #False
              If \sPhysicalDev
                If bUsePrimary = #False
                  ; user hasn't already indicated they want to use primary device, so display the message
                  debugMsg(sProcName, "Audio device '" + \sPhysicalDev + "' not found.  Using primary device for '" + \sLogicalDev + "'")
                  gbModalDisplayed = #True
                  ensureSplashNotOnTop()
                  scsMessageRequester(#SCS_TITLE, "Audio device '" + \sPhysicalDev + "' not found.  Using primary device for '" + \sLogicalDev + "'", #PB_MessageRequester_Ok)
                  gbModalDisplayed = bModalDisplayed
                EndIf
              EndIf
              If nPrimaryPhysDevPtr >= 0
                ; use primary device
                debugMsg(sProcName, "changing grMaps\aMap(" + getDevMapName(nDevMapPtr) + ")\rAudioDev[" + d1 + "]\sPhysicalDev from '" + \sPhysicalDev + "' to '" + gaAudioDev(0)\sDesc + "'")
                \sPhysicalDev = gaAudioDev(nPrimaryPhysDevPtr)\sDesc
                \nBassDevice = gaAudioDev(nPrimaryPhysDevPtr)\nBassDevice
                debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\nBassDevice=" + \nBassDevice)
                \bBassASIO = gaAudioDev(nPrimaryPhysDevPtr)\bASIO
                \nBassASIODevice = gaAudioDev(nPrimaryPhysDevPtr)\nDevBassASIODevice
                \nNrOfDevOutputChans = gaAudioDev(nPrimaryPhysDevPtr)\nOutputs
                debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\nNrOfDevOutputChans=" + \nNrOfDevOutputChans)
                \bNoDevice = gaAudioDev(nPrimaryPhysDevPtr)\bNoDevice
                \bNoSoundDevice = gaAudioDev(nPrimaryPhysDevPtr)\bNoSoundDevice
                If gaAudioDev(nPrimaryPhysDevPtr)\bInitialized = #False
                  debugMsg(sProcName, "calling initDevice(0, #False)")
                  nInitResult = initDevice(0, #False)
                Else
                  nInitResult = #BASS_OK
                EndIf
                If nInitResult = #BASS_OK
                  If nFirstInitializedDevice = -1
                    nFirstInitializedDevice = nPrimaryPhysDevPtr
                  EndIf
                EndIf
                If \nNrOfDevOutputChans = 0
                  \nNrOfDevOutputChans = gaAudioDev(nPrimaryPhysDevPtr)\nSpeakers
                  debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\nNrOfDevOutputChans=" + \nNrOfDevOutputChans)
                EndIf
              EndIf
              
            ElseIf nInitResult <> #BASS_OK
              If bUseFirst = #False
                ; user hasn't already indicated they want to use the first device
                nNotInitializedCount + 1
                If gbUseBASS
                  sNotInitializedString + #CRLF$ + \sPhysicalDev + " (assigned to " + \sLogicalDev + ") Error: " + getBassErrorDesc(nInitResult)
                  If nInitResult = #BASS_ERROR_DRIVER
                    bDriverErrorFound = #True
                  EndIf
                Else ; SM-S
                  sNotInitializedString + #CRLF$ + \sPhysicalDev + " (assigned to " + \sLogicalDev + ") Error reported by SoundMan-Server"
                EndIf
              Else
                If nFirstInitializedDevice = -1
                  If nPrimaryPhysDevPtr >= 0
                    If gaAudioDev(nPrimaryPhysDevPtr)\bInitialized
                      nFirstInitializedDevice = nPrimaryPhysDevPtr
                    EndIf
                  EndIf
                EndIf
                If nFirstInitializedDevice >= 0
                  ; use first initialized device
                  debugMsg(sProcName, "changing grMaps\aMap(" + getDevMapName(nDevMapPtr) + ")\rAudioDev[" + d1 + "]\sPhysicalDev from " + \sPhysicalDev + " to " + gaAudioDev(nFirstInitializedDevice)\sDesc)
                  \sPhysicalDev = gaAudioDev(nFirstInitializedDevice)\sDesc
                  \nBassDevice = gaAudioDev(nFirstInitializedDevice)\nBassDevice
                  debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\nBassDevice=" + \nBassDevice)
                  \bBassASIO = gaAudioDev(nFirstInitializedDevice)\bASIO
                  \nBassASIODevice = gaAudioDev(nFirstInitializedDevice)\nDevBassASIODevice
                  \nNrOfDevOutputChans= gaAudioDev(nFirstInitializedDevice)\nOutputs
                  \bNoDevice = gaAudioDev(nFirstInitializedDevice)\bNoDevice
                  \bNoSoundDevice = gaAudioDev(nFirstInitializedDevice)\bNoSoundDevice
                  If \nNrOfDevOutputChans = nFirstInitializedDevice
                    \nNrOfDevOutputChans = gaAudioDev(nFirstInitializedDevice)\nSpeakers
                    debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\nNrOfDevOutputChans=" + \nNrOfDevOutputChans)
                  EndIf
                EndIf
              EndIf
            EndIf
          EndIf
        EndIf
        d1 = \nNextDevIndex
      EndWith
    Wend
    
    debugMsg(sProcName, "nNotInitializedCount=" + nNotInitializedCount + ", gbReviewDevMap=" + strB(gbReviewDevMap))
    If nNotInitializedCount = 0 Or gbReviewDevMap ; Added "Or gbReviewDevMap" 28Oct2024 11.10.6ax
      bInitDevices = #False
    Else
      If nFirstInitializedDevice = -1
        If nPrimaryPhysDevPtr >= 0
          If gaAudioDev(nPrimaryPhysDevPtr)\bInitialized = #False
            debugMsg(sProcName, "calling initDevice(0, #False)")
            nInitResult = initDevice(0, #False)
          Else
            nInitResult = #BASS_OK
          EndIf
          nFirstInitializedDevice = nPrimaryPhysDevPtr
        EndIf
      EndIf
      sFirstInitializedDevice = gaAudioDev(nFirstInitializedDevice)\sDesc
      ; if length of this name is too long for the "Use Primary Device" button, then truncate the description
      If Len(sFirstInitializedDevice) > Len("Primary Device   ")
        sFirstInitializedDevice = Trim(Left(sFirstInitializedDevice, Len("Primary Device"))) + "\\\"
      EndIf
      nMousePointer = GetMouseCursor()
      SetMouseCursorNormal()
      gbModalDisplayed = #True
      debugMsg(sProcName, "sNotInitializedString=" + #DQUOTE$ + sNotInitializedString + #DQUOTE$ + ", Length=" + Len(sNotInitializedString))
      sPrompt = "The following devices could not be initialized:" + sNotInitializedString + #CRLF$ + #CRLF$
      If bDriverErrorFound
        sPrompt + "'Device already in use' can occur with some sound cards if a required output channel is already assigned to ASIO output." + #CRLF$ +
                  "'Cannot find a free sound driver' can occur for emulated sound devices that do not have a DS driver." + #CRLF$
      EndIf
      Protected sPrompt2.s
      sPrompt2 = ReplaceString(sPrompt, #CRLF$, "|") ; Logic associated with this added 28Oct2024 11.10.6ax
      sTitle = GetFilePart(gsCueFile)
      sButtons = Lang("DevMap", "TryAgain") + "|" +
                 Lang("DevMap", "UsePrimary")
      ensureSplashNotOnTop()
      nReply = OptionRequester(0, 0, sTitle + "|" + sPrompt2, sButtons, 200, #IDI_EXCLAMATION)
      gbModalDisplayed = bModalDisplayed
      SetMouseCursor(nMousePointer)
      Select nReply
        Case 1
          debugMsg(sProcName, "nReply='Try Again'")
          debugMsg(sProcName, "calling getAllPhysicalDevices()")
          getAllPhysicalDevices()
        Case 2
          debugMsg(sProcName, "nReply='Use Primary'")
          bUseFirst = #True
          nPrimaryPhysDevPtr = getPrimaryPhysDevPtr(nAudioDriver)
          gbReloadAndDisplayDevsForProd = #True
        Case 3
          debugMsg(sProcName, "nReply='Quit'")
          bQuit = #True
          bInitDevices = #False
      EndSelect
    EndIf
    
  Wend
  
  If bQuit
    gbCrashClose = #True
    debugMsg(sProcName, "closing down")
    closeDown(#True)
    End
  EndIf
  
  Select nAudioDriver
    Case #SCS_DRV_BASS_DS, #SCS_DRV_BASS_WASAPI
      If gbUseBASSMixer
        debugMsg(sProcName, "calling createMixerStreams()")
        createMixerStreams()
      EndIf
      
    Case #SCS_DRV_BASS_ASIO
      debugMsg(sProcName, "calling createMixerStreams()")
      createMixerStreams()
      
  EndSelect
  
  debugMsg(sProcName, "calling setFirstAndLastDev()")
  For k = 1 To gnLastAud
    If aAud(k)\bExists
      setFirstAndLastDev(k)
    EndIf
  Next k
  
  gbInMapProdLogicalDevs = #False

EndProcedure

Procedure mapAudLogicalDevsToPhysicalDevsForSMS(nAudioDriver)
  PROCNAMEC()
  Protected d1, d2, k, bModalDisplayed
  Protected bFound
  Protected bCheckDevices
  Protected nNotFoundCount, sNotFoundString.s
  Protected nMousePointer
  Protected nReply, nResult
  Protected sPrompt.s, nFlags, sTitle.s, sCheckText.s, sButtons.s
  Protected bUsePrimary, nPrimaryPhysDevPtr
  Protected sMsg.s
  Protected bQuit
  Protected bMidiNotFound
  
  debugMsg(sProcName, #SCS_START)
  bModalDisplayed = gbModalDisplayed
  gbInMapProdLogicalDevs = #True
  
  ; check all required devices exist
  bCheckDevices = #True
  bUsePrimary = #False
  While bCheckDevices
    nNotFoundCount = 0
    sNotFoundString = ""
    bMidiNotFound = #False
    
    If nNotFoundCount = 0
      bCheckDevices = #False
    Else
      nMousePointer = GetMouseCursor()
      SetMouseCursorNormal()
      gbModalDisplayed = #True
      sPrompt = LangPars("DevMap", "DevsNotFound", decodeDevGrpL(#SCS_DEVGRP_AUDIO_OUTPUT)) + ":|" + sNotFoundString + "|"
      sTitle = GetFilePart(gsCueFile)
      debugMsg(sProcName, sTitle + ": " + sPrompt)
      sButtons = Lang("DevMap", "TryAgain") + "|" +
                 Lang("DevMap", "UsePrimary")
      ensureSplashNotOnTop()
      nReply = OptionRequester(0, 0, sTitle + "|" + sPrompt, sButtons, 200, #IDI_EXCLAMATION)
      gbModalDisplayed = bModalDisplayed
      SetMouseCursor(nMousePointer)
      Select nReply
        Case 1
          debugMsg(sProcName, "nReply='Try Again")
          debugMsg(sProcName, "calling getAllPhysicalDevices()")
          getAllPhysicalDevices()
        Case 2
          debugMsg(sProcName, "nReply='Use Primary'")
          bUsePrimary = #True
          nPrimaryPhysDevPtr = getPrimaryPhysDevPtr(nAudioDriver)
          bCheckDevices = #False
          gbReloadAndDisplayDevsForProd = #True
      EndSelect
    EndIf
  Wend
  
  debugMsg(sProcName, "calling setLogicalDevsDerivedFields")
  setLogicalDevsDerivedFields()
  
  debugMsg(sProcName, "calling setFirstAndLastDev()")
  For k = 1 To gnLastAud
    If aAud(k)\bExists
      setFirstAndLastDev(k)
    EndIf
  Next k
  
  gbInMapProdLogicalDevs = #False
  debugMsg(sProcName, #SCS_END)

EndProcedure

Procedure mapVidAudLogicalDevsToPhysicalDevs()
  PROCNAMEC()
  Protected d1, d2, k, bModalDisplayed
  Protected bFound
  Protected bCheckDevices
  Protected nNotFoundCount, sNotFoundString.s
  Protected nMousePointer
  Protected nReply, nResult
  Protected sPrompt.s, nFlags, sTitle.s, sCheckText.s, sButtons.s
  Protected bUsePrimary, nPrimaryPhysDevPtr
  Protected bUseFirst
  Protected sMsg.s
  Protected bQuit
  Protected sAlternativeDevice.s
  Protected sPrimaryDevice.s
  Protected nDevMapPtr
  Protected nPass
  
  debugMsg(sProcName, #SCS_START)
  
  nDevMapPtr = grProd\nSelectedDevMapPtr
  If nDevMapPtr < 0
    ProcedureReturn
  EndIf
  
  bModalDisplayed = gbModalDisplayed
  gbInMapProdLogicalDevs = #True
  
  sPrimaryDevice = gaVideoAudioDev(0)\sVidAudName
  debugMsg(sProcName, "sPrimaryDevice=" + sPrimaryDevice)
  
  ; check all required devices exist
  bCheckDevices = #True
  bUsePrimary = #False
  While bCheckDevices
    nNotFoundCount = 0
    sNotFoundString = ""
    
    d1 = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
    While d1 >= 0
      With grMaps\aDev(d1)
        If (\bExists) And (\nDevGrp = #SCS_DEVGRP_VIDEO_AUDIO)
          If \sLogicalDev
            If \bIgnoreDevThisRun = #False
              bFound = #False
              \nPhysicalDevPtr = getPhysicalDevPtr(\nDevType, \sPhysicalDev, #SCS_DRV_TVG)
              If \nPhysicalDevPtr >= 0
                bFound = #True
              EndIf
              If bFound = #False
                If \sPhysicalDev
                  nNotFoundCount + 1
                  sNotFoundString + "|" + \sPhysicalDev + " (assigned To " + \sLogicalDev + ")"
                EndIf
              EndIf
            EndIf
          EndIf
        EndIf
        d1 = \nNextDevIndex
      EndWith
    Wend
    
    If nNotFoundCount = 0
      bCheckDevices = #False
    Else
      nMousePointer = GetMouseCursor()
      SetMouseCursorNormal()
      gbModalDisplayed = #True
      sPrompt = LangPars("DevMap", "DevsNotFound", decodeDevGrpL(#SCS_DEVGRP_VIDEO_AUDIO)) + ":|" + sNotFoundString + "|"
      sTitle = GetFilePart(gsCueFile)
      debugMsg(sProcName, sTitle + ": " + sPrompt)
      sButtons = Lang("DevMap", "TryAgain") + "|" +
                 Lang("DevMap", "UsePrimary")
      ensureSplashNotOnTop()
      nReply = OptionRequester(0, 0, sTitle + "|" + sPrompt, sButtons, 200, #IDI_EXCLAMATION)
      gbModalDisplayed = bModalDisplayed
      SetMouseCursor(nMousePointer)
      Select nReply
        Case 1
          debugMsg(sProcName, "nReply='Try Again'")
          debugMsg(sProcName, "calling getAllPhysicalDevices()")
          getAllPhysicalDevices()
        Case 2
          debugMsg(sProcName, "nReply='Use Primary'")
          bUsePrimary = #True
          nPrimaryPhysDevPtr = 0
          bCheckDevices = #False
      EndSelect
    EndIf
  Wend
  
  debugMsg(sProcName, "calling setLogicalDevsDerivedFields")
  setLogicalDevsDerivedFields()
  
  bUseFirst = #False
  d1 = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
  While d1 >= 0
    With grMaps\aDev(d1)
      If (\bExists) And (\nDevGrp = #SCS_DEVGRP_VIDEO_AUDIO)
        bFound = #False
        If Len(\sLogicalDev) = 0
          \sPhysicalDev = ""
          \nPhysicalDevPtr = -1
        ElseIf \bIgnoreDevThisRun
          \nPhysicalDevPtr = -1
        Else
          \nPhysicalDevPtr = getPhysicalDevPtr(\nDevType, \sPhysicalDev, #SCS_DRV_TVG)
          If \nPhysicalDevPtr >= 0
            bFound = #True
          EndIf
          debugMsg(sProcName, "d1=" + d1 + ", \sPhysicalDev=" + \sPhysicalDev + ", bFound=" + strB(bFound)+ ", bUseFirst=" + strB(bUseFirst))
          If (bFound = #False)
            If \sPhysicalDev
              If bUsePrimary = #False
                ; user hasn't already indicated they want to use primary device, so display the message
                debugMsg(sProcName, "Audio device '" + \sPhysicalDev + "' not found.  Using primary device for '" + \sLogicalDev + "'")
                gbModalDisplayed = #True
                ensureSplashNotOnTop()
                scsMessageRequester(#SCS_TITLE, "Audio device '" + \sPhysicalDev + "' not found.  Using primary device for '" + \sLogicalDev + "'", #PB_MessageRequester_Ok)
                gbModalDisplayed = bModalDisplayed
              EndIf
            EndIf
            If nPrimaryPhysDevPtr >= 0
              ; use primary device
              debugMsg(sProcName, "changing grMaps\aMap(" + getDevMapName(nDevMapPtr) + ")\rAudioDev[" + d1 + "]\sPhysicalDev from " + \sPhysicalDev + " to " + gaAudioDev(0)\sDesc)
              \sPhysicalDev = gaVideoAudioDev(nPrimaryPhysDevPtr)\sVidAudName
              debugMsg(sProcName, "gaVideoAudioDev(" + nPrimaryPhysDevPtr + ")\sVidAudName=" + gaVideoAudioDev(nPrimaryPhysDevPtr)\sVidAudName)
            EndIf
          EndIf
        EndIf
      EndIf
      d1 = \nNextDevIndex
    EndWith
    
  Wend
  
  If bQuit
    gbCrashClose = #True
    debugMsg(sProcName, "closing down")
    closeDown(#True)
    End
  EndIf
  
  gbInMapProdLogicalDevs = #False
  
EndProcedure

Procedure mapVidCapLogicalDevsToPhysicalDevs()
  PROCNAMEC()
  Protected d1, d2, k, bModalDisplayed
  Protected bFound
  Protected bCheckDevices
  Protected nNotFoundCount, sNotFoundString.s
  Protected nMousePointer
  Protected nReply, nResult
  Protected sPrompt.s, nFlags, sTitle.s, sCheckText.s, sButtons.s
  Protected bUsePrimary, nPrimaryPhysDevPtr
  Protected bUseFirst
  Protected sMsg.s
  Protected bQuit
  Protected sAlternativeDevice.s
  Protected sPrimaryDevice.s
  Protected nDevMapPtr
  Protected nPass
  
  debugMsg(sProcName, #SCS_START)
  
  nDevMapPtr = grProd\nSelectedDevMapPtr
  If nDevMapPtr < 0
    ProcedureReturn
  EndIf
  
  bModalDisplayed = gbModalDisplayed
  gbInMapProdLogicalDevs = #True
  
  sPrimaryDevice = gaVideoCaptureDev(0)\sVidCapName
  debugMsg(sProcName, "sPrimaryDevice=" + sPrimaryDevice)
  
  ; check all required devices exist
  bCheckDevices = #True
  bUsePrimary = #False
  While bCheckDevices
    nNotFoundCount = 0
    sNotFoundString = ""
    
    d1 = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
    While d1 >= 0
      With grMaps\aDev(d1)
        If (\bExists) And (\nDevGrp = #SCS_DEVGRP_VIDEO_CAPTURE)
          If \sLogicalDev
            If \bIgnoreDevThisRun = #False
              bFound = #False
              \nPhysicalDevPtr = getPhysicalDevPtr(\nDevType, \sPhysicalDev, #SCS_DRV_TVG)
              If \nPhysicalDevPtr >= 0
                bFound = #True
              EndIf
              If bFound = #False
                If \sPhysicalDev
                  nNotFoundCount + 1
                  sNotFoundString + "|" + \sPhysicalDev + " (assigned To " + \sLogicalDev + ")"
                EndIf
              EndIf
            EndIf
          EndIf
        EndIf
        d1 = \nNextDevIndex
      EndWith
    Wend
    
    If nNotFoundCount = 0
      bCheckDevices = #False
    Else
      nMousePointer = GetMouseCursor()
      SetMouseCursorNormal()
      gbModalDisplayed = #True
      sPrompt = LangPars("DevMap", "DevsNotFound", decodeDevGrpL(#SCS_DEVGRP_VIDEO_CAPTURE)) + ":|" + sNotFoundString + "|"
      sTitle = GetFilePart(gsCueFile)
      debugMsg(sProcName, sTitle + ": " + sPrompt)
      sButtons = Lang("DevMap", "TryAgain") + "|" +
                 Lang("DevMap", "UsePrimary")
      ensureSplashNotOnTop()
      nReply = OptionRequester(0, 0, sTitle + "|" + sPrompt, sButtons, 200, #IDI_EXCLAMATION)
      gbModalDisplayed = bModalDisplayed
      SetMouseCursor(nMousePointer)
      Select nReply
        Case 1
          debugMsg(sProcName, "nReply='Try Again'")
          debugMsg(sProcName, "calling getAllPhysicalDevices()")
          getAllPhysicalDevices()
        Case 2
          debugMsg(sProcName, "nReply='Use Primary'")
          bUsePrimary = #True
          nPrimaryPhysDevPtr = 0
          bCheckDevices = #False
      EndSelect
    EndIf
  Wend
  
  debugMsg(sProcName, "calling setLogicalDevsDerivedFields")
  setLogicalDevsDerivedFields()
  
  bUseFirst = #False
  d1 = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
  While d1 >= 0
    With grMaps\aDev(d1)
      If (\bExists) And (\nDevGrp = #SCS_DEVGRP_VIDEO_CAPTURE)
        bFound = #False
        If Len(\sLogicalDev) = 0
          \sPhysicalDev = ""
          \nPhysicalDevPtr = -1
        ElseIf \bIgnoreDevThisRun
          \nPhysicalDevPtr = -1
        Else
          \nPhysicalDevPtr = getPhysicalDevPtr(\nDevType, \sPhysicalDev, #SCS_DRV_TVG)
          If \nPhysicalDevPtr >= 0
            bFound = #True
          EndIf
          debugMsg(sProcName, "d1=" + d1 + ", \sPhysicalDev=" + \sPhysicalDev + ", bFound=" + strB(bFound)+ ", bUseFirst=" + strB(bUseFirst))
          If bFound = #False
            If \sPhysicalDev
              If bUsePrimary = #False
                ; user hasn't already indicated they want to use primary device, so display the message
                debugMsg(sProcName, "Capture device '" + \sPhysicalDev + "' not found.  Using primary device for '" + \sLogicalDev + "'")
                gbModalDisplayed = #True
                ensureSplashNotOnTop()
                scsMessageRequester(#SCS_TITLE, "Capture device '" + \sPhysicalDev + "' not found.  Using primary device for '" + \sLogicalDev + "'", #PB_MessageRequester_Ok)
                gbModalDisplayed = bModalDisplayed
              EndIf
            EndIf
;             If nPrimaryPhysDevPtr >= 0
;               ; use primary device
;               debugMsg(sProcName, "changing grMaps\aMap(" + getDevMapName(nDevMapPtr) + ")\rCaptureDev[" + d1 + "]\sPhysicalDev from " + \sPhysicalDev + " to " + gaCaptureDev(0)\sDesc)
;               \sPhysicalDev = gaVideoCaptureDev(nPrimaryPhysDevPtr)\sVidCapName
;               debugMsg(sProcName, "gaVideoCaptureDev(" + nPrimaryPhysDevPtr + ")\sVidCapName=" + gaVideoCaptureDev(nPrimaryPhysDevPtr)\sVidCapName)
;             EndIf
          EndIf
        EndIf
      EndIf
      d1 = \nNextDevIndex
    EndWith
    
  Wend
  
  If bQuit
    gbCrashClose = #True
    debugMsg(sProcName, "closing down")
    closeDown(#True)
    End
  EndIf
  
  gbInMapProdLogicalDevs = #False
  
EndProcedure

Procedure checkAudTimes(pAudPtr)
  PROCNAMEC()
  Protected bClear
  Protected nMaxTime

  If gbEditHasFocus = #False
    ProcedureReturn
  EndIf

  debugMsg(sProcName, "AP=" + pAudPtr)
  If pAudPtr >= 0
    With aAud(pAudPtr)
      debugMsg(sProcName, \sAudLabel + ", \nFileState=" + decodeFileState(\nFileState) + ", \nFileDuration=" + \nFileDuration + ", \nAbsStartAt=" + \nAbsStartAt + ", \nAbsEndAt=" + \nAbsEndAt)
      ; debugMsg(sProcName, \sAudLabel + ", \nAbsLoopStart=" + \nAbsLoopStart + ", \nAbsLoopEnd=" + \nAbsLoopEnd + ", \bContainsLoop=" + strB(\bContainsLoop))
      debugMsg(sProcName, \sAudLabel + ", \nFadeInTime=" + \nFadeInTime + ", \nFadeOutTime=" + \nFadeOutTime)
      nMaxTime = \nFileDuration - 1
      If \nFileDuration = 0
        bClear = #True
      ElseIf (\nAbsStartAt > nMaxTime) Or (\nAbsEndAt > nMaxTime)
        bClear = #True
;       ElseIf (\nAbsLoopStart > nMaxTime) Or (\nAbsLoopEnd > nMaxTime)
;         bClear = #True
      ElseIf ((\nFadeInTime > nMaxTime) Or (\nFadeOutTime > nMaxTime)) And (\nMaxLoopInfo < 0) ; (\bContainsLoop = #False)
        bClear = #True
      EndIf
      If \nMaxLoopInfo >= 0
        If (\aLoopInfo(\nMaxLoopInfo)\nAbsLoopStart > nMaxTime) Or (\aLoopInfo(\nMaxLoopInfo)\nAbsLoopEnd > nMaxTime)
          bClear = #True
        EndIf
      EndIf
      
      debugMsg(sProcName, \sAudLabel + ", bClear=" + StrB(bClear))
      If bClear
        \nStartAt = grAudDef\nStartAt
        \nEndAt = grAudDef\nEndAt
        \nMaxLoopInfo = grAudDef\nMaxLoopInfo
        \nCurrLoopInfoIndex = grAudDef\nCurrLoopInfoIndex
;         \bContainsLoop = grAudDef\bContainsLoop
;         \nLoopStart = grAudDef\nLoopStart
;         \nLoopEnd = grAudDef\nLoopEnd
        \nFadeInTime = grAudDef\nFadeInTime
        \nFadeOutTime = grAudDef\nFadeOutTime
        \nFadeInType = grAudDef\nFadeInType
        \nFadeOutType = grAudDef\nFadeOutType
;         \bLoopReleased = grAudDef\bLoopReleased
;         \nLoopPassNo = grAudDef\nLoopPassNo
        \nCurrFadeInTime = \nFadeInTime
        \nCurrFadeOutTime = \nFadeOutTime
        ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nCurrFadeInTime=" + \nCurrFadeInTime + ", \nCurrFadeOutTime=" + \nCurrFadeOutTime)
        debugMsg(sProcName, "calling setDerivedAudFields")
        setDerivedAudFields(pAudPtr)
        If grCED\bQFDisplayed
          SGT(WQF\txtStartAt, "")
          SGT(WQF\txtEndAt, "")
          ; setOwnState(WQF\chkLoop, #False)
          SGT(WQF\txtLoopStart, "")
          SGT(WQF\txtLoopEnd, "")
          SGT(WQF\txtFadeInTime, "")
          SGT(WQF\txtFadeOutTime, "")
          SLD_setMax(WQF\sldProgress, (\nCueDuration-1))
        EndIf
        If \bLiveInput = #False
          debugMsg(sProcName, "calling rewindAud(" + getAudLabel(pAudPtr) + ")")
          rewindAud(pAudPtr)
        EndIf
        If grCED\bQFDisplayed
          WQF_setClearState()
          debugMsg(sProcName, "calling drawWholeGraphArea()")
          drawWholeGraphArea()
        EndIf
        gbCallEditUpdateDisplay = #True
        \bCheckProgSlider = #False
        debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\bCheckProgSlider=" + strB(\bCheckProgSlider))
      EndIf
    EndWith
  EndIf

EndProcedure

Procedure checkDevicesStillAvailable()
  PROCNAMEC()
  Protected d, nBassResult.l
  Protected rDeviceInfo.BASS_DEVICEINFO
  Protected nDeviceFlags.l  ; long
  Protected rAsioDeviceInfo.BASS_ASIO_DEVICEINFO
  Protected bDisplayMessage
  Protected sMsg.s, sFullMsg.s
  Protected nAsioErrorCode
  Protected nDevMapPtr

  ; debugMsg(sProcName, #SCS_START)
  
  If gbUseBASS  ; BASS
    nDevMapPtr = grProd\nSelectedDevMapPtr
    If nDevMapPtr >= 0
      d = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
      While d >= 0
        CheckSubInRange(d, grMaps\aDev(), "grMaps\aDev()")
        With grMaps\aDev(d)
          If (\nDevGrp = #SCS_DEVGRP_AUDIO_OUTPUT) And (\bExists)
            If \bBassASIO = #False
              If \nBassDevice >= 0
                nBassResult = BASS_GetDeviceInfo(\nBassDevice, @rDeviceInfo)
                If (nBassResult = #BASSFALSE) Or (rDeviceInfo\flags & #BASS_DEVICE_ENABLED = 0)
                  ; device invalid or not enabled
                  If \bUnavailableMessageDisplayed = #False
                    debugMsg2(sProcName, "BASS_GetDeviceInfo(" + \nBassDevice + ", rDeviceInfo)", nBassResult)
                    bDisplayMessage = #True
                    \bUnavailableMessageDisplayed = #True
                  EndIf
                  sMsg + #CRLF$ + \sLogicalDev + " (" + \sPhysicalDev + ")"
                Else
                  ; device valid and enabled
                  \bUnavailableMessageDisplayed = #False
                EndIf
              EndIf
            Else
              ; \bBassASIO = #True
              ; can't yet test if an ASIO device has been lost
            EndIf
          EndIf
          d = \nNextDevIndex
        EndWith
      Wend
    EndIf
    
  Else  ; SM-S
    ; not required
    
  EndIf

  If bDisplayMessage
    sFullMsg = "WARNING! Device(s) lost!" + #CRLF$ + #CRLF$ + "The following device(s) are not available:" + sMsg + #CRLF$ + #CRLF$ + "You may need to close and restart SCS after the device(s) have been reconnected."
    debugMsg(sProcName, sFullMsg)
    ensureSplashNotOnTop()
    scsMessageRequester("SCS Device Check", sFullMsg, #MB_ICONEXCLAMATION)
  EndIf

EndProcedure

Procedure clearProdLogicalDevs()
  PROCNAMEC()

  debugMsg(sProcName, #SCS_START)
  
  With grProd
    \nMaxAudioLogicalDev = -1
    \nMaxVidAudLogicalDev = -1
    \nMaxVidCapLogicalDev = -1
    \nMaxLiveInputLogicalDev = -1
    \nMaxInGrp = -1
    \nMaxFixType = -1
    \nMaxLightingLogicalDev = -1
    \nMaxCtrlSendLogicalDev = -1
    \nMaxCueCtrlLogicalDev = -1
  EndWith
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure closeAllMciDevices()
  PROCNAMEC()
  Protected nErrCode.l
  Protected sMciString.s
  
  ; warning! all mciSendString calls must be from the same thread or mciSendString returns error 263 (not a registered device), so use main thread
  ASSERT_THREAD(#SCS_THREAD_MAIN)

  sMciString = "close all"
  nErrCode = mciSendString_(sMciString, #Null, 0, #Null)
  debugMsg2(sProcName, "mciSendString_(" + sMciString + ", #Null, 0, #Null)", nErrCode)
  
EndProcedure

Procedure closeDevices(nAudioDriver)
  PROCNAMEC()
  Protected d, i, j, k, n, nBassResult.l
  Protected nDevMapPtr
  Protected nPrevMixerStreamPtr, d2 ; Added 3Oct2023 11.10.0cf

  debugMsg(sProcName, #SCS_START + ", nAudioDriver=" + decodeDriver(nAudioDriver))
  
  gbClosingDevices = #True
  
  For k = 1 To gnLastAud
    If aAud(k)\bExists
      closeAud(k)
    EndIf
  Next k
  
  For n = 0 To (gnGaplessSeqCount-1)
    With gaGaplessSeqs(n)
      nBassResult = BASS_StreamFree(\nGaplessStream)
      debugMsg2(sProcName, "BASS_StreamFree(" + decodeHandle(\nGaplessStream) + ")", nBassResult)
    EndWith
  Next n
  If gbClosingDown = #False
    clearAllGaplessInds()
  EndIf
  gnGaplessSeqCount = 0

  Select nAudioDriver
    Case #SCS_DRV_BASS_DS, #SCS_DRV_BASS_WASAPI, #SCS_DRV_BASS_ASIO  ; BASS
      
      ; Moved here 17Mar2023 11.10.0am (was later in this procedure)
      debugMsg(sProcName, "calling freeMixerStreams()")
      freeMixerStreams()
      ; End moved here 17Mar2023 11.10.0am
      
      debugMsg(sProcName, "calling freeStreams(#True)")
      freeStreams(#True)
      
      For d = 0 To (gnPhysicalAudDevs - 1)
        With gaAudioDev(d)
          If \bInitialized
            Select \nAudioDriver
              Case #SCS_DRV_BASS_DS, #SCS_DRV_BASS_WASAPI
                nBassResult = BASS_SetDevice(\nBassDevice)
                debugMsg2(sProcName, "BASS_SetDevice(" + \nBassDevice + ")", nBassResult)
                If nBassResult = #BASSTRUE
                  nBassResult = BASS_Free()
                  debugMsg2(sProcName, "BASS_Free() for device " + \nBassDevice, nBassResult)
                EndIf
                
              Case #SCS_DRV_BASS_ASIO
                nBassResult = BASS_ASIO_SetDevice(\nDevBassASIODevice)
                debugMsg2(sProcName, "BASS_ASIO_SetDevice(" + \nDevBassASIODevice + ")", nBassResult)
                If nBassResult = #BASSTRUE
                  nBassResult = BASS_ASIO_Free()
                  debugMsg2(sProcName, "BASS_ASIO_Free() for ASIO device " + \nDevBassASIODevice, nBassResult)
                EndIf
                
            EndSelect
            \bInitialized = #False
          EndIf
        EndWith
      Next d
      
      For i = 1 To gnLastCue
        j = aCue(i)\nFirstSubIndex
        While j >= 0
          If aSub(j)\bSubEnabled
            If aSub(j)\bSubTypeP
              For d = 0 To grLicInfo\nMaxAudDevPerAud
                aSub(j)\nPLBassDevice[d] = grSubDef\nPLBassDevice[d]
                aSub(j)\bPLASIO[d] = grSubDef\bPLASIO[d]
                aSub(j)\nPLBassASIODevice[d] = grSubDef\nPLBassASIODevice[d]
              Next d
            EndIf
            If aSub(j)\bSubTypeHasAuds
              k = aSub(j)\nFirstAudIndex
              While k >= 0
                For d = 0 To grLicInfo\nMaxAudDevPerAud
                  aAud(k)\nBassDevice[d] = grAudDef\nBassDevice[d]
                  aAud(k)\bASIO[d] = grAudDef\bASIO[d]
                  aAud(k)\nBassASIODevice[d] = grAudDef\nBassASIODevice[d]
                  aAud(k)\nBassChannel[d] = grAudDef\nBassChannel[d]
                Next d
                k = aAud(k)\nNextAudIndex
              Wend
            EndIf
          EndIf
          j = aSub(j)\nNextSubIndex
        Wend
      Next i
      
      nDevMapPtr = grProd\nSelectedDevMapPtr
      If nDevMapPtr >= 0
        d = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
        While d >= 0
          With grMaps\aDev(d)
            If (\nDevGrp = #SCS_DEVGRP_AUDIO_OUTPUT) And (\bExists)
              nPrevMixerStreamPtr = \nMixerStreamPtr ; Added 3Oct2023 11.10.0cf
              ; debugMsg(sProcName, "changing grMaps\aDev(" + d + ")\nMixerStreamPtr from " + \nMixerStreamPtr + " To " + grDevMapDevDef\nMixerStreamPtr)
              \nMixerStreamPtr = grDevMapDevDef\nMixerStreamPtr
              \nBassDevice = grDevMapDevDef\nBassDevice
              ; debugMsg(sProcName, "grMaps\aDev(" + d + ")\nBassDevice=" + \nBassDevice)
              \bBassASIO = grDevMapDevDef\bBassASIO
              \nBassASIODevice = grDevMapDevDef\nBassASIODevice
              \bBassASIO = grDevMapDevDef\bBassASIO
              ; Added 3Oct2023 11.10.0cf following test of:
              ; (a) import devices from another cue file
              ; (b) apply device changes
              ; (c) import a cue from another cue file, where this cue contains an audio file sub-cue (and there are no existing audio cues in the cue file)
              ; (d) try to delete the audio file sub-cue (leaving, in this case, a lighting sub-cue from the imported cue)
              ; The attempt to delete the audio file sub-cue crashed openMediaFile() because \nReassignDevMapDevPtr pointed to a device map entry where the
              ; mixer stream had been closed, leaving \nMixerStreamPtr = -1 (the default). Since \nReassignDevMapDevPtr "didn't know about this", openMediafile()
              ; thought it didn't need to open the mixer stream, but then crashed on trying to use (\nMixerStreamPtr = -1) as an index to an array.
              If nPrevMixerStreamPtr <> grDevMapDevDef\nMixerStreamPtr
                d2 = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
                While d2 >= 0
                  If grMaps\aDev(d2)\nDevGrp = #SCS_DEVGRP_AUDIO_OUTPUT
                    If grMaps\aDev(d2)\nReassignDevMapDevPtr = d
                      ; debugMsg(sProcName, "changing grMaps\aDev(" + d2 + ")\nReassignDevMapDevPtr from " + grMaps\aDev(d2)\nReassignDevMapDevPtr + " To " + grDevMapDevDef\nReassignDevMapDevPtr)
                      grMaps\aDev(d2)\nReassignDevMapDevPtr = grDevMapDevDef\nReassignDevMapDevPtr
                    EndIf
                  EndIf
                  d2 = grMaps\aDev(d2)\nNextDevIndex
                Wend
              EndIf
              ; End added 3Oct2023 11.10.0cf
            EndIf
            d = \nNextDevIndex
          EndWith
        Wend
      EndIf
      
      ; Moved near start of procedure 17Mar2023 11.10.0am
      ; debugMsg(sProcName, "calling freeMixerStreams()")
      ; freeMixerStreams()
      ; End moved near start of procedure 17Mar2023 11.10.0am
      
      For n = 0 To ArraySize(gaMixerStreams())
        gaMixerStreams(n) = grMixerStreamDef
      Next n
      
    Case #SCS_DRV_SMS_ASIO ; SM-S
      
      debugMsg(sProcName, "calling resetSMS()")
      resetSMS()
      
      For i = 1 To gnLastCue
        j = aCue(i)\nFirstSubIndex
        While j >= 0
          If aSub(j)\bSubTypeHasAuds And aSub(j)\bSubEnabled
            k = aSub(j)\nFirstAudIndex
            While k >= 0
              aAud(k)\nPrimaryChan = grAudDef\nPrimaryChan
              aAud(k)\sPPrimaryChan = grAudDef\sPPrimaryChan
              aAud(k)\nAltPrimaryChan = grAudDef\nAltPrimaryChan
              aAud(k)\sAltPPrimaryChan = grAudDef\sAltPPrimaryChan
              aAud(k)\sAudPChanList = grAudDef\sAudPChanList
              aAud(k)\sAltAudPChanList = grAudDef\sAltAudPChanList
              aAud(k)\sAudPXChanList = grAudDef\sAudPXChanList
              aAud(k)\sAltAudPXChanList = grAudDef\sAltAudPXChanList
              For d = 0 To grLicInfo\nMaxAudDevPerAud
                aAud(k)\sDevPXChanListLeft[d] = grAudDef\sDevPXChanListLeft[d]
                aAud(k)\sDevPXChanListRight[d] = grAudDef\sDevPXChanListRight[d]
                aAud(k)\sAltDevPXChanListLeft[d] = grAudDef\sAltDevPXChanListLeft[d]
                aAud(k)\sAltDevPXChanListRight[d] = grAudDef\sAltDevPXChanListRight[d]
              Next d
              k = aAud(k)\nNextAudIndex
            Wend
          EndIf
          j = aSub(j)\nNextSubIndex
        Wend
      Next i
      
  EndSelect
  
  If nAudioDriver = #SCS_DRV_SMS_ASIO
    closeSMSConnection()
  EndIf
  
  gnStandbyCuePtr = -1
  gbClosingDevices = #False
  
  debugMsg(sProcName, #SCS_END)

EndProcedure

Procedure closeAllDevices(bIncludeRAI=#True, bIncludeFM=#True)
  ; Added bIncludeFM 16Aug2021 11.8.5.1aa
  PROCNAMEC()
  
  debugMsg(sProcName, #SCS_START + ", bIncludeRAI=" + strB(bIncludeRAI))
  
  debugMsg(sProcName, "calling stopAllTimeCodes()")
  stopAllTimeCodes()
  
  debugMsg(sProcName, "closing MIDI ports (including MTC)")
  closeMidiPorts()
  
  debugMsg(sProcName, "closing RS232 ports")
  closeRS232()
  
  If bIncludeRAI
    debugMsg(sProcName, "calling RAI_Terminate()")
    RAI_Terminate()
  EndIf
  
  debugMsg(sProcName, "closing Network connections(" + strB(bIncludeRAI) + ", " + strB(bIncludeFM) + ")")
  closeNetwork(bIncludeRAI, bIncludeFM) ; Added bIncludeFM 16Aug2021 11.8.5.1aa
  
  If gbFTD2XXAvailable
    debugMsg(sProcName, "calling DMX_closeDMXDevs()")
    DMX_closeDMXDevs()
  EndIf
  
  debugMsg(sProcName, "calling closeDevices(" + decodeDriver(gnCurrAudioDriver) + ")")
  closeDevices(gnCurrAudioDriver)
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure closeAud(pAudPtr, bUnloadingCue=#False, bCompleteCue=#False)
  PROCNAMECA(pAudPtr)
  Protected nVidPicTarget
  Protected bAudStreamsFreed
  Protected bUse2DDrawing

  debugMsg(sProcName, #SCS_START + ", bUnloadingCue=" + strB(bUnloadingCue) + ", bCompleteCue=" + strB(bCompleteCue))
  
  With aAud(pAudPtr)
    ; debugMsg(sProcName, "\nAudLinkCount=" + \nAudLinkCount)
    If \bAudTypeA
      CompilerIf #c_include_tvg
        If \bLogo = #False
          If grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG
            removeAudFromTVGFadeAudArray(pAudPtr)
          EndIf
        EndIf
      CompilerEndIf
      bUse2DDrawing = checkUse2DDrawing(\nSubIndex)
    EndIf
    
    If \nAudLinkCount > 0
      debugMsg(sProcName, "calling removeLinksOneAud(" + getAudLabel(pAudPtr) + ")")
      removeLinksOneAud(pAudPtr)
    EndIf
    
    If (\nFileFormat = #SCS_FILEFORMAT_LIVE_INPUT) And (aSub(\nSubIndex)\bStartedInEditor = #False)
      ; do not 'stop' live input channels as they should already have been muted, and some live inputs may have been re-instated by a later cue
      \nFileState = #SCS_FILESTATE_CLOSED
      debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nFileState=" + decodeFileState(\nFileState))
      If \nPreEditPtr >= 0
        gaHoldAud(\nPreEditPtr)\nFileState = #SCS_FILESTATE_CLOSED
        debugMsg(sProcName, "gaHoldAud(" + getAudLabel(\nPreEditPtr) + ")\nFileState=" + decodeFileState(gaHoldAud(\nPreEditPtr)\nFileState))
      EndIf
      
    ElseIf (\nFileFormat = #SCS_FILEFORMAT_PICTURE) And (aSub(\nSubIndex)\bStartedInEditor) And (bUse2DDrawing)
      ; do not close a picture file that was started in the editor
      
    Else
      debugMsg(sProcName, "\nFileState=" + decodeFileState(\nFileState) + ", \nFileState=" + decodeFileState(\nFileState) + ", \nAudState=" + decodeCueState(\nAudState))
      If \nFileState = #SCS_FILESTATE_OPEN
        If \bAudTypeA And \bLogo ; Test added 15Mar2025 11.10.8al following emails and log files from Andy Jones
          ; Logo, so keep open
        Else
          If (\nAudState >= #SCS_CUE_FADING_IN) And (\nAudState <= #SCS_CUE_FADING_OUT)
            If \bAudTypeA
              debugMsg(sProcName, "calling StopOrFadeOutAudChannels(" + getAudLabel(pAudPtr) + ", #False, #False, #False, " + decodeVidPicTarget(\nAudVidPicTarget) + ")")
              StopOrFadeOutAudChannels(pAudPtr, #False, #False, #False, \nAudVidPicTarget)
            Else
              debugMsg(sProcName, "calling StopOrFadeOutAudChannels(" + getAudLabel(pAudPtr) + ")")
              StopOrFadeOutAudChannels(pAudPtr)
            EndIf
          EndIf ; EndIf (\nAudState >= #SCS_CUE_FADING_IN) And (\nAudState <= #SCS_CUE_FADING_OUT)
          debugMsg(sProcName, "calling freeAudStreams(" + getAudLabel(pAudPtr) + ")")
          freeAudStreams(pAudPtr) ; nb calls closeVideo() for \bAudTypeA, and closeVideo() calls closePicture() for pictures
          bAudStreamsFreed = #True
          \nFileState = #SCS_FILESTATE_CLOSED
          \nImagePtr = -1
          debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nFileState=" + decodeFileState(\nFileState) + ", \nImagePtr=" + \nImagePtr)
          If \nPreEditPtr >= 0
            gaHoldAud(\nPreEditPtr)\nFileState = #SCS_FILESTATE_CLOSED
          EndIf
        EndIf ; EndIf \bAudTypeA And \bLogo / Else
      EndIf ; EndIf \nFileState = #SCS_FILESTATE_OPEN
    EndIf
    
    If (\nAudState = #SCS_CUE_STANDBY) And (\nCueIndex < gnStandbyCuePtr)
      debugMsg(sProcName, "calling endOfAud(" + getAudLabel(pAudPtr) + ", " + decodeCueState(#SCS_CUE_COMPLETED) + ")")
      endOfAud(pAudPtr, #SCS_CUE_COMPLETED)
    EndIf
    
    If (\nFileFormat = #SCS_FILEFORMAT_PICTURE) And ((grVideoDriver\nVideoPlaybackLibrary <> #SCS_VPL_TVG) Or (bUse2DDrawing))
      For nVidPicTarget = 0 To ArraySize(grVidPicTarget())
        If grVidPicTarget(nVidPicTarget)\nPrimaryAudPtr = pAudPtr
          debugMsg(sProcName, "calling hidePicture(" + getAudLabel(pAudPtr) + ", " + decodeVidPicTarget(nVidPicTarget) + ")")
          hidePicture(pAudPtr, nVidPicTarget)
        EndIf
      Next nVidPicTarget
      \bReloadMainImage = #True
      
    ElseIf (\nFileFormat = #SCS_FILEFORMAT_VIDEO) Or
           ((\nFileFormat = #SCS_FILEFORMAT_PICTURE) And (grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG) And (bUse2DDrawing = #False))
      If bAudStreamsFreed = #False
        debugMsg(sProcName, "calling closeVideo(" + getAudLabel(pAudPtr) + ")")
        closeVideo(pAudPtr)
      EndIf
      \bReloadMainImage = #True
      
    EndIf
    
    If (bUnloadingCue) And ((\nAudState < #SCS_CUE_COMPLETED) Or (aCue(\nCueIndex)\bHotkey) Or (aCue(\nCueIndex)\bExtAct) Or (aCue(\nCueIndex)\bCallableCue))
      audSetState(pAudPtr, #SCS_CUE_NOT_LOADED, 28)
      If \bAudTypeA
        freeAudImages(pAudPtr)
      EndIf
    ElseIf bCompleteCue
      debugMsg(sProcName, "calling endOfAud(" + getAudLabel(pAudPtr) + ", " + decodeCueState(#SCS_CUE_COMPLETED) + ")")
      endOfAud(pAudPtr, #SCS_CUE_COMPLETED)
    ElseIf \nFileState = #SCS_FILESTATE_CLOSED  ; added 16Sep2017 11.7.0 because sometimes an audio file in a playlist will be left as 'playing' when the editor is closed
      If \nAudState < #SCS_CUE_COMPLETED
        audSetState(pAudPtr, #SCS_CUE_NOT_LOADED, 29)
      EndIf
    EndIf
    
    \bTempoChannelCreated = #False
    \bTempoChannelReqd = #False
    \nChannelTempoChannelReplaced = grAudDef\nChannelTempoChannelReplaced
    
    setIgnoreDevInds(pAudPtr) ; reset 'ignore dev' inds in case aud is re-opened, especially after changing operational mode
    
    debugMsg(sProcName, #SCS_END + ", \nFileState=" + decodeFileState(\nFileState) + ", \nAudState=" + decodeCueState(\nAudState))
  EndWith
  
EndProcedure

Procedure closeCue(pCuePtr, bUnloadingCue=#False, bCompleteCue=#False)
  PROCNAMECQ(pCuePtr)
  Protected j
  
  debugMsg(sProcName, #SCS_START + ", bUnloadingCue=" + strB(bUnloadingCue) + ", bCompleteCue=" + strB(bCompleteCue))

  j = aCue(pCuePtr)\nFirstSubIndex
  While j >= 0
    If aSub(j)\bSubEnabled
      debugMsg(sProcName, "calling closeSub(" + getSubLabel(j) + ", " + strB(bUnloadingCue) + ", " + strB(bCompleteCue) + ")")
      closeSub(j, bUnloadingCue, bCompleteCue)
    EndIf
    j = aSub(j)\nNextSubIndex
  Wend

  If (aCue(pCuePtr)\nCueState = #SCS_CUE_STANDBY) And (pCuePtr < gnStandbyCuePtr)
    aCue(pCuePtr)\nCueState = #SCS_CUE_COMPLETED
  EndIf
  
  If grCED\bClosingEditor
    aCue(pCuePtr)\bCloseCueWhenLeavingEditor = #False
  EndIf
  
  ; added 29Jan2019 11.8.0.2ad to help sort out issue with Auto-Start after Load not starting in Marco's "SPACE JOURNEY DEMO - Low Q.scs11"
  aCue(pCuePtr)\bTimeToStartCueSet = #False
  ; end added 29Jan2019 11.8.0.2ad
  
  setCueState(pCuePtr)
  
  debugMsg(sProcName, #SCS_END + ", \nCueState=" + decodeCueState(aCue(pCuePtr)\nCueState))

EndProcedure

Procedure closeMidiFile(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nErrCode.l
  Protected sMciString.s
  Protected bDummyDev
  
  ; warning! all mciSendString calls must be from the same thread or mciSendString returns error 263 (not a registered device), so use main thread
  ASSERT_THREAD(#SCS_THREAD_MAIN)
  
  With aAud(pAudPtr)
    bDummyDev = gaMidiOutDevice(\nMidiPhysicalDevPtr)\bDummy
    debugMsg(sProcName, "gaMidiOutDevice(" + \nMidiPhysicalDevPtr + ")\bDummy=" + strB(gaMidiOutDevice(\nMidiPhysicalDevPtr)\bDummy) + ", bDummyDev=" + strB(bDummyDev))
    If bDummyDev = #False
      sMciString = "close " + \sMidiAlias
      nErrCode = mciSendString_(sMciString, #Null, 0, #Null)
      debugMsg2(sProcName, "mciSendString_(" + sMciString + ", #Null, 0, #Null)", nErrCode)
      \sMidiAlias = ""
    EndIf
  EndWith

EndProcedure

Procedure closeSub(pSubPtr, bUnloadingCue=#False, bCompleteCue=#False, bTypeUStopsMTC=#True)
  PROCNAMECS(pSubPtr)
  Protected k, bCalledEndOfSub
  
  ; debugMsg(sProcName, #SCS_START + ", bUnloadingCue=" + strB(bUnloadingCue) + ", bCompleteCue=" + strB(bCompleteCue) + ", bTypeUStopsMTC=" + strB(bTypeUStopsMTC))
  
  ; bUnloadingCue and bCompleteCue mutually exclusive - both cannot be #True
  If bUnloadingCue And bCompleteCue
    debugMsg(sProcName, "WARNING: bUnloadingCue=" + strB(bUnloadingCue) + " and bCompleteCue=" + strB(bCompleteCue))
  EndIf
  
  With aSub(pSubPtr)
    If \bSubTypeHasAuds
      k = \nFirstAudIndex
      While k >= 0
        ; debugMsg(sProcName, "calling closeAud(" + getAudLabel(k) + ", " + strB(bUnloadingCue) + ", " + strB(bCompleteCue) + ")")
        closeAud(k, bUnloadingCue, bCompleteCue)
        k = aAud(k)\nNextAudIndex
      Wend
    EndIf
    
    If \bSubTypeU
      stopSub(pSubPtr, "U", #False, #True, #False, bTypeUStopsMTC)  ; mod 7Jan2017
    EndIf
    
    If (\nSubState = #SCS_CUE_STANDBY) And (\nCueIndex < gnStandbyCuePtr)
      If aCue(\nCueIndex)\bNonLinearCue
        debugMsg(sProcName, "calling endOfSub(" + getSubLabel(pSubPtr) + ", #SCS_CUE_NOT_LOADED)")
        endOfSub(pSubPtr, #SCS_CUE_NOT_LOADED)
        bCalledEndOfSub = #True
      Else
        debugMsg(sProcName, "calling endOfSub(" + getSubLabel(pSubPtr) + ", #SCS_CUE_COMPLETED)")
        endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
        bCalledEndOfSub = #True
      EndIf
    EndIf
    
    If bCalledEndOfSub = #False And bUnloadingCue
      debugMsg(sProcName, "calling endOfSub(" + getSubLabel(pSubPtr) + ", #SCS_CUE_NOT_LOADED)")
      endOfSub(pSubPtr, #SCS_CUE_NOT_LOADED)
      bCalledEndOfSub = #True
    EndIf
    
    If bCalledEndOfSub = #False And bCompleteCue
      debugMsg(sProcName, "calling endOfSub(" + getSubLabel(pSubPtr) + ", #SCS_CUE_COMPLETED)")
      endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
      bCalledEndOfSub = #True
    EndIf
    
    ; debugMsg(sProcName, "calling freeDeadGaplessStreams()")
    freeDeadGaplessStreams()
    
    ; debugMsg(sProcName, "calling hideMonitorsNotInUse()")
    hideMonitorsNotInUse()
    
    \bStartedInEditor = #False
    ; debugMsg(sProcName, "\bStartedInEditor=" + strB(\bStartedInEditor))
    
  EndWith
  
  ; debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure stopTestTone()
  PROCNAMEC()
  Protected nBassResult.l, nMyTestToneChan.l, qNotBefore.q

  debugMsg(sProcName, #SCS_START)
  
  If gbUseBASS  ; BASS
    nMyTestToneChan = grTestTone\nTestToneChan
    
    If nMyTestToneChan <> 0
      nBassResult = BASS_ChannelSlideAttribute(nMyTestToneChan, #BASS_ATTRIB_VOL, 0, gnStopFadeTime)
      debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nMyTestToneChan) + ", BASS_ATTRIB_VOL, 0, " + gnStopFadeTime + ")", nBassResult)
      Delay(gnStopFadeTime)
      nBassResult = BASS_ChannelStop(nMyTestToneChan)
      debugMsg2(sProcName, "BASS_ChannelStop(" + decodeHandle(nMyTestToneChan) + ")", nBassResult)
      freeStreamRequest(nMyTestToneChan, -1, -1, 0, #False, grTestTone\nMixerStreamPtr)
      grTestTone\nTestToneChan = 0
    EndIf
    
  Else  ; SM-S
    If grMMedia\sTestToneChan
      sendSMSCommand("set chan i1000 mute on")
      sendSMSCommand("set chan x1000." + grMMedia\sTestToneChan + " gain 0")
      grMMedia\sTestToneChan = ""
    EndIf
    
  EndIf
  
  grTestTone\bPlayingTestTone = #False
  grTestTone\qTimeToRemoveTimer = ElapsedMilliseconds() + 1000
  
  If gbUseBASSMixer = #False
    qNotBefore = ElapsedMilliseconds() + gnStopFadeTime
    samAddRequest(#SCS_SAM_BUILD_DEV_CHANNEL_LIST, 0, 0, 0, "", qNotBefore)
  EndIf
  
EndProcedure

Procedure getChannelAttributes(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nBassResult.l, fBassLevel.f, fBassPan.f
  Protected d, d2
  Protected fTotalVol.f
  Protected nVideoVol, nVideoPan
  Protected fdB.f
  Protected n1, m1
  Protected n, m
  Protected fLeft.f, fRight.f
  Protected nDevMapDevPtr, fOutputGain.f
  Protected nInputDevMapDevPtr, fInputLevel.f
  Protected nFirstInputDev, nLastInputDev
  Protected fReqdDBLevel.f
  
  ; debugMsg(sProcName, #SCS_START)
  
  With aAud(pAudPtr)
    If \bWaitForLinkSyncPos
      ; exit immediately if we are waiting for LinkSyncPos because fields like \fCueVolNow[d] must not be updated when waiting for LinkSyncPos
      ; as the audio level is muted but \fCueVolNow[d] contains the initial level to be set when SyncProcLinkPos() is processed
      ProcedureReturn
    EndIf
    Select \nFileFormat
      Case #SCS_FILEFORMAT_MIDI
        d = 0
        \fCueVolNow[d] = grLevels\fMaxBVLevel
        \fCuePanNow[d] = #SCS_PANCENTRE_SINGLE
        \fCueTotalVolNow[d] = \fCueVolNow[d]
        
      Case #SCS_FILEFORMAT_PICTURE, #SCS_FILEFORMAT_VIDEO
        d = 0
        \fCueTotalVolNow[d] = \fCueVolNow[d]
        CompilerIf #cTraceCueTotalVolNow
          debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\fCueTotalVolNow[" + d + "]=" + traceLevel(\fCueTotalVolNow[d]))
        CompilerEndIf
        
      Case #SCS_FILEFORMAT_AUDIO
        If gbUseBASS  ; BASS
          
          For d = 0 To grLicInfo\nMaxAudDevPerAud
            If \nBassChannel[d] <> 0
              nBassResult = BASS_ChannelGetAttribute(\nBassChannel[d], #BASS_ATTRIB_VOL, @fBassLevel)
              CompilerIf #cTraceGetLevels Or #cTraceCueTotalVolNow
                debugMsg3(sProcName, "BASS_ChannelGetAttribute(" + decodeHandle(\nBassChannel[d]) + ", BASS_ATTRIB_VOL, @fBassLevel) returned " + nBassResult + ", fBassLevel=" + traceLevel(fBassLevel) +
                                     ", \bInLoopXFade=" + strB(\bInLoopXFade) + ", \nBassAltChannel[" + d + "]=" + decodeHandle(\nBassAltChannel[d]))
              CompilerEndIf
              CompilerIf #cTraceGetLevelsForExcel
                debugMsg3(sProcName, "Excel: " + Chr(9) + convertBVLevelToDBString(fBassLevel))
              CompilerEndIf
              If gbUseBASSMixer = #False
                nDevMapDevPtr = \nOutputDevMapDevPtr[d]
                If nDevMapDevPtr >= 0
                  fOutputGain = grMaps\aDev(nDevMapDevPtr)\fDevOutputGain
                  If fOutputGain <> 1.0
                    fBassLevel / fOutputGain
                  EndIf
                  ; debugMsg3(sProcName, "fOutputGain=" + traceLevel(fOutputGain) + ", fBassLevel=" + traceLevel(fBassLevel))
                EndIf
              EndIf
              If nBassResult = #BASSTRUE
                \fCueVolNow[d] = fBassLevel
                fTotalVol = fBassLevel
                If \bUseMatrix[d] = #False
                  nBassResult = BASS_ChannelGetAttribute(\nBassChannel[d], #BASS_ATTRIB_PAN, @fBassPan)
                  CompilerIf #cTraceGetPan
                    debugMsg3(sProcName, "BASS_ChannelGetAttribute("+ decodeHandle(\nBassChannel[d]) + ", BASS_ATTRIB_PAN, @fBassPan) returned " + nBassResult +
                                         ", fBassPan=" + formatPan(fBassPan))
                  CompilerEndIf
                Else
                  n1 = \nMatrixOutputs[d]  ; matrix outputs
                  m1 = \nNrOfInputChans    ; matrix inputs
                  fLeft = 0
                  fRight = 0
                  For n = \nMatrixOutputOffSet[d] To (\nMatrixOutputOffSet[d] + \nSelectedDeviceOutputs[d] - 1)
                    For m = 0 To (m1 - 1)
                      If ((n - \nMatrixOutputOffSet[d]) % \nSelectedDeviceOutputs[d]) = 0
                        fLeft = fLeft + \aMixerMatrix[d]\aMatrix[(n * m1) + m]
                      Else
                        fRight = fRight + \aMixerMatrix[d]\aMatrix[(n * m1) + m]
                      EndIf
                    Next m
                  Next n
                  ; CompilerIf #cTraceGetPan
                    ; debugMsg3(sProcName, "fLeft=" + formatLevel(fLeft) + ", fRight=" + formatLevel(fRight))
                  ; CompilerEndIf
                  If fLeft = fRight
                    ; center
                    fBassPan = 0
                  ElseIf fLeft < fRight
                    ; pan right
                    fBassPan = (1 - (fLeft / fRight))
                  Else
                    ; pan left
                    fBassPan = (1 - (fRight / fLeft)) * -1
                  EndIf
                EndIf
                \fCuePanNow[d] = fBassPan
                CompilerIf #cTraceGetPan
                  debugMsg3(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\fCueVolNow[" + d + ")=" + traceLevel(\fCueVolNow[d]) + ", \fCuePanNow[" + d + ")=" + formatPan(\fCuePanNow[d]))
                CompilerEndIf
                If \bInLoopXFade
                  If \nBassAltChannel[d] <> 0
                    nBassResult = BASS_ChannelGetAttribute(\nBassAltChannel[d], #BASS_ATTRIB_VOL, @fBassLevel)
                    CompilerIf #cTraceGetLevels Or #cTraceCueTotalVolNow
                      debugMsg3(sProcName, "BASS_ChannelGetAttribute(" + decodeHandle(\nBassAltChannel[d]) + ", BASS_ATTRIB_VOL, @fBassLevel) returned " + nBassResult +
                                           ", fBassLevel=" + traceLevel(fBassLevel))
                    CompilerEndIf
                    CompilerIf #cTraceGetLevelsForExcel
                      debugMsg3(sProcName, "Excel: " + Chr(9) + convertBVLevelToDBString(fBassLevel))
                    CompilerEndIf
                    If nBassResult = #BASSTRUE
                      If gbUseBASSMixer = #False
                        nDevMapDevPtr = \nOutputDevMapDevPtr[d]
                        If nDevMapDevPtr >= 0
                          fOutputGain = grMaps\aDev(nDevMapDevPtr)\fDevOutputGain
                          If fOutputGain <> 1.0
                            fBassLevel / fOutputGain
                          EndIf
                        EndIf
                      EndIf
                      \fCueAltVolNow[d] = fBassLevel
                      fTotalVol + fBassLevel
                    EndIf
                  EndIf
                EndIf
                \fCueTotalVolNow[d] = fTotalVol
                CompilerIf #cTraceCueTotalVolNow
                  debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\fCueTotalVolNow[" + d + "]=" + traceLevel(aAud(pAudPtr)\fCueTotalVolNow[d]))
                CompilerEndIf
              EndIf
            EndIf
          Next d
          
        Else  ; SM-S
          For d = 0 To grLicInfo\nMaxAudDevPerAud
            If Len(\sDevPXChanListLeft[d]) > 0
              fLeft = getSMSGain(\sDevPXChanListLeft[d])
              If Len(\sDevPXChanListRight[d]) > 0
                fRight = getSMSGain(\sDevPXChanListRight[d])
              Else
                fRight = fLeft
              EndIf
              ; debugMsg(sProcName, "\sDevPXChanListLeft[" + d + "]=" + \sDevPXChanListLeft[d] + ", \sDevPXChanListRight[" + d + "]=" + \sDevPXChanListRight[d] + ", fLeft=" + StrF(fLeft,4) + ", fRight=" + StrF(fRight,4))
              If (fLeft <> -1) And (fRight <> -1)
                If \sDevPXDownMix[d] = "DM"
                  macSMSLevelPlus6dB(fLeft)
                  macSMSLevelPlus6dB(fRight)
                EndIf
                If fLeft = fRight
                  ; center
                  \fCuePanNow[d] = 0
                  \fCueVolNow[d] = fLeft
                ElseIf fLeft < fRight
                  ; pan right
                  \fCuePanNow[d] = (1 - (fLeft / fRight))
                  \fCueVolNow[d] = fRight
                Else
                  ; pan left
                  \fCuePanNow[d] = (1 - (fRight / fLeft)) * -1
                  \fCueVolNow[d] = fLeft
                EndIf
                \fCueTotalVolNow[d] = \fCueVolNow[d]
                ; debugMsg(sProcName, "\fCueTotalVolNow[" + d + "]=" + StrF(\fCueTotalVolNow[d],3))
              EndIf
            EndIf
          Next d
          
        EndIf
        
      Case #SCS_FILEFORMAT_LIVE_INPUT
        ; debugMsg(sProcName, "Live Input")
        
    EndSelect
  EndWith

EndProcedure

Procedure getFileDetail(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nBassChannel.l
  Protected d
  Protected nMarkers
  Protected rFileInfo.tyFileInfo

  ; debugMsg(sProcName, #SCS_START)
  
  grFileInfo = rFileInfo ; clear grFileInfo
  
  With grFileInfo
    
    \sFileName = aAud(pAudPtr)\sFileName
    \sFileExt = GetExtensionPart(\sFileName)
    ; debugMsg(sProcName, "grFileInfo\sFileTitle=" + \sFileTitle + ", \sFileExt=" + \sFileExt)
    ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\bAudTypeForP=" + strB(aAud(pAudPtr)\bAudTypeForP) + ", \bAudPlaceHolder=" + strB(aAud(pAudPtr)\bAudPlaceHolder))
    If (aAud(pAudPtr)\bAudTypeForP) And (aAud(pAudPtr)\bAudPlaceHolder = #False)
      
      If Len(\sFileTitle) = 0
        
        Select LCase(\sFileExt)
          Case "wav"
            If aAud(pAudPtr)\nFirstSoundingDev >= 0
              d = aAud(pAudPtr)\nFirstSoundingDev
              nBassChannel = aAud(pAudPtr)\nBassChannel[d]
              nMarkers = analyzeMrkFile(\sFileName, nBassChannel) ; get cue points (markers) from Wavelab MRK file if present
              If nMarkers <= 0
                ; Wavelab MRK file not present, or no markers found
                debugMsg(sProcName, "calling analyzeWavFile(" + GetFilePart(\sFileName))
                analyzeWavFile(\sFileName, nBassChannel)  ; get cue points directly from the WAV file
              EndIf
            EndIf
            
          Case "mid"
            ; no action
            
          Default ; mp3, etc
            d = aAud(pAudPtr)\nFirstSoundingDev
            If d >= 0
              nBassChannel = aAud(pAudPtr)\nBassChannel[d]
              nMarkers = analyzeMrkFile(\sFileName, nBassChannel) ; get cue points (markers) from Wavelab MRK file if present
            EndIf
            GetTagsFromFile(\sFileName)
            \sFileTitle = Trim(removeNonPrintingChars(grSongTags\strTitle))
            
        EndSelect
        
      EndIf
      
    EndIf
    
    ; debugMsg(sProcName, "grFileInfo\sFileTitle=" + \sFileTitle)
    If Len(\sFileTitle) = 0
      \sFileTitle = removeNonPrintingChars(ignoreExtension(GetFilePart(\sFileName)))
    EndIf
    
    debugMsg(sProcName, "grFileInfo\sFileName=" + GetFilePart(\sFileName) + ", \sFileTitle=" + \sFileTitle)
    ; debugMsg(sProcName, "\sComment=" + \sComment)
    
    ; debugMsg(sProcName,"calling updateCueMarkerArrayWithCuePoints(" + getAudLabel(pAudPtr) + ")")
    updateCueMarkerArrayWithCuePoints(pAudPtr)
    
    ; debugMsg(sProcName, "calling loadCueMarkerArrays()")
    loadCueMarkerArrays()
    
  EndWith
  
  ; debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure loadArrayAudioDevs()
  PROCNAMEC()
  Protected d, n
  Protected rConnectedDev.tyConnectedDev
  Protected sMsg.s
  
  ; debugMsg(sProcName, #SCS_START + ", gnMaxConnectedDev=" + gnMaxConnectedDev + ", gnPhysicalAudDevs=" + gnPhysicalAudDevs)
  debugMsg(sProcName, "Audio devices")
  
  ReDim gaAudioDev(gnPhysicalAudDevs)
  d = -1
  For n = 0 To gnMaxConnectedDev
    If gaConnectedDev(n)\nDevType = #SCS_DEVTYPE_AUDIO_OUTPUT
      rConnectedDev = gaConnectedDev(n)
      ; debugMsg(sProcName, "rConnectedDev\nDriver=" + decodeDriver(rConnectedDev\nDriver) + ", \sPhysicalDevDesc=" + rConnectedDev\sPhysicalDevDesc)
      d + 1
      CheckSubInRange(d, ArraySize(gaAudioDev()), "gaAudioDev()")
      gaAudioDev(d) = grAudioDevDef
      With gaAudioDev(d)
        \nAudioDriver = rConnectedDev\nDriver
        \sDesc = rConnectedDev\sPhysicalDevDesc
        \bDummy = rConnectedDev\bDummy
        \bDefaultDev = rConnectedDev\bDefaultDev
        \nBassInitErrorCode = rConnectedDev\nBassInitErrorCode
        \nBassInitFlags = rConnectedDev\nBassInitFlags
        Select rConnectedDev\nDriver
          Case #SCS_DRV_BASS_DS, #SCS_DRV_BASS_WASAPI
            \nBassDevice = rConnectedDev\nDevice
          Case #SCS_DRV_BASS_ASIO
            \bASIO = #True
            \nDevBassASIODevice = rConnectedDev\nDevice
          Case #SCS_DRV_SMS_ASIO
            \bSMS = #True
        EndSelect
        \nSpeakers = rConnectedDev\nSpeakers
        \nOutputs = rConnectedDev\nOutputs
        \nInputs = rConnectedDev\nInputs
        \bNoSoundDevice = rConnectedDev\bNoSoundDevice
      EndWith
      With gaDriverInfo(rConnectedDev\nDriver)
        \bPhysicalDevsPopulated = #True
      EndWith
    EndIf
  Next n
  
  For d = 0 To (gnPhysicalAudDevs - 1)
    loadOutputArrayForDev(d)
  Next d
  
  For d = 0 To (gnPhysicalAudDevs - 1)
    With gaAudioDev(d)
      sMsg = "gaAudioDev(" + d + ")\nAudioDriver=" + decodeDriver(\nAudioDriver) + ", \sDesc=" + \sDesc + ", \bDefaultDev=" + strB(\bDefaultDev)
      If \bASIO
        sMsg + ", \nDevBassASIODevice=" + \nDevBassASIODevice
      Else
        sMsg + ", \nBassDevice=" + \nBassDevice
      EndIf
      ; sMsg + ", \bASIO=" + strB(\bASIO) + ", \nOutputs=" + \nOutputs + ", \nSpeakers=" + \nSpeakers
      sMsg + ", \nOutputs=" + \nOutputs + ", \nSpeakers=" + \nSpeakers
      debugMsg(sProcName, sMsg)
    EndWith
  Next d
  
EndProcedure

Procedure devIndexForLogicalDev(nDevType, sLogicalDev.s)
  PROCNAMEC()
  Protected n, nDevIndex
  
  ; debugMsg(sProcName, "sLogicalDev=" + sLogicalDev)
  nDevIndex = -1
  Select nDevType
    Case #SCS_DEVTYPE_AUDIO_OUTPUT
      For n = 0 To grProd\nMaxAudioLogicalDev
        If grProd\aAudioLogicalDevs(n)\sLogicalDev = sLogicalDev
          nDevIndex = n
          Break
        EndIf
      Next n
      
    Case #SCS_DEVTYPE_VIDEO_AUDIO
      For n = 0 To grProd\nMaxVidAudLogicalDev
        If grProd\aVidAudLogicalDevs(n)\sVidAudLogicalDev = sLogicalDev
          nDevIndex = n
          Break
        EndIf
      Next n
      
  EndSelect

  ProcedureReturn nDevIndex
EndProcedure

Procedure getBassDeviceForLogicalDev(sAudioLogicalDev.s)
  PROCNAMEC()
  Protected d, nBassDevice, nBassSpeaker.l
  Protected nNrOfOutputChans
  Protected nDevMapPtr
  
  ; debugMsg(sProcName, #SCS_START + ", sAudioLogicalDev=" + sAudioLogicalDev)
  
  nBassDevice = -1  ; nb BASS device -1 = default device
  nBassSpeaker = 0
  nNrOfOutputChans = 0
  
  nDevMapPtr = grProd\nSelectedDevMapPtr
  If nDevMapPtr < 0
    ProcedureReturn nBassDevice
  EndIf
  
  ; debugMsg(sProcName, "grMaps\aMap(" + nDevMapPtr + ")\nFirstDevIndex=" + grMaps\aMap(nDevMapPtr)\nFirstDevIndex)
  d = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
  While d >= 0
    ; debugMsg(sProcName, "grMaps\aDev(" + d + ")\nDevType=" + decodeDevType(grMaps\aDev(d)\nDevType) + ", \bExists=" + strB((grMaps\aDev(d)\bExists)))
    If (grMaps\aDev(d)\nDevType = #SCS_DEVTYPE_AUDIO_OUTPUT) And (grMaps\aDev(d)\bExists)
      ; debugMsg(sProcName, "grMaps\aDev(" + d + ")\sLogicalDev=" + grMaps\aDev(d)\sLogicalDev)
      If grMaps\aDev(d)\sLogicalDev = sAudioLogicalDev
        ; debugMsg(sProcName, "grMaps\aDev(" + d + ")\nBassDevice=" + grMaps\aDev(d)\nBassDevice)
        nBassDevice = grMaps\aDev(d)\nBassDevice
        nBassSpeaker = grMaps\aDev(d)\nBassSpeakerFlags
        nNrOfOutputChans = grMaps\aDev(d)\nNrOfDevOutputChans
        Break
      EndIf
    EndIf
    d = grMaps\aDev(d)\nNextDevIndex
  Wend
  
  ; debugMsg(sProcName, "sAudioLogicalDev=" + sAudioLogicalDev + ", returning " + nBassDevice + ", nBassSpeaker=$" + Hex(nBassSpeaker) + ", nSpeakerFlagsCount=" + nNrOfOutputChans)
  
  grMMedia\nBassSpeaker = nBassSpeaker
  grMMedia\nSpeakerCount = nNrOfOutputChans
  
  ProcedureReturn nBassDevice
EndProcedure

Procedure getMixerStreamPtrForLogicalDev(sLogicalDev.s)
  PROCNAMEC()
  Protected d, nMixerStreamPtr
  Protected nDevMapPtr

  nMixerStreamPtr = -1
  
  nDevMapPtr = grProd\nSelectedDevMapPtr
  If nDevMapPtr >= 0
    d = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
    While d >= 0
      With grMaps\aDev(d)
        If (\nDevType = #SCS_DEVTYPE_AUDIO_OUTPUT) And (\bExists)
          If \sLogicalDev = sLogicalDev
            nMixerStreamPtr = \nMixerStreamPtr
            Break
          EndIf
        EndIf
        d = \nNextDevIndex
      EndWith
    Wend
  EndIf
  
  ; debugMsg(sProcName, "sLogicalDev=" + sLogicalDev + ", returning " + nMixerStreamPtr)
  ProcedureReturn nMixerStreamPtr

EndProcedure

Procedure getProdLogicalDevPtrForLogicalDev(sLogicalDev.s, nDevGrp=#SCS_DEVGRP_AUDIO_OUTPUT)
  PROCNAMEC()
  Protected d
  Protected nProdLogicalDevPtr = -1
  
  With grProd
    Select nDevGrp
      Case #SCS_DEVGRP_AUDIO_OUTPUT
        For d = 0 To \nMaxAudioLogicalDev
          If \aAudioLogicalDevs(d)\sLogicalDev = sLogicalDev
            nProdLogicalDevPtr = d
            Break
          EndIf
        Next d
        
      Case #SCS_DEVGRP_LIVE_INPUT
        For d = 0 To \nMaxLiveInputLogicalDev
          If \aLiveInputLogicalDevs(d)\sLogicalDev = sLogicalDev
            nProdLogicalDevPtr = d
            Break
          EndIf
        Next d
        
      Case #SCS_DEVGRP_LIGHTING
        For d = 0 To \nMaxLightingLogicalDev
          If \aLightingLogicalDevs(d)\sLogicalDev = sLogicalDev
            nProdLogicalDevPtr = d
            Break
          EndIf
        Next d
        
      Case #SCS_DEVGRP_CTRL_SEND
        For d = 0 To \nMaxCtrlSendLogicalDev
          If \aCtrlSendLogicalDevs(d)\sLogicalDev = sLogicalDev
            nProdLogicalDevPtr = d
            Break
          EndIf
        Next d
        
    EndSelect
  EndWith
  
  ; debugMsg(sProcName, "sLogicalDev=" + sLogicalDev + ", nDevGrp=" + dcodeDevGrp(nDevGrp) + ", returning " + Str(nProdLogicalDevPtr))
  ProcedureReturn nProdLogicalDevPtr
  
EndProcedure

Procedure openFileForBASS(pAudPtr, pDevNo)
  PROCNAMECA(pAudPtr)
  ; openFileForBASS() is only called once for each audio file aAud(), regardless of the number of output devices assigned in the sub-cue.
  ; pDevNo is ONLY used for selecting \nBassStreamCreateFlags[pDevNo] or \nBassDecodeStreamCreateFlags[pDevNo], and pDevNo is expected to = \nFirstSoundingDev
  Protected nChannel.l, nMax, *nMemoryID, nDataLength.l
  Protected qOffset.q, qLength.q
  Protected nFlags.l
  Protected rChanInfo.BASS_CHANNELINFO
  Protected nBassResult.l, nErrorCode.l
  Protected nFileDataPtr
  Protected sDriveRootFolder.s, nDriveType
  Protected qFileSize.q, nFileBytesPerMS
  Protected nAsyncBufferSize.l
  Protected nFileBufLenFixed, nFileBufLenRemote
  Protected qLengthInBytes.q, dLengthInSeconds.d
  Protected nTempoChannel.l, nTempoFlags.l, fAttributeValue.f

  debugMsg(sProcName, #SCS_START + ", pDevNo=" + pDevNo)
  
  If (gnCurrAudioDriver = #SCS_DRV_BASS_ASIO) Or ((gnCurrAudioDriver = #SCS_DRV_BASS_DS Or gnCurrAudioDriver = #SCS_DRV_BASS_WASAPI) And (gbUseBASSMixer))
    With grDriverSettings
      If \nFileBufLen = 0
        nFileBufLenFixed = #SCS_DEFAULT_FILEBUFLEN
      Else
        nFileBufLenFixed = \nFileBufLen
      EndIf
      nFileBufLenRemote = nFileBufLenFixed << 2
      If nFileBufLenRemote > 3000
        nFileBufLenRemote = 3000
      EndIf
      CompilerIf #cEnableFileBufLen And 1=2
        debugMsg(sProcName, "grDriverSettings\nFileBufLen=" + \nFileBufLen + ", nFileBufLenFixed=" + nFileBufLenFixed + ", nFileBufLenRemote=" + nFileBufLenRemote)
      CompilerEndIf
    EndWith
  EndIf
  
  With aAud(pAudPtr)
    gsFile = \sFileName
    sDriveRootFolder = getDriveRootFolder(gsFile)
    nDriveType = getDriveType(sDriveRootFolder)
    If grLicInfo\bTempoAndPitchAvailable
      setAudTempoChannelReqd(pAudPtr)
    EndIf
    If \bUsingSplitStream Or \bAudUseGaplessStream Or \bTempoChannelReqd
      nFlags = \nBassDecodeStreamCreateFlags[pDevNo] | #SCS_BASS_UNICODE | #BASS_STREAM_DECODE
    Else
      nFlags = \nBassStreamCreateFlags[pDevNo] | #SCS_BASS_UNICODE
    EndIf
    ; debugMsg(sProcName, "nFlags=" + decodeStreamCreateFlags(nFlags))
    If (gnCurrAudioDriver = #SCS_DRV_BASS_ASIO) Or ((gnCurrAudioDriver = #SCS_DRV_BASS_DS Or gnCurrAudioDriver = #SCS_DRV_BASS_WASAPI) And (gbUseBASSMixer))
      nFlags | #BASS_ASYNCFILE
      If \nFileDuration > 0
        qFileSize = FileSize(\sFileName)
        nFileBytesPerMS = qFileSize / \nFileDuration
        Select nDriveType
          Case #DRIVE_REMOTE, #DRIVE_CDROM
            nAsyncBufferSize = nFileBufLenRemote * nFileBytesPerMS
          Default ; eg #DRIVE_FIXED
            nAsyncBufferSize = nFileBufLenFixed * nFileBytesPerMS
        EndSelect
        ; debugMsg(sProcName, "qFileSize=" + qFileSize + ", nFileDuration=" + \nFileDuration + ", nFileBytesPerMS=" + nFileBytesPerMS + ", nAsyncBufferSize=" + nAsyncBufferSize)
      EndIf
      If nAsyncBufferSize < 65536 ; 64kb
        nAsyncBufferSize = 65536
      EndIf
      If LCase(\sFileExt) = "wav"
        If nAsyncBufferSize < 262144 ; 256kb
          nAsyncBufferSize = 262144
        EndIf
      EndIf
      ; debugMsg(sProcName, "\sFileExt=" + \sFileExt + ", nAsyncBufferSize=" + nAsyncBufferSize)
      nBassResult = BASS_SetConfig(#BASS_CONFIG_ASYNCFILE_BUFFER, nAsyncBufferSize)
      debugMsg2(sProcName, "BASS_SetConfig(#BASS_CONFIG_ASYNCFILE_BUFFER, " + nAsyncBufferSize + ")", nBassResult)
    EndIf
    
    ; debugMsg(sProcName, "\nAbsLoopEnd=" + \nAbsLoopEnd + ", \nAbsEndAt=" + \nAbsEndAt + ", \nAbsMax=" + \nAbsMax + ", \qFileBytesForTenSecs=" + \qFileBytesForTenSecs)
    If (\nAbsMax > 0) And (\qFileBytesForTenSecs > 0)
      qLength = \nAbsMax * \qFileBytesForTenSecs / 10000
      debugMsg(sProcName, "qLength=" + qLength)
    EndIf
    
    nChannel = BASS_StreamCreateFile(#BASSFALSE, @gsFile, qOffset, qLength, nFlags)
    ; Added 1Dec2019 11.8.2rc6a following tests of Bruce Gillbard's run using the file "186 Sci Fi Scanner.m4a" where an 'end at' of less than 2 seconds was set.
    ; That caused an 'unsupported format' error (#BASS_ERROR_FILEFORM), whereas opening the full file was OK.
    ; Since setting the 'length' parameter in BASS_StreamCreateFile() is optional here (because we also call BASS_ChannelSetSync() for the end position),
    ; retry creating the stream using 0 as the length, which means 'end of file'.
    ; I think it's worth retaining the non-zero qLength value as I expect that gives a tighter end point than relying an the sync point ending playback.
    If nChannel = 0
      debugMsg2(sProcName, "BASS_StreamCreateFile(BASSFALSE, " + GetFilePart(gsFile) + ", " + qOffset + ", " + qLength + ", " + decodeStreamCreateFlags(nFlags) + ")", nChannel)
      grMMedia\nStreamCreateError = BASS_ErrorGetCode()
      debugMsg3(sProcName, getBassErrorDesc(grMMedia\nStreamCreateError))
      If grMMedia\nStreamCreateError = #BASS_ERROR_FORMAT Or grMMedia\nStreamCreateError = #BASS_ERROR_FILEFORM
        qLength = 0
        nChannel = BASS_StreamCreateFile(#BASSFALSE, @gsFile, qOffset, qLength, nFlags)
      EndIf
    EndIf
    ; End added 1Dec2019 11.8.2
    If nChannel <> 0
      newHandle(#SCS_HANDLE_SOURCE, nChannel, #False)
      debugMsg2(sProcName, "BASS_StreamCreateFile(BASSFALSE, " + GetFilePart(gsFile) + ", " + qOffset + ", " + qLength + ", " + decodeStreamCreateFlags(nFlags) + ")", nChannel)
      ; logKeyEvent("BASS_StreamCreateFile(BASSFALSE, " + #DQUOTE$ + GetFilePart(gsFile) + #DQUOTE$ + ", " + qOffset + ", " + qLength + ", " + decodeStreamCreateFlags(nFlags) + ") returned " + decodeHandle(nChannel))
    EndIf
    
    If nChannel = 0
      grMMedia\nStreamCreateError = BASS_ErrorGetCode()
      debugMsg3(sProcName, getBassErrorDesc(grMMedia\nStreamCreateError))
    Else
      qLengthInBytes = BASS_ChannelGetLength(nChannel, #BASS_POS_BYTE)
      dLengthInSeconds = BASS_ChannelBytes2Seconds(nChannel, qLengthInBytes)
      debugMsg(sProcName, "File=" + #DQUOTE$ + GetFilePart(gsFile) + #DQUOTE$ + ", LengthInBytes=" + qLengthInBytes + ", LengthInSeconds=" + StrD(dLengthInSeconds,3))
      nBassResult = BASS_ChannelGetInfo(nChannel, @rChanInfo)
      ; calculate bytes per sample
      \nBytesPerSamplePos = rChanInfo\chans  ; start with channel count (1=mono, 2=stereo, etc)
      If rChanInfo\flags & #BASS_SAMPLE_FLOAT
        \nBytesPerSamplePos * 4    ; 32-bit floating point = 4 bytes
      ElseIf rChanInfo\flags & #BASS_SAMPLE_FLOAT = 0
        \nBytesPerSamplePos * 2    ; 16-bit = 2 bytes
      EndIf
      \nSampleRate = rChanInfo\freq
      \nBytesPerSec = \nSampleRate * \nBytesPerSamplePos
      \nBassChans = rChanInfo\chans
      \nFileChannels = \nBassChans
      debugMsg(sProcName, "\nFileChannels=" + \nFileChannels + ", \nBytesPerSamplePos=" + \nBytesPerSamplePos + ", \nSampleRate=" + \nSampleRate + ", \nBytesPerSec=" + \nBytesPerSec)
      ; \qFileLengthInSamples = BASS_ChannelGetLength(nChannel, #BASS_POS_BYTE) / \nBytesPerSamplePos
      ; debugMsg(sProcName, "\qFileLengthInSamples=" + Str(\qFileLengthInSamples))
      grMMedia\nStreamCreateError = 0
      
      ; debugMsg(sProcName, "calling setNextCueMarker(" + getAudLabel(pAudPtr) + ", 0)")
      setNextCueMarker(pAudPtr, 0)
      
      If \nAbsEndAt > 0
        debugMsg(sProcName, "BASS_ChannelSeconds2Bytes(" + decodeHandle(nChannel) + ", " + StrD(\nAbsEndAt / 1000, 3) + ") returned " + Str(BASS_ChannelSeconds2Bytes(nChannel, \nAbsEndAt / 1000)))
      EndIf
      
      If grLicInfo\bTempoAndPitchAvailable
        If \bTempoChannelReqd
          nTempoFlags = nFlags | #BASS_FX_FREESOURCE
          nTempoChannel = BASS_FX_TempoCreate(nChannel, nTempoFlags)
          debugMsg2(sProcName, "BASS_FX_TempoCreate(" + decodeHandle(nChannel) + ", " + decodeStreamCreateFlags(nTempoFlags) + ")", nTempoChannel)
          If nTempoChannel = 0
            nErrorCode = BASS_ErrorGetCode()
            debugMsg3(sProcName, "Error: " + getBassErrorDesc(nErrorCode))
          Else
            newHandle(#SCS_HANDLE_TEMPO, nTempoChannel)
            \nChannelTempoChannelReplaced = nChannel
            \bTempoChannelCreated = #True
            nChannel = nTempoChannel
            debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nAudTempoEtcAction=" + decodeAFAction(\nAudTempoEtcAction) + ", \fAudTempoEtcValue=" + StrF(\fAudTempoEtcValue,2))
            If \fAudTempoEtcValue <> grAudDef\fAudTempoEtcValue
              Select \nAudTempoEtcAction
                Case #SCS_AF_ACTION_FREQ
                  fAttributeValue = \nSampleRate * \fAudTempoEtcValue
                  nBassResult = BASS_ChannelSetAttribute(nTempoChannel, #BASS_ATTRIB_TEMPO_FREQ, fAttributeValue)
                  debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nTempoChannel) + ", #BASS_ATTRIB_TEMPO_FREQ, " + StrF(fAttributeValue,2) + ")", nBassResult)
                  If nBassResult = 0
                    debugMsg0(sProcName, "aAud(" + getAudLabel(pAudPtr) + "\fAudTempoEtcValue=" + StrF(\fAudTempoEtcValue,2) + ", \nSampleRate=" + \nSampleRate + ", fAttributeValue=" + StrF(fAttributeValue,2))
                    nErrorCode = BASS_ErrorGetCode()
                    debugMsg0(sProcName, "Error: " + getBassErrorDesc(nErrorCode))
                  EndIf
                Case #SCS_AF_ACTION_TEMPO
                  fAttributeValue = (\fAudTempoEtcValue * 100.0) - 100.0
                  nBassResult = BASS_ChannelSetAttribute(nTempoChannel, #BASS_ATTRIB_TEMPO, fAttributeValue)
                  debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nTempoChannel) + ", #BASS_ATTRIB_TEMPO, " + StrF(fAttributeValue,2) + ")", nBassResult)
                  If nBassResult = 0
                    debugMsg0(sProcName, "aAud(" + getAudLabel(pAudPtr) + "\fAudTempoEtcValue=" + StrF(\fAudTempoEtcValue,2) + ", fAttributeValue=" + StrF(fAttributeValue,2))
                    nErrorCode = BASS_ErrorGetCode()
                    debugMsg0(sProcName, "Error: " + getBassErrorDesc(nErrorCode))
                  EndIf
                Case #SCS_AF_ACTION_PITCH
                  fAttributeValue = \fAudTempoEtcValue
                  nBassResult = BASS_ChannelSetAttribute(nTempoChannel, #BASS_ATTRIB_TEMPO_PITCH, fAttributeValue)
                  debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nTempoChannel) + ", #BASS_ATTRIB_TEMPO_PITCH, " + StrF(fAttributeValue,2) + ")", nBassResult)
                  If nBassResult = 0
                    debugMsg0(sProcName, "aAud(" + getAudLabel(pAudPtr) + "\fAudTempoEtcValue=" + StrF(\fAudTempoEtcValue,2) + ", fAttributeValue=" + StrF(fAttributeValue,2))
                    nErrorCode = BASS_ErrorGetCode()
                    debugMsg0(sProcName, "Error: " + getBassErrorDesc(nErrorCode))
                  EndIf
              EndSelect
            EndIf
          EndIf
        EndIf
      EndIf
      
      \nBassDevFailSync = BASS_ChannelSetSync(nChannel, #BASS_SYNC_DEV_FAIL, 0, @DevFailSyncProc(), pAudPtr)
      newHandle(#SCS_HANDLE_SYNC, \nBassDevFailSync, #False)
      debugMsg2(sProcName, "BASS_ChannelSetSync(" + decodeHandle(nChannel) + ", #BASS_SYNC_DEV_FAIL, 0, @DevFailSyncProc(), " + getAudLabel(pAudPtr) + ")", \nBassDevFailSync)
      If \nBassDevFailSync = 0
        debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
      EndIf

    EndIf
    
  EndWith
  
  debugMsg(sProcName, #SCS_END + ", returning " + decodeHandle(nChannel))
  
  ProcedureReturn nChannel

EndProcedure

Procedure openMidiFile(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nErrCode.l
  Protected sMciString.s
  Protected sPort.s
  Protected sLength.s, nLength
  Protected nMousePointer
  Protected bOK
  Protected *lpReturnString
  Protected bDummyDev

  debugMsg(sProcName, #SCS_START)
  
  ; warning! all mciSendString calls must be from the same thread or mciSendString returns error 263 (not a registered device), so use main thread
  ASSERT_THREAD(#SCS_THREAD_MAIN)

  nMousePointer = getMouseCursor()
  setMouseCursorBusy()
  bOK = #True
  
  With aAud(pAudPtr)
    bDummyDev = gaMidiOutDevice(\nMidiPhysicalDevPtr)\bDummy
    debugMsg(sProcName, "gaMidiOutDevice(" + \nMidiPhysicalDevPtr + ")\bDummy=" + strB(gaMidiOutDevice(\nMidiPhysicalDevPtr)\bDummy) + ", bDummyDev=" + strB(bDummyDev))
    
    If bDummyDev = #False
      ; close this alias if currently open (do not check nErrCode)
      sMciString = "close " + \sMidiAlias
      nErrCode = mciSendString_(sMciString, #Null, 0, #Null)
      debugMsg2(sProcName, "mciSendString_(" + sMciString + ", #Null, 0, #Null)", nErrCode)
      
      sMciString = "open " + #DQUOTE$ + \sFileName + #DQUOTE$ + " alias " + \sMidiAlias + " type sequencer"
      nErrCode = mciSendString_(sMciString, #Null, 0, #Null)
      debugMsg2(sProcName, "mciSendString_(" + sMciString + ", #Null, 0, #Null)", nErrCode)
      If nErrCode <> 0
        displayMidiError(nErrCode, sMciString, sProcName)
        bOK = #False
      EndIf
      
      If bOK
        If gaMidiOutDevice(\nMidiPhysicalDevPtr)\hMidiOut
          MidiOut_Port("close", \nMidiPhysicalDevPtr, "all")
        EndIf
        sMciString = "set " + \sMidiAlias + " port " + \nMidiPhysicalDevPtr
        nErrCode = mciSendString_(sMciString, #Null, 0, #Null)
        debugMsg2(sProcName, "mciSendString_(" + sMciString + ", #Null, 0, #Null)", nErrCode)
        If nErrCode <> 0
          displayMidiError(nErrCode, sMciString, sProcName)
          bOK = #False
        EndIf
      EndIf
      
      If bOK
        ; change to the required port if necessary
        sMciString = "status " + \sMidiAlias + " port"
        *lpReturnString = AllocateMemory(64)
        nErrCode = mciSendString_(sMciString, *lpReturnString, 32, 0)
        debugMsg2(sProcName, "mciSendString_(" + sMciString + ", *lpReturnString, 32, 0)", nErrCode)
        If nErrCode <> 0
          displayMidiError(nErrCode, sMciString, sProcName)
          bOK = #False
        Else
          sPort = PeekS(*lpReturnString)
          debugMsg3(sProcName, "sPort=" + sPort)
        EndIf
        FreeMemory(*lpReturnString)
      EndIf
    EndIf
    
    If bOK
      \sDriver = "MCI"
      audSetState(pAudPtr, #SCS_CUE_READY, 30)
      \sFileType = "MIDI"
      getFileDetail(pAudPtr)
      debugMsg(sProcName, "\nFileDuration=" + \nFileDuration)
      \sFileTitle = grFileInfo\sFileTitle
      
      If bDummyDev = #False
        ; debug info
        *lpReturnString = AllocateMemory(64)  ; 64 = twice the string size requested, to allow for Unicode
        
        sMciString = "status " + \sMidiAlias + " division type"
        nErrCode = mciSendString_(sMciString, *lpReturnString, 32, 0)
        If nErrCode = 0
          debugMsg3(sProcName, sMciString + " returned " + PeekS(*lpReturnString))
        Else
          displayMidiError(nErrCode, sMciString, sProcName)
        EndIf
        
        sMciString = "status " + \sMidiAlias + " time format"
        nErrCode = mciSendString_(sMciString, *lpReturnString, 32, 0)
        If nErrCode = 0
          debugMsg3(sProcName, sMciString + " returned " + PeekS(*lpReturnString))
        Else
          displayMidiError(nErrCode, sMciString, sProcName)
        EndIf
        
        sMciString = "status " + \sMidiAlias + " length"
        nErrCode = mciSendString_(sMciString, *lpReturnString, 32, 0)
        If nErrCode = 0
          debugMsg3(sProcName, sMciString + " returned " + PeekS(*lpReturnString))
        Else
          displayMidiError(nErrCode, sMciString, sProcName)
        EndIf
        
        sMciString = "status " + \sMidiAlias + " tempo"
        nErrCode = mciSendString_(sMciString, *lpReturnString, 32, 0)
        If nErrCode = 0
          debugMsg3(sProcName, sMciString + " returned " + PeekS(*lpReturnString))
        Else
          displayMidiError(nErrCode, sMciString, sProcName)
        EndIf
        
        sMciString = "status " + \sMidiAlias + " number of tracks"
        nErrCode = mciSendString_(sMciString, *lpReturnString, 32, 0)
        If nErrCode = 0
          debugMsg3(sProcName, sMciString + " returned " + PeekS(*lpReturnString))
        Else
          displayMidiError(nErrCode, sMciString, sProcName)
        EndIf
        
        FreeMemory(*lpReturnString)
        
        ; set the time format to milliseconds (for returning the length)
        sMciString = "set " + \sMidiAlias + " time format milliseconds"
        nErrCode = mciSendString_(sMciString, #Null, 0, #Null)
        debugMsg2(sProcName, "mciSendString_(" + sMciString + ", #Null, 0, #Null)", nErrCode)
        If nErrCode <> 0
          displayMidiError(nErrCode, sMciString, sProcName)
          bOK = #False
        EndIf
        
        If bOK
          ; find the length
          sMciString = "status " + \sMidiAlias + " length"
          *lpReturnString = AllocateMemory(64)
          nErrCode = mciSendString_(sMciString, *lpReturnString, 32, 0)
          debugMsg2(sProcName, "mciSendString_(" + sMciString + ", *lpReturnString, 32, 0)", nErrCode)
          If nErrCode <> 0
            displayMidiError(nErrCode, sMciString, sProcName)
            bOK = #False
          Else
            sLength = PeekS(*lpReturnString)
            debugMsg3(sProcName, "sLength=" + sLength)
          EndIf
          FreeMemory(*lpReturnString)
        EndIf
        
      EndIf ; EndIf bDummyDev = #False
      
    EndIf ; EndIf bOK
    
    If (bOK) And (bDummyDev = #False)
      \nFileDuration = Val(sLength)
    EndIf
      \nStartAt = grAudDef\nStartAt
      \nMaxLoopInfo = grAudDef\nMaxLoopInfo
      \nCurrLoopInfoIndex = grAudDef\nCurrLoopInfoIndex
      \nCueDuration = \nFileDuration
      setDerivedAudFields(pAudPtr)
      debugMsg(sProcName, "\nCueDuration=" + \nCueDuration)
;     EndIf
    
    debugMsg(sProcName, "getMidiMode(" + getAudLabel(pAudPtr) + ")=" + getMidiMode(pAudPtr))
  EndWith

  setMouseCursor(nMousePointer)

EndProcedure

Procedure openInputChannels(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nOpenInputsResult, nDevPtr, bDummy
  Protected bResult
  Protected nRow
  
  ; debugMsg3(sProcName, #SCS_START)
  
  With aAud(pAudPtr)
    
    debugMsg(sProcName, "calling setFirstAndLastDev(" + getAudLabel(pAudPtr) + ")")
    setFirstAndLastDev(pAudPtr)
    
    Select gnCurrAudioDriver
      Case #SCS_DRV_SMS_ASIO ; SM-S
        nOpenInputsResult = openInputsForSMS(pAudPtr)
        Select nOpenInputsResult
          Case -2   ; SM-S failed to open the inputs
            
          ; Case -1   ; insufficient SM-S playback channels
            ; bDeviceFound = #False
            ; bInsufficientSMSPlaybacks = #True
            
          Default   ; SM-S opened the inputs OK
            bResult = #True
            \sDriver = "SM-S"
            debugMsg(sProcName, "calling setDerivedAudFields")
            setDerivedAudFields(pAudPtr)
            
        EndSelect
        
        audSetState(pAudPtr, #SCS_CUE_READY, 2)
        \nFileState = #SCS_FILESTATE_OPEN
        
      Default ; not SM-S
        If \nFirstInputDev < 0
          bDummy = #True
        Else
          nDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_LIVE_INPUT, \sInputLogicalDev[\nFirstInputDev])
          ; debugMsg0(sProcName, "aAud(" +  getAudLabel(pAudPtr)  +")\nFirstInputDev="+ \nFirstInputDev)
          ; debugMsg0(sProcName, "getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_LIVE_INPUT, " + \sInputLogicalDev[\nFirstInputDev] + ") returned nDevPtr=" + nDevPtr)
          If nDevPtr >= 0
            bDummy = grMaps\aDev(nDevPtr)\bDummy
          EndIf
        EndIf
        If bDummy
          bResult = #True
          \sDriver = "BASS"
          ; debugMsg(sProcName, "calling setDerivedAudFields")
          setDerivedAudFields(pAudPtr)
          audSetState(pAudPtr, #SCS_CUE_READY, 21)
          \nFileState = #SCS_FILESTATE_OPEN
        Else
          \nAudState = #SCS_CUE_ERROR
          audSetState(pAudPtr, #SCS_CUE_ERROR, 31)
          \nFileState = #SCS_FILESTATE_CLOSED
          \sErrorMsg = "Live Input not supported by audio driver " + decodeDriverL(gnCurrAudioDriver)
        EndIf
        
    EndSelect
    
    ; debugMsg(sProcName, "calling setCueState(" + getCueLabel(\nCueIndex) + ")")
    setCueState(\nCueIndex)
    If (gbInitialising = #False) And (gbInPaste = #False) And (gbGridLoaded)
      If aSub(\nSubIndex)\nPrevSubIndex = -1
        ; first sub for this cue
        If gnThreadNo = #SCS_THREAD_MAIN
          ; debugMsg(sProcName, "calling colorLine(" + getCueLabel(\nCueIndex) + ")")
          colorLine(\nCueIndex)
          nRow = aCue(\nCueIndex)\nGrdCuesRowNo
          If nRow >= 0
            WMN_setGrdCuesCellValue(nRow, #SCS_GRDCUES_DU, timeToStringBWZ(\nCueDuration, \nCueDuration))
            WMN_setGrdCuesCellValue(nRow, #SCS_GRDCUES_FT, \sFileType)
          EndIf
          updateGrid(\nCueIndex)
        Else
          samAddRequest(#SCS_SAM_LOAD_GRID_ROW, \nCueIndex)
        EndIf
      EndIf
      If inSaveSettings(\nSubIndex)
        debugMsg(sProcName, "calling removeFromSaveSettings(" + getSubLabel(\nSubIndex) + ")")
        removeFromSaveSettings(\nSubIndex)
        setSaveSettings()
      EndIf
    EndIf
    
  EndWith
  
  ; debugMsg3(sProcName, #SCS_END + ", returning " + strB(bResult))
  ProcedureReturn bResult
  
EndProcedure

Procedure getFileDuration(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nBassResult.l   ; long
  Protected nFlags.l
  Protected nTmpChan.l  ; long
  Protected qOffset.q, qLength.q
  Protected nFileDataPtr
  Protected dTime.d
  Protected rChanInfo.BASS_CHANNELINFO
  
  If pAudPtr >= 0
    With aAud(pAudPtr)
      If \bAudPlaceHolder
        \nFileDuration = 0
      Else
        ; need to get length now so open with BASS_STREAM_DECODE and BASS_STREAM_PRESCAN, and after
        ; obtaining the length, free the stream so the file can subsequently be opened normally
        ; nFlags = #BASS_STREAM_DECODE | #BASS_STREAM_PRESCAN | #SCS_BASS_UNICODE
        nFlags = #BASS_STREAM_DECODE | #BASS_STREAM_PRESCAN | #SCS_BASS_UNICODE | #BASS_SAMPLE_FLOAT
        gsFile = \sFileName
        nTmpChan = BASS_StreamCreateFile(#BASSFALSE, @gsFile, qOffset, qLength, nFlags)
        newHandle(#SCS_HANDLE_SOURCE, nTmpChan)
        ; debugMsg2(sProcName, "BASS_StreamCreateFile(BASSFALSE, " + GetFilePart(gsFile) + ", " + qOffset + ", " + qLength + ", " + decodeStreamCreateFlags(nFlags) + ")", nTmpChan)
        If nTmpChan = 0
          \sErrorMsg = LangPars("Errors", "CannotOpen", GetFilePart(gsFile)) + " (" + getBassErrorDesc(BASS_ErrorGetCode()) + ")"
          audSetState(pAudPtr, #SCS_CUE_ERROR, 32)
          ProcedureReturn #False
        EndIf
        ; debugMsg(sProcName, "BASS_StreamCreateFile(BASSFALSE, " + GetFilePart(gsFile) + ", " + qOffset + ", " + qLength + ", " + decodeStreamCreateFlags(nFlags) + ") returned " + decodeHandle(nTmpChan))
        \nFileDuration = GetDuration(nTmpChan)
        ; debugMsg2(sProcName, "GetDuration(" + decodeHandle(nTmpChan) + ")", \nFileDuration)
        \qFileBytes = GetFileBytes(nTmpChan)
        ; debugMsg2(sProcName, "GetFileBytes(" + decodeHandle(nTmpChan) + ")", \qFileBytes)
        dTime = 10.0
        \qFileBytesForTenSecs = BASS_ChannelSeconds2Bytes(nTmpChan, dTime)
        ; debugMsg3(sProcName, "BASS_ChannelSeconds2Bytes(" + decodeHandle(nTmpChan) + ", " + StrD(dTime,1) + ") returned " + Str(\qFileBytesForTenSecs))
        ; debugMsg(sProcName, "\nFileDuration=" + \nFileDuration + ", \qFileBytes=" + \qFileBytes + ", \qFileBytesForTenSecs=" + \qFileBytesForTenSecs)
        
        ; added 14Nov2017 11.6.2.2aa
        ; calculate bytes per sample
        nBassResult = BASS_ChannelGetInfo(nTmpChan, @rChanInfo)
        \nBytesPerSamplePos = rChanInfo\chans  ; start with channel count (1=mono, 2=stereo, etc)
        If rChanInfo\flags & #BASS_SAMPLE_FLOAT
          \nBytesPerSamplePos * 4    ; 32-bit floating point = 4 bytes
        ElseIf rChanInfo\flags & #BASS_SAMPLE_FLOAT = 0
          \nBytesPerSamplePos * 2    ; 16-bit = 2 bytes
        EndIf
        ; end added 14Nov2017 11.6.2.2aa
        
        nBassResult = BASS_StreamFree(nTmpChan)
        ; debugMsg2(sProcName, "BASS_StreamFree(" + decodeHandle(nTmpChan) + ")", nBassResult)
        freeHandle(nTmpChan)
        nFileDataPtr = \nFileDataPtr
        If nFileDataPtr >= 0
          gaFileData(nFileDataPtr)\nFileDuration = \nFileDuration
          gaFileData(nFileDataPtr)\qFileBytes = \qFileBytes
          gaFileData(nFileDataPtr)\qFileBytesForTenSecs = \qFileBytesForTenSecs
          gaFileData(nFileDataPtr)\qFileSize = FileSize(\sFileName)
          debugMsg(sProcName, "gaFileData(" + nFileDataPtr + ")\nFileDuration=" + gaFileData(nFileDataPtr)\nFileDuration +
                              ", \qFileBytes=" + gaFileData(nFileDataPtr)\qFileBytes +
                              ", \qFileBytesForTenSecs=" + gaFileData(nFileDataPtr)\qFileBytesForTenSecs +
                              ", \qFileSize=" + gaFileData(nFileDataPtr)\qFileSize)
        EndIf
      EndIf
    EndWith
  EndIf
  ProcedureReturn #True
EndProcedure

Procedure addChannelToChannelUpdateArray(nBassChannel.l, nUpdateLength.l)
  PROCNAMEC()
  
  With grMMedia
    \nMaxChannelUpdateIndex + 1
    If \nMaxChannelUpdateIndex > ArraySize(\aChannelUpdate())
      ReDim \aChannelUpdate(\nMaxChannelUpdateIndex + 4)
    EndIf
    \aChannelUpdate(\nMaxChannelUpdateIndex)\nBassChannel = nBassChannel
    \aChannelUpdate(\nMaxChannelUpdateIndex)\nUpdateLength = nUpdateLength
  EndWith
  
EndProcedure

Procedure doChannelUpdates()
  PROCNAMEC()
  Protected n
  Protected nBassResult.l ; long
  
  ; ProcedureReturn ; INFO: (Temp) added 23Mar2022 11.9.1at
  ; Note: BASS_ChannelUpdate() should be called AFTER any calls to set sync points using BASS_ChannelSetSync(), especially if a
  ; sync point may be required during the 'length' of BASS_ChannelUpdate(). For example, if the update length is 5000 milliseconds
  ; but the sync point is 4.000 seconds then if BASS_ChannelSetSync() was called AFTER BASS_ChannelUpdate() then that sync point
  ; procedure may not be called. Note that the procedure setBassMarkerPositions() checks for this and does implement a work-around.
  
  For n = 0 To grMMedia\nMaxChannelUpdateIndex
    With grMMedia\aChannelUpdate(n)
      nBassResult = BASS_ChannelUpdate(\nBassChannel, \nUpdateLength)
      debugMsg2(sProcName, "BASS_ChannelUpdate(" + decodeHandle(\nBassChannel) + ", " + \nUpdateLength + ")", nBassResult)
      If nBassResult = #BASSFALSE
        debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
      EndIf
    EndWith
  Next n
  
EndProcedure

Procedure openMediaFile(pAudPtr, bForceDurationCheck=#False, nVidPicTarget=#SCS_VID_PIC_TARGET_NONE, bClearExistingSecondary=#False, bInsufficientSMSPlaybacksOK=#False, bMayClearSettings=#False)
  PROCNAMECA(pAudPtr)
  Protected nBassDevice.l, d, d1, d2, l2, bMyForceDurationCheck
  Protected nBassResult.l   ; long
  Protected nBassSpeaker.l  ; long
  Protected nTmpBassSpeaker.l, nSpeakerCount
  Protected nChannelCount, sMsg.s
  Protected nErrorCode.l, sTmpFileName.s
  Protected bDeviceFound, bDeviceNamed
  Protected nStreamCreateFlags.l, nDecodeStreamCreateFlags.l, nPluginFlags.l  ; longs
  Protected nSplitStreamCreateFlags.l ; long
  Protected nRow, fCPU.f
  Protected nPlaybackBufferSize.l, nMaxPlaybackBufferSize.l, nLoopPlaybackBufferSize.l   ; longs
  Protected nChannel.l, nAltChannel.l ; longs
  Protected nMixerStreamPtr
  Protected nMixerStreamHandle.l, nMixerChannelFlags.l  ; longs
  Protected rChannelInfo.BASS_CHANNELINFO
  Protected bChannelInfoObtained
  Protected n, m, n1, m1, nSubPtr
  Protected f, bFound, rFileData.tyFileData
  Protected nLogicalDevPtr, sLogicalDev.s
  Protected bSanityCheckOK
  Protected qOffset.q, qLength.q
  Protected bMidiPortOK
  Protected nMyVidPicTarget
  Protected nFlags.l  ; long
  Protected nDevMapPtr, nDevMapDevPtr
  Protected nPhysicalDevPtr
  Protected nOpenFileResult
  Protected bFileNameTooLong, bTooManyInputsOpen
  Protected nFirstDevReqd, nLastDevReqd
  Protected bLockedMutex
  Protected fReqdBVLevel.f, fReqdPan.f
  Protected bAddChannelToMixer
  Protected sBassCommand.s
  Protected nTempoChannel.l
  Protected nTempoFlags.l
  Protected fTempo.f
  Protected nScreenNo, nMonitorCanvasNo
  Protected bFileNotOpened
  Protected nActiveWindow
  Protected fBassPan.f
  Protected bXFadePresent
  Protected qChannelDecodePosition.q
  Protected bMemoryImageCreated
  Protected nMyFileFormat
  
  LockCueListMutex(246)
  
  If aAud(pAudPtr)\bAudTypeI
    openInputChannels(pAudPtr)
    UnlockCueListMutex()
    ProcedureReturn
  EndIf
  
  debugMsg3(sProcName, #SCS_START + ", \sFileName=" + GetFilePart(aAud(pAudPtr)\sFileName) + ", nVidPicTarget=" + decodeVidPicTarget(nVidPicTarget))
  ; logKeyEvent("aAud(" + getAudLabel(pAudPtr) + "\sFileName=" + GetFilePart(aAud(pAudPtr)\sFileName) + ", nVidPicTarget=" + decodeVidPicTarget(nVidPicTarget))
  
;   bMyForceDurationCheck = bForceDurationCheck
  bMyForceDurationCheck = #True   ; 11.3.9h force duration check following strange error reported by Filpas Mika whereby a file duration had been stored incorrectly in the cue file
  
  nActiveWindow = GetActiveWindow()
  ; debugMsg(sProcName, "nActiveWindow=" + decodeWindow(nActiveWindow))
  
  grMMedia\nMaxChannelUpdateIndex = -1
  
  With aAud(pAudPtr)
    ; debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\nCueState=" + decodeCueState(aCue(\nCueIndex)\nCueState))
    Select \nFileFormat
      Case #SCS_FILEFORMAT_CAPTURE
        If Len(\sVideoCaptureLogicalDevice) = 0
          UnlockCueListMutex()
          ProcedureReturn
        EndIf
        debugMsg(sProcName, "Opening " + \sVideoCaptureLogicalDevice)
      Default
        If Len(\sFileName) = 0
          UnlockCueListMutex()
          ProcedureReturn
        EndIf
        debugMsg(sProcName, "Opening " + \sStoredFileName + " (" + \sFileName + ")")
    EndSelect
    
    resetAudFlags(pAudPtr)
    
    nStreamCreateFlags = 0
    nDecodeStreamCreateFlags = 0
    nBassDevice = -1
    If \bFileOpenFailNotified = #False
      \sErrorMsg = ""
    EndIf
    ; added the following at 11.2.4j because if a cue file is opened with an image that cannot be found,
    ; then in the editor you browse for a new file, then previously \nAudState would have been left as 'error'
    ; even though a new valid file has been selected.
    If \nAudState = #SCS_CUE_ERROR
      audSetState(pAudPtr, grAudDef\nAudState, 33)
      \sErrorMsg = ""
    EndIf
    ; end of 11.2.4j addition
    
    ; added 11Nov2015 11.4.1.2j (trying to fix problem reported by Nick Langford about cues stopping)
    For d = 0 To #SCS_MAX_AUDIO_DEV_PER_AUD_OR_SUB
      \bStopping[d] = #False
      \bAltStopping[d] = #False
      \bFading[d] = #False
      \bAltFading[d] = #False
    Next d
    ; end added 11Nov2015 11.4.1.2j
    
    ; debugMsg(sProcName, "calling setFirstAndLastDev(" + getAudLabel(pAudPtr) + ")")
    setFirstAndLastDev(pAudPtr)
    
    nSubPtr = \nSubIndex
    
    If \bAudPlaceHolder
      \sFileExt = ""
      \nFileFormat = #SCS_FILEFORMAT_AUDIO
      
    Else
      Select \nVideoSource
        Case #SCS_VID_SRC_CAPTURE
          \sFileExt = ""
          \nFileFormat = #SCS_FILEFORMAT_CAPTURE
        Default
          \sFileExt = GetExtensionPart(\sFileName)
          \nFileFormat = getFileFormat(\sFileName)
      EndSelect
      ; debugMsg(sProcName, "\nFileFormat=" + \nFileFormat)
      
      If \nFileFormat = #SCS_FILEFORMAT_MIDI
        If Len(Trim(\sMidiAlias)) = 0
          gnMidiAliasCount + 1
          \sMidiAlias = "midi" + Trim(Str(gnMidiAliasCount))
        EndIf
      Else
        \sMidiAlias = ""
      EndIf
      
      If \nVideoSource = #SCS_VID_SRC_FILE
        If FileExists(\sFileName, #False) = #False
          debugMsg(sProcName, "File " + \sFileName + " not found")
          debugMsg(sProcName, "\bFileOpenFailNotified=" + strB(\bFileOpenFailNotified))
          If \bFileOpenFailNotified = #False
            \bFileOpenFailNotified = #True
            If FileExists(\sFileName) = #False
              \sErrorMsg = LangPars("Errors", "FileNotFound", \sFileName)
              audSetState(pAudPtr, #SCS_CUE_ERROR, 34)
              debugMsg(sProcName, "SCS_CUE_ERROR(a) " + \sErrorMsg)
            EndIf
          EndIf
          If FileExists(\sFileName) = #False
            Goto osfNotFound
          EndIf
        EndIf ; EndIf FileExists(\sFileName, #False) = #False
      EndIf ; EndIf \nVideoSource = #SCS_VID_SRC_FILE
    EndIf ; EndIf \bAudPlaceHolder / Else
    
    nMyFileFormat = \nFileFormat
    ; Temp added 29Dec2020 for checking if BASS can successfully play the audio from video files - (yes, it can)
    If nMyFileFormat = #SCS_FILEFORMAT_VIDEO
      If aSub(\nSubIndex)\bSubTypeF
        nMyFileFormat = #SCS_FILEFORMAT_AUDIO
      EndIf
    EndIf
    ; End temp added 29Dec2020
    
    Select nMyFileFormat
      Case #SCS_FILEFORMAT_MIDI ; #SCS_FILEFORMAT_MIDI
        ;{
        ; debugMsg(sProcName, "#SCS_FILEFORMAT_MIDI")
        bDeviceFound = #False
        bMidiPortOK = #True
        
        d = 0
        ; debugMsg(sProcName, "\sLogicalDev=" + \sLogicalDev)
        If \sLogicalDev
          nPhysicalDevPtr = getPhysDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_CTRL_SEND, \sLogicalDev)
          \nMidiPhysicalDevPtr = nPhysicalDevPtr  ; MIDI port no. identical to gaMidiOutDevice() array index as it the array is populated in the order of the MIDI ports
          debugMsg(sProcName, "\nMidiPhysicalDevPtr=" + \nMidiPhysicalDevPtr)
          If \nMidiPhysicalDevPtr < 0
            \sErrorMsg = "Device " + \sLogicalDev + " has not been assigned to a MIDI Device in the Production Properties"
            bMidiPortOK = #False
          EndIf
          If bMidiPortOK
            bDeviceFound = #True
          EndIf
        Else
          \sErrorMsg = "No Audio Device has been assigned"
        EndIf
        If bDeviceFound
          ; max length of path and filename must be less than 128 characters for mciSendString. Error found by Richard Borsey 1 June 2015.
          If Len(\sFileName) > 127
            \sErrorMsg = LangPars("Errors", "FileNameTooLong", "127", Str(Len(\sFileName)), #DQUOTE$ + \sFileName + #DQUOTE$)
            audSetState(pAudPtr, #SCS_CUE_ERROR, 35)
            debugMsg(sProcName, "SCS_CUE_ERROR(a) " + \sErrorMsg)
            bFileNameTooLong = #True
            bFileNotOpened = #True
          Else
            openMidiFile(pAudPtr)
          EndIf
          \bDisplayPan[d] = #False
        EndIf
        ;}
      Case #SCS_FILEFORMAT_PICTURE, #SCS_FILEFORMAT_CAPTURE ; #SCS_FILEFORMAT_PICTURE, #SCS_FILEFORMAT_CAPTURE
        ;{
        ; debugMsg(sProcName, "#SCS_FILEFORMAT_PICTURE")
        If nVidPicTarget = #SCS_VID_PIC_TARGET_NONE
          If aSub(nSubPtr)\bStartedInEditor
            nMyVidPicTarget = #SCS_VID_PIC_TARGET_P
          Else
            nMyVidPicTarget = getVidPicTargetForOutputScreen(aSub(nSubPtr)\nOutputScreen)
          EndIf
        Else
          nMyVidPicTarget = nVidPicTarget
        EndIf
        debugMsg(sProcName, "nVidPicTarget=" + decodeVidPicTarget(nVidPicTarget) + ", nMyVidPicTarget=" + decodeVidPicTarget(nMyVidPicTarget))
        If (grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG) And (\nFileFormat = #SCS_FILEFORMAT_PICTURE)
          If \nXPos <> 0 Or \nYPos <> 0
            debugMsg(sProcName, "calling createMemoryImageForAud(" + getAudLabel(pAudPtr) + ") because \nXPos=" + \nXPos + ", \nYPos=" + \nYPos)
            bMemoryImageCreated = createMemoryImageForAud(pAudPtr)
            debugMsg(sProcName, "createMemoryImageForAud(" + getAudLabel(pAudPtr) + ") returned " + strB(bMemoryImageCreated) + ", \nMemoryImageNo=" + decodeHandle(\nMemoryImageNo))
          EndIf
        EndIf
        If (grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG) And (\bLogo = #False Or checkUse2DDrawing(nSubPtr) = #False) And (checkUse2DDrawing(nSubPtr) = #False) ; Changed 9Jan2025 11.10.6-b02 as part of the fix for logos not to be displayed using 2D Drawing if the sub's bUseNew2DDrawing=#False
          bDeviceFound = #True
          bDeviceNamed = #True
          d = 0
          debugMsg(sProcName, "calling openVideoFile(" + getAudLabel(pAudPtr) + ", " + decodeVidPicTarget(nMyVidPicTarget) + ")")
          nChannel = openVideoFile(pAudPtr, nMyVidPicTarget)
          If gbCloseCueFile Or gbCloseSCS
            ProcedureReturn
          EndIf
          If nChannel < 0
            bTooManyInputsOpen = #True
            bFileNotOpened = #True
          ElseIf nChannel = 0
            bFileNotOpened = #True
          EndIf
          \bDisplayPan[d] = #False
        ElseIf (grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_VMIX) And (\nFileFormat = #SCS_FILEFORMAT_CAPTURE)
          bDeviceFound = #True
          bDeviceNamed = #True
          d = 0
          debugMsg(sProcName, "calling openVideoFile(" + getAudLabel(pAudPtr) + ", " + decodeVidPicTarget(nMyVidPicTarget) + ")")
          nChannel = openVideoFile(pAudPtr, nMyVidPicTarget)
          If gbCloseCueFile Or gbCloseSCS
            ProcedureReturn
          EndIf
          If nChannel < 0
            bTooManyInputsOpen = #True
            bFileNotOpened = #True
          ElseIf nChannel = 0
            bFileNotOpened = #True
          EndIf
          \bDisplayPan[d] = #False
        Else
          Select nMyVidPicTarget
            Case #SCS_VID_PIC_TARGET_F2 To #SCS_VID_PIC_TARGET_LAST
              ; debugMsg(sProcName, "grVidPicTarget(" + decodeVidPicTarget(nMyVidPicTarget) + ")\bTargetExists=" + strB(grVidPicTarget(nMyVidPicTarget)\bTargetExists))
              If grVidPicTarget(nMyVidPicTarget)\bTargetExists = #False
                debugMsg(sProcName, "calling setVidPicTargets()")
                setVidPicTargets()
              EndIf
              If grVideoMonitors\bDisplayMonitorWindows
                nScreenNo = nMyVidPicTarget - #SCS_VID_PIC_TARGET_F2
                nMonitorCanvasNo = WMO(nScreenNo)\aMonitor(0)\cvsMonitorCanvas
              EndIf
          EndSelect
          bDeviceFound = #True
          bDeviceNamed = #True
          d = 0
          If grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_VMIX
            debugMsg(sProcName, "calling openVideoFile(" + getAudLabel(pAudPtr) + ", " + decodeVidPicTarget(nMyVidPicTarget) + ")")
            nChannel = openVideoFile(pAudPtr, nMyVidPicTarget)
            If gbCloseCueFile Or gbCloseSCS
              ProcedureReturn
            EndIf
            If nChannel < 0
              bTooManyInputsOpen = #True
              bFileNotOpened = #True
            ElseIf nChannel = 0
              bFileNotOpened = #True
            EndIf
            \bDisplayPan[d] = #False
          Else
            CompilerIf 1=1
              debugMsg(sProcName, "calling loadAndFitPictureForAud(" + getAudLabel(pAudPtr) + ")")
              If loadAndFitPictureForAud(pAudPtr)
                \nFileDuration = 0
                \nFileState = #SCS_FILESTATE_OPEN
                debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nFileState=" + decodeFileState(\nFileState))
                \nVideoPlaybackLibrary = #SCS_VPL_IMAGE
                \nAudMonitorCanvasNo = nMonitorCanvasNo
                \sDriver = "PIC"
                \bDisplayPan[d] = #False
              EndIf
            CompilerElse
              debugMsg(sProcName, "calling loadAndFitAPicture(" + getAudLabel(pAudPtr) + ", " + decodeVidPicTarget(nMyVidPicTarget) + ")")
              If loadAndFitAPicture(pAudPtr, nMyVidPicTarget)
                \nFileDuration = 0
                \nFileState = #SCS_FILESTATE_OPEN
                debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nFileState=" + decodeFileState(\nFileState))
                \nVideoPlaybackLibrary = #SCS_VPL_IMAGE
                \nAudMonitorCanvasNo = nMonitorCanvasNo
                \sDriver = "PIC"
                \bDisplayPan[d] = #False
              EndIf
            CompilerEndIf
          EndIf
        EndIf
        ;}
      Case #SCS_FILEFORMAT_VIDEO  ; #SCS_FILEFORMAT_VIDEO
        ;{
        ; debugMsg(sProcName, "#SCS_FILEFORMAT_VIDEO")
        If nVidPicTarget = #SCS_VID_PIC_TARGET_NONE
          If aSub(nSubPtr)\bStartedInEditor
            nMyVidPicTarget = #SCS_VID_PIC_TARGET_P
          Else
            nMyVidPicTarget = getVidPicTargetForOutputScreen(aSub(nSubPtr)\nOutputScreen)
          EndIf
        Else
          nMyVidPicTarget = nVidPicTarget
        EndIf
        bDeviceFound = #True
        bDeviceNamed = #True
        d = 0
        debugMsg(sProcName, "calling openVideoFile(" + getAudLabel(pAudPtr) + ", " + decodeVidPicTarget(nMyVidPicTarget) + ")")
        nChannel = openVideoFile(pAudPtr, nMyVidPicTarget)
        If gbCloseCueFile Or gbCloseSCS
          ProcedureReturn
        EndIf
        Select grVideoDriver\nVideoPlaybackLibrary
          Case #SCS_VPL_VMIX
            If nChannel < 0
              bTooManyInputsOpen = #True
              bFileNotOpened = #True
            ElseIf nChannel = 0
              bFileNotOpened = #True
            EndIf
          Case #SCS_VPL_TVG
            If nChannel = 0
              bFileNotOpened = #True
            EndIf
        EndSelect
        \bDisplayPan[d] = #True
        ;}
      Case #SCS_FILEFORMAT_AUDIO  ; #SCS_FILEFORMAT_AUDIO
        ;{
        ; debugMsg(sProcName, "#SCS_FILEFORMAT_AUDIO")
        bDeviceFound = #True
        bDeviceNamed = #False
        
        For d = \nFirstSoundingDev To \nLastSoundingDev
          ; debugMsg(sProcName, "\fBVLevel[" + d + "]=" + formatLevel(\fBVLevel[d]) + ", \fSavedBVLevel[" + d + "]=" + formatLevel(\fSavedBVLevel[d]))
          \fBVLevel[d] = \fSavedBVLevel[d]
          \fPan[d] = \fSavedPan[d]
        Next d
        
        Select gnCurrAudioDriver
          Case #SCS_DRV_BASS_DS, #SCS_DRV_BASS_WASAPI, #SCS_DRV_BASS_ASIO ; BASS_DS, BASS_WASAPI, BASS_ASIO
            
            ; debugMsg(sProcName, "\nFirstSoundingDev=" + \nFirstSoundingDev + ", \nLastSoundingDev=" + \nLastSoundingDev)
            For d = \nFirstSoundingDev To \nLastSoundingDev
              
              If (\sLogicalDev[d]) And (\bIgnoreDev[d] = #False)
                nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_AUDIO_OUTPUT, \sLogicalDev[d])
                ; debugMsg(sProcName, "\sLogicalDev[" + d + "]=" + \sLogicalDev[d] + ", nDevMapDevPtr=" + nDevMapDevPtr)
                
                ; debugMsg(sProcName, "calling getBassDeviceForLogicalDev(" + \sLogicalDev[d] + ")")
                nBassDevice = getBassDeviceForLogicalDev(\sLogicalDev[d])
                nTmpBassSpeaker = grMMedia\nBassSpeaker  ; set by getBassDeviceForLogicalDev()
                nSpeakerCount = grMMedia\nSpeakerCount   ; set by getBassDeviceForLogicalDev()
                                                         ; debugMsg(sProcName, ">>>> nBassDevice=" + nBassDevice)
                If nBassDevice = -1
                  debugMsg(sProcName, "\sLogicalDev[" + d + "]=" + \sLogicalDev[d] + " not assigned")
                  debugMsg(sProcName, "calling mapAudLogicalDevsToPhysicalDevs(" + decodeDriver(gnCurrAudioDriver) + ")")
                  mapAudLogicalDevsToPhysicalDevs(gnCurrAudioDriver)
                  ; try again
                  debugMsg(sProcName, "calling getBassDeviceForLogicalDev(" + \sLogicalDev[d] + ")")
                  nBassDevice = getBassDeviceForLogicalDev(\sLogicalDev[d])
                  nTmpBassSpeaker = grMMedia\nBassSpeaker  ; set by getBassDeviceForLogicalDev()
                  nSpeakerCount = grMMedia\nSpeakerCount   ; set by getBassDeviceForLogicalDev()
                EndIf
                
                If nBassDevice = -1
                  bDeviceFound = #False
                  \nBassDevice[d] = 0
                  If Len(\sErrorMsg) = 0
                    \sErrorMsg = LangPars("Errors", "DevNotAssigned", \sLogicalDev[d])  ; "Device " + \sLogicalDev[d] + " has not been assigned to an Audio Device in the Production Properties"
                  EndIf
                Else
                  bDeviceNamed = #True
                  \nBassDevice[d] = nBassDevice
                  
; debugMsg(sProcName, "\nBassDevice(" + d + ")=" + \nBassDevice[d] + ", nSpeakerCount=" + nSpeakerCount + ", nTmpBassSpeaker=$" + Hex(nTmpBassSpeaker))
                  If nSpeakerCount = 2
                    \bDisplayPan[d] = #True
                  Else
                    \bDisplayPan[d] = #False     ; pan not available for mono or >2 channels
                  EndIf
                  If \bAudTypeP
                    aSub(\nSubIndex)\bSubDisplayPan[d] = \bDisplayPan[d]
                  EndIf
                  
                  nBassResult = mmSetDevice(nBassDevice, sProcName, \sCue)
                  If nBassResult = #BASSFALSE
                    UnlockCueListMutex()
                    ProcedureReturn
                  EndIf
                  
                  nPluginFlags = 0
                  
                  If (\bInfoObtained = #False) Or (\nStartAt > 0) Or (\nEndAt > 0) Or (\nMaxLoopInfo >= 0) ; (\bContainsLoop)
                    If LCase(\sFileExt) = "mp3"
                      ; mp3 files to be prescanned for 'pin-point' accuracy
                      nStreamCreateFlags | #BASS_STREAM_PRESCAN
                      nDecodeStreamCreateFlags | #BASS_STREAM_PRESCAN
                    EndIf
                  EndIf
                  
                  If \nBassChannel[d] <> 0
                    nBassResult = BASS_StreamFree(\nBassChannel[d])
                    debugMsg2(sProcName, "BASS_StreamFree(" + decodeHandle(\nBassChannel[d]) + ")", nBassResult)
                    ; Added 5Jul2022 11.9.3.1ab
                    If nBassResult = #BASSFALSE
                      nErrorCode = BASS_ErrorGetCode()
                      debugMsg3(sProcName, "Error: " + getBassErrorDesc(nErrorCode))
                    EndIf
                    ; End added 5Jul2022 11.9.3.1ab
                    freeHandle(\nBassChannel[d])
                    If \nSourceChannel = \nBassChannel[d]
                      \nSourceChannel = 0
                    EndIf
                    \nBassChannel[d] = 0
                  EndIf
                  If \nBassAltChannel[d] <> 0
                    nBassResult = BASS_StreamFree(\nBassAltChannel[d])
                    debugMsg2(sProcName, "BASS_StreamFree(" + Str(\nBassAltChannel[d]) + ")", nBassResult)
                    ; Added 5Jul2022 11.9.3.1ab
                    If nBassResult = #BASSFALSE
                      nErrorCode = BASS_ErrorGetCode()
                      debugMsg3(sProcName, "Error: " + getBassErrorDesc(nErrorCode))
                    EndIf
                    ; End added 5Jul2022 11.9.3.1ab
                    freeHandle(\nBassAltChannel[d])
                    If \nSourceAltChannel = \nBassAltChannel[d]
                      \nSourceAltChannel = 0
                    EndIf
                    \nBassAltChannel[d] = 0
                  EndIf
                  ; debugMsg(sProcName, ">>> (a) \nBassChannel[" + d + "]=" + decodeHandle(\nBassChannel[d]) + ", \nBassAltChannel[" + d + "]=" + decodeHandle(\nBassAltChannel[d]))
                  ; debugMsg(sProcName, ">>> (a) \nSourceChannel=" + decodeHandle(\nSourceChannel) + ", \nSourceAltChannel=" + decodeHandle(\nSourceAltChannel))
                  
                  If \nLastSoundingDev > \nFirstSoundingDev
                    \bUsingSplitStream = #True
                  EndIf
                  
                  If \bAudUseGaplessStream
                    \bUsingSplitStream = #True
                  EndIf
                  
                  If d = \nFirstSoundingDev
                    If bMyForceDurationCheck = #False
                      If checkFileChanged(pAudPtr)
                        bMyForceDurationCheck = #True
                      EndIf
                    EndIf
                    
                    If (\nFileDuration = grAudDef\nFileDuration) Or (\qFileBytes = grAudDef\qFileBytes) Or (bMyForceDurationCheck)
                      debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nFileDuration=" + \nFileDuration +
                                          ", \qFileBytes=" + \qFileBytes + ", bMyForceDurationCheck=" + strB(bMyForceDurationCheck))
                      ; don't know or may not know file duration or file byte size yet
                      If getFileDuration(pAudPtr) = #False
                        Break
                      EndIf
                    EndIf
                    ; debugMsg(sProcName, "\nFileDuration=" + \nFileDuration + ", \qFileBytes=" + \qFileBytes)
                    
                    ; sanity check against \nFileDuration
                    bSanityCheckOK = #True
                    If \bAudPlaceHolder = #False
                      If \nStartAt >= \nFileDuration
                        bSanityCheckOK = #False
                        sMsg = "Start At (" + ttszt(\nStartAt) + ") must be less than File Length (" + ttszt(\nFileDuration) + ")"
                      ElseIf \nEndAt > \nFileDuration
                        bSanityCheckOK = #False
                        sMsg = "End At (" + ttszt(\nEndAt) + ") cannot be greater than File Length (" + ttszt(\nFileDuration) + ")"
                      ElseIf \nMaxLoopInfo >= 0
                        If \aLoopInfo(\nMaxLoopInfo)\nLoopStart >= \nFileDuration
                          bSanityCheckOK = #False
                          sMsg = "Loop Start (" + ttszt(\aLoopInfo(\nMaxLoopInfo)\nLoopStart) + ") must be less than File Length (" + ttszt(\nFileDuration) + ")"
                        ElseIf \aLoopInfo(\nMaxLoopInfo)\nLoopEnd > \nFileDuration
                          bSanityCheckOK = #False
                          sMsg = "Loop End (" + ttszt(\aLoopInfo(\nMaxLoopInfo)\nLoopEnd) + ") cannot be greater than File Length (" + ttszt(\nFileDuration) + ")"
                        EndIf
                      EndIf
                    EndIf
                    If bSanityCheckOK = #False
                      If bMayClearSettings
                        ; debugMsg(sProcName, "clearing existing start/end/loop/fade/level-point settings")
                        \nStartAt = grAudDef\nStartAt
                        \nEndAt = grAudDef\nEndAt
                        \nMaxLoopInfo = grAudDef\nMaxLoopInfo
                        \nCurrLoopInfoIndex = grAudDef\nCurrLoopInfoIndex
                        \nFadeInTime = grAudDef\nFadeInTime
                        \nFadeOutTime = grAudDef\nFadeOutTime
                        \nFadeInType = grAudDef\nFadeInType
                        \nFadeOutType = grAudDef\nFadeOutType
                        \nCurrFadeInTime = \nFadeInTime
                        \nCurrFadeOutTime = \nFadeOutTime
                        \sStartAtCPName = grAudDef\sStartAtCPName
                        \qStartAtSamplePos = grAudDef\qStartAtSamplePos
                        \dStartAtCPTime = grAudDef\dStartAtCPTime
                        \sEndAtCPName = grAudDef\sEndAtCPName
                        \qEndAtSamplePos = grAudDef\qEndAtSamplePos
                        \dEndAtCPTime = grAudDef\dEndAtCPTime
                        \nMaxLevelPoint = grAudDef\nMaxLevelPoint
                      Else
                        \sErrorMsg = sMsg
                        audSetState(pAudPtr, #SCS_CUE_ERROR, 36)
                        Break
                      EndIf
                    EndIf ; EndIf bSanityCheckOK = #False
                    
                    ; debugMsg(sProcName, "calling setDerivedAudFields")
                    setDerivedAudFields(pAudPtr)
                    
                  EndIf ; EndIf d = \nFirstSoundingDev
                  
                  If (gnCurrAudioDriver = #SCS_DRV_BASS_DS Or gnCurrAudioDriver = #SCS_DRV_BASS_WASAPI) And (gbUseBASSMixer = #False)
                    If grDriverSettings\sPlaybackBufOption = "Default" Or grDriverSettings\nPlaybackBufLength = 0
                      nPlaybackBufferSize = gnDefaultBuffer
                    Else
                      nPlaybackBufferSize = grDriverSettings\nPlaybackBufLength
                    EndIf
                    If  \nMaxLoopInfo >= 0 ; \bContainsLoop
                      bXFadePresent = #False
                      For l2 = 0 To \nMaxLoopInfo
                        nLoopPlaybackBufferSize = \aLoopInfo(l2)\nAbsLoopEnd - \aLoopInfo(l2)\nAbsLoopStart - 50
                        If \aLoopInfo(l2)\nLoopXFadeTime > 0
                          nLoopPlaybackBufferSize - \aLoopInfo(l2)\nLoopXFadeTime
                          bXFadePresent = #True
                        EndIf
                        If (l2 = 0) Or (nLoopPlaybackBufferSize < nMaxPlaybackBufferSize)
                          nMaxPlaybackBufferSize = nLoopPlaybackBufferSize
                        EndIf
                      Next l2
                      If bXFadePresent = #False
                        nMaxPlaybackBufferSize = #SCS_DEFAULT_BUFFER_USING_MIXER  ; added 24/04/2014
                        ; note: the playback buffer size (set via #BASS_CONFIG_BUFFER) must be small for loop processing
                        ; where a single file is being used, because otherwise releasing the loop could cause an extra
                        ; iteration of the loop. if the loop is released after the mixtime loop sync occurs, then the
                        ; loop will only release the next time that mixtime loop sync would have occured, ie at the end
                        ; of the next iteration of the loop. so by keeping the playback buffer size to 300ms, an extra
                        ; iteration of the loop will only occur of the loop is released during that last 300ms of the loop.
                      EndIf
                      If nMaxPlaybackBufferSize < 200
                        nMaxPlaybackBufferSize = 200
                      EndIf
                      If nMaxPlaybackBufferSize < nPlaybackBufferSize
                        nPlaybackBufferSize = nMaxPlaybackBufferSize
                      EndIf
                    EndIf
                    If Trim(\sVSTPluginName) Or Trim(\sVSTPluginSameAsCue)
                      If nPlaybackBufferSize > 1000
                        nPlaybackBufferSize = 1000
                      EndIf
                    EndIf
                    ; debugMsg(sProcName, "nPlaybackBufferSize=" + nPlaybackBufferSize)
                    nBassResult = BASS_SetConfig(#BASS_CONFIG_BUFFER, nPlaybackBufferSize)
                    debugMsg2(sProcName, "BASS_SetConfig(BASS_CONFIG_BUFFER, " + nPlaybackBufferSize + ")", nBassResult)
                  EndIf
                  
                EndIf
                
                If gbUseBASSMixer
                  nBassSpeaker = 0
                Else
                  nBassSpeaker = nTmpBassSpeaker
                EndIf
                debugMsg(sProcName, "opening " + \sFileName + " flags: $" + Hex(nBassSpeaker | nStreamCreateFlags))
                
                If \bAudPlaceHolder
                  bDeviceFound = #True
                  \sDriver = "PLH"
                Else
                  debugMsg(sProcName, "calling openNormal(" + getAudLabel(pAudPtr) + ", " + d + ", $" + Hex(nBassSpeaker) + ", $" + Hex(nStreamCreateFlags) + ")")
                  openNormal(pAudPtr, d, nBassSpeaker, nStreamCreateFlags, nDecodeStreamCreateFlags)
                  
                  nChannel = \nBassChannel[d]
                  nAltChannel = \nBassAltChannel[d]
                  
                  ; debugMsg(sProcName, ">>> (b) \nBassChannel[" + d + "]=" + decodeHandle(\nBassChannel[d]) + ", \nBassAltChannel[" + d + "]=" + decodeHandle(\nBassAltChannel[d]))
                  If nChannel = 0
                    \sErrorMsg = LangPars("Errors", "FileError", \sFileName, getBassErrorDesc(BASS_ErrorGetCode()))
                    audSetState(pAudPtr, #SCS_CUE_ERROR, 37)
                    debugMsg(sProcName, "SCS_CUE_ERROR(b) d=" + d + " " + \sErrorMsg)
                    \nBassStreamCreateFlags[d] = 0
                    \nBassDecodeStreamCreateFlags[d] = 0
                    
                  Else
                    
                    If gbUseBASSMixer
                      nMixerStreamPtr = getMixerStreamPtrForLogicalDev(\sLogicalDev[d])
                      If nMixerStreamPtr >= 0
                        nMixerStreamHandle = gaMixerStreams(nMixerStreamPtr)\nMixerStreamHandle
                        If (\bAudUseGaplessStream) And (\nAudGaplessSeqPtr >= 0)
                          gaGaplessSeqs(\nAudGaplessSeqPtr)\nMixerStream = nMixerStreamHandle
                        EndIf
                        
                        \nMixerStreamPtr[d] = nMixerStreamPtr
                        debugMsg(sProcName, "\sLogicalDev(" + d + ")=" + \sLogicalDev[d] + ", \nMixerStreamPtr(" + d + ")=" + \nMixerStreamPtr[d])
                        debugMsg(sProcName, "nMixerStreamHandle=" + decodeHandle(nMixerStreamHandle))
                        
                        nMixerChannelFlags = #BASS_MIXER_CHAN_DOWNMIX | #BASS_MIXER_CHAN_PAUSE ; default flags - may be changed in code below
                        
                        nBassResult = BASS_ChannelGetInfo(\nSourceChannel, @rChannelInfo)
                        debugMsg2(sProcName, "BASS_ChannelGetInfo(" + decodeHandle(\nSourceChannel) + ", rChannelInfo)", nBassResult)
                        debugMsg(sProcName, "rChannelInfo\chans=" + rChannelInfo\chans + ", gaMixerStreams(" + nMixerStreamPtr + ")\bUseMatrix=" + strB(gaMixerStreams(nMixerStreamPtr)\bUseMatrix))
                        \nNrOfInputChans = rChannelInfo\chans
                        
                        If gaMixerStreams(nMixerStreamPtr)\bUseMatrix
                          nMixerChannelFlags = #BASS_MIXER_CHAN_MATRIX | #BASS_MIXER_CHAN_PAUSE
                          n1 = gaMixerStreams(nMixerStreamPtr)\nMatrixOutputs     ; matrix outputs
                          If n1 < 1 Or n1 > 2
                            debugMsg3(sProcName, "gaMixerStreams(" + nMixerStreamPtr + ")\nMatrixOutputs=" + gaMixerStreams(nMixerStreamPtr)\nMatrixOutputs)
                            ensureSplashNotOnTop()
                            scsMessageRequester(#SCS_TITLE, "gaMixerStreams(" + nMixerStreamPtr + ")\nMatrixOutputs=" + gaMixerStreams(nMixerStreamPtr)\nMatrixOutputs + " - expected 1 or 2", #PB_MessageRequester_Error)
                            UnlockCueListMutex()
                            ProcedureReturn
                          EndIf
                          m1 = \nNrOfInputChans                                       ; matrix inputs
                          For n = 0 To (n1 - 1)
                            For m = 0 To (m1 - 1)
                              If n = 0
                                \aMixerMatrix[d]\aMatrix[(n * m1) + m] = gaMixerStreams(nMixerStreamPtr)\fMatrixLeftValue
                              Else
                                \aMixerMatrix[d]\aMatrix[(n * m1) + m] = gaMixerStreams(nMixerStreamPtr)\fMatrixRightValue
                              EndIf
                              ;debugMsg3(sProcName, "\aMixerMatrix(" & d & ")\aMatrix(" & n & ", " & m & ")=" & \aMixerMatrix[d]\aMatrix(n, m))
                            Next m
                          Next n
                          For n = 1 To (n1 * m1)
                            debugMsg3(sProcName, "\aMixerMatrix(" + d + ")\aMatrix(" + Str(n - 1) + ")=" + StrF(\aMixerMatrix[d]\aMatrix[n - 1],1))
                          Next n
                          
                        Else
                          \bUseMatrix[d] = #False
                          nLogicalDevPtr = getProdLogicalDevPtrForLogicalDev(\sLogicalDev[d])
                          ; nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_AUDIO_OUTPUT, \sLogicalDev[d])
                          \nSelectedDeviceOutputs[d] = grMaps\aDev(nDevMapDevPtr)\nNrOfDevOutputChans
                          ; debugMsg(sProcName, "\nSelectedDeviceOutputs[" + d + "]=" + Str(\nSelectedDeviceOutputs[d]))
                          \nOutputDevMapDevPtr[d] = nDevMapDevPtr
                          If grMaps\aDev(nDevMapDevPtr)\nReassignDevMapDevPtr >= 0
                            d1 = nDevMapDevPtr
                            d2 = grMaps\aDev(d1)\nReassignDevMapDevPtr
                            debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\nNrOfDevOutputChans=" + Str(grMaps\aDev(d1)\nNrOfDevOutputChans) + ", grMaps\aDev(" + d2 + ")\nNrOfDevOutputChans=" + Str(grMaps\aDev(d2)\nNrOfDevOutputChans))
                            If grMaps\aDev(d1)\nNrOfDevOutputChans <> grMaps\aDev(d2)\nNrOfDevOutputChans
                              nMixerChannelFlags = #BASS_MIXER_CHAN_MATRIX | #BASS_MIXER_CHAN_PAUSE
                              \bUseMatrix[d] = #True
                              \nMatrixOutputs[d] = grMaps\aDev(d2)\nNrOfDevOutputChans
                              n1 = \nMatrixOutputs[d]     ; matrix outputs
                              m1 = \nNrOfInputChans           ; matrix inputs
                              debugMsg3(sProcName, Str(n1) + " matrix outputs, " + Str(m1) + " matrix inputs")
                              ; Redim \aMixerMatrix[d]\aMatrix(n1 * m1)
                              \nMatrixFactor[d] = \nSelectedDeviceOutputs[d] / rChannelInfo\chans
                              debugMsg(sProcName, "\nSelectedDeviceOutputs[" + d + "]=" + \nSelectedDeviceOutputs[d] + ", rChannelInfo\chans=" + rChannelInfo\chans + ", \nMatrixFactor[" + d + "]=" + \nMatrixFactor[d])
                              If \nMatrixFactor[d] > 1
                                \nMatrixFactor[d] = 1
                              EndIf
                              debugMsg3(sProcName, "\nSelectedDeviceOutputs(" + d + ")=" + Str(\nSelectedDeviceOutputs[d]) + ", \nNrOfInputChans=" + Str(\nNrOfInputChans) + ", \nMatrixFactor[d]=" + Str(\nMatrixFactor[d]))
                              \nMatrixOutputOffSet[d] = grMaps\aDev(d1)\nFirstASIOChannel - grMaps\aDev(d2)\nFirstASIOChannel
                              debugMsg3(sProcName, "\nMatrixOutputOffSet[" + d + "]=" + Str(\nMatrixOutputOffSet[d]) + ", (\nMatrixOutputOffSet(" + d + ") + \nSelectedDeviceOutputs(" + d + "))=" + Str(\nMatrixOutputOffSet[d] + \nSelectedDeviceOutputs[d]))
                              For n = \nMatrixOutputOffSet[d] To (\nMatrixOutputOffSet[d] + \nSelectedDeviceOutputs[d] - 1)
                                For m = 0 To (m1 - 1)
                                  If (m1 = 1) Or (\nSelectedDeviceOutputs[d] = 1) Or (m = (n - \nMatrixOutputOffSet[d]))
                                    debugMsg(sProcName, "n=" + n + ", m1=" + m1 + ", m=" + m + ", ((n * m1) + m)=" + Str((n * m1) + m))
                                    \aMixerMatrix[d]\aMatrix[(n * m1) + m] = \nMatrixFactor[d]
                                  EndIf
                                Next m
                              Next n
                              For n = 1 To (n1 * m1)
                                debugMsg3(sProcName, "\aMixerMatrix(" + d + ")\aMatrix(" + Str(n-1) + ")=" + StrF(\aMixerMatrix[d]\aMatrix[n-1],1))
                              Next n
                            EndIf
                          ElseIf \nNrOfInputChans < grMaps\aDev(nDevMapDevPtr)\nNrOfDevOutputChans
                            ; NOTE: The code in this 'ElseIf' added Apr2025 11.10.8ax to handle scenarios where there are more outputs than inputs, especially more than a stereo output.
                            ; If there are more output channels than input channels then SCS treats all the output channels as mono,
                            ; so if a stereo file is played to, say, 4 output channels, then each of those 4 output channels will receive a downmix of the stereo channels.
                            ; I (Mike) made this decision rather than to assign, for example, L, R, L, R because in a multi-output scenario like this the 3rd+ channels
                            ; may not be stereo pairs. For example: Main (output 1-4), Front (1-2), USR (3), USL (4), Rear (5-6).
                            d1 = nDevMapDevPtr
                            debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nNrOfInputChans=" + \nNrOfInputChans + ", grMaps\aDev(" + d1 + ")\nNrOfDevOutputChans=" + grMaps\aDev(d1)\nNrOfDevOutputChans)
                              nMixerChannelFlags = #BASS_MIXER_CHAN_MATRIX | #BASS_MIXER_CHAN_PAUSE
                              \bUseMatrix[d] = #True
                              \nMatrixOutputs[d] = grMaps\aDev(d1)\nNrOfDevOutputChans
                              n1 = \nMatrixOutputs[d]     ; matrix outputs
                              m1 = \nNrOfInputChans       ; matrix inputs
                              debugMsg3(sProcName, Str(n1) + " matrix outputs, " + Str(m1) + " matrix inputs")
                              Select rChannelInfo\chans
                                Case 1 ; mono file
                                  \nMatrixFactor[d] = 1.0
                                Case 2 ; stereo file
                                  \nMatrixFactor[d] = 0.5 ; output as mono to every matrix output (0.5 as both input channels will be summed for each output channel)
                                Default
                                  \nMatrixFactor[d] = \nSelectedDeviceOutputs[d] / rChannelInfo\chans
                                  If \nMatrixFactor[d] > 1
                                    \nMatrixFactor[d] = 1
                                  EndIf
                              EndSelect
                              debugMsg3(sProcName, "\nSelectedDeviceOutputs(" + d + ")=" + Str(\nSelectedDeviceOutputs[d]) + ", \nNrOfInputChans=" + Str(\nNrOfInputChans) + ", \nMatrixFactor[d]=" + Str(\nMatrixFactor[d]))
                              \nMatrixOutputOffSet[d] = 0 ; grMaps\aDev(d1)\nFirstASIOChannel - grMaps\aDev(d2)\nFirstASIOChannel
                              debugMsg3(sProcName, "\nMatrixOutputOffSet[" + d + "]=" + Str(\nMatrixOutputOffSet[d]) + ", (\nMatrixOutputOffSet(" + d + ") + \nSelectedDeviceOutputs(" + d + "))=" + Str(\nMatrixOutputOffSet[d] + \nSelectedDeviceOutputs[d]))
                              For n = 1 To (n1 * m1)
                                \aMixerMatrix[d]\aMatrix[n-1] = \nMatrixFactor[d]
                                debugMsg3(sProcName, "\aMixerMatrix(" + d + ")\aMatrix[" + Str(n-1) + "]=" + StrF(\aMixerMatrix[d]\aMatrix[n-1],1))
                              Next n
                          EndIf
                          
                        EndIf
                        
                        nMixerChannelFlags | #BASS_MIXER_CHAN_NORAMPIN | #BASS_MIXER_CHAN_BUFFER | nBassSpeaker
                        
                        If gaMixerStreams(nMixerStreamPtr)\bNoDevice
                          bAddChannelToMixer = #False
                        Else
                          bAddChannelToMixer = #True
                          If \nAudGaplessSeqPtr >= 0
                            If \bUsingSplitStream = #False
                              nChannel = gaGaplessSeqs(\nAudGaplessSeqPtr)\nGaplessStream
                            EndIf
                            If gaGaplessSeqs(\nAudGaplessSeqPtr)\nFirstGaplessAudPtr <> pAudPtr
                              bAddChannelToMixer = #False
                            EndIf
                          EndIf
                        EndIf
                        
                        ; debugMsg(sProcName, "bAddChannelToMixer=" + strB(bAddChannelToMixer))
                        If bAddChannelToMixer
                          sBassCommand = "BASS_Mixer_StreamAddChannel(" + decodeHandle(nMixerStreamHandle) + ", " + decodeHandle(nChannel) + ", " + decodeStreamCreateFlags(nMixerChannelFlags, #False, #True) + ")"
                          debugMsg(sProcName, "calling " + sBassCommand)
                          nBassResult = BASS_Mixer_StreamAddChannel(nMixerStreamHandle, nChannel, nMixerChannelFlags)
                          debugMsg2(sProcName, sBassCommand, nBassResult)
                          
                          If nBassResult = #BASSFALSE
                            nErrorCode = BASS_ErrorGetCode()
                            debugMsg3(sProcName, "Error: " + getBassErrorDesc(nErrorCode) + Chr(10) + sBassCommand)
                          Else ; nBassResult = #BASSTRUE
                            If \bASIO[d] = #False
                              ; not a decoding stream
                              If grMaps\aDev(nDevMapDevPtr)\bNoSoundDevice = #False
                                addChannelToChannelUpdateArray(nMixerStreamHandle, 0)
                              EndIf
                            EndIf
                            
                            nBassResult = BASS_Mixer_ChannelFlags(nChannel, 0, 0)
                            debugMsg3(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(nChannel) + ", 0, 0) returned " + decodeMixerChannelFlags(nBassResult))
                            
                            debugMsg(sProcName, "nMixerStreamPtr=" + nMixerStreamPtr + ", d=" + d)
                            If gaMixerStreams(nMixerStreamPtr)\bUseMatrix Or \bUseMatrix[d]
                              debugMsg(sProcName, "gaMixerStreams(" + nMixerStreamPtr + ")\bUseMatrix=" + strB(gaMixerStreams(nMixerStreamPtr)\bUseMatrix))
                              nBassResult = BASS_Mixer_ChannelSetMatrix(nChannel, @\aMixerMatrix[d]\aMatrix[0])
                              debugMsg2(sProcName, "BASS_Mixer_ChannelSetMatrix(" + decodeHandle(nChannel) + ", @\aMixerMatrix(" + d + ")\aMatrix[0])", nBassResult)
                              If nBassResult = #BASSFALSE
                                Error_(sProcName, "BASS_Mixer_ChannelSetMatrix failed")
                                UnlockCueListMutex()
                                ProcedureReturn
                              EndIf
                            EndIf
                            
                            If nAltChannel <> 0
                              nBassResult = BASS_Mixer_StreamAddChannel(nMixerStreamHandle, nAltChannel, nMixerChannelFlags)
                              debugMsg2(sProcName, "(alt) BASS_Mixer_StreamAddChannel(" + decodeHandle(nMixerStreamHandle) + ", " + decodeHandle(nAltChannel) + ", " + decodeStreamCreateFlags(nMixerChannelFlags, #False, #True) + ")", nBassResult)
                              If nBassResult = 0
                                Error_(sProcName, "(alt) BASS_Mixer_StreamAddChannel failed")
                                UnlockCueListMutex()
                                ProcedureReturn
                              EndIf
                              
                              If gaMixerStreams(nMixerStreamPtr)\bUseMatrix Or \bUseMatrix[d]
                                nBassResult = BASS_Mixer_ChannelSetMatrix(nAltChannel, @\aMixerMatrix[d]\aMatrix[0])
                                debugMsg2(sProcName, "BASS_Mixer_ChannelSetMatrix(" + decodeHandle(nAltChannel) + ", @\aMixerMatrix(" + d + ")\aMatrix[0])", nBassResult)
                                If nBassResult = #BASSFALSE
                                  nErrorCode = BASS_ErrorGetCode()
                                  debugMsg3(sProcName, "Error: " + getBassErrorDesc(nErrorCode))
                                EndIf
                              EndIf
                              
                            EndIf ; EndIf nAltChannel <> 0
                            
                          EndIf ; EndIf nBassResult = #BASSFALSE (after BASS_Mixer_StreamAddChannel(nMixerStreamHandle, nChannel, nMixerChannelFlags))
                          
                        EndIf ; EndIf bAddChannelToMixer
                        
                      EndIf ; EndIf nMixerStreamPtr >= 0
                      
                    Else    ; gbUseBASSMixer = False
                      nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_AUDIO_OUTPUT, \sLogicalDev[d])
                      debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\sLogicalDev[" + d + "]=" + \sLogicalDev[d] + ", nDevMapDevPtr=" + nDevMapDevPtr)
                      CheckSubInRange(nDevMapDevPtr, ArraySize(grMaps\aDev()), "grMaps\aDev()")
                      \nSelectedDeviceOutputs[d] = grMaps\aDev(nDevMapDevPtr)\nNrOfDevOutputChans
                      debugMsg(sProcName, "\nSelectedDeviceOutputs[" + d + "]=" + \nSelectedDeviceOutputs[d])
                      If (\bInfoObtained = #False) Or (\nNrOfInputChans = 0)
                        nBassResult = BASS_ChannelGetInfo(\nSourceChannel, @rChannelInfo)
                        debugMsg2(sProcName, "BASS_ChannelGetInfo(" + decodeHandle(\nSourceChannel) + ", @rChannelInfo)", nBassResult)
                        debugMsg3(sProcName, "rChannelInfo\chans=" + rChannelInfo\chans)
                        \nNrOfInputChans = rChannelInfo\chans
                        \bInfoObtained = #True
                      EndIf
                      
                    EndIf
                    
                    If \qFileBytes = grAudDef\qFileBytes
                      \qFileBytes = BASS_ChannelGetLength(nChannel, #BASS_POS_BYTE)
                      debugMsg(sProcName, "BASS_ChannelGetLength(" + decodeHandle(nChannel) + ", BASS_POS_BYTE) returned \qFileBytes=" + \qFileBytes)
                      If \qFileBytes = -1
                        Error_(sProcName, "BASS_ChannelGetLength(" + decodeHandle(nChannel) + ", BASS_POS_BYTE) failed")
                      EndIf
                    Else
                      debugMsg(sProcName, "\qFileBytes=" + \qFileBytes)
                    EndIf
                    
                    If \nStartAt = -2
                      \nAbsStartAt = 0
                    Else
                      \nAbsStartAt = \nStartAt
                    EndIf
                    If \nEndAt = -2
                      \nAbsEndAt = \nFileDuration - 1
                    Else
                      \nAbsEndAt = \nEndAt
                    EndIf
                    
                    If \bAudUseGaplessStream = #False
                      debugMsg(sProcName, "\sFadeInTime=" + \sFadeInTime + ", \nFadeInTime=" + \nFadeInTime + ", \nFadeOutTime=" + \nFadeOutTime)
                      If \nFadeInTime <= 0 And \sFadeInTime = ""
                        fReqdBVLevel = \fAudPlayBVLevel[d]
                        If fReqdBVLevel > 1.0 ; could be > 1.0 if previously used ASIO with +12dB as maximum level
                          fReqdBVLevel = 1.0
                        EndIf
                        ; Added 28Sep2022 11.9.6
                        If fReqdBVLevel <= grLevels\fMinBVLevel
                          fReqdBVLevel = 0.0
                        EndIf
                        ; End added 28Sep2022 11.9.6
                      Else
                        fReqdBVLevel = #SCS_MINVOLUME_SINGLE
                      EndIf
                      nBassResult = BASS_ChannelSetAttribute(nChannel, #BASS_ATTRIB_VOL, fReqdBVLevel)
                      debugMsg(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nChannel) + ", BASS_ATTRIB_VOL, " + formatLevel(fReqdBVLevel) + ") returned " + nBassResult + ", fReqdBVLevel=" + traceLevel(fReqdBVLevel))
                      If nBassResult = #BASSFALSE
                        debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                        Error_(sProcName, "Channel set vol attribute for " + \sCue + " failed, fReqdBVLevel=" + StrF(fReqdBVLevel,4))
                      EndIf
                      fReqdPan = \fPan[d]
                      nBassResult = BASS_ChannelSetAttribute(nChannel, #BASS_ATTRIB_PAN, fReqdPan)
                      debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nChannel) + ", BASS_ATTRIB_PAN, " + formatPan(fReqdPan) + ")", nBassResult)
                      CompilerIf #cTraceGetPan
                        debugMsg3(sProcName, "BASS_ChannelGetAttribute("+ decodeHandle(nChannel) + ", BASS_ATTRIB_PAN, @fBassPan) returned " + nBassResult +
                                             ", fBassPan=" + formatPan(fBassPan))
                      CompilerEndIf
                      If nBassResult = #BASSFALSE
                        Error_(sProcName, "Channel set pan attribute for " + \sCue + " failed")
                      EndIf
                      If nAltChannel <> 0
                        nBassResult = BASS_ChannelSetAttribute(nAltChannel, #BASS_ATTRIB_VOL, #SCS_MINVOLUME_SINGLE)
                        debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nAltChannel) + ", BASS_ATTRIB_VOL, " + formatLevel(#SCS_MINVOLUME_SINGLE) + ")", nBassResult)
                        nBassResult = BASS_ChannelSetAttribute(nAltChannel, #BASS_ATTRIB_PAN, fReqdPan)
                        debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nAltChannel) + ", BASS_ATTRIB_PAN, " + formatPan(fReqdPan) + ")", nBassResult)
                      EndIf
                    EndIf
                    
                    If d = \nFirstSoundingDev
                      ; only need to do this once
                      ; debugMsg(sProcName, "calling setDerivedAudFields")
                      setDerivedAudFields(pAudPtr)
                    EndIf
                    
                    If \nAbsStartAt <> 0
                      debugMsg(sProcName, "calling setChannelPosition(" + getAudLabel(pAudPtr) + ", " + d + ", " + \nAbsStartAt + ", " + \qStartAtBytePos + ")")
                      setChannelPosition(pAudPtr, d, \nAbsStartAt, \qStartAtBytePos)
                    EndIf
                    
                    If nAltChannel <> 0
                      SetPlayingPos(pAudPtr, d, #SCS_CHAN_ALT, \aLoopInfo(0)\nAbsLoopStart, (\aLoopInfo(0)\qLoopStartSamplePos * \nBytesPerSamplePos))
                      BASS_ChannelSetAttribute(nAltChannel, #BASS_ATTRIB_VOL, #SCS_MINVOLUME_SINGLE)
                      debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nAltChannel) + ", BASS_ATTRIB_VOL, " + formatLevel(#SCS_MINVOLUME_SINGLE) + ")", nBassResult)
                    EndIf
                    
                    CompilerIf #cAlwaysUseMixerForBass  ; 28Dec2015 - always use default buffer length
                      \nPlaybackBufSize = gnDefaultBuffer
                    CompilerElse
                      \nPlaybackBufSize = 0
                      If grDriverSettings\sPlaybackBufOption = "Default"
                        \nPlaybackBufSize = gnDefaultBuffer
                      ElseIf grDriverSettings\sPlaybackBufOption = "User"
                        \nPlaybackBufSize = grDriverSettings\nPlaybackBufLength
                      EndIf
                    CompilerEndIf
                    
                    If (gbUseBASSMixer = #False) And (\bASIO[d] = #False)
                      If (\bUsingSplitStream = #False) And (\bAudUseGaplessStream = #False)
                        If grMaps\aDev(nDevMapDevPtr)\bNoSoundDevice = #False
                          If (nPlaybackBufferSize = 0) Or (\nPlaybackBufSize < nPlaybackBufferSize)
                            nPlaybackBufferSize = \nPlaybackBufSize
                          EndIf
                          addChannelToChannelUpdateArray(nChannel, nPlaybackBufferSize)
                          If nAltChannel <> 0
                            addChannelToChannelUpdateArray(nAltChannel, nPlaybackBufferSize)
                          EndIf
                        EndIf
                      EndIf
                      \qInitialGetPosition = BASS_ChannelGetPosition(\nSourceChannel, #BASS_POS_BYTE)
                      debugMsg2(sProcName, "BASS_ChannelGetPosition(" + decodeHandle(\nSourceChannel) + ", BASS_POS_BYTE)", \qInitialGetPosition)
                      ; Added 25Nov2022 11.9.7am
                      If \qInitialGetPosition = -1
                        debugMsg(sProcName, "Error " + BASS_ErrorGetCode() + ": " + getBassErrorDesc(BASS_ErrorGetCode()))
                        \qInitialGetPosition = 0
                      EndIf
                      ; End added 25Nov2022 11.9.7am
                      debugMsg3(sProcName, "\qInitialGetPosition=" + \qInitialGetPosition)
                    EndIf
                    
                  EndIf
                  
                  If nBassDevice = -1 Or nChannel = 0
                    sMsg = ""
                    If nBassDevice = -1
                      If \sLogicalDev[d]
                        sMsg = "Device " + \sLogicalDev[d] + " required by " + \sCue + " has not been assigned to an Audio Device in the Production Properties"
                        \sErrorMsg = sMsg
                        audSetState(pAudPtr, #SCS_CUE_ERROR, 38)
                        debugMsg(sProcName, "SCS_CUE_ERROR(c) d=" + d + " " + \sErrorMsg)
                      EndIf
                    Else
                      ; no good - BASS can't process this file
                      nErrorCode = BASS_ErrorGetCode()
                      If nErrorCode = #BASS_ERROR_SPEAKER
                        nChannelCount = GetChannels(nChannel)
                        If nSpeakerCount = 1
                          If nChannelCount = 2
                            sMsg = "You cannot play a stereo file through a single (mono) speaker"
                          ElseIf nChannelCount > 2
                            sMsg = "You cannot play a " + nChannelCount + "-channel file thru a single (mono) speaker"
                          EndIf
                        ElseIf nSpeakerCount > 1
                          If nChannelCount > nSpeakerCount
                            sMsg = "You cannot play a " + nChannelCount + "-channel file thru " + nSpeakerCount + " speaker"
                          EndIf
                        EndIf
                      EndIf
                    EndIf
                    
                    If sMsg
                      \sErrorMsg = sMsg
                      audSetState(pAudPtr, #SCS_CUE_ERROR, 40)
                      debugMsg(sProcName, "SCS_CUE_ERROR(d) d=" + d + " " + \sErrorMsg)
                    Else
                      If Len(\sErrorMsg) = 0
                        \sErrorMsg = LangPars("Errors", "CannotOpen", \sStoredFileName)
                        audSetState(pAudPtr, #SCS_CUE_ERROR, 41)
                        debugMsg(sProcName, "SCS_CUE_ERROR(e) d=" + d + " " + \sErrorMsg)
                      EndIf
                    EndIf
                  EndIf
                EndIf
              EndIf
            Next d
            
            If \nFirstSoundingDev < 0
              ; above device loop would not have been executed
              getFileDuration(pAudPtr)
            EndIf
            
          Case #SCS_DRV_SMS_ASIO ; SM-S
            ;{
            
            ; debugMsg(sProcName, "calling setFirstAndLastDev(" + getAudLabel(pAudPtr) + ")")
            setFirstAndLastDev(pAudPtr)
            
            If \bAudPlaceHolder ; 14/07/2014: this test on \bAudPlaceHolder added for 11.3.2
              bDeviceFound = #True
              \sDriver = "PLH"
            Else
              ; added 14Nov2017 11.6.2.2aa because without this audio graph in the editor may not get displayed
              If (\nFileDuration = grAudDef\nFileDuration) Or (\qFileBytes = grAudDef\qFileBytes) Or (bMyForceDurationCheck)
                debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nFileDuration=" + \nFileDuration +
                                    ", \qFileBytes=" + \qFileBytes +
                                    ", bMyForceDurationCheck=" + strB(bMyForceDurationCheck))
                ; don't know or may not know file duration or file byte size yet
                getFileDuration(pAudPtr)
              EndIf
              ; end added 14Nov2017 11.6.2.2aa
              nOpenFileResult = openFileForSMS(pAudPtr)
              Select nOpenFileResult
                Case -2   ; SM-S failed to open the file
                  bDeviceFound = #False
                  
                Case -1   ; insufficient SM-S playback channels
                  bDeviceFound = #False
                  \bInsufficientSMSPlaybacks = #True
                  debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\bInsufficientSMSPlaybacks=" + strB(aAud(pAudPtr)\bInsufficientSMSPlaybacks))
                  
                Default   ; SM-S opened the file OK
                  bDeviceFound = #True
                  \sDriver = "SM-S"
                  
                  If \nGraphChan <> 0
                    nBassResult = BASS_StreamFree(\nGraphChan)
                    debugMsg2(sProcName, "BASS_StreamFree(" + Str(\nGraphChan) + ")", nBassResult)
                    freeHandle(\nGraphChan)
                  EndIf
                  nFlags = #BASS_STREAM_DECODE | #BASS_STREAM_PRESCAN | #SCS_BASS_UNICODE
                  gsFile = \sFileName
                  \nGraphChan = BASS_StreamCreateFile(#BASSFALSE, @gsFile, qOffset, qLength, nFlags)
                  newHandle(#SCS_HANDLE_SOURCE, \nGraphChan)
                  debugMsg2(sProcName, "BASS_StreamCreateFile(#BASSFALSE, " + GetFilePart(gsFile) + ", " + Str(qOffset) + ", " + Str(qLength) + ", " + decodeStreamCreateFlags(nFlags) + ")", \nGraphChan)
                  If \nGraphChan = 0
                    \sErrorMsg = LangPars("Errors", "CannotOpen", \sFileName + " (" + getBassErrorDesc(BASS_ErrorGetCode()) + ")")
                  EndIf
                  
                  ; debugMsg(sProcName, "calling setDerivedAudFields")
                  ; setDerivedAudFields(pAudPtr)
                  
                  ; sanity check against \nFileDuration
                  bSanityCheckOK = #True
                  If \nStartAt >= \nFileDuration
                    bSanityCheckOK = #False
                    sMsg = "Start At (" + ttszt(\nStartAt) + ") must be less than File Length (" + ttszt(\nFileDuration) + ")"
                  ElseIf \nEndAt > \nFileDuration
                    bSanityCheckOK = #False
                    sMsg = "End At (" + ttszt(\nEndAt) + ") cannot be greater than File Length (" + ttszt(\nFileDuration) + ")"
                  ElseIf \nMaxLoopInfo >= 0
                    If \aLoopInfo(\nMaxLoopInfo)\nLoopStart >= \nFileDuration
                      bSanityCheckOK = #False
                      sMsg = "Loop Start (" + ttszt(\aLoopInfo(\nMaxLoopInfo)\nLoopStart) + ") must be less than File Length (" + ttszt(\nFileDuration) + ")"
                    ElseIf \aLoopInfo(\nMaxLoopInfo)\nLoopEnd > \nFileDuration
                      bSanityCheckOK = #False
                      sMsg = "Loop End (" + ttszt(\aLoopInfo(\nMaxLoopInfo)\nLoopEnd) + ") cannot be greater than File Length (" + ttszt(\nFileDuration) + ")"
                    EndIf
                  EndIf
                  If bSanityCheckOK = #False
                    If bMayClearSettings
                      ; debugMsg(sProcName, "clearing existing start/end/loop/fade/level-point settings")
                      \nStartAt = grAudDef\nStartAt
                      \nEndAt = grAudDef\nEndAt
                      \nMaxLoopInfo = grAudDef\nMaxLoopInfo
                      \nCurrLoopInfoIndex = grAudDef\nCurrLoopInfoIndex
                      \nFadeInTime = grAudDef\nFadeInTime
                      \nFadeOutTime = grAudDef\nFadeOutTime
                      \nFadeInType = grAudDef\nFadeInType
                      \nFadeOutType = grAudDef\nFadeOutType
                      \nCurrFadeInTime = \nFadeInTime
                      \nCurrFadeOutTime = \nFadeOutTime
                      \sStartAtCPName = grAudDef\sStartAtCPName
                      \qStartAtSamplePos = grAudDef\qStartAtSamplePos
                      \dStartAtCPTime = grAudDef\dStartAtCPTime
                      \sEndAtCPName = grAudDef\sEndAtCPName
                      \qEndAtSamplePos = grAudDef\qEndAtSamplePos
                      \dEndAtCPTime = grAudDef\dEndAtCPTime
                      \nMaxLevelPoint = grAudDef\nMaxLevelPoint
                    Else
                      \sErrorMsg = sMsg
                      audSetState(pAudPtr, #SCS_CUE_ERROR, 42)
                    EndIf
                  EndIf
                  
                  ; debugMsg(sProcName, "calling setDerivedAudFields(" + getAudLabel(pAudPtr) + ")")
                  setDerivedAudFields(pAudPtr)
                  
              EndSelect
              
            EndIf
            ;}
            
        EndSelect
        ;}
        
    EndSelect
    
    osfNotFound:
    If (bDeviceFound = #False) And ((\bInsufficientSMSPlaybacks = #False) Or ((\bInsufficientSMSPlaybacks) And (bInsufficientSMSPlaybacksOK = #False)))
      debugMsg(sProcName, "bDeviceFound=" + strB(bDeviceFound) + ", \sDriver=" + \sDriver)
      If \bInsufficientSMSPlaybacks
        \sErrorMsg = Lang("Errors", "InsufficientPlaybacks")
        audSetState(pAudPtr, #SCS_CUE_NOT_LOADED, 43)
      Else
        audSetState(pAudPtr, #SCS_CUE_ERROR, 44)
      EndIf
      
    ElseIf \sDriver <> "?"
      \nFileState = #SCS_FILESTATE_OPEN
      debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nFileState=" + decodeFileState(\nFileState) + ", \sDriver=" + \sDriver + ", \nFileDuration=" + \nFileDuration)
      If \bAudTypeF
        If \nCueIndex = gnStandbyCuePtr
          audSetState(pAudPtr, #SCS_CUE_STANDBY, 45)
        Else
          audSetState(pAudPtr, #SCS_CUE_READY, 3)
        EndIf
        
      ElseIf \bAudTypeAorP
        If (\nPrevPlayIndex = -1 Or (pAudPtr = aSub(\nSubIndex)\nFirstPlayIndexThisRun) And (aSub(\nSubIndex)\nPLAudPlayCount = 0))
          ; first file in playlist and the playlist has not yet been played
          If \nCueIndex = gnStandbyCuePtr
            audSetState(pAudPtr, #SCS_CUE_STANDBY, 46)
          Else
            If aSub(\nSubIndex)\nSubState = #SCS_CUE_SUB_COUNTDOWN_TO_START
              audSetState(pAudPtr, #SCS_CUE_SUB_COUNTDOWN_TO_START, 47)
            ElseIf (aSub(\nSubIndex)\nSubState >= #SCS_CUE_COUNTDOWN_TO_START) And (aSub(\nSubIndex)\nSubState <= #SCS_CUE_FADING_OUT)
              audSetState(pAudPtr, #SCS_CUE_PL_READY, 56)
            Else
              audSetState(pAudPtr, #SCS_CUE_READY, 4)
            EndIf
          EndIf
        Else
          ; later file in playlist
          \nAudState = #SCS_CUE_PL_READY
          audSetState(pAudPtr, #SCS_CUE_PL_READY, 48)
        EndIf
      EndIf
      
      If (\nFileFormat = #SCS_FILEFORMAT_AUDIO) And (\bAudPlaceHolder = #False)
        ;{
        If gbUseBASS  ; BASS
          If \nFirstSoundingDev >= 0
            ; nChannel = \nBassChannel[\nFirstSoundingDev]
            nChannel = \nSourceChannel
            \sFileType = getFileInfo(nChannel, \sFileName, #True, pAudPtr)
            debugMsg(sProcName, "\sFileType=" + \sFileType)
            \nBassChans = GetChannels(nChannel)
            \nFileChannels = \nBassChans
            \nBassFreq = getFrequency(nChannel)
          EndIf
        Else  ; SM-S
          ; no action - getFileInfo() already called via GetInfoAboutFile() from openfileForSMS()
        EndIf
        debugMsg(sProcName, "calling setLinksOneAud(" + getAudLabel(pAudPtr) + ")")
        setLinksOneAud(pAudPtr)
        If gbUseSMS ; SM-S
          setSyncPChanListForAud(pAudPtr)
        EndIf
        If (\nAbsStartAt < \nFileDuration) And (\nAbsStartAt > 0) And (gbUseBASS)
          debugMsg(sProcName, "calling setAudChannelPositions(" + getAudLabel(pAudPtr) + ", " + ttszt(\nAbsStartAt) + ", #False, " + \qStartAtBytePos + ")")
          setAudChannelPositions(pAudPtr, \nAbsStartAt, #False, \qStartAtBytePos)
        EndIf
        
        debugMsg(sProcName, "calling setBassLoopStart(" + getAudLabel(pAudPtr) + ")")
        setBassLoopStart(pAudPtr)
        debugMsg(sProcName, "calling setBassLoopEnd(" + getAudLabel(pAudPtr) + ")")
        setBassLoopEnd(pAudPtr)
        If \bAudUseGaplessStream = #False
          debugMsg(sProcName, "calling setBassPlayEnd(" + getAudLabel(pAudPtr) + ")")
          setBassPlayEnd(pAudPtr)
        EndIf
        ;}
      ElseIf \bAudTypeA And \nFileFormat = #SCS_FILEFORMAT_VIDEO
        setLinksOneAud(pAudPtr)
        
      ElseIf \nFileFormat = #SCS_FILEFORMAT_PICTURE
        If Len(\sFileType) = 0
          \sFileType = getPictureInfoForAud(pAudPtr)
        EndIf
        
      EndIf
      
    Else
      Select \nFileFormat
        Case #SCS_FILEFORMAT_MIDI
          \nMidiPhysicalDevPtr = -1
        Case #SCS_FILEFORMAT_AUDIO
          For d = 0 To grLicInfo\nMaxAudDevPerAud
            If \sLogicalDev[d]
              \nBassDevice[d] = -1
            EndIf
          Next d
      EndSelect
      
      If bFileNotOpened
        If \nAudState <> #SCS_CUE_ERROR
          audSetState(pAudPtr, #SCS_CUE_NOT_LOADED, 49)
        EndIf
        
      Else
        debugMsg(sProcName, "\bInsufficientSMSPlaybacks=" + strB(\bInsufficientSMSPlaybacks) + ", bInsufficientSMSPlaybacksOK=" + strB(bInsufficientSMSPlaybacksOK))
        If (\bInsufficientSMSPlaybacks = #False) Or ((\bInsufficientSMSPlaybacks) And (bInsufficientSMSPlaybacksOK = #False))
          If \bInsufficientSMSPlaybacks
            audSetState(pAudPtr, #SCS_CUE_NOT_LOADED, 50)
          Else
            audSetState(pAudPtr, #SCS_CUE_ERROR, 51)
            If Len(\sErrorMsg) = 0
              If bDeviceNamed = #False
                \sErrorMsg = Lang("Errors", "NoAudioDevice")
              Else
                \sErrorMsg = Lang("Errors", "FileOpenFailure")
              EndIf
            EndIf
          EndIf
        EndIf
        debugMsg(sProcName, "\sFileName=" + GetFilePart(\sFileName) + ", \nFileFormat=" + decodeFileFormat(\nFileFormat))
        debugMsg(sProcName, "SCS_CUE_ERROR " + \sErrorMsg)
      EndIf
    EndIf
    debugMsg(sProcName, "\nAudState=" + decodeCueState(\nAudState) + ", \sErrorMsg=" + \sErrorMsg)
    
    If \nFileFormat = #SCS_FILEFORMAT_MIDI
      ;{
      d = 0
      \bCueVolManual[d] = #False
      \bCuePanManual[d] = #False
      \bCueLevelLC[d] = #False
      \bCuePanLC[d] = #False
      \bAffectedByLevelChange = #False
      \nLevelChangeSubPtr = -1
      \bIncDecLevelSet = #False
      \fBVLevel[d] = grLevels\fMaxBVLevel
      \fPan[d] = #SCS_PANCENTRE_SINGLE
      \fCueVolNow[d] = \fBVLevel[d]
      \fCueAltVolNow[d] = #SCS_MINVOLUME_SINGLE
      \fCueTotalVolNow[d] = \fCueVolNow[d]
      \fCuePanNow[d] = \fPan[d]
      ;}
    ElseIf \bAudTypeA
      ;{
      d = 0
      \bStopping[d] = #False
      \bAltStopping[d] = #False
      \bCueVolManual[d] = #False
      \bCuePanManual[d] = #False
      \bCueLevelLC[d] = #False
      \bCuePanLC[d] = #False
      \fBVLevel[d] = aSub(\nSubIndex)\fSubMastBVLevel[d] * \fPLRelLevel / 100.0
      \fPan[d] = aSub(\nSubIndex)\fPLPan[d]
      If ((aSub(\nSubIndex)\nPLFadeInTime > 0) And (\nPrevPlayIndex = -1)) Or (\nFadeInTime > 0)
        \fCueVolNow[d] = #SCS_MINVOLUME_SINGLE
      Else
        \fCueVolNow[d] = \fBVLevel[d]
        \fCueAltVolNow[d] = #SCS_MINVOLUME_SINGLE
        \fCueTotalVolNow[d] = \fCueVolNow[d]
      EndIf
      CompilerIf #cTraceCueTotalVolNow
        debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\fCueTotalVolNow[" + d + "]=" + traceLevel(\fCueTotalVolNow[d]))
      CompilerEndIf
      \fCuePanNow[d] = \fPan[d]
      debugMsg(sProcName, "Q=" + \sCue + ", \fBVLevel[" + d + "]=" + formatLevel(\fBVLevel[d]) + ", \fCueVolNow[" + d + "]=" + formatLevel(\fCueVolNow[d]))
      \bAffectedByLevelChange = #False
      \nLevelChangeSubPtr = -1
      \bIncDecLevelSet = #False
      ;}
    ElseIf \bAudTypeP
      ;{
      For d = 0 To grLicInfo\nMaxAudDevPerAud
        \bStopping[d] = #False
        \bAltStopping[d] = #False
        If Len(aSub(\nSubIndex)\sPLLogicalDev[d]) > 0
          \bCueVolManual[d] = #False
          \bCuePanManual[d] = #False
          \bCueLevelLC[d] = #False
          \bCuePanLC[d] = #False
          \fBVLevel[d] = aSub(\nSubIndex)\fSubMastBVLevel[d] * \fPLRelLevel / 100.0
          debugMsg(sProcName, "aSub(" + getSubLabel(\nSubIndex) + ")\fSubLevel(" + d + ")=" + formatLevel(aSub(\nSubIndex)\fSubMastBVLevel[d]) + ", \fPLRelLevel=" + Str(\fPLRelLevel))
          \fPan[d] = aSub(\nSubIndex)\fPLPan[d]
          If (aSub(\nSubIndex)\nPLFadeInTime > 0) Or (\nFadeInTime > 0)
            \fCueVolNow[d] = #SCS_MINVOLUME_SINGLE
          Else
            \fCueVolNow[d] = \fBVLevel[d]
          EndIf
          \fCueAltVolNow[d] = #SCS_MINVOLUME_SINGLE
          \fCueTotalVolNow[d] = \fCueVolNow[d]
          CompilerIf #cTraceCueTotalVolNow
            debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\fCueTotalVolNow[" + d + "]=" + traceLevel(\fCueTotalVolNow[d]))
          CompilerEndIf
          \bSetLevelsWhenPlayAud = #True
          debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\bSetLevelsWhenPlayAud=" + strB(\bSetLevelsWhenPlayAud))
          \fCuePanNow[d] = \fPan[d]
          debugMsg(sProcName, "Q=" + \sCue + ", \fBVLevel[" + d + "]=" + formatLevel(\fBVLevel[d]) + ", \fCueVolNow[" + d + "]=" + formatLevel(\fCueVolNow[d]))
        EndIf
      Next d
      \bAffectedByLevelChange = #False
      \nLevelChangeSubPtr = -1
      \bIncDecLevelSet = #False
      ;}
    Else
      ;{
      For d = 0 To grLicInfo\nMaxAudDevPerAud
        \bStopping[d] = #False
        \bAltStopping[d] = #False
        If \sLogicalDev[d]
          \bCueVolManual[d] = #False
          \bCuePanManual[d] = #False
          \bCueLevelLC[d] = #False
          \bCuePanLC[d] = #False
          If \nFadeInTime > 0
            \fCueVolNow[d] = #SCS_MINVOLUME_SINGLE
          Else
            \fCueVolNow[d] = \fBVLevel[d]
          EndIf
          \fCueAltVolNow[d] = #SCS_MINVOLUME_SINGLE
          \fCueTotalVolNow[d] = \fCueVolNow[d]
          CompilerIf #cTraceCueTotalVolNow
            debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\fCueTotalVolNow[" + d + "]=" + traceLevel(aAud(pAudPtr)\fCueTotalVolNow[d]))
          CompilerEndIf
          \fCuePanNow[d] = \fPan[d]
          debugMsg(sProcName, "Q=" + \sCue + ", \fBVLevel[" + d + "]=" + formatLevel(\fBVLevel[d]) + ", \fCueVolNow[" + d + "]=" + formatLevel(\fCueVolNow[d]))
        EndIf
      Next d
      \bAffectedByLevelChange = #False
      \nLevelChangeSubPtr = -1
      \bIncDecLevelSet = #False
      ;}
    EndIf
    
    \nRelFilePos = \nRelStartAt
    \nPlayingPos = grAudDef\nPlayingPos
    CompilerIf 1=1
      ; Changed 2Feb2022 11.9.0rc7
      \nCuePos = \nRelStartAt
      \nCuePosWhenLastChecked = \nCuePos
      \nCuePosAtFadeStart = grAudDef\nCuePosAtFadeStart
    CompilerElse
      \nCuePos = 0
      \nCuePosWhenLastChecked = 0
    CompilerEndIf
    \nRelPassStart = \nRelStartAt
    If \nMaxLoopInfo >= 0 ; \bContainsLoop
      \nRelPassEnd = \aLoopInfo(0)\nRelLoopEnd
    Else
      \nRelPassEnd = \nRelEndAt
    EndIf
    \nCuePosAtLoopStart = grAudDef\nCuePosAtLoopStart  ; added 14Oct2016 11.5.2.3 to prevent issue of loop being released immediately in the editor if the cue had completed in the main window
    debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nRelFilePos=" + \nRelFilePos + ", \nRelPassEnd=" + \nRelPassEnd + ", \nCuePos=" + \nCuePos + ", \nCuePosAtLoopStart=" + \nCuePosAtLoopStart)
    
    If \bInsufficientSMSPlaybacks = #False
      getFileDetail(pAudPtr)
      \sFileTitle = grFileInfo\sFileTitle
      
      ; 29Jul2019 11.8.1.3ad the following moved from earlier in this procedure because getFileDetail() may have found cue points that have now been added to the \aCueMarker() array
      If \bAudPlaceHolder = #False
        Select \nFileFormat
          Case #SCS_FILEFORMAT_AUDIO
            If \bAudUseGaplessStream = #False
              debugMsg(sProcName, "calling setBassMarkerPositions(" + getAudLabel(pAudPtr) + ")")
              setBassMarkerPositions(pAudPtr)
            EndIf
          Case #SCS_FILEFORMAT_VIDEO
            debugMsg(sProcName, "calling setTVGMarkerPositions(" + getAudLabel(pAudPtr) + ")")
            setTVGMarkerPositions(pAudPtr)
        EndSelect
      EndIf
      ; end 29Jul2019 11.8.1.3ad
      
      If pAudPtr >= 0
        debugMsg(sProcName, "calling setCueState(" + getCueLabel(\nCueIndex) + ")")
        setCueState(\nCueIndex)
        If (gbInitialising = #False) And (gbInPaste = #False) And (gbGridLoaded)
          If \bAudTypeF
            If aSub(\nSubIndex)\nPrevSubIndex = -1
              ; first sub for this cue
              If gnThreadNo = #SCS_THREAD_MAIN
                ; debugMsg(sProcName, "calling colorLine(" + getCueLabel(\nCueIndex) + ")")
                colorLine(\nCueIndex)
                nRow = aCue(\nCueIndex)\nGrdCuesRowNo
                If nRow >= 0
                  WMN_setGrdCuesCellValue(nRow, #SCS_GRDCUES_DU, timeToStringBWZ(\nCueDuration, \nCueDuration))
                  WMN_setGrdCuesCellValue(nRow, #SCS_GRDCUES_FT, \sFileType)
                EndIf
                updateGrid(\nCueIndex)
              Else
                samAddRequest(#SCS_SAM_LOAD_GRID_ROW, \nCueIndex)
              EndIf
            EndIf
          EndIf
          If inSaveSettings(\nSubIndex)
            debugMsg(sProcName, "calling removeFromSaveSettingsIfReqd(" + getSubLabel(\nSubIndex) + ")")
            removeFromSaveSettingsIfReqd(\nSubIndex)
            setSaveSettings()
          EndIf
        EndIf
        
        If (gbEditHasFocus) And (\bAudTypeF)
          If \nAudState <> #SCS_CUE_ERROR
            checkAudTimes(pAudPtr)
          EndIf
        EndIf
        
        If (gbEditing) And (gbInPaste = #False)
          gnRefreshCuePtr = \nCueIndex
          gnRefreshSubPtr = \nSubIndex
          gnRefreshAudPtr = pAudPtr
          gbCallRefreshDispPanel = #True
          debugMsg(sProcName, "gbCallRefreshDispPanel=" + strB(gbCallRefreshDispPanel) + ", gnRefreshCuePtr=" + getCueLabel(gnRefreshCuePtr) +
                              ", gnRefreshSubPtr=" + getSubLabel(gnRefreshSubPtr) + ", gnRefreshAudPtr=" + getAudLabel(gnRefreshAudPtr))
        EndIf
      EndIf
      
    EndIf
    
    omf_check_for_error:  ; label omf_check_for_error
    
    If gbUseBASS
      If \nFileFormat = #SCS_FILEFORMAT_AUDIO
        If \nFirstSoundingDev >= 0
          fCPU = BASS_GetCPU()
          debugMsg(sProcName, "\nAudState=" + decodeCueState(\nAudState) + ", \sDriver=" + \sDriver +
                              ", \nBassChannel(" + \nFirstSoundingDev + ")=" + decodeHandle(\nBassChannel[\nFirstSoundingDev]) +
                              ", CPU=" + StrF(fCPU, 3) + "%" + ", \fBVLevel[0]=" + formatLevel(\fBVLevel[0]))
        EndIf
      EndIf
    EndIf
    
    If \bInsufficientSMSPlaybacks = #False
      debugMsg(sProcName, "\nFileDataPtr=" + \nFileDataPtr + ", ArraySize(gaFileData)=" + ArraySize(gaFileData()))
      If \nFileDataPtr < 0
        If \nFileState = #SCS_FILESTATE_OPEN
          bFound = #False
          For f = 1 To gnLastFileData
            If gaFileData(f)\sFileName = \sFileName
              bFound = #True
              \nFileDataPtr = f
              Break
            EndIf
          Next f
          If bFound = #False
            rFileData = grFileDataDef
            rFileData\sFileName = \sFileName
            rFileData\sStoredFileName = \sStoredFileName
            rFileData\sFileModified = FormatDate(#SCS_CUE_FILE_DATE_FORMAT, GetFileDate(\sFileName, #PB_Date_Modified))
            rFileData\nFileDuration = \nFileDuration
            rFileData\sFileTitle = \sFileTitle
            rFileData\sFileType = \sFileType
            rFileData\nxFileChannels = \nBassChans
            If ArraySize(gaFileData()) <= gnLastFileData
              REDIM_ARRAY(gaFileData, gnLastFileData+20, grFileDataDef, "gaFileData()")
              ; debugMsg(sProcName, "ArraySize(gaFileData())=" + ArraySize(gaFileData()))
            EndIf
            gnLastFileData + 1
            gaFileData(gnLastFileData) = rFileData
            \nFileDataPtr = gnLastFileData
          EndIf
        EndIf
      EndIf
      
      If \nFileDataPtr >= 0
        ; If gaFileData(\nFileDataPtr)\sFileType = grAudDef\sFileType ; Commented out this test 2Dec2023
          gaFileData(\nFileDataPtr)\nFileDuration = \nFileDuration
          gaFileData(\nFileDataPtr)\sFileTitle = \sFileTitle
          gaFileData(\nFileDataPtr)\sFileType = \sFileType
          gaFileData(\nFileDataPtr)\nxFileChannels = \nFileChannels
          ; Added 2Dec2023
          gaFileData(\nFileDataPtr)\sFileName = \sFileName
          gaFileData(\nFileDataPtr)\sStoredFileName = \sStoredFileName
          debugMsg(sProcName, "gaFileData(" + \nFileDataPtr + ")\sStoredFileName=" + gaFileData(\nFileDataPtr)\sStoredFileName)
          ; End added 2Dec2023
        ; EndIf
        If (\nFileFormat = #SCS_FILEFORMAT_PICTURE) Or (\nFileFormat = #SCS_FILEFORMAT_VIDEO)
          If \nSourceWidth <> grAudDef\nSourceWidth
            gaFileData(\nFileDataPtr)\nSourceWidth = \nSourceWidth
            gaFileData(\nFileDataPtr)\nSourceHeight = \nSourceHeight
            ; debugMsg(sProcName, "gaFileData(" + \nFileDataPtr + ")\nSourceWidth=" + gaFileData(\nFileDataPtr)\nSourceWidth + ", \nSourceHeight=" + gaFileData(\nFileDataPtr)\nSourceHeight)
          EndIf
        EndIf
      EndIf
    EndIf
    
    ; debugMsg(sProcName, "ending")
    If \sMidiAlias
      debugMsg(sProcName, "\sMidiAlias=" + \sMidiAlias)
    EndIf
    If \nSourceChannel <> 0
      debugMsg(sProcName, "\nSourceChannel=" + decodeHandle(\nSourceChannel))
    EndIf
    For d = \nFirstDev To \nLastDev
      If \nBassChannel[d] <> 0
        debugMsg(sProcName, "\nBassChannel[" + d + "]=" + decodeHandle(\nBassChannel[d]))
      EndIf
    Next d
    
  EndWith
  
  If grMMedia\nMaxChannelUpdateIndex >= 0
    doChannelUpdates()
  EndIf
  
  ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\bBlending=" + strB(aAud(pAudPtr)\bBlending))
  
  ; debugMsg(sProcName, "(z1) GetActiveWindow()=" + decodeWindow(GetActiveWindow()))
  If GetActiveWindow() < 0
    If IsWindow(nActiveWindow)
      ; debugMsg(sProcName, "calling SetActiveWindow(" + decodeWindow(nActiveWindow) + ")")
      SAW(nActiveWindow)
    EndIf
  EndIf
  ; debugMsg(sProcName, "(z2) GetActiveWindow()=" + decodeWindow(GetActiveWindow()))
  
  UnlockCueListMutex()
  
  If aAud(pAudPtr)\bInsufficientSMSPlaybacks
    debugMsg3(sProcName, #SCS_END + ", returning #False because aAud(" + getAudLabel(pAudPtr) + ")\bInsufficientSMSPlaybacks=" + strB(aAud(pAudPtr)\bInsufficientSMSPlaybacks))
    
  ElseIf (aAud(pAudPtr)\bUsingMemoryImage = #False) And (aAud(pAudPtr)\bTVG_OpenPlayerFailed)
    debugMsg3(sProcName, #SCS_END + ", returning #False because aAud(" + getAudLabel(pAudPtr) + ")\bTVG_OpenPlayerFailed=" + strB(aAud(pAudPtr)\bTVG_OpenPlayerFailed))
    ProcedureReturn #False
    
  ElseIf bFileNameTooLong
    debugMsg3(sProcName, #SCS_END + ", returning #False because bFileNameTooLong=" + strB(bFileNameTooLong))
    ProcedureReturn #False
    
  Else
    debugMsg3(sProcName, #SCS_END + ", returning #True")
    ProcedureReturn #True
    
  EndIf
  
EndProcedure

Procedure pauseAllEarlierCues(pCuePtr, nSFRCueType=#SCS_SFR_CUE_ALL_ANY, nExcludeCuePtr=-99, bExcludeSFRCueList=#False, bHibernate=#False)
  PROCNAMECQ(pCuePtr)
  Protected i, n
  Protected nItemState, bWantThisCue
  Protected bThisCueChanged, bAnyCueChanged
  Protected bAnyCues, bPlayingCuesOnly, bAudioOnly, bVideoOnly, bLiveOnly
  
  debugMsg(sProcName, #SCS_START + ", nSFRCueType=" + decodeSFRCueType(nSFRCueType) +
                      ", nExcludeCuePtr=" + getCueLabel(nExcludeCuePtr) + ", bExcludeSFRCueList=" + strB(bExcludeSFRCueList) + ", bHibernate=" + strB(bHibernate))
  
  setProcSFRFlags(nSFRCueType)  ; macro sets bPlayingCuesOnly, bAudioOnly and bVideoOnly, based on nSRCueType
  debugMsg(sProcName, "bAnyCues=" + strB(bAnyCues) + ", bPlayingCuesOnly=" + strB(bPlayingCuesOnly) + ", bAudioOnly=" + strB(bAudioOnly) + ", bVideoOnly=" + strB(bVideoOnly) + ", bLiveOnly=" + strB(bLiveOnly))
  
  For i = 1 To pCuePtr - 1
    bWantThisCue = #False
    ; debugMsg(sProcName, "aCue(" + getCueLabel(i) + ")\nCueState=" + decodeCueState(aCue(i)\nCueState))
    
    If i <> nExcludeCuePtr
      setWantThisCue(i) ; sets bWantThisCue
    EndIf
    nItemState = aCue(i)\nCueState
    debugMsg(sProcName, "aCue(" + getCueLabel(i) + ")\nCueState=" + decodeCueState(aCue(i)\nCueState) + ", bWantThisCue=" + strB(bWantThisCue))
    
;     If (nItemState >= #SCS_CUE_COUNTDOWN_TO_START) And (nItemState <= #SCS_CUE_FADING_OUT)
;       If ((bHibernate = #False) And (nItemState <> #SCS_CUE_PAUSED)) Or ((bHibernate) And (nItemState <> #SCS_CUE_HIBERNATING))
;         bWantThisCue = #True
;       EndIf
;     EndIf
; above changed to the following 04Jul2015 11.4.0.1 following bug report from 'SoundBloke', 21Jun2015
    ; (also added parameter nExcludeCuePtr)
    If bWantThisCue
      If (bHibernate) And (nItemState = #SCS_CUE_HIBERNATING)
        bWantThisCue = #False
      ElseIf (bHibernate = #False) And (nItemState = #SCS_CUE_PAUSED)
        bWantThisCue = #False
      EndIf
    EndIf
    
    If bExcludeSFRCueList
      For n = 0 To grMMedia\nSFRCueMax
        If grMMedia\anSFRCuePtr[n] = i
          bWantThisCue = #False
          Break
        EndIf
      Next n
    EndIf
    
    If bWantThisCue
      debugMsg(sProcName, "calling pauseCue(" + getCueLabel(i) + ", " + strB(bHibernate) + ")")
      pauseCue(i, bHibernate)
      bThisCueChanged = #True
    EndIf
    
    If bThisCueChanged
      bAnyCueChanged = #True
      setCueState(i, #True)
      updateGrid(i)
    EndIf
  Next i
  
  If bAnyCueChanged
    gnCallOpenNextCues = 1
    debugMsg(sProcName, "gnCallOpenNextCues=" + gnCallOpenNextCues)
    debugMsg(sProcName, "setting gbCallLoadDispPanels=#True")
    gbCallLoadDispPanels = #True
    debugMsg(sProcName, "calling setCueToGo()")
    setCueToGo()
    gbCallSetNavigateButtons = #True
  EndIf
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure              

Procedure pauseAud(pAudPtr, bHibernate = #False)
  PROCNAMECA(pAudPtr)
  Protected h, nTmpAudPtr, nTmpAudState
  Protected bSyncPauseIssued
  Protected nSubPtr, j
  Protected nVideoAudioDevPtr
  
  debugMsg(sProcName, #SCS_START)
  logKeyEvent("Pause Aud " + getAudLabel(pAudPtr))
  
  If gbUseSMS
    With aAud(pAudPtr)
      debugMsg(sProcName, "\nFileFormat=" + decodeFileFormat(\nFileFormat))
      Select \nFileFormat
        Case #SCS_FILEFORMAT_AUDIO
          debugMsg(sProcName, "\bSyncPChanListPlaying=" + strB(\bSyncPChanListPlaying) + ", \sSyncPChanList=" + \sSyncPChanList)
          If \bSyncPChanListPlaying
            If \sSyncPChanList
              sendSMSCommand("pause " + \sSyncPChanList)
              bSyncPauseIssued = #True
            EndIf
          EndIf
        Case #SCS_FILEFORMAT_LIVE_INPUT
          debugMsg(sProcName, "\sSyncChanList=" + \sSyncXChanList)
          If \sSyncXChanList
            sendSMSCommand("set chan " + \sSyncXChanList + " mute on")
            bSyncPauseIssued = #True
          EndIf
      EndSelect
    EndWith
  EndIf
  
  For h = 0 To aAud(pAudPtr)\nMaxAudSetPtr2
    nTmpAudPtr = gaAudSet(pAudPtr, h)
    If nTmpAudPtr > 0
      With aAud(nTmpAudPtr)
        nTmpAudState = \nAudState
        debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nAudState=" + decodeCueState(nTmpAudState))
        
        If nTmpAudState = #SCS_CUE_COUNTDOWN_TO_START
          If aCue(\nCueIndex)\bCueCountDownPaused = #False
            aCue(\nCueIndex)\bCueCountDownPaused = #True
            aCue(\nCueIndex)\qTimeCueCountDownPaused = ElapsedMilliseconds()
          EndIf
          
        ElseIf nTmpAudState = #SCS_CUE_SUB_COUNTDOWN_TO_START
          If aSub(\nSubIndex)\bSubCountDownPaused = #False
            aSub(\nSubIndex)\bSubCountDownPaused = #True
            aSub(\nSubIndex)\qTimeSubCountDownPaused = ElapsedMilliseconds()
          EndIf
          
        ElseIf (nTmpAudState >= #SCS_CUE_FADING_IN) And (nTmpAudState <= #SCS_CUE_FADING_OUT)
          If ((bHibernate = #False) And (nTmpAudState <> #SCS_CUE_PAUSED)) Or ((bHibernate) And (nTmpAudState <> #SCS_CUE_HIBERNATING))
            If bSyncPauseIssued = #False
              debugMsg(sProcName, "calling pauseAudChannels(" + getAudLabel(nTmpAudPtr) + ")")
              pauseAudChannels(nTmpAudPtr)
            EndIf
            \qTimePauseStarted = gqTimeNow
            \nPriorTimeOnPause = \nTotalTimeOnPause
            \nTotalTimeOnPause = 0
            \nPrepauseAudState = nTmpAudState
            If (bHibernate) And (aSub(\nSubIndex)\nCurrPlayIndex = nTmpAudPtr)
              audSetState(nTmpAudPtr, #SCS_CUE_HIBERNATING, 52)
            Else
              audSetState(nTmpAudPtr, #SCS_CUE_PAUSED, 53)
            EndIf
            \nCurrFadeInTime = \nFadeInTime
            \nCurrFadeOutTime = \nFadeOutTime
            debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nAudState=" + decodeCueState(\nAudState) + ", \nCurrFadeInTime=" + \nCurrFadeInTime + ", \nCurrFadeOutTime=" + \nCurrFadeOutTime)
          EndIf
          
        ElseIf nTmpAudState = #SCS_CUE_PL_COUNTDOWN_TO_START
          If bSyncPauseIssued = #False
            debugMsg(sProcName, "calling pauseAudChannels(" + getAudLabel(nTmpAudPtr) + ")")
            pauseAudChannels(nTmpAudPtr)
          EndIf
          \qTimePauseStarted = gqTimeNow
          \nPriorTimeOnPause = \nTotalTimeOnPause
          \nTotalTimeOnPause = 0
          \nPrepauseAudState = #SCS_CUE_PL_READY
          If (bHibernate)
            audSetState(nTmpAudPtr, #SCS_CUE_HIBERNATING, 54)
          Else
            audSetState(nTmpAudPtr, #SCS_CUE_PAUSED, 55)
          EndIf
          \nCurrFadeInTime = \nFadeInTime
          \nCurrFadeOutTime = \nFadeOutTime
          debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nAudState=" + decodeCueState(\nAudState) + ", \nCurrFadeInTime=" + \nCurrFadeInTime + ", \nCurrFadeOutTime=" + \nCurrFadeOutTime)
          ; do NOT reset \nFadeInTimeFromSFR or \nFadeOutTimeFromSFR if 'countdown to start'
          
        EndIf
        
      EndWith
    EndIf
  Next h
  
  nSubPtr = aAud(nTmpAudPtr)\nSubIndex
  If aSub(nSubPtr)\bStartedInEditor = #False
    If aSub(nSubPtr)\bSubTypeAorF
      If aSub(nSubPtr)\nAFLinkedToMTCSubPtr >= 0
        j = aSub(nSubPtr)\nAFLinkedToMTCSubPtr
        If aSub(j)\bSubTypeU
          If aSub(j)\nMTCLinkedToAFSubPtr = nSubPtr And aSub(j)\bSubEnabled
            debugMsg(sProcName, "calling pauseSub(" + buildSubLabel(j) + ", " + strB(bHibernate) + ")")
            pauseSub(j, bHibernate)
          EndIf
        EndIf ; EndIf aSub(j)\bSubTypeU
      EndIf ; EndIf aSub(nSubPtr)\nAFLinkedToMTCSubPtr >= 0
    EndIf ; EndIf aSub(nSubPtr)\bSubTypeAorF
  EndIf ; EndIf aSub(nSubPtr)\bStartedInEditor = #False
  
  For h = 0 To aAud(pAudPtr)\nMaxAudSetPtr2
    nTmpAudPtr = gaAudSet(pAudPtr, h)
    If nTmpAudPtr > 0
      With aAud(nTmpAudPtr)
        setCueState(\nCueIndex)
        updateGrid(\nCueIndex)
        aCue(\nCueIndex)\nCuePanelUpdateFlags | #SCS_CUEPNL_PROGRESS | #SCS_CUEPNL_TRANSPORT
        debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\nCuePanelUpdateFlags=" + Str(aCue(\nCueIndex)\nCuePanelUpdateFlags))
      EndWith
    EndIf
  Next h
  
  ; Added 26Feb2025 11.10.7-b06 to ensure VU meter for video is cleared (email from Llus Vilarrasa)
  If aAud(pAudPtr)\bAudTypeA
    nSubPtr = aAud(pAudPtr)\nSubIndex
    nVideoAudioDevPtr = aSub(nSubPtr)\nVideoAudioDevPtr
    If nVideoAudioDevPtr >= 0
      If aSub(nSubPtr)\bMuteVideoAudio = #False
        With grMaps\aDev(nVideoAudioDevPtr)
          \dAudioPeakLeftPercent = 0.0
          \dAudioPeakRightPercent = 0.0
        EndWith
      EndIf ; EndIf aSub(nSubPtr)\bMuteVideoAudio = #False
    EndIf ; EndIf nVideoAudioDevPtr >= 0
  EndIf
  ; End added 26Feb2025 11.10.7-b06

  THR_resumeAThread(#SCS_THREAD_CONTROL)
  
  If gbUseBASSMixer = #False
    samAddRequest(#SCS_SAM_BUILD_DEV_CHANNEL_LIST)
  EndIf
  
  debugMsg(sProcName, #SCS_END)
EndProcedure

Procedure pauseAudChannels(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nBassResult.l, d, d2
  Protected h, nTmpAudPtr
  Protected nMixerStreamHandle.l, nFlags.l
  Protected nBassError.l
  
  debugMsg(sProcName, #SCS_START)
  
  With aAud(pAudPtr)
    
    Select \nFileFormat
      Case #SCS_FILEFORMAT_MIDI
        pauseMidiFile(pAudPtr)
        
      Case #SCS_FILEFORMAT_VIDEO, #SCS_FILEFORMAT_PICTURE
        debugMsg(sProcName, "calling pauseVideo")
        pauseVideo(pAudPtr)
        
      Case #SCS_FILEFORMAT_AUDIO
        If gbUseBASS  ; BASS
          d = \nFirstSoundingDev
          If d >= 0
            If \nBassChannel[d] <> 0
              If gbUseBASSMixer
                For d2 = \nFirstSoundingDev To \nLastSoundingDev
                  If \nBassChannel[d2] <> 0
                    nBassResult = BASS_Mixer_ChannelFlags(\nBassChannel[d2], #BASS_MIXER_CHAN_PAUSE, #BASS_MIXER_CHAN_PAUSE) ; set the pause flag
                    debugMsg3(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(\nBassChannel[d2]) + ", BASS_MIXER_CHAN_PAUSE, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
                  EndIf
                  If \nBassAltChannel[d2] <> 0
                    nBassResult = BASS_Mixer_ChannelFlags(\nBassAltChannel[d2], #BASS_MIXER_CHAN_PAUSE, #BASS_MIXER_CHAN_PAUSE) ; set the pause flag
                    debugMsg3(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(\nBassAltChannel[d2]) + ", BASS_MIXER_CHAN_PAUSE, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
                  EndIf
                Next d2
              Else
                nBassResult = BASS_ChannelIsActive(\nBassChannel[d])
                debugMsg2(sProcName, "BASS_ChannelIsActive(" + decodeHandle(\nBassChannel[d]) + ")", nBassResult)
                nBassResult = BASS_ChannelPause(\nBassChannel[d])
                debugMsg2(sProcName, "BASS_ChannelPause(" + decodeHandle(\nBassChannel[d]) + ")", nBassResult)
                If nBassResult = #BASSFALSE
                  nBassError = BASS_ErrorGetCode()
                  debugMsg3(sProcName, "nBassError=" + getBassErrorDesc(nBassError))
                  If nBassError = #BASS_ERROR_NOPLAY
                    ; no action
                  ElseIf nBassError = #BASS_ERROR_ALREADY
                    ; no action (already paused)
                  ElseIf nBassError = #BASS_ERROR_DECODE
                    ; Added 17Feb2022 11.9.1aa following email from Michel Winogradoff
                    ; no action
                    ; This BASS error can occur if the user has created a tempo etc stream but the BASS mixer is not (yet) enabled, and the user has started 'playing' the cue and then clicks Pause or Rewind.
                    ; Note that they will already have seen the message:
                    ;    To process Playback Rate, Tempo or Pitch, please save your changes and then close and re-open your cue file.
                    ;    Until you do that, playing an Audio File cue affected by Playback Rate, Tempo or Pitch may not sound at all.
                  Else
                    Error_(sProcName, "Pause " + \sCue + " failed")
                    ProcedureReturn
                  EndIf
                EndIf
                If \nBassAltChannel[d2] <> 0
                  nBassResult = BASS_ChannelPause(\nBassAltChannel[d])
                  debugMsg2(sProcName, "BASS_ChannelPause(" + decodeHandle(\nBassAltChannel[d]) + ")", nBassResult)
                EndIf
                nBassResult = BASS_ChannelIsActive(\nBassChannel[d])
                debugMsg2(sProcName, "BASS_ChannelIsActive(" + decodeHandle(\nBassChannel[d]) + ")", nBassResult)
              EndIf
            EndIf
          EndIf
          
        Else  ; SM-S
          ; do nothing
          
        EndIf
        
        If (\nAudState = #SCS_CUE_FADING_IN) Or (\nAudState = #SCS_CUE_FADING_OUT)
          stopChannelSlides(pAudPtr)
        EndIf
        
    EndSelect
    
  EndWith
EndProcedure

Procedure pauseCue(pCuePtr, bHibernate=#False)
  PROCNAMECQ(pCuePtr)
  Protected j

  debugMsg(sProcName, #SCS_START)
  logKeyEvent("Pause Cue " + getCueLabel(pCuePtr))
  
  If pCuePtr >= 0
    With aCue(pCuePtr)
      j = \nFirstSubIndex
      While j >= 0
        If aSub(j)\bSubEnabled
          pauseSub(j, bHibernate)
          If aSub(j)\bSubTypeAorP
            aSub(j)\bSFRFadeInOnResume = #False
            debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\bSFRFadeInOnResume=" + strB(aSub(j)\bSFRFadeInOnResume))
            aSub(j)\nPLCurrFadeInTime = 0
          EndIf
        EndIf
        j = aSub(j)\nNextSubIndex
      Wend
;       If \nCueState = #SCS_CUE_COUNTDOWN_TO_START ; commented out 1Aug2017 11.6.3ac
        If \bCueCountDownPaused = #False
          \bCueCountDownPaused = #True
          \qTimeCueCountDownPaused = ElapsedMilliseconds()
        EndIf
;       EndIf ; commented out 1Aug2017 11.6.3ac
;       \bCueCountDownPaused = #True ; commented out 1Aug2017 11.6.3ac
      \nCuePanelUpdateFlags | #SCS_CUEPNL_TRANSPORT | #SCS_CUEPNL_PROGRESS
      debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\nCuePanelUpdateFlags=" + Str(aCue(pCuePtr)\nCuePanelUpdateFlags))
    EndWith
  EndIf

EndProcedure

Procedure resumeCue(pCuePtr)
  PROCNAMECQ(pCuePtr)
  Protected j
  
  debugMsg(sProcName, #SCS_START)
  logKeyEvent("Resume Cue " + getCueLabel(pCuePtr))
  
  If pCuePtr >= 0
    With aCue(pCuePtr)
      \bCueEnded = #False
      debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\bCueEnded=" + strB(\bCueEnded))
      If \bCueCountDownPaused
        resetCueTimeToStart(pCuePtr)
        \bCueCountDownPaused = #False
      EndIf
      j = \nFirstSubIndex
      While j >= 0
        If aSub(j)\bSubEnabled
          resumeSub(j)
        EndIf
        j = aSub(j)\nNextSubIndex
      Wend
      \nCuePanelUpdateFlags | #SCS_CUEPNL_TRANSPORT | #SCS_CUEPNL_PROGRESS
      debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\nCuePanelUpdateFlags=" + Str(aCue(pCuePtr)\nCuePanelUpdateFlags))
    EndWith
  EndIf
  
EndProcedure

Procedure PauseOrResumeCue(pCuePtr)
  PROCNAMECQ(pCuePtr)
  Protected bCountDownPaused
  Protected j
  
  debugMsg(sProcName, #SCS_START)
  
  If pCuePtr >= 0
    With aCue(pCuePtr)
      If \bCueCountDownPaused
        bCountDownPaused = #True
      Else
        j = \nFirstSubIndex
        While j >= 0
          If aSub(j)\bSubCountDownPaused And aSub(j)\bSubEnabled
            bCountDownPaused = #True
            Break
          EndIf
          j = aSub(j)\nNextSubIndex
        Wend
      EndIf
      debugMsg(sProcName, "\nCueState=" + decodeCueState(\nCueState) + ", bCountDownPaused=" + strB(bCountDownPaused))
      If \nCueState = #SCS_CUE_PAUSED Or bCountDownPaused
        resumeCue(pCuePtr)
      Else
        pauseCue(pCuePtr)
      EndIf
    EndWith
    
  EndIf
  
  SAG(-1)

EndProcedure

Procedure pauseMidiFile(pAudPtr)
  PROCNAMEC()
  Protected nErrCode.l
  Protected sMciString.s
  Protected bDummyDev
  
  ; warning! all mciSendString calls must be from the same thread or mciSendString returns error 263 (not a registered device), so use main thread
  ASSERT_THREAD(#SCS_THREAD_MAIN)
  
  With aAud(pAudPtr)
    bDummyDev = gaMidiOutDevice(\nMidiPhysicalDevPtr)\bDummy
    debugMsg(sProcName, "gaMidiOutDevice(" + \nMidiPhysicalDevPtr + ")\bDummy=" + strB(gaMidiOutDevice(\nMidiPhysicalDevPtr)\bDummy) + ", bDummyDev=" + strB(bDummyDev))
    If bDummyDev = #False
      sMciString = "pause " + \sMidiAlias
      nErrCode = mciSendString_(sMciString, #Null, 0, #Null)
      debugMsg2(sProcName, "mciSendString_(" + sMciString + ", #Null, 0, #Null)", nErrCode)
      If nErrCode <> 0
        displayMidiError(nErrCode, sMciString, sProcName)
        ProcedureReturn
      EndIf
    EndIf
  EndWith

EndProcedure

Procedure pauseSub(pSubPtr, bHibernate=#False)
  PROCNAMECS(pSubPtr)
  Protected k
  Protected j, nPrevSubState
  
  debugMsg(sProcName, #SCS_START)
  logKeyEvent("Pause Sub " + getSubLabel(pSubPtr))
  
  If pSubPtr >= 0
    With aSub(pSubPtr)
      Select \nSubState
        Case #SCS_CUE_COUNTDOWN_TO_START, #SCS_CUE_SUB_COUNTDOWN_TO_START
          If \bSubCountDownPaused = #False
            resetSubTimeToStart(pSubPtr)
            \bSubCountDownPaused = #True
            \qTimeSubCountDownPaused = ElapsedMilliseconds()
          EndIf
          
        Case #SCS_CUE_FADING_IN To #SCS_CUE_FADING_OUT
          nPrevSubState = \nSubState
          \bFadingPreHibernating = #False
          If \bSubTypeAorF Or \bSubTypeP
            k = \nFirstPlayIndex
            While k >= 0
              If bHibernate
                If (aAud(k)\nAudState >= #SCS_CUE_FADING_IN) And (aAud(k)\nAudState <= #SCS_CUE_FADING_OUT)
                  If k = \nCurrPlayIndex
                    debugMsg(sProcName, "calling pauseAud(" + getAudLabel(k) + ")")
                    pauseAud(k, bHibernate)
                  Else
                    stopAud(k)
                  EndIf
                ElseIf aAud(k)\nAudState = #SCS_CUE_PL_COUNTDOWN_TO_START
                  debugMsg(sProcName, "calling pauseAud(" + getAudLabel(k) + ")")
                  pauseAud(k, bHibernate)
                EndIf
              Else
                debugMsg(sProcName, "calling pauseAud(" + getAudLabel(k) + ")")
                pauseAud(k, bHibernate)
              EndIf
              k = aAud(k)\nNextPlayIndex
            Wend
          ElseIf \bSubTypeE Or \bSubTypeK Or \bSubTypeM Or \bSubTypeU
            If nPrevSubState <> #SCS_CUE_PAUSED
              ; see also similar code to the following in setCueState() when \nSubState is being set to #SCS_CUE_PAUSED
              \nSubPrepauseSubState = \nSubState
              \nSubState = #SCS_CUE_PAUSED
              \qSubTimePauseStarted = ElapsedMilliseconds()
              \nSubPriorTimeOnPause = \nSubTotalTimeOnPause
              \nSubTotalTimeOnPause = 0
              If \bSubTypeU
                pauseTimeCode(pSubPtr)
              EndIf
              If gbInPauseAll
                \bSubGloballyPaused = #True
                \qSubTimePauseStarted = gqGlobalPauseTimeStarted
                debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\bSubGloballyPaused=" + strB(\bSubGloballyPaused) + ", \qSubTimePauseStarted=" + traceTime(\qSubTimePauseStarted))
              EndIf
            EndIf
          EndIf
          
          aCue(\nCueIndex)\nCuePanelUpdateFlags | #SCS_CUEPNL_TRANSPORT | #SCS_CUEPNL_PROGRESS
          debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\nCuePanelUpdateFlags=" + Str(aCue(\nCueIndex)\nCuePanelUpdateFlags))
          
          If aSub(pSubPtr)\bStartedInEditor = #False
            If aSub(pSubPtr)\bSubTypeF
              If aSub(pSubPtr)\nAFLinkedToMTCSubPtr >= 0
                j = aSub(pSubPtr)\nAFLinkedToMTCSubPtr
                If aSub(j)\bSubTypeU
                  If aSub(j)\nMTCLinkedToAFSubPtr = pSubPtr And aSub(j)\bSubEnabled
                    debugMsg(sProcName, "calling pauseSub(" + buildSubLabel(j) + ", " + strB(bHibernate) + ")")
                    pauseSub(j, bHibernate)
                  EndIf
                EndIf ; EndIf aSub(j)\bSubTypeU
              EndIf   ; EndIf aSub(pSubPtr)\nAFLinkedToMTCSubPtr >= 0
            EndIf     ; EndIf aSub(pSubPtr)\bSubTypeF
          EndIf       ; EndIf aSub(pSubPtr)\bStartedInEditor = #False
          
      EndSelect
      
    EndWith
  EndIf

EndProcedure

Procedure resumeSub(pSubPtr)
  PROCNAMECS(pSubPtr)
  Protected j, k
  Protected qTimeNow.q
  Protected bSetSync, nMTCSubPtr, bResumeAudioNow, bResumeMTCNow, nLinkedSubPtr, nLinkedAudPtr
  
  debugMsg(sProcName, #SCS_START)
  logKeyEvent("Resume Sub " + getSubLabel(pSubPtr))
  
  If pSubPtr >= 0
    qTimeNow = ElapsedMilliseconds()
    With aSub(pSubPtr)
      Select \nSubState
        Case #SCS_CUE_COUNTDOWN_TO_START, #SCS_CUE_SUB_COUNTDOWN_TO_START
          If \bSubCountDownPaused
            resetSubTimeToStart(pSubPtr)
            \bSubCountDownPaused = #False
          EndIf
          
        Case #SCS_CUE_FADING_IN To #SCS_CUE_FADING_OUT
          If \bSubTypeF ; bSubTypeF
            k = \nFirstPlayIndex
            If k >= 0
              bResumeAudioNow = #True
              If aSub(pSubPtr)\bStartedInEditor = #False
                nMTCSubPtr = \nAFLinkedToMTCSubPtr
                If nMTCSubPtr >= 0
                  bResumeAudioNow = #False
                  If aSub(nMTCSubPtr)\nSubState >= #SCS_CUE_FADING_IN And aSub(nMTCSubPtr)\nSubState <= #SCS_CUE_FADING_OUT And aSub(nMTCSubPtr)\nSubState <> #SCS_CUE_PAUSED And aSub(nMTCSubPtr)\nSubState <> #SCS_CUE_HIBERNATING
                    debugMsg(sProcName, "calling MTC_playOrResumeMTCAndLinkedAud(" + getSubLabel(pSubPtr) + ", #False, #True)")
                    MTC_playOrResumeMTCAndLinkedAud(pSubPtr, #False, #True)
                  EndIf
                EndIf
              EndIf
              If bResumeAudioNow
                debugMsg(sProcName, "calling resumeAud(" + getAudLabel(k) + ")")
                resumeAud(k)
              EndIf
            EndIf ; EndIf k >= 0
            
          ElseIf \bSubTypeAorP  ; bSubTypeA, bSubTypeP
            k = \nFirstPlayIndex
            While k >= 0
              If aAud(k)\nAudState = #SCS_CUE_PAUSED ; check individual nAudState because AorP can have multiple aud's per sub, so only the currently 'paused' aud(s) need to be resumed
                resumeAud(k)
              EndIf
              k = aAud(k)\nNextPlayIndex
            Wend
            
          ElseIf \bSubTypeE ; bSubTypeE
            \nSubState = #SCS_CUE_PLAYING
            \qTimeSubRestarted = qTimeNow
            setCueState(\nCueIndex)
            
          ElseIf \bSubTypeK ; bSubTypeK
            \nSubState = #SCS_CUE_PLAYING
            \qTimeSubRestarted = qTimeNow
            setCueState(\nCueIndex)
            
          ElseIf \bSubTypeM ; bSubTypeM
            \nSubState = #SCS_CUE_PLAYING
            \qTimeSubRestarted = qTimeNow
            setCueState(\nCueIndex)
            
          ElseIf \bSubTypeU ; bSubTypeU
            Select \nMTCType
              Case #SCS_MTC_TYPE_LTC
                resumeTimeCode(pSubPtr)
              Case #SCS_MTC_TYPE_MTC
                debugMsg(sProcName, "\nSubPosition=" + \nSubPosition + ", \nMTCPreRoll=" + \nMTCPreRoll)
                bResumeMTCNow = #True
                If gbUseSMS = #False ; Test added 17Aug2021 11.8.5.1 to bypass the following when using SM-S
                  If \bStartedInEditor = #False
                    debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\nMTCLinkedToAFSubPtr=" + getSubLabel(\nMTCLinkedToAFSubPtr))
                    nLinkedSubPtr = \nMTCLinkedToAFSubPtr
                    If nLinkedSubPtr >= 0
                      nLinkedAudPtr = aSub(nLinkedSubPtr)\nFirstAudIndex
                      If nLinkedAudPtr >= 0
                        bResumeMTCNow = #False
                        debugMsg(sProcName, "aAud(" + getAudLabel(nLinkedAudPtr) + ")\nAudState=" + decodeCueState(aAud(nLinkedAudPtr)\nAudState))
                        If aAud(nLinkedAudPtr)\nAudState >= #SCS_CUE_FADING_IN And aAud(nLinkedAudPtr)\nAudState <= #SCS_CUE_FADING_OUT And aAud(nLinkedAudPtr)\nAudState <> #SCS_CUE_PAUSED And aAud(nLinkedAudPtr)\nAudState <> #SCS_CUE_HIBERNATING
                          debugMsg(sProcName, "calling MTC_playOrResumeMTCAndLinkedAud(" + getSubLabel(pSubPtr) + ", #False, #True)")
                          MTC_playOrResumeMTCAndLinkedAud(pSubPtr, #False, #True)
                        EndIf
                      EndIf
                    EndIf
                  EndIf
                EndIf
                If bResumeMTCNow
                  debugMsg(sProcName, "calling reposTimeCode(" + getSubLabel(pSubPtr) + ", " + ttszt(\nSubPosition) + ")")
                  reposTimeCode(pSubPtr, \nSubPosition)
                  If \nSubPosition < \nMTCPreRoll
                    grMTCSendControl\nMTCThreadRequest | #SCS_MTC_THR_RESTART_MTC
                  Else
                    grMTCSendControl\nMTCThreadRequest | #SCS_MTC_THR_RESUME_MTC
                  EndIf
                  debugMsg(sProcName, "grMTCSendControl\nMTCThreadRequest=" + grMTCSendControl\nMTCThreadRequest)
                  debugMsg(sProcName, "calling THR_createOrResumeAThread(#SCS_THREAD_MTC_CUES)")
                  THR_createOrResumeAThread(#SCS_THREAD_MTC_CUES)
                EndIf
            EndSelect
            \nSubState = #SCS_CUE_PLAYING
            \qTimeSubRestarted = qTimeNow
            setCueState(\nCueIndex)
            
          EndIf
          
          aCue(\nCueIndex)\nCuePanelUpdateFlags | #SCS_CUEPNL_TRANSPORT | #SCS_CUEPNL_PROGRESS
          ; debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\nCuePanelUpdateFlags=" + Str(aCue(\nCueIndex)\nCuePanelUpdateFlags))
          
      EndSelect
      
    EndWith
  EndIf
  
EndProcedure

Procedure playMidiCue(sMidiCue.s)
  PROCNAMEC()
  Protected i, nCuePtr
  
  nCuePtr = -1
  For i = 1 To gnLastCue
    If aCue(i)\sMidiCue = sMidiCue
      nCuePtr = i
      Break
    EndIf
  Next i
  If nCuePtr >= 0
    If aCue(nCuePtr)\bCueCurrentlyEnabled  ; 'enabled' test added 07/04/2014 following error reported by Nick Reich
      debugMsg(sProcName, "calling playCue(" + getCueLabel(nCuePtr) + ")")
      playCue(nCuePtr)
    EndIf
  EndIf
EndProcedure

Procedure playCue(pCuePtr, bConfirm=#False, nHotkeyToggleState=-1, bRecursiveCall=#False)
  PROCNAMECQ(pCuePtr)
  Protected d, i, i2, j, k, bRedoCueState, bStopReqd
  Protected nCueState
  Protected sGoToCue.s, nGoToCuePtr
  Protected sSetPosCue.s, sSetPosTime.s
  Protected nSetPosCuePtr, nSetPosTime
  Protected bPlayIssued, nMyRelStartMode
  Protected bStartLive
  Protected bCalledLockStreams
  Protected bLockedMutex
  Protected bCallBuildGetSMSCurrInfoCommandStrings
  Protected sXChanList.s
  Protected nActiveWindow
  Protected bDeferPlaySub
  Protected nPosSyncType.l, sPosSyncType.s
  
  debugMsg3(sProcName, #SCS_START + ", bConfirm=" + strB(bConfirm) + ", nHotkeyToggleState=" + nHotkeyToggleState + ", bRecursiveCall=" + strB(bRecursiveCall))
  If nHotkeyToggleState >= 0
    logKeyEvent("Play Cue " + getCueLabel(pCuePtr) + ", nHotkeyToggleState=" + nHotkeyToggleState)
  Else
    logKeyEvent("Play Cue " + getCueLabel(pCuePtr))
  EndIf

  If gbStoppingEverything Or gbSamRequestUnderStoppingEverything
    debugMsg(sProcName, "exiting - gbStoppingEverything=" + strB(gbStoppingEverything) + ", gbSamRequestUnderStoppingEverything=" + strB(gbSamRequestUnderStoppingEverything))
    ProcedureReturn #False
  EndIf
  
  If (pCuePtr <= 0) Or (pCuePtr >= gnCueEnd)
    debugMsg(sProcName, "exiting because pCuePtr out of range")
    ProcedureReturn #False
  EndIf
  
  If grProd\nMaxLightingLogicalDev >= 0 And grProd\bDoNotCalcCueStartValues = #False
    ; debugMsg(sProcName, "grProd\nMaxLightingLogicalDev=" + grProd\nMaxLightingLogicalDev+ ", calling DMX_saveCueStartDMXSave(pCuePtr)")
    DMX_saveCueStartDMXSave(pCuePtr)
    ; debugMsg(sProcName, "returned from DMX_saveCueStartDMXSave(pCuePtr)")
  EndIf
  
  nActiveWindow = GetActiveWindow() ; added 16Jun2019 11.8.1.3ab following email from Joe Eaton about editor window flashing
  ; debugMsg(sProcName, "nActiveWindow=" + nActiveWindow)
  
  aCue(pCuePtr)\bCallSetWindowVisible = #False
  
  ; debugMsg(sProcName, "grProd\nGridClickAction=" + decodeGridClickAction(grProd\nGridClickAction) + ", gnCueToGoOverride=" + getCueLabel(gnCueToGoOverride))
  If (grProd\nGridClickAction = #SCS_GRDCLICK_SET_GO_BUTTON_ONLY) And (gnCueToGoOverride = pCuePtr)
    gnCueToGoOverride = -1
    GoToCue(pCuePtr, #False, #False)  ; going to this cue forces any earlier 'ready' cues to be 'completed'
    ; no drop into main 'playCue() logic
  EndIf
  
  If bRecursiveCall = #False
    ; debugMsg(sProcName, "calling LockCueListMutex(300), gnCueListMutexLockThread=" + gnCueListMutexLockThread + ", gnThreadNo=" + gnThreadNo)
    LockCueListMutex(300)
    ; debugMsg(sProcName, "returned from LockCueListMutex(300)")
    If gbCallSetVidPicTargets
      ; should only occur if user has added a new 'screen' in a video/image cue in the Editor, so should not occur during production runs
      debugMsg(sProcName, "calling setVidPicTargets()")
      setVidPicTargets()
    EndIf
  EndIf
  
  grMMedia\bInPlayCue = #True
  
  With aCue(pCuePtr)
    debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\nActivationMethod=" + decodeActivationMethod(\nActivationMethod) + ", \nActivationMethodReqd=" + decodeActivationMethod(\nActivationMethodReqd))
    If \bSubTypeA
      ; Added 13Nov2020 11.8.3.3ag
      j = \nFirstSubIndex
      While j >= 0
        If aSub(j)\bSubTypeA
          k = aSub(j)\nFirstAudIndex
          While k >= 0
            aAud(k)\bCallSetWindowVisible = #False
            k = aAud(k)\nNextAudIndex
          Wend
        EndIf
        j = aSub(j)\nNextSubIndex
      Wend
      \bCallSetWindowVisible = #False
      ; End added 13Nov2020 11.8.3.3ag
      debugMsg(sProcName, "calling reopenVidFilesForCueIfReqd(" + getCueLabel(pCuePtr) + ")")
      reopenVidFilesForCueIfReqd(pCuePtr)
    EndIf  

    \bCueEnded = #False
    ; debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\bCueEnded=" + strB(\bCueEnded))
    \bCueCountDownPaused = #False
    If (\nActivationMethod = #SCS_ACMETH_AUTO) Or (\nActivationMethod = #SCS_ACMETH_AUTO_PLUS_CONF)
      If \bAutoStartLocked = #False
        ; debugMsg(sProcName, "setting \bAutoStartLocked = #True")
        \bAutoStartLocked = #True
        debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\bAutoStartLocked=" + strB(\bAutoStartLocked))
      EndIf
    EndIf
    
    ; debugMsg(sProcName, "calling resetRelatedCueActivationMethodReqd(" + getCueLabel(pCuePtr) + ")")
    resetRelatedCueActivationMethodReqd(pCuePtr)
    
    If gbUseSMS ; SM-S
      If \sFastCuePlayCommandString
        sendSMSCommand("play " + \sFastCuePlayCommandString)
        bPlayIssued = #True
      EndIf
    EndIf
    
    \sCueSetGainCommandString = ""
    \sCuePlayCommandString = ""
    
    nCueState = \nCueState
    nGoToCuePtr = -1
    
    If \bExclusiveCue
      If \bHotkey
        If (grGeneralOptions\bCtrlOverridesExclCue) And (GetAsyncKeyState_(#VK_CONTROL) & 32768)
          ; ctrl key down and option 'ctrl overrides exclusive cue for go methods' is set, so no need to check if an exclusive cue is playing
        Else
          ; else we DO need to check if an exclusive cue is playing
          If (nCueState >= #SCS_CUE_FADING_IN) And (nCueState <= #SCS_CUE_FADING_OUT)
            If gbEditHasFocus = #False
              WMN_setStatusField(LangPars("Errors", "ExclHKPlaying", \sCue), #SCS_STATUS_ERROR)
              ; debugMsg(sProcName, "calling UnlockCueListMutex()")
              UnlockCueListMutex()
              grMMedia\bInPlayCue = #False
              ProcedureReturn #False
            EndIf
          EndIf
        EndIf
      EndIf
    EndIf
    
    If (nCueState = #SCS_CUE_NOT_LOADED) Or (nCueState >= #SCS_CUE_COMPLETED)
      debugMsg(sProcName, "calling loadOneCue(" + pCuePtr + ") because \nCueState=" + decodeCueState(nCueState))
      loadOneCue(pCuePtr)
      nCueState = aCue(pCuePtr)\nCueState
      If nCueState = #SCS_CUE_ERROR
        WMN_setStatusField(LangPars("Errors", "CannotOpenCue", \sCue, \sErrorMsg), #SCS_STATUS_ERROR)
        ; debugMsg(sProcName, "calling UnlockCueListMutex()")
        UnlockCueListMutex()
        grMMedia\bInPlayCue = #False
        ProcedureReturn #False
      ElseIf nCueState = #SCS_CUE_NOT_LOADED
        WMN_setStatusField(LangPars("Errors", "CannotLoadCue", \sCue), #SCS_STATUS_ERROR)
        ; debugMsg(sProcName, "calling UnlockCueListMutex()")
        UnlockCueListMutex()
        grMMedia\bInPlayCue = #False
        ProcedureReturn #False
      EndIf
    EndIf
    
    If (\bHotkey) Or (\bExtAct) Or (\bCallableCue) Or ((\nActivationMethod = #SCS_ACMETH_MAN) And (grProd\nRunMode <> #SCS_RUN_MODE_LINEAR))
      If (\bLockMixerStreamsOnPlayCue) And (bRecursiveCall = #False)
        lockAllMixerStreams(#True, #True)
        bCalledLockStreams = #True
      EndIf
      j = \nFirstSubIndex
      While j >= 0
        If aSub(j)\bSubEnabled
          If (aSub(j)\nSubState > #SCS_CUE_READY) And (aSub(j)\bSubTypeI = #False)
            debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\nSubState=" + decodeCueState(aSub(j)\nSubState) + ", setting bStopReqd=#True")
            bStopReqd = #True
          Else
            debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\nSubState=" + decodeCueState(aSub(j)\nSubState))
          EndIf
        EndIf
        j = aSub(j)\nNextSubIndex
      Wend
      If bStopReqd
        debugMsg(sProcName, "calling stopCue")
        stopCue(pCuePtr, "ALL", #True)
        bPlayIssued = #False
      EndIf
      
    ElseIf (\nActivationMethodReqd = #SCS_ACMETH_MAN_PLUS_CONF) Or (\nActivationMethodReqd = #SCS_ACMETH_AUTO_PLUS_CONF)
      ; "manual + confirm" or "auto + confirm"
      If (nCueState = #SCS_CUE_READY) Or (nCueState = #SCS_CUE_COUNTDOWN_TO_START)
        setWholeCueState(pCuePtr, nCueState, #SCS_CUE_WAITING_FOR_CONFIRM)
        setCueState(pCuePtr, #False, #False, #True)
        completeOtherWaitingCues(pCuePtr)
        ; debugMsg(sProcName, "calling UnlockCueListMutex()")
        UnlockCueListMutex()
        grMMedia\bInPlayCue = #False
        ProcedureReturn #True
      ElseIf (nCueState = #SCS_CUE_WAITING_FOR_CONFIRM) And (bConfirm = #False)
        ; ignore
        ; debugMsg(sProcName, "calling UnlockCueListMutex()")
        UnlockCueListMutex()
        grMMedia\bInPlayCue = #False
        ProcedureReturn #False
      EndIf
      
    Else
      If (\bLockMixerStreamsOnPlayCue) And (bRecursiveCall = #False)
        debugMsg3(sProcName, "lock mixer streams")
        lockAllMixerStreams(#True, #True)
        bCalledLockStreams = #True
      EndIf
      
    EndIf
    
    gbForceFocusPointToNextManual = #False
    \qTimeCueStopped = 0
    \bTimeCueStoppedSet = #False
    \bCueStoppedByStopEverything = #False
    \bCueStoppedByGoToCue = #False
    ; debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\bTimeCueStoppedSet=" + strB(\bTimeCueStoppedSet))
    \nCuePanelUpdateFlags | #SCS_CUEPNL_TRANSPORT | #SCS_CUEPNL_PROGRESS
    ; debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\nCuePanelUpdateFlags=" + Str(\nCuePanelUpdateFlags))
    If \bCueEnded
      \bCueEnded = #False
      debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\bCueEnded=" + strB(\bCueEnded))
      bRedoCueState = #True
    EndIf
    
    ; firstly, process all audio sub-cues in this cue (ie types F and P), while the mixer streams may be locked
    j = \nFirstSubIndex
    While j >= 0
      If aSub(j)\bSubTypeForP
        If aSub(j)\bSubEnabled
          bDeferPlaySub = #False
          If aSub(j)\nSubStart <> #SCS_SUBSTART_REL_TIME
            bDeferPlaySub = #True
          EndIf
          If bDeferPlaySub = #False
            aSub(j)\bHibernating = #False
            nMyRelStartMode = aSub(j)\nRelStartMode
            If (j = \nFirstSubIndex) And ((nMyRelStartMode = #SCS_RELSTART_AS_PREV_SUB) Or (nMyRelStartMode = #SCS_RELSTART_AE_PREV_SUB))
              nMyRelStartMode = #SCS_RELSTART_DEFAULT
            EndIf
            ; debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\nRelStartMode=" + decodeRelStartMode(aSub(j)\nRelStartMode) + ", nMyRelStartMode=" + decodeRelStartMode(nMyRelStartMode))
            Select nMyRelStartMode
              Case #SCS_RELSTART_DEFAULT, #SCS_RELSTART_AS_CUE
                If aSub(j)\nRelStartTime <= 0
                  debugMsg(sProcName, "calling playSub(" + getSubLabel(j) + ")")
                  playSub(j, 0, #False, #False, -1, -1, -1, #False, nHotkeyToggleState)
                Else
                  aSub(j)\qTimeToStartSub = gqTimeNow + aSub(j)\nRelStartTime
                  aSub(j)\nSubState = #SCS_CUE_SUB_COUNTDOWN_TO_START
                  debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\qTimeToStartSub=" + traceTime(aSub(j)\qTimeToStartSub) + ", gqTimeNo=" + traceTime(gqTimeNow) + ", \nSubState=" + decodeCueState(aSub(j)\nSubState))
                  k = aSub(j)\nFirstPlayIndex
                  If k >= 0
                    aAud(k)\nAudState = #SCS_CUE_SUB_COUNTDOWN_TO_START
                  EndIf
                  bRedoCueState = #True
                EndIf
              Default
                ; no action yet
            EndSelect
            ; debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\nSubState=" + decodeCueState(aSub(j)\nSubState))
          EndIf ; EndIf bDeferPlaySub = #False
        EndIf ; EndIf aSub(j)\bSubEnabled
      EndIf ; EndIf aSub(j)\bSubTypeForP
      j = aSub(j)\nNextSubIndex
    Wend
    
    ; now unlock the mixer streams if currently locked
    If bCalledLockStreams
      debugMsg3(sProcName, "unlock mixer streams")
      lockAllMixerStreams(#False, #True)
    EndIf
    
    ; now process the other sub-cues in this cue
    j = \nFirstSubIndex
    While j >= 0
      If aSub(j)\bSubTypeForP = #False
        If aSub(j)\bSubEnabled
          bDeferPlaySub = #False
          If aSub(j)\nSubStart <> #SCS_SUBSTART_REL_TIME
            bDeferPlaySub = #True
          EndIf
          If bDeferPlaySub = #False
            aSub(j)\bHibernating = #False
            nMyRelStartMode = aSub(j)\nRelStartMode
            If (j = \nFirstSubIndex) And ((nMyRelStartMode = #SCS_RELSTART_AS_PREV_SUB) Or (nMyRelStartMode = #SCS_RELSTART_AE_PREV_SUB))
              nMyRelStartMode = #SCS_RELSTART_DEFAULT
            EndIf
            ; debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\nRelStartMode=" + decodeRelStartMode(aSub(j)\nRelStartMode) + ", nMyRelStartMode=" + decodeRelStartMode(nMyRelStartMode))
            Select nMyRelStartMode
              Case #SCS_RELSTART_DEFAULT, #SCS_RELSTART_AS_CUE
                If aSub(j)\nRelStartTime <= 0
                  debugMsg(sProcName, "calling playSub(" + getSubLabel(j) + ")")
                  playSub(j, 0, #False, #False, -1, -1, -1, #False, nHotkeyToggleState)
                Else
                  aSub(j)\qTimeToStartSub = gqTimeNow + aSub(j)\nRelStartTime
                  aSub(j)\nSubState = #SCS_CUE_SUB_COUNTDOWN_TO_START
                  debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\qTimeToStartSub=" + traceTime(aSub(j)\qTimeToStartSub) + ", gqTimeNo=" + traceTime(gqTimeNow) + ", \nSubState=" + decodeCueState(aSub(j)\nSubState))
                  k = aSub(j)\nFirstPlayIndex
                  If k >= 0
                    aAud(k)\nAudState = #SCS_CUE_SUB_COUNTDOWN_TO_START
                  EndIf
                  bRedoCueState = #True
                EndIf
              Default
                ; no action yet
            EndSelect
            ; debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\nSubState=" + decodeCueState(aSub(j)\nSubState))
          EndIf ; EndIf bDeferPlaySub = #False
        EndIf ; EndIf aSub(j)\bSubEnabled
      EndIf ; EndIf aSub(j)\bSubTypeForP
      j = aSub(j)\nNextSubIndex
    Wend
    
    If \bSubTypeN ; 'Note' cue
      j = aCue(pCuePtr)\nFirstSubIndex
      If j >= 0
        If aSub(j)\bSubTypeN
          aSub(j)\nSubState = #SCS_CUE_COMPLETED
        EndIf
      EndIf
      \nCueState = #SCS_CUE_COMPLETED
      bRedoCueState = #True
    EndIf
    
    If gbUseSMS ; SM-S
      ; debugMsg(sProcName, "\bSetLevelsWhenPlayCue=" + strB(\bSetLevelsWhenPlayCue) + ", \sCueSetGainCommandString=" + \sCueSetGainCommandString)
      If (\bSetLevelsWhenPlayCue) And (Trim(\sCueSetGainCommandString))
        sendSMSCommand("set " + Trim(\sCueSetGainCommandString))
        bCallBuildGetSMSCurrInfoCommandStrings = #True
        If \bSubTypeI
          sXChanList = buildXChanListForCue(pCuePtr)
          If sXChanList
            sendSMSCommand("set chan " + sXChanList + " mute off")
          EndIf
        EndIf
      EndIf
      If bPlayIssued = #False
        If Trim(\sCuePlayCommandString)
          sendSMSCommand("play " + Trim(\sCuePlayCommandString))
          bCallBuildGetSMSCurrInfoCommandStrings = #True
        EndIf
      Else
        bCallBuildGetSMSCurrInfoCommandStrings = #True
      EndIf
      If bCallBuildGetSMSCurrInfoCommandStrings
        buildGetSMSCurrInfoCommandStrings()
      EndIf
      \sCueSetGainCommandString = ""
      \sCuePlayCommandString = ""
    EndIf
    
    If \bSubTypeI
      WCN_setLiveOnInds()
    EndIf
    
    If bRedoCueState
      ; debugMsg(sProcName, "calling setCueState(" + getCueLabel(pCuePtr) + ", \bCueEnded=" + strB(\bCueEnded) + ")")
      setCueState(pCuePtr)
      updateGrid(pCuePtr)
    EndIf
    
    ; now start any auto-start cues with an auto start time of 0.000 seconds after start of this cue
    For i = pCuePtr+1 To gnLastCue
      If aCue(i)\nActivationMethod = #SCS_ACMETH_AUTO
        If aCue(i)\nAutoActCuePtr = pCuePtr
          If aCue(i)\nAutoActTime <= 0
            If (aCue(i)\nAutoActPosn = #SCS_ACPOSN_AS) Or (aCue(i)\nAutoActPosn = #SCS_ACPOSN_DEFAULT)
              If aCue(i)\bCueCurrentlyEnabled
                debugMsg(sProcName, "calling playCue(" + getCueLabel(i) + ")")
                playCue(i, #False, -1, #True)
              EndIf
            EndIf
          EndIf
        EndIf
      EndIf
    Next i
    
    ; added 23Nov2019 11.8.2rc5
    If grFMOptions\nFunctionalMode = #SCS_FM_PRIMARY
      If \nActivationMethodReqd = #SCS_ACMETH_TIME
        FMP_sendCommandIfReqd(#SCS_OSCINP_CUE_PLAY, pCuePtr)
      EndIf
    EndIf
    ; end added 23Nov2019 11.8.2rc5

    If bRecursiveCall = #False
      ; mark as 'complete' any other cues that are 'waiting for confirmation'
      ; debugMsg(sProcName, "calling completeOtherWaitingCues(" + getCueLabel(pCuePtr) + ")")
      completeOtherWaitingCues(pCuePtr)
    EndIf
    
    If \nProdTimerAction <> #SCS_PTA_NO_ACTION
      processProdTimerAction(\nProdTimerAction, #SCS_PTW_WHEN_CUE_STARTS, pCuePtr)
    EndIf
    
    ; Added 31Nov2020 11.8.3.3ag
    If \bCallSetWindowVisible
      j = \nFirstSubIndex
      While j >= 0
        If aSub(j)\bSubTypeA And aSub(j)\bSubEnabled
          bDeferPlaySub = #False
          If aSub(j)\nSubStart <> #SCS_SUBSTART_REL_TIME
            bDeferPlaySub = #True
          EndIf
          If bDeferPlaySub = #False
            k = aSub(j)\nFirstPlayIndex
            While k >= 0
              ; debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\bCallSetWindowVisible=" + strB(aAud(k)\bCallSetWindowVisible))
              If aAud(k)\bCallSetWindowVisible
                ; debugMsg(sProcName, "calling setTVGWindowsVisibleAsReqd(" + getAudLabel(k) + ", " + getVidPicTargetForOutputScreen(aSub(j)\nOutputScreen) + ")")
                setTVGWindowsVisibleAsReqd(k, getVidPicTargetForOutputScreen(aSub(j)\nOutputScreen))
                aAud(k)\bCallSetWindowVisible = #False
              EndIf
              k = aAud(k)\nNextPlayIndex
            Wend
          EndIf ; EndIf bDeferPlaySub = #False
        EndIf ; EndIf aSub(j)\bSubTypeA And aSub(j)\bSubEnabled
        j = aSub(j)\nNextSubIndex
      Wend
      \bCallSetWindowVisible = #False
    EndIf
    ; End added 31Nov2020 11.8.3.3ag
    
  EndWith
  
  samCancelRequest(#SCS_SAM_PLAY_CUE, pCuePtr)
  
  ; debugMsg(sProcName, "calling UnlockCueListMutex()")
  UnlockCueListMutex()
  
  If bRecursiveCall = #False
    If gnCallOpenNextCues < 1
      If (aCue(pCuePtr)\bHotkey = #False) And (aCue(pCuePtr)\bExtAct = #False)  ; test added 19Jul2018 11.7.1.1ac
        gnCallOpenNextCues = pCuePtr
        ; debugMsg(sProcName, "gnCallOpenNextCues=" + getCueLabel(gnCallOpenNextCues))
      EndIf
    EndIf
    ; debugMsg(sProcName, "gnCallOpenNextCues=" + getCueLabel(gnCallOpenNextCues) + ", gnWaitUntilCueEnded=" + getCueLabel(gnWaitUntilCueEnded))
    resetActiveWindowIfReqd(nActiveWindow) ; above modified 16Jun2019 11.8.1.3ab following email from Joe Eaton about editor window flashing
  EndIf
  
  With aCue(pCuePtr)
    ; the following modified 26Jul2019 11.8.1.3ad following bug report from Dieter Edinger whereby the call cue to turn on worker lights was called too soon, because the previous sub-cue was in 'countdown' state
    ; If \nCueState < #SCS_CUE_FADING_IN Or \nCueState > #SCS_CUE_FADING_OUT
    If \nCueState <= #SCS_CUE_READY Or \nCueState > #SCS_CUE_FADING_OUT
      \bCueEnded = #True
      debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\bCueEnded=" + strB(\bCueEnded))
    EndIf
    ; debugMsg(sProcName, "\nCueState=" + decodeCueState(\nCueState) + ", \bCueEnded=" + strB(\bCueEnded))
    If \nActivationMethod <> #SCS_ACMETH_CALL_CUE ; 6Sep2019 11.8.2am added test to prevent callable cues being shown as 'last playing cue', as the calling cue itself should be shown
      setLastPlayingCue(pCuePtr)
    EndIf
  EndWith
  
  grMMedia\bInPlayCue = #False
  
  debugMsg3(sProcName, #SCS_END)
  ProcedureReturn #True

EndProcedure

Procedure playCueViaCas(pCuePtr, nCasGroupId=-1, bConfirm=#False)
  PROCNAMECQ(pCuePtr)
  Protected i, j, k, bRedoCueState, bStopReqd
  Protected nMyCasGroupId
  Protected nCueState
  Protected sGoToCue.s, nGoToCuePtr
  Protected sSetPosCue.s, sSetPosTime.s
  Protected nSetPosCuePtr, nSetPosTime
  Protected bCalledLockStreams
  Protected bLockedMutex
  Protected nActiveWindow
  
  debugMsg3(sProcName, #SCS_START)
  
  If (pCuePtr <= 0) Or (pCuePtr >= gnCueEnd)
    debugMsg(sProcName, "exiting because pCuePtr out of range")
    ProcedureReturn
  EndIf
  
  logKeyEvent("Play Cue " + getCueLabel(pCuePtr))
  
  nActiveWindow = GetActiveWindow() ; added 16Jun2019 11.8.1.3ab
  
  With aCue(pCuePtr)
    If (\bUseCasForThisCue = #False) And (nCasGroupId = -1)
      ; this cue does not need to use cas so directly call playCue()
      debugMsg(sProcName, "calling playCue(" + getCueLabel(pCuePtr) + ", " + strB(bConfirm) + ")")
      playCue(pCuePtr, bConfirm)
      ; Added 13Dec2021 11.8.6cx following test in which I added several audio file cues, then started one from the main screen (using 'GO'), and then closed the editor. That closed the cue I had just started from the main screen.
      If \bCloseCueWhenLeavingEditor
        debugMsg(sProcName, "clearing aCue(" + getCueLabel(pCuePtr) + ")\bCloseCueWhenLeavingEditor")
        \bCloseCueWhenLeavingEditor = #False
      EndIf
      ; End added 13Dec2021 11.8.6cx
      resetActiveWindowIfReqd(nActiveWindow) ; added 16Jun2019 11.8.1.3ab
      ProcedureReturn
    EndIf
  EndWith

  If gbStoppingEverything Or gbSamRequestUnderStoppingEverything
    debugMsg(sProcName, "exiting - gbStoppingEverything=" + strB(gbStoppingEverything) + ", gbSamRequestUnderStoppingEverything=" + strB(gbSamRequestUnderStoppingEverything))
    ProcedureReturn
  EndIf
  
  ; debugMsg(sProcName, "grProd\nGridClickAction=" + decodeGridClickAction(grProd\nGridClickAction) + ", gnCueToGoOverride=" + getCueLabel(gnCueToGoOverride))
  If (grProd\nGridClickAction = #SCS_GRDCLICK_SET_GO_BUTTON_ONLY) And (gnCueToGoOverride = pCuePtr)
    gnCueToGoOverride = -1
    GoToCue(pCuePtr, #False, #False)  ; going to this cue forces any earlier 'ready' cues to be 'completed'
    ; no drop into main 'playCueViaCas() logic
  EndIf
  
  LockCueListMutex(302)
  
  If gbCallSetVidPicTargets
    ; should only occur if user has added a new 'screen' in a video/image cue in the Editor, so should not occur during production runs
    debugMsg(sProcName, "calling setVidPicTargets()")
    setVidPicTargets()
  EndIf
  
  With aCue(pCuePtr)
    \bCueEnded = #False
    ; debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\bCueEnded=" + strB(\bCueEnded))
    \bCueCountDownPaused = #False
    If (\nActivationMethod = #SCS_ACMETH_AUTO) Or (\nActivationMethod = #SCS_ACMETH_AUTO_PLUS_CONF)
      If \bAutoStartLocked = #False
        ; debugMsg(sProcName, "setting \bAutoStartLocked = #True")
        \bAutoStartLocked = #True
        debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\bAutoStartLocked=" + strB(\bAutoStartLocked))
      EndIf
    EndIf
    
    debugMsg(sProcName, "calling resetRelatedCueActivationMethodReqd(" + getCueLabel(pCuePtr) + ")")
    resetRelatedCueActivationMethodReqd(pCuePtr)
    
    If (\nActivationMethodReqd = #SCS_ACMETH_MAN_PLUS_CONF) Or (\nActivationMethodReqd = #SCS_ACMETH_AUTO_PLUS_CONF)
      ; "manual + confirm" or "auto + confirm"
      nCueState = \nCueState
      If (nCueState = #SCS_CUE_READY) Or (nCueState = #SCS_CUE_COUNTDOWN_TO_START)
        setWholeCueState(pCuePtr, nCueState, #SCS_CUE_WAITING_FOR_CONFIRM)
        setCueState(pCuePtr, #False, #False, #True)
        completeOtherWaitingCues(pCuePtr)
        UnlockCueListMutex()
        ProcedureReturn
      ElseIf (nCueState = #SCS_CUE_WAITING_FOR_CONFIRM) And (bConfirm = #False)
        ; ignore
        UnlockCueListMutex()
        ProcedureReturn
      EndIf
    EndIf
    
    If (\nCueState = #SCS_CUE_NOT_LOADED) Or (\nCueState >= #SCS_CUE_COMPLETED)
      debugMsg(sProcName, "calling loadOneCue(" + pCuePtr + ") because \nCueState=" + decodeCueState(\nCueState))
      loadOneCue(pCuePtr)
    EndIf
    
    ; If (gbUseBASSMixer) And (\bSubTypeForP) And (nCasGroupId = -1)
    debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\bLockMixerStreamsOnPlayCue=" + strB(aCue(pCuePtr)\bLockMixerStreamsOnPlayCue))
    If (\bLockMixerStreamsOnPlayCue) And (nCasGroupId = -1)
      debugMsg3(sProcName, "lock mixer streams")
      lockAllMixerStreams(#True, #True)
      bCalledLockStreams = #True
    EndIf
    
    If nCasGroupId = -1
      nMyCasGroupId = casNewGroup()
    Else
      nMyCasGroupId = nCasGroupId
    EndIf
    
    If \bHotkey Or \bCallableCue
      j = \nFirstSubIndex
      While j >= 0
        If aSub(j)\bSubEnabled
          If aSub(j)\nSubState > #SCS_CUE_READY
            bStopReqd = #True
          EndIf
        EndIf
        j = aSub(j)\nNextSubIndex
      Wend
      If bStopReqd
        debugMsg(sProcName, "calling stopCue")
        stopCue(pCuePtr, "ALL", #True)
      EndIf
    EndIf
    
    ; firstly, process all audio sub-cues in this cue (ie types F and P), while the mixer streams may be locked
    j = \nFirstSubIndex
    While j >= 0
      If aSub(j)\nSubStart = #SCS_SUBSTART_REL_TIME ; Test added 31Mar2022 11.9.1ax following email for Lars Stokdijk about an OCM sub-cue starting immedieatly
        If aSub(j)\bSubTypeForP
          If aSub(j)\bSubEnabled
            aSub(j)\bHibernating = #False
            If aSub(j)\nRelStartMode <= #SCS_RELSTART_AS_CUE
              If aSub(j)\nRelStartTime <= 0
                debugMsg(sProcName, "calling playSub(" + getSubLabel(j) + ", 0, #True)")
                playSub(j, 0, #True)
              Else
                aSub(j)\qTimeToStartSub = gqTimeNow + aSub(j)\nRelStartTime
                aSub(j)\nSubState = #SCS_CUE_SUB_COUNTDOWN_TO_START
                debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\qTimeToStartSub=" + traceTime(aSub(j)\qTimeToStartSub) + ", gqTimeNo=" + traceTime(gqTimeNow) + ", \nSubState=" + decodeCueState(aSub(j)\nSubState))
                k = aSub(j)\nFirstPlayIndex
                If k >= 0
                  aAud(k)\nAudState = #SCS_CUE_SUB_COUNTDOWN_TO_START
                EndIf
                bRedoCueState = #True
              EndIf
            EndIf ; EndIf aSub(j)\nSubStart = #SCS_SUBSTART_REL_TIME
          EndIf ; EndIf aSub(j)\bSubEnabled
        EndIf ; EndIf aSub(j)\bSubTypeForP
      EndIf
      j = aSub(j)\nNextSubIndex
    Wend
    
    ; now unlock the mixer streams if currently locked
    If bCalledLockStreams
      debugMsg3(sProcName, "unlock mixer streams")
      lockAllMixerStreams(#False, #True)
    EndIf
    
    ; now process the other sub-cues in this cue
    j = \nFirstSubIndex
    While j >= 0
      If aSub(j)\nSubStart = #SCS_SUBSTART_REL_TIME ; Test added 20Jan2022 11.9.0rc3
        If aSub(j)\bSubTypeForP = #False
          If aSub(j)\bSubEnabled
            aSub(j)\bHibernating = #False
            If aSub(j)\nRelStartMode <= #SCS_RELSTART_AS_CUE
              If aSub(j)\nRelStartTime <= 0
                debugMsg(sProcName, "calling playSub(" + getSubLabel(j) + ", 0, #True)")
                playSub(j, 0, #True)
              Else
                aSub(j)\qTimeToStartSub = gqTimeNow + aSub(j)\nRelStartTime
                aSub(j)\nSubState = #SCS_CUE_SUB_COUNTDOWN_TO_START
                debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\qTimeToStartSub=" + traceTime(aSub(j)\qTimeToStartSub) + ", gqTimeNo=" + traceTime(gqTimeNow) + ", \nSubState=" + decodeCueState(aSub(j)\nSubState))
                k = aSub(j)\nFirstPlayIndex
                If k >= 0
                  aAud(k)\nAudState = #SCS_CUE_SUB_COUNTDOWN_TO_START
                EndIf
                bRedoCueState = #True
              EndIf
            EndIf
          EndIf ; EndIf aSub(j)\bSubEnabled
        EndIf ; EndIf aSub(j)\bSubTypeForP = #False
      Else
        debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\nSubStart=" + decodeSubStart(aSub(j)\nSubStart))
      EndIf ; EndIf/Else aSub(j)\nSubStart = #SCS_SUBSTART_REL_TIME
      j = aSub(j)\nNextSubIndex
    Wend
    
    gbForceFocusPointToNextManual = #False
    
    ; now start any auto-start cues dependent on this cue
    For i = 1 To gnLastCue
      If i <> pCuePtr
        If (aCue(i)\nActivationMethodReqd = #SCS_ACMETH_AUTO) Or (aCue(i)\nActivationMethodReqd = #SCS_ACMETH_AUTO_PLUS_CONF)
          If aCue(i)\nAutoActCuePtr = pCuePtr
            If aCue(i)\bCueCurrentlyEnabled
              If aCue(i)\nCueState <= #SCS_CUE_READY
                If aCue(i)\nAutoActPosn = #SCS_ACPOSN_AS
                  If aCue(i)\nAutoActTime <= 0
                    debugMsg(sProcName, "calling playCueViaCas(" + getCueLabel(i) + ", " + Str(nMyCasGroupId) + ")")
                    playCueViaCas(i, nMyCasGroupId)
                  Else
                    aCue(i)\qTimeToStartCue = \qTimeCueStarted + aCue(i)\nAutoActTime
                    aCue(i)\bTimeToStartCueSet = #True
                    debugMsg(sProcName, "aCue(" + getCueLabel(i) + ")\bTimeToStartCueSet=" + strB(aCue(i)\bTimeToStartCueSet) + ", \qTimeToStartCue=" + traceTime(aCue(i)\qTimeToStartCue))
                    CompilerIf 1=2 ; Blocked out 19Oct2022 11.9.6 following testing of Davide Bellucci's Space Journey demo, where some auto-start sub-cues were incorrectly set to countdown just because the parent cue's '\qTimeToStartCue' was set
                      j = aCue(i)\nFirstSubIndex
                      While j >= 0
                        If aSub(j)\bSubEnabled
                          If (aSub(j)\bSubTypeHasAuds) And ((aSub(j)\bSubCompletedBeforeOpenedInEditor = #False) Or (gbEditHasFocus = #False))
                            k = aSub(j)\nFirstAudIndex
                            While k >= 0
                              If aAud(k)\nAudState = #SCS_CUE_READY
                                debugMsg(sProcName, "setting aAud(" + getAudLabel(k) + ")\nAudState (" + decodeCueState(aAud(k)\nAudState) + ") to " + decodeCueState(#SCS_CUE_COUNTDOWN_TO_START))
                                aAud(k)\nAudState = #SCS_CUE_COUNTDOWN_TO_START
                              EndIf
                              k = aAud(k)\nNextAudIndex
                            Wend
                          ElseIf (aSub(j)\nSubState = #SCS_CUE_READY) And ((aSub(j)\bSubCompletedBeforeOpenedInEditor = #False) Or (gbEditHasFocus = #False))
                            debugMsg(sProcName, "setting aSub(" + getSubLabel(j) + ")\nSubState (" + decodeCueState(aSub(j)\nSubState) + ") to " + decodeCueState(#SCS_CUE_COUNTDOWN_TO_START))
                            aSub(j)\nSubState = #SCS_CUE_COUNTDOWN_TO_START
                          EndIf
                        EndIf ; EndIf aSub(j)\bSubEnabled
                        j = aSub(j)\nNextSubIndex
                      Wend
                    CompilerEndIf ; ; End blocked out 19Oct2022 11.9.6
                    setCueState(i)  ; call setCueState() now to prevent statusCheck() trying to repeat the same code
                    debugMsg(sProcName, "aCue(" + getCueLabel(i) + ")\nCueState=" + decodeCueState(aCue(i)\nCueState))
                    aCue(i)\bUpdateGrid = #True
                  EndIf
                EndIf
              EndIf
            EndIf
          EndIf
        EndIf
      EndIf
    Next i
    
    If nCasGroupId = -1
      ; group created at start of this call
      debugMsg(sProcName, "calling casReadyGroup(" + Str(nMyCasGroupId) + ")")
      casReadyGroup(nMyCasGroupId)
      debugMsg(sProcName, "calling casProcess")
      casProcess()
    EndIf
    
    If \bSubTypeN
      j = \nFirstSubIndex
      If j >= 0
        If aSub(j)\bSubTypeN
          aSub(j)\nSubState = #SCS_CUE_COMPLETED
        EndIf
      EndIf
      If \nFirstSubIndex = -1
        \nCueState = #SCS_CUE_COMPLETED
      EndIf
      bRedoCueState = #True
    EndIf
    
    If bRedoCueState
      \bRedoCueState = #True
      \bUpdateGrid = #True
      If nMyCasGroupId = -1
        For i = 1 To gnLastCue
          If aCue(i)\bRedoCueState
            setCueState(i)
          EndIf
          If aCue(i)\bUpdateGrid
            updateGrid(i)
            aCue(i)\nCuePanelUpdateFlags | #SCS_CUEPNL_PROGRESS | #SCS_CUEPNL_TRANSPORT
            debugMsg(sProcName, "aCue(" + getCueLabel(i) + ")\nCuePanelUpdateFlags=" + Str(aCue(i)\nCuePanelUpdateFlags))
          EndIf
        Next i
      EndIf
    EndIf
    completeOtherWaitingCues(pCuePtr)
    
    If \nProdTimerAction <> #SCS_PTA_NO_ACTION
      processProdTimerAction(\nProdTimerAction, #SCS_PTW_WHEN_CUE_STARTS, pCuePtr)
    EndIf
    
  EndWith
  
  UnlockCueListMutex()
  
  If gnCallOpenNextCues < 1
    gnCallOpenNextCues = pCuePtr
    debugMsg(sProcName, "gnCallOpenNextCues=" + getCueLabel(gnCallOpenNextCues))
  EndIf
  
  setLastPlayingCue(pCuePtr)
  
  resetActiveWindowIfReqd(nActiveWindow) ; added 16Jun2019 11.8.1.3ab
  
  debugMsg3(sProcName, #SCS_END)

EndProcedure

Procedure playOrResumeCue(pCuePtr)
  PROCNAMECQ(pCuePtr)
  Protected j, k

  debugMsg(sProcName, #SCS_START)
  
  If gbStoppingEverything Or gbSamRequestUnderStoppingEverything
    debugMsg(sProcName, "exiting - gbStoppingEverything=" + strB(gbStoppingEverything) + ", gbSamRequestUnderStoppingEverything=" + strB(gbSamRequestUnderStoppingEverything))
    ProcedureReturn
  EndIf

  If aCue(pCuePtr)\nCueState <> #SCS_CUE_PAUSED
    debugMsg(sProcName, "calling playCueViaCas(" + getCueLabel(pCuePtr) + ")")
    playCueViaCas(pCuePtr)
    ProcedureReturn
  EndIf

  gbForceFocusPointToNextManual = #False  ; focal2
  
  j = aCue(pCuePtr)\nFirstSubIndex
  While j >= 0
    If aSub(j)\bSubEnabled
      If aSub(j)\bSubTypeF Or aSub(j)\bSubTypeP
        k = aSub(j)\nFirstPlayIndex
        While k >= 0
          If aAud(k)\nAudState = #SCS_CUE_PAUSED
            resumeAud(k)
          EndIf
          k = aAud(k)\nNextPlayIndex
        Wend
      EndIf
    EndIf
    j = aSub(j)\nNextSubIndex
  Wend

  setCueState(pCuePtr)

  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure playCueFromStart(pCuePtr)
  PROCNAMECQ(pCuePtr)
  Protected j, k
  Protected bLockedMutex

  debugMsg(sProcName, #SCS_START)
  
  If gbStoppingEverything Or gbSamRequestUnderStoppingEverything
    debugMsg(sProcName, "exiting - gbStoppingEverything=" + strB(gbStoppingEverything) + ", gbSamRequestUnderStoppingEverything=" + strB(gbSamRequestUnderStoppingEverything))
    ProcedureReturn
  EndIf
  
  If (pCuePtr <= 0) Or (pCuePtr >= gnCueEnd)
    debugMsg(sProcName, "exiting because pCuePtr out of range")
    ProcedureReturn
  EndIf
  
  LockCueListMutex(301)
  
  With aCue(pCuePtr)
    \bCueEnded = #False
    debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\bCueEnded=" + strB(\bCueEnded))
    \bCueCountDownPaused = #False
    If \nActivationMethod = #SCS_ACMETH_AUTO Or \nActivationMethod = #SCS_ACMETH_AUTO_PLUS_CONF
      If \bAutoStartLocked = #False
        ; debugMsg(sProcName, "setting \bAutoStartLocked = #True")
        \bAutoStartLocked = #True
        debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\bAutoStartLocked=" + strB(\bAutoStartLocked))
      EndIf
    EndIf
    
    debugMsg(sProcName, "calling resetRelatedCueActivationMethodReqd(" + getCueLabel(pCuePtr) + ")")
    resetRelatedCueActivationMethodReqd(pCuePtr)
    
    If \nCueState = #SCS_CUE_PAUSED
      
      j = \nFirstSubIndex
      While j >= 0
        If aSub(j)\bSubEnabled
          If aSub(j)\bSubTypeF Or aSub(j)\bSubTypeP
            k = aSub(j)\nFirstPlayIndex
            While k >= 0
              If aAud(k)\nAudState = #SCS_CUE_PAUSED
                debugMsg(sProcName, "callng rewindAud(" + getAudLabel(k) + ")")
                rewindAud(k)
                debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nAudState=" + decodeCueState(aAud(k)\nAudState))
              EndIf
              k = aAud(k)\nNextPlayIndex
            Wend
          EndIf
          debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\nSubState=" + decodeCueState(aSub(j)\nSubState))
        EndIf
        j = aSub(j)\nNextSubIndex
      Wend
      
      setCueState(pCuePtr)
      debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\nCueState=" + decodeCueState(\nCueState))
      
    EndIf
  EndWith

  ;; playCueViaCas(pCuePtr)           ; commented out in 10.6.1
  ; playCue(pCuePtr)                  ; added in 10.6.1; commented out in 10.6.2 as some users reported SCS crashing on MIDI control
  debugMsg(sProcName, "calling playCueViaCas(" + getCueLabel(pCuePtr) + ")")
  playCueViaCas(pCuePtr)              ; re-added in 10.6.2
  
  UnlockCueListMutex()
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure.s getMidiMode(pAudPtr)
  PROCNAMEC()
  Protected nErrCode.l
  Protected sMciString.s
  Protected *lpReturnString
  
  If pAudPtr >= 0
    With aAud(pAudPtr)
      ; warning! all mciSendString calls must be from the same thread or mciSendString returns error 263 (not a registered device), so use main thread
      If gnThreadNo > #SCS_THREAD_MAIN
        ; register a call to get the MIDI mode
        grMMedia\nAudPtrForGetMidiMode = pAudPtr
        gqMainThreadRequest | #SCS_MTH_GET_MIDI_MODE
        ; but return the latest MIDI mode obtained
        ProcedureReturn \sMidiMode
      Else
        sMciString = "status " + \sMidiAlias + " mode"
        *lpReturnString = AllocateMemory(64)
        nErrCode = mciSendString_(sMciString, *lpReturnString, 32, 0)
        ; debugMsg3(sProcName, sMciString + " (returned " + sReturnString + "), nErrCode=" + Str(nErrCode))
        \sMidiMode = PeekS(*lpReturnString)
        ; debugMsg3(sProcName, "\sMidiMode=" + \sMidiMode + ", nErrCode=" + Str(nErrCode))
        FreeMemory(*lpReturnString)
        ProcedureReturn \sMidiMode
      EndIf
    EndWith
  EndIf
  
EndProcedure

Procedure playMidiFile(pAudPtr, bUseCas=#False, nCasGroupId=-1, nCtrlSendIndex=-1)
  PROCNAMECA(pAudPtr)
  Protected nErrCode.l
  Protected rCasInfo.tyCasItem
  Protected sMciString.s
  Protected sMsgA.s, sMsgB.s, sTitle.s
  Protected nMidiPhysicalDevPtr.l
  Protected sPhysicalDev.s, sLogicalDev.s, nProdDevNo
  Protected bDummyDev
  
  ; warning! all mciSendString calls must be from the same thread or mciSendString returns error 263 (not a registered device), so use main thread
  ASSERT_THREAD(#SCS_THREAD_MAIN)

  debugMsg(sProcName, #SCS_START)
  
  With aAud(pAudPtr)
    If \nAudState = #SCS_CUE_ERROR
      ProcedureReturn #False
    EndIf
    
    bDummyDev = gaMidiOutDevice(\nMidiPhysicalDevPtr)\bDummy
    debugMsg(sProcName, "gaMidiOutDevice(" + \nMidiPhysicalDevPtr + ")\bDummy=" + strB(gaMidiOutDevice(\nMidiPhysicalDevPtr)\bDummy) + ", bDummyDev=" + strB(bDummyDev))
    
    If bDummyDev = #False
      debugMsg(sProcName, "\sMidiAlias=" + \sMidiAlias + ", \nMidiPhysicalDevPtr=" + \nMidiPhysicalDevPtr)
      nMidiPhysicalDevPtr = \nMidiPhysicalDevPtr
      If nMidiPhysicalDevPtr >= 0
        If gaMidiOutDevice(nMidiPhysicalDevPtr)\hMidiOut <> 0
          MidiOut_Port("close", nMidiPhysicalDevPtr, "all")
        EndIf
      EndIf
      
      sMciString = "play " + \sMidiAlias
      If bUseCas
        rCasInfo\nCasCueAction = #SCS_CAS_MCI_STRING
        rCasInfo\sCasMciString = sMciString
        rCasInfo\sCasOriginProcName = sProcName
        rCasInfo\nCasGroupId = nCasGroupId
        grCasItem = rCasInfo
        casAddRequest()
      Else
        nErrCode = mciSendString_(sMciString, #Null, 0, #Null)
        debugMsg2(sProcName, "mciSendString_(" + sMciString + ", #Null, 0, #Null)", nErrCode)
        If nErrCode = 337 ; 'port in use'
          sTitle = Lang("Requesters", "PlayMidiFile")
          sPhysicalDev = gaMidiOutDevice(\nMidiPhysicalDevPtr)\sName
          sMsgA = LangPars("Errors", "CannotPlayMIDIA", \sAudLabel, sPhysicalDev)
          If nCtrlSendIndex >= 0
            sLogicalDev = aSub(\nSubIndex)\aCtrlSend[nCtrlSendIndex]\sCSLogicalDev
            debugMsg(sProcName, "sLogicalDev=" + sLogicalDev)
            nProdDevNo = getDevNoForLogicalDev(@grProd, #SCS_DEVGRP_CTRL_SEND, sLogicalDev)
            debugMsg(sProcName, "nProdDevNo=" + nProdDevNo)
            If nProdDevNo >= 0
              debugMsg(sProcName, "grProd\aCtrlSendLogicalDevs(" + nProdDevNo + ")\bCtrlMidiForMTC=" + strB(grProd\aCtrlSendLogicalDevs(nProdDevNo)\bCtrlMidiForMTC))
              If grProd\aCtrlSendLogicalDevs(nProdDevNo)\bCtrlMidiForMTC
                sMsgB = Lang("Errors", "CannotPlayMIDIB2")
              EndIf
            EndIf
          EndIf
          If Len(sMsgB) = 0
            sMsgB = Lang("Errors", "CannotPlayMIDIB1")
          EndIf
          debugMsg3(sProcName, "sMsgA=" + sMsgA)
          debugMsg3(sProcName, "sMsgB=" + sMsgB)
          scsMessageRequester(#SCS_TITLE, sMsgA + Chr(10) + Chr(10) + sMsgB, #MB_ICONEXCLAMATION)
          ProcedureReturn #False
          
        ElseIf nErrCode <> 0
          displayMidiError(nErrCode, sMciString, sProcName)
          ProcedureReturn #False
        EndIf
      EndIf
    EndIf ; EndIf bDummyDev = #False
  EndWith

  ProcedureReturn #True

EndProcedure

Procedure playSubTypeA(pSubPtr, bCalledFromEditor, bUseCas, nCasGroupId, nStartAtTrkNo)
  ; SubType A = Video/Image
  PROCNAMECS(pSubPtr)
  Protected d, k
  Protected nAudPtr, nTmpSubPtr
  Protected nMyPLMastFadeInTime
  Protected nMyFirstPlayIndex
  Protected nVidPicTarget
  Protected nMyPrevPlayIndex
  Protected bIgnoreFadein
  Protected nMyStartPos = -1
  
  debugMsg(sProcName, #SCS_START + ", nStartAtTrkNo=" + nStartAtTrkNo)
  
  With aSub(pSubPtr)
    
    debugMsg(sProcName, "\nSubState=" + decodeCueState(\nSubState) + ", \nFirstAudIndex=" + getAudLabel(\nFirstAudIndex) + ", \nFirstPlayIndex=" + getAudLabel(\nFirstPlayIndex))
    Select \nSubState
      Case #SCS_CUE_PLAYING, #SCS_CUE_FADING_IN, #SCS_CUE_TRANS_FADING_IN, #SCS_CUE_TRANS_FADING_OUT, #SCS_CUE_TRANS_MIXING_OUT
        ; cue already playing - ignore this 'playsub' request
        debugMsg(sProcName, "exiting (returning #False) because \nSubState=" + decodeCueState(\nSubState))
        ProcedureReturn
    EndSelect
    
    nMyPLMastFadeInTime = \nPLFadeInTime
    nMyFirstPlayIndex = \nFirstPlayIndex
    \bPLFadingIn = #False
    \bPLFadingOut = #False
    \nPLCurrFadeInTime = \nPLFadeInTime
    \nPLCurrFadeOutTime = \nPLFadeOutTime
    debugMsg(sProcName, "\nPLCurrFadeInTime=" + \nPLCurrFadeInTime + ", \nPLCurrFadeOutTime=" + \nPLCurrFadeOutTime)
    ; Added 13May2020 11.8.3rc4
    If \nPLCurrFadeInTime = -2
      debugMsg(sProcName, "grMMedia\nVideoImageCurrFadeOutSubPtr=" + getSubLabel(grMMedia\nVideoImageCurrFadeOutSubPtr) + ", \nVideoImageCurrFadeOutTime=" + grMMedia\nVideoImageCurrFadeOutTime)
      If grMMedia\nVideoImageCurrFadeOutTime > 0
        nTmpSubPtr = grMMedia\nVideoImageCurrFadeOutSubPtr
        If nTmpSubPtr >= 0
          debugMsg(sProcName, "aSub(" + getSubLabel(nTmpSubPtr) + ")\nSubState=" + decodeCueState(aSub(nTmpSubPtr)\nSubState))
          If aSub(nTmpSubPtr)\nSubState >= #SCS_CUE_FADING_IN And aSub(nTmpSubPtr)\nSubState <= #SCS_CUE_FADING_OUT
            \nPLCurrFadeInTime = grMMedia\nVideoImageCurrFadeOutTime
            debugMsg(sProcName, "grMMedia\nVideoImageCurrFadeOutSubPtr=" + getSubLabel(nTmpSubPtr) + ", \nVideoImageCurrFadeOutTime=" + grMMedia\nVideoImageCurrFadeOutTime + ", aSub(" + getSubLabel(pSubPtr) + ")\nPLCurrFadeInTime=" + \nPLCurrFadeInTime)
            nMyPLMastFadeInTime = \nPLCurrFadeInTime
          EndIf
        EndIf
      EndIf
    EndIf
    If \nPLCurrFadeOutTime = -2
      k = \nLastPlayIndex
      If k >= 0
        If aAud(k)\nPLTransType = #SCS_TRANS_XFADE And aAud(k)\nPLTransTime > 0
          \nPLCurrFadeOutTime = aAud(k)\nPLTransTime
          debugMsg(sProcName,"\nLastPlayIndex=" + getAudLabel(\nLastPlayIndex) + ", aAud(k)\nPLTransTime=" + aAud(k)\nPLTransTime + ", aSub(" + getSubLabel(pSubPtr) + ")\nPLCurrFadeOutTime=" + \nPLCurrFadeOutTime)
        EndIf
      EndIf
    EndIf
    ; End added 13May2020 11.8.3rc4
    
    ; debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\nFirstPlayIndex=" + getAudLabel(\nFirstPlayIndex))
    k = \nFirstPlayIndex
    nAudPtr = nMyFirstPlayIndex
    While k >= 0
      ; debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nAudState=" + decodeCueState(aAud(k)\nAudState) + ", aAud(" + getAudLabel(k) + ")\nNextPlayIndex=" + getAudLabel(aAud(k)\nNextPlayIndex))
      aAud(k)\bIgnoreInStatusCheck = #False
      ; debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\bIgnoreInStatusCheck=" + strB(aAud(k)\bIgnoreInStatusCheck))
      If (aAud(k)\nAudState = #SCS_CUE_COMPLETED) Or (aAud(k)\nAudState = #SCS_CUE_READY) Or (aAud(k)\nAudState = #SCS_CUE_PL_READY)
        ; reset 'completed' auds to 'pl_ready' which is necessary if restarting after stopping the sub, eg after hitting ESC
        ; debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nAudNo=" + aAud(k)\nAudNo)
        If aAud(k)\nAudNo = nStartAtTrkNo
          nAudPtr = k
        EndIf
        If aAud(k)\nAudNo < nStartAtTrkNo
          ; If aSub(pSubPtr)\bPLRepeat
          If getPLRepeatActive(pSubPtr)
            aAud(k)\nAudState = #SCS_CUE_PL_READY
          Else
            aAud(k)\nAudState = #SCS_CUE_COMPLETED
            debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nAudState=" + decodeCueState(aAud(k)\nAudState))
          EndIf
        Else
          If aAud(k)\nPrevPlayIndex < 0
            audSetState(k, #SCS_CUE_READY, 5)
          Else
            audSetState(k, #SCS_CUE_PL_READY, 6)
          EndIf
        EndIf
        
        For d = 0 To grLicInfo\nMaxAudDevPerAud
          If k = nMyFirstPlayIndex
            If nMyPLMastFadeInTime > 0
              aAud(k)\fCueVolNow[d] = #SCS_MINVOLUME_SINGLE
            Else
              aAud(k)\fCueVolNow[d] = aAud(k)\fBVLevel[d]
            EndIf
          ElseIf (aAud(k)\nFadeInTime > 0) Or ((k = aSub(pSubPtr)\nFirstPlayIndex) And (aSub(pSubPtr)\nPLFadeInTime > 0))
            aAud(k)\fCueVolNow[d] = #SCS_MINVOLUME_SINGLE
          Else
            aAud(k)\fCueVolNow[d] = aAud(k)\fBVLevel[d]
          EndIf
          aAud(k)\fCueAltVolNow[d] = #SCS_MINVOLUME_SINGLE
          aAud(k)\fCueTotalVolNow[d] = aAud(k)\fCueVolNow[d]
          CompilerIf #cTraceCueTotalVolNow
            debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\fCueTotalVolNow[" + d + "]=" + traceLevel(aAud(k)\fCueTotalVolNow[d]))
          CompilerEndIf
          aAud(k)\fCuePanNow[d] = aAud(k)\fPan[d]
        Next d
      EndIf
      If (k = nMyFirstPlayIndex) And (nMyPLMastFadeInTime > 0)
        aAud(k)\nCurrFadeInTime = nMyPLMastFadeInTime
      EndIf
      debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nCurrFadeInTime=" + aAud(k)\nCurrFadeInTime)
      k = aAud(k)\nNextPlayIndex
    Wend
    
    For d = 0 To grLicInfo\nMaxAudDevPerAud
      \fSubBVLevelNow[d] = \fSubMastBVLevel[d]
      \fSubPanNow[d] = \fPLPan[d]
    Next d
    
    debugMsg(sProcName, "nAudPtr=" + getAudLabel(nAudPtr))
    \nCurrPlayIndex = nAudPtr
    If nAudPtr >= 0 ; nb nAudPtr may be negative due to the sub being set as a placeholder (test added 5Dec2020 11.8.3.3ar following email from Peter Holmes)
      debugMsg(sProcName, "\nCurrPlayIndex=" + getAudLabel(\nCurrPlayIndex) + ", aAud(" + getAudLabel(nAudPtr) + ")\nCurrFadeInTime=" + aAud(nAudPtr)\nCurrFadeInTime)
    EndIf
    
    If (\bStartedInEditor) And (gnPLTestMode = #SCS_PLTESTMODE_HIGHLIGHTED_FILE)
      nAudPtr = nEditAudPtr
    EndIf
    debugMsg(sProcName, "calling calcPLTotalTime(" + getSubLabel(pSubPtr) + ")")
    calcPLTotalTime(pSubPtr)
    If (\bStartedInEditor) And (gbPreviewOnOutputScreen = #False)
      nVidPicTarget = #SCS_VID_PIC_TARGET_P
    Else
      nVidPicTarget = getVidPicTargetForOutputScreen(\nOutputScreen)
    EndIf
    If \bStartedInEditor
      setPLFades(pSubPtr)
    EndIf
    
    If nAudPtr >= 0
      If (aAud(nAudPtr)\bLogo = #False Or aSub(pSubPtr)\bUseNew2DDrawing = #False) Or (\bStartedInEditor) ; Added bUseNew2DDrawing test 9Jan2025 11.10.6-b02 as part of the fix for logos not to be displayed using 2D Drawing if the sub's bUseNew2DDrawing=#False
        nMyPrevPlayIndex = aAud(nAudPtr)\nPrevPlayIndex
        If (\nPLFadeInTime > 0) And (bIgnoreFadein = #False)
          If (\bStartedInEditor) And (gbPreviewOnOutputScreen = #False)
            If nMyPrevPlayIndex = -1
              grVidPicTarget(#SCS_VID_PIC_TARGET_P)\nPrimaryImageNo = grVidPicTarget(#SCS_VID_PIC_TARGET_P)\nBlackImageNo
              debugMsg(sProcName, "grVidPicTarget(" + decodeVidPicTarget(#SCS_VID_PIC_TARGET_P) + ")\nPrimaryImageNo=" + decodeHandle(grVidPicTarget(#SCS_VID_PIC_TARGET_P)\nPrimaryImageNo))
            Else
              If IsImage(aAud(nMyPrevPlayIndex)\nVidPicTargetImageNo(#SCS_VID_PIC_TARGET_P))
                grVidPicTarget(#SCS_VID_PIC_TARGET_P)\nPrimaryImageNo = aAud(nMyPrevPlayIndex)\nVidPicTargetImageNo(#SCS_VID_PIC_TARGET_P)
                debugMsg(sProcName, "grVidPicTarget(" + decodeVidPicTarget(#SCS_VID_PIC_TARGET_P) + ")\nPrimaryImageNo=" + decodeHandle(grVidPicTarget(#SCS_VID_PIC_TARGET_P)\nPrimaryImageNo))
              Else
                debugMsg(sProcName, "calling loadAndFitAPicture(" + getAudLabel(nMyPrevPlayIndex) + ", #SCS_VID_PIC_TARGET_P)")
                If loadAndFitAPicture(nMyPrevPlayIndex, #SCS_VID_PIC_TARGET_P)
                  grVidPicTarget(#SCS_VID_PIC_TARGET_P)\nPrimaryImageNo = aAud(nMyPrevPlayIndex)\nVidPicTargetImageNo(#SCS_VID_PIC_TARGET_P)
                  debugMsg(sProcName, "grVidPicTarget(" + decodeVidPicTarget(#SCS_VID_PIC_TARGET_P) + ")\nPrimaryImageNo=" + decodeHandle(grVidPicTarget(#SCS_VID_PIC_TARGET_P)\nPrimaryImageNo))
                EndIf
              EndIf
            EndIf
          Else
            ; ; if no current primary image then set to black for the blend function
            ; If IsImage(grVidPicTarget(nVidPicTarget)\nPrimaryImageNo) = #False
            ; grVidPicTarget(nVidPicTarget)\nPrimaryImageNo = grVidPicTarget(nVidPicTarget)\nBlackImageNo
            ; EndIf
          EndIf
          ; if no current primary image then set to black for the blend function
          If IsImage(grVidPicTarget(nVidPicTarget)\nPrimaryImageNo) = #False
            grVidPicTarget(nVidPicTarget)\nPrimaryImageNo = grVidPicTarget(nVidPicTarget)\nBlackImageNo
            debugMsg(sProcName, "grVidPicTarget(" + decodeVidPicTarget(nVidPicTarget) + ")\nPrimaryImageNo=" + decodeHandle(grVidPicTarget(nVidPicTarget)\nPrimaryImageNo))
          EndIf
        EndIf
      EndIf
      
      debugMsg(sProcName, "calling playAud(" + getAudLabel(nAudPtr) + ")")
      playAud(nAudPtr, bUseCas, #True, nCasGroupId)
      debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\nAudState=" + decodeCueState(aAud(nAudPtr)\nAudState))
      
      ; added 13Feb2020 11.8.2.2al
      If \bStartedInEditor = #False
        For nVidPicTarget = #SCS_VID_PIC_TARGET_F2 To #SCS_VID_PIC_TARGET_LAST
          If \bOutputScreenReqd(nVidPicTarget)
            grVidPicTarget(nVidPicTarget)\nCurrentSubPtr = pSubPtr
            debugMsg(sProcName, "grVidPicTarget(" + decodeVidPicTarget(nVidPicTarget) + ")\nCurrentSubPtr=" + getSubLabel(grVidPicTarget(nVidPicTarget)\nCurrentSubPtr))
          EndIf
        Next nVidPicTarget
      EndIf
      ; end added 13Feb2020 11.8.2.2al
      
    EndIf
    
    If (nAudPtr = -1) And (\bSubPlaceHolder)
      endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
    ElseIf nAudPtr >= 0
      If aAud(nAudPtr)\bLogo
        endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
      EndIf
    EndIf
    
    setCueState(\nCueIndex, #True)
    updateGrid(\nCueIndex)
    ; debugMsg(sProcName, "calling calcPLUnplayedFilesTime(" + getSubLabel(pSubPtr) + ")")
    calcPLUnplayedFilesTime(pSubPtr)
    
    If nAudPtr >= 0
      If aAud(nAudPtr)\bLogo = #False
        If \nPLFadeInTime > 0
          \qPLTimeFadeInStarted = ElapsedMilliseconds()
        EndIf
      EndIf
    EndIf
    
    ; debugMsg(sProcName, "calling stopInactiveVideoImageSubs(nExcludeSubPtr=" + getSubLabel(pSubPtr) + ", nCurrFadeInTime=" + \nPLCurrFadeInTime + ")")
    stopInactiveVideoImageSubs(pSubPtr, \nPLCurrFadeInTime) ; Added \nPLCurrFadeInTime 27Aug2021 11.8.6 following test of U3A "A Twist on Christmas VFX.scs11"
    ; debugMsg(sProcName, "calling hideMonitorsNotInUse()")
    hideMonitorsNotInUse()
    
  EndWith
  
  debugMsg(sProcName, #SCS_END + ", returning #True")
  ProcedureReturn #True
  
EndProcedure

Procedure playSubTypeE(pSubPtr, bCalledFromEditor)
  ; SubType E = Memo
  PROCNAMECS(pSubPtr)
  Protected nVidPicTarget, nPrevSubPtr, nUseScreenNo, bDisplayOnMainPanel
  Protected nActiveWindow
  
  debugMsg(sProcName, #SCS_START)
  
  If pSubPtr >= 0
    If bCalledFromEditor = #False
      nActiveWindow = GetActiveWindow() ; added 16Jun2019 11.8.1.3ab
      With aSub(pSubPtr)
        \qTimeSubStarted = gqTimeNow
        \qAdjTimeSubStarted = gqTimeNow
        \bTimeSubStartedSet = #True
        \qTimeSubRestarted = \qTimeSubStarted
        \nSubTotalTimeOnPause = 0
        \nSubPriorTimeOnPause = 0
        \nSubState = #SCS_CUE_PLAYING
        setCueState(\nCueIndex)
        updateGrid(\nCueIndex)
        nUseScreenNo = \nMemoScreen
        If nUseScreenNo > gnScreens
          nUseScreenNo = gnScreens
        EndIf
        If nUseScreenNo = 1
          Select grProd\nMemoDispOptForPrim
            Case #SCS_MEMO_DISP_PRIM_POPUP
              ; apply default action
            Case #SCS_MEMO_DISP_PRIM_SHARE_CUE_LIST
              If getVisible(WMN\splCueListMemo)
                bDisplayOnMainPanel = #True
              EndIf
            Case #SCS_MEMO_DISP_PRIM_SHARE_MAIN
              If getVisible(WMN\splMainMemo)
                bDisplayOnMainPanel = #True
              EndIf
          EndSelect
          If bDisplayOnMainPanel
            nPrevSubPtr = grMain\nMainMemoSubPtr
            debugMsg(sProcName, "calling WEN_displayMemoInMainMemoPanel(" + getSubLabel(pSubPtr) + ")")
            WEN_displayMemoInMainMemoPanel(pSubPtr)
          Else
            nPrevSubPtr = grWEN\nMainSubPtr
            debugMsg(sProcName, "calling WEN_Form_Show(#WE1, " + getSubLabel(pSubPtr) + ")")
            WEN_Form_Show(#WE1, pSubPtr)
          EndIf
          If nPrevSubPtr >= 0
            If (aSub(nPrevSubPtr)\bSubTypeE) And (aSub(nPrevSubPtr)\nSubState < #SCS_CUE_COMPLETED)
              debugMsg(sProcName, "calling stopSub(" + getSubLabel(nPrevSubPtr) + ", 'E', #True, #False)")
              stopSub(nPrevSubPtr, "E", #True, #False)
            EndIf
          EndIf
        Else
          nVidPicTarget = #SCS_VID_PIC_TARGET_F2 + nUseScreenNo - 2
          WEN_displayMemoOnSecondaryScreen(pSubPtr, nVidPicTarget)
        EndIf
        resetActiveWindowIfReqd(nActiveWindow) ; above modified 16Jun2019 11.8.1.3ab
        SAG(-1)
      EndWith
    EndIf
  EndIf
  
  debugMsg(sProcName, #SCS_END + ", returning #True")
  ProcedureReturn #True
  
EndProcedure

Procedure playSubTypeF(pSubPtr, bCalledFromEditor, bUseCas, nCasGroupId)
  ; SubType F = Audio File
  PROCNAMECS(pSubPtr)
  Protected k, k2
  Protected nMyBassChannel.l
  Protected dSyncPosSecs.d
  Protected qSyncPosBytes.q   ; quad
  Protected nCuePtr
  Protected nSyncType.l, sSyncType.s
  
  debugMsg(sProcName, #SCS_START)
  
  With aSub(pSubPtr)
    
    debugMsg(sProcName, "\nSubState=" + decodeCueState(\nSubState) + ", \nCueState=" + decodeCueState(aCue(\nCueIndex)\nCueState))
    If (\nSubState = #SCS_CUE_PLAYING) Or (\nSubState = #SCS_CUE_FADING_IN) Or (\nSubState = #SCS_CUE_FADING_OUT)
      ; probably a hotkey cue currently playing
      If ((\bHotkey) Or (\bExtAct) Or (\bCallableCue)) And (\nPrevSubIndex = -1)
        debugMsg(sProcName, "\nSubState=" + decodeCueState(\nSubState) + ", calling stopSub(" + pSubPtr + ")")
        stopSub(pSubPtr, "F", #True, #False)
      Else
        ; cue already playing - ignore this 'playsub' request
        ProcedureReturn #False
      EndIf
    EndIf
    
    ; If \nSubState = #SCS_CUE_SUB_COUNTDOWN_TO_START
      ; ; initially set to nSubState to SCS_CUE_PLAYING so setCueState will drill down to any aud's to determine state
      ; \nSubState = #SCS_CUE_PLAYING
    ; EndIf
    
    ; If gbUseBASSMixer
    If \bLockMixerStreamsOnPlaySub
      lockAllMixerStreams(#True)
    EndIf
    
    If \nFirstAudIndex >= 0
      k = \nFirstAudIndex
      aAud(k)\bIgnoreInStatusCheck = #False
      ; debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\bIgnoreInStatusCheck=" + strB(aAud(k)\bIgnoreInStatusCheck))
      aAud(k)\nCurrFadeInTime = aAud(k)\nFadeInTime
      ; debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nCurrFadeInTime=" + aAud(k)\nCurrFadeInTime)
      aAud(k)\nCurrFadeOutTime = aAud(k)\nFadeOutTime
      aAud(k)\nBassLinkPosSync = 0
      aAud(k)\bWaitForLinkSyncPos = #False
      
      If aAud(k)\nAudLinkCount > 0
        For k2 = aAud(k)\nFirstAudLink To gnLastAud
          If aAud(k2)\nLinkedToAudPtr = k
            If aAud(k2)\bExists
              aAud(k2)\bIgnoreInStatusCheck = #False
              ; debugMsg(sProcName, "aAud(" + getAudLabel(k2) + ")\bIgnoreInStatusCheck=" + strB(aAud(k2)\bIgnoreInStatusCheck))
              aAud(k2)\nCurrFadeInTime = aAud(k2)\nFadeInTime
              ; debugMsg(sProcName, "aAud(" + getAudLabel(k2) + ")\nCurrFadeInTime=" + aAud(k2)\nCurrFadeInTime)
              aAud(k2)\nCurrFadeOutTime = aAud(k2)\nFadeOutTime
              aAud(k2)\nBassLinkPosSync = 0
              aAud(k2)\bWaitForLinkSyncPos = #False
            EndIf
          EndIf
        Next k2
      EndIf
    
      ; debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nAudLinkCount=" + Str(aAud(k)\nAudLinkCount) + ", \nFirstAudLink=" + getAudLabel(aAud(k)\nFirstAudLink))
      If (gdResetPosForLinked > 0) And (gbUseBASS)
        If (aAud(k)\nAudLinkCount > 0) And (aAud(k)\nFirstSoundingDev >= 0)
          
          ; nMyBassChannel = aAud(k)\nBassChannel[aAud(k)\nFirstSoundingDev]
          ; 28Dec2015 - changed aAud(k)\nBassChannel[aAud(k)\nFirstSoundingDev] to aAud(k)\nSourceChannel as Ian recommends using the source channel
          ; (see see Ian's reply to my BASS Forum posting "BASS_ChannelLock hangs")
          nMyBassChannel = aAud(k)\nSourceChannel
          
          debugMsg3(sProcName, "gdResetPosForLinked=" + StrD(gdResetPosForLinked,4) + ", aAud(" + getAudLabel(k) + ")\nAbsStartAt=" + Str(aAud(k)\nAbsStartAt) + ", \nManualOffset=" + Str(aAud(k)\nManualOffset))
          dSyncPosSecs = (aAud(k)\nAbsStartAt + aAud(k)\nManualOffset) / 1000.0
          dSyncPosSecs + gdResetPosForLinked
          qSyncPosBytes = BASS_ChannelSeconds2Bytes(nMyBassChannel, dSyncPosSecs)
          ; added BASS_SYNC_MIXTIME 23Sep2016 11.5.2.2 in line with changes in setBassPlayEnd() and setBassLoopEnd(), q.v.
          If gbUseBASSMixer
            nSyncType = #BASS_SYNC_POS|#BASS_SYNC_ONETIME|#BASS_SYNC_MIXTIME
            sSyncType = "BASS_SYNC_POS|BASS_SYNC_ONETIME|BASS_SYNC_MIXTIME"
          Else
            nSyncType = #BASS_SYNC_POS|#BASS_SYNC_ONETIME
            sSyncType = "BASS_SYNC_POS|BASS_SYNC_ONETIME"
          EndIf
          aAud(k)\nBassLinkPosSync = BASS_ChannelSetSync(nMyBassChannel, nSyncType, qSyncPosBytes, @SyncProcLinkPos(), k)
          newHandle(#SCS_HANDLE_SYNC, aAud(k)\nBassLinkPosSync)
          debugMsg2(sProcName, "BASS_ChannelSetSync(" + decodeHandle(nMyBassChannel) + ", " + sSyncType + ", " + Str(qSyncPosBytes) + ", @SyncProcLinkPos(), " + getAudLabel(k) + ")", aAud(k)\nBassLinkPosSync)
          aAud(k)\bWaitForLinkSyncPos = #True
        EndIf
      EndIf
      
      If \bStartedInEditor = #False
        If aAud(k)\bResetFilePosToStartAtInMain
          debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\bResetFilePosToStartAtInMain=" + strB(aAud(k)\bResetFilePosToStartAtInMain))
          debugMsg(sProcName, "calling setAudChannelPositions(" + getAudLabel(k) + ", " + ttszt(aAud(k)\nAbsStartAt) + ")")
          setAudChannelPositions(k, aAud(k)\nAbsStartAt)
          aAud(k)\bResetFilePosToStartAtInMain = #False
          debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\bResetFilePosToStartAtInMain=" + strB(aAud(k)\bResetFilePosToStartAtInMain))
        EndIf
      EndIf
;       aAud(k)\bResetFilePosToStartAtInMain = #False
;       debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\bResetFilePosToStartAtInMain=" + strB(aAud(k)\bResetFilePosToStartAtInMain))
      
      ; modified 15Nov2017 11.6.2.2ab
      ; debugMsg(sProcName, "calling playAud(" + getAudLabel(k) + ")")
      ; playAud(k, bUseCas, #False, nCasGroupId)
      debugMsg(sProcName, "calling playAud(" + getAudLabel(k) + ", " + strB(bUseCas) + ", #False, " + nCasGroupId + ", #True)")
      playAud(k, bUseCas, #False, nCasGroupId, #True)   ; set bTopLevelCall = #True to force SM-S play to be issued
      ; end modified 15Nov2017 11.6.2.2ab
    EndIf
    
    ; If gbUseBASSMixer
    If \bLockMixerStreamsOnPlaySub
      lockAllMixerStreams(#False)
    EndIf
    
    debugMsg(sProcName, "calling setCueState(" + getCueLabel(\nCueIndex) + ", #True)")
    setCueState(\nCueIndex, #True)
    samAddRequest(#SCS_SAM_LOAD_GRID_ROW, \nCueIndex)
    
  EndWith
  
  ProcedureReturn #True
  
EndProcedure

Procedure playSubTypeG(pSubPtr, bCalledFromEditor)
  ; SubType G = Go To Cue
  PROCNAMECS(pSubPtr)
  Protected nMyCueIndex
  Protected bHoldFlag
  
  debugMsg(sProcName, #SCS_START)
  
  bHoldFlag = gbProcessingSubTypeG    ; bHoldFlag allows for possible, although hopefully unlikely, recursion, ie GoTo a GoTo cue
  gbProcessingSubTypeG = #True
  
  With aSub(pSubPtr)
    debugMsg(sProcName, "calling goToCueLabel(" + \sCueToGoTo + ", #False)")
    nMyCueIndex = goToCueLabel(\sCueToGoTo, #False)
    If nMyCueIndex < 0
      WMN_setStatusField(LangPars("Errors", "CueNotFound", \sCueToGoTo), #SCS_STATUS_ERROR)
    Else
      If \bGoToCueButDoNotStartIt
        debugMsg(sProcName, "calling GoToCue(" + getCueLabel(nMyCueIndex) + ")")
        GoToCue(nMyCueIndex)
      Else
        debugMsg(sProcName, "calling playCueViaCas(" + getCueLabel(nMyCueIndex) + ")")
        playCueViaCas(nMyCueIndex)
      EndIf
    EndIf
    If aCue(\nCueIndex)\bNonLinearCue
      endOfSub(pSubPtr, #SCS_CUE_READY)
    ; added 28Dec2019 11.8.2.1aq following email from KAI (AV FantaSea) where a TBC cue was constantly counting down due to the order and sequence of the cues, which wasn't right anyway for what KAI wanted to do!
    ElseIf aCue(\nCueIndex)\nActivationMethodReqd = #SCS_ACMETH_TIME
      endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
    ; end added 28Dec2019 11.8.2.1aq
    ElseIf aCue(\nCueIndex)\nActivationMethodReqd = #SCS_ACMETH_HK_STEP
      endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
    Else
      If (\bHotkey) Or (\bExtAct) Or (\bCallableCue) Or (nMyCueIndex < \nCueIndex)
        endOfSub(pSubPtr, #SCS_CUE_READY)
      Else
        endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
      EndIf
    EndIf
    setCueState(\nCueIndex)
    updateGrid(\nCueIndex)
    aCue(\nCueIndex)\bStopOpenNextCuesHere = #True
    debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\bStopOpenNextCuesHere=#True")
  EndWith
  
  gbProcessingSubTypeG = bHoldFlag
  
  ProcedureReturn #True
  
EndProcedure

Procedure playSubTypeI(pSubPtr, bCalledFromEditor)
  ; SubType I = Live Input (eg microphone)
  PROCNAMECS(pSubPtr)
  Protected k
  
  debugMsg(sProcName, #SCS_START)
  
  With aSub(pSubPtr)
    If \nFirstAudIndex >= 0
      k = \nFirstAudIndex
      aAud(k)\bIgnoreInStatusCheck = #False
      ; debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\bIgnoreInStatusCheck=" + strB(aAud(k)\bIgnoreInStatusCheck))
      aAud(k)\nCurrFadeInTime = aAud(k)\nFadeInTime
      aAud(k)\nCurrFadeOutTime = aAud(k)\nFadeOutTime
      aAud(k)\nBassLinkPosSync = 0
      aAud(k)\bWaitForLinkSyncPos = #False
      debugMsg(sProcName, "calling playAud(" + getAudLabel(k) + ")")
      playAud(k)
    EndIf
    debugMsg(sProcName, "calling setCueState(" + \nCueIndex + ", #True)")
    setCueState(\nCueIndex, #True)
    samAddRequest(#SCS_SAM_LOAD_GRID_ROW, \nCueIndex)
  EndWith
  
  ProcedureReturn #True
  
EndProcedure

Procedure playSubTypeJ(pSubPtr, bCalledFromEditor)
  ; SubType J = Enable/Disable a Cue
  PROCNAMECS(pSubPtr)
  Protected sFirstCue.s, sLastCue.s
  Protected nFirstCuePtr, nLastCuePtr
  Protected bEnable, nCuesChanged, nCuesChangedThisCall
  Protected n
  Protected nThisCuePtr
  
  debugMsg(sProcName, #SCS_START)
  
  If pSubPtr >= 0
    nThisCuePtr = aSub(pSubPtr)\nCueIndex
    For n = 0 To #SCS_MAX_ENABLE_DISABLE
      With aSub(pSubPtr)\aEnableDisable[n]
        sFirstCue = \sFirstCue
        nFirstCuePtr = getCuePtr(sFirstCue)
        If nFirstCuePtr >= 0
          sLastCue = \sLastCue
          nLastCuePtr = getCuePtr(sLastCue)
          If nLastCuePtr < 0
            nLastCuePtr = nFirstCuePtr
          EndIf
          If nLastCuePtr >= nFirstCuePtr
            Select \nAction
              Case #SCS_ENADIS_ENABLE
                bEnable = #True
              Case #SCS_ENADIS_DISABLE
                bEnable = #False
              Default
                ; shouldn't get here
                Continue
            EndSelect
            debugMsg(sProcName, "calling EnableDisableCues(" + strB(bEnable) + ", " + getCueLabel(nFirstCuePtr) + ", " + getCueLabel(nLastCuePtr) + ", " + getCueLabel(nThisCuePtr) + ")")
            nCuesChangedThisCall = EnableDisableCues(bEnable, nFirstCuePtr, nLastCuePtr, nThisCuePtr)
            nCuesChanged + nCuesChangedThisCall
          EndIf
        EndIf
      EndWith
    Next n
    
    With aSub(pSubPtr)
;       If aCue(\nCueIndex)\bNonLinearCue
;         endOfSub(pSubPtr, #SCS_CUE_READY)
;       Else
;         endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
;       EndIf
      setSubStateForEndOfSub(pSubPtr, #SCS_CUE_READY) ; Changed from the above 23May2025 11.10.8bc
      setCueState(\nCueIndex)
      updateGrid(\nCueIndex)
    EndWith
    
    ; Added 1Feb2021 11.8.3.5 - see comments in EnableDisableCues()
    If nCuesChanged > 0
      debugMsg(sProcName, "calling setCueDetailsInMain()")
      setCueDetailsInMain()
      debugMsg(sProcName, "calling ONC_openNextCues()")
      ONC_openNextCues()
    EndIf
    ; End added 1Feb2021 11.8.3.5
    
  EndIf
  
  debugMsg(sProcName, #SCS_END)
  
  ProcedureReturn #True
  
EndProcedure

Procedure playSubTypeK(pSubPtr, bCalledFromEditor, bUsePreHotkeyValues=#False, bCalculatingDMXStartValuesOnly=#False)
  ; SubType K = Lighting
  PROCNAMECS(pSubPtr)
  Protected bDMXValueChange
  Protected bDMXSendMutexLocked
  Protected nSubLength
  Protected sLightingInfoMsg.s
  Protected nInfoStatus = #SCS_STATUS_CLEAR
  Protected bLockedMutex
  Protected bSetPreSubValues
  Protected bSetPlayingState
  Protected bSavePreHotkeyNoteValues
  Protected nCuePtr
  Protected nCalledBySubPtr, nCalledByCuePtr
  Protected bStopChase, m, n
  Protected nMyMaxChaseStepIndex, nMyMaxDMXSendItem
  Protected nDMXPercentage
  
  debugMsg(sProcName, #SCS_START + ", bCalledFromEditor=" + strB(bCalledFromEditor) + ", bUsePreHotkeyValues=" + strB(bUsePreHotkeyValues) + ", bCalculatingDMXStartValuesOnly=" + strB(bCalculatingDMXStartValuesOnly))
  
  traceDMXChannelItems(#cTraceDMXLoadChannelInfo)
  
  With grDMXChaseItems
    If \bChaseRunning
      If \nChaseSubPtr <> pSubPtr
        If \bNextLTStopsChase
          ; the chase sub-cue (\nChaseSubPtr) has the property set for 'next lighting cue stops chase'
          bStopChase = #True
          debugMsg(sProcName, "next lighting cue stops chase")
        Else
          ; check to see if this sub-cue (pSubPtr) contains a DBO item, and if so then stop the current chase
          nMyMaxChaseStepIndex = aSub(pSubPtr)\nMaxChaseStepIndex
          For m = 0 To nMyMaxChaseStepIndex
            ; For n = 0 To #SCS_MAX_DMX_ITEM_PER_LIGHTING_SUB ; Deleted 19Dec2020 11.8.3.4ac, replaced constant by nMyMaxDMXSendItem (calculated below)
            nMyMaxDMXSendItem = aSub(pSubPtr)\aChaseStep(m)\nDMXSendItemCount-1
            debugMsg(sProcName, "m=" + m + ", nMyMaxDMXSendItem=" + nMyMaxDMXSendItem)
            For n = 0 To nMyMaxDMXSendItem
              If aSub(pSubPtr)\aChaseStep(m)\aDMXSendItem(n)\bDBO
                bStopChase = #True
                debugMsg(sProcName, "DBO stops chase")
                Break 2 ; Break n and m
              EndIf
            Next n
          Next m
        EndIf
        If bStopChase
          debugMsg(sProcName, "calling stopSub(" + getSubLabel(\nChaseSubPtr) + ", 'K', #False, #False)")
          stopSub(\nChaseSubPtr, "K", #False, #False)
        EndIf
      EndIf
    EndIf
  EndWith
  
  With aSub(pSubPtr)
    \nSubState = #SCS_CUE_PLAYING ; prevents statusChecks() re-calling playSub()
    \bCalculatingDMXStartValuesOnly = bCalculatingDMXStartValuesOnly ; Added 30Sep2024 11.10.6ad
    ; debugMsg(sProcName, "\bDMXSend=" + strB(\bDMXSend) + ", grSession\nDMXOutEnabled=" + grSession\nDMXOutEnabled)
    If \bDMXSend
      If grSession\nDMXOutEnabled = #SCS_DEVTYPE_ENABLED
        \nDMXControlPtr = DMX_getDMXControlPtrForLogicalDev(\nLTDevType, \sLTLogicalDev)  ; added 17Jan2017 11.5.4 following error reported by Simon Paulekuhn
        LockDMXSendMutex(610)
        bDMXSendMutexLocked = #True
        If \bChase = #False
          ; debugMsg(sProcName, "grDMX\bLoadPreCueDMXValuesIfReqd=" + strB(grDMX\bLoadPreCueDMXValuesIfReqd))
          If grDMX\bLoadPreCueDMXValuesIfReqd
            If (\nLTEntryType = #SCS_LT_ENTRY_TYPE_DMX_ITEMS And \nLTDIFadeOutOthersAction = #SCS_DMX_DI_FADE_ACTION_DO_NOT_FADEOUTOTHERS) Or
               (\nLTEntryType = #SCS_LT_ENTRY_TYPE_FIXTURE_ITEMS And \nLTFIFadeOutOthersAction = #SCS_DMX_FI_FADE_ACTION_DO_NOT_FADEOUTOTHERS)
              bSetPreSubValues = #True
            EndIf
            grDMX\bLoadPreCueDMXValuesIfReqd = #False
          EndIf
        EndIf
        If bCalledFromEditor = #False
          nCuePtr = \nCueIndex
          debugMsg(sProcName, "aCue(" + getCueLabel(nCuePtr) + ")\nActivationMethod=" + decodeActivationMethod(aCue(nCuePtr)\nActivationMethod))
          Select aCue(nCuePtr)\nActivationMethod
            Case #SCS_ACMETH_HK_NOTE, #SCS_ACMETH_EXT_NOTE
              bSetPlayingState = #True
              bSavePreHotkeyNoteValues = #True
            Case #SCS_ACMETH_HK_TOGGLE, #SCS_ACMETH_EXT_TOGGLE
              bSavePreHotkeyNoteValues = #True
            Case #SCS_ACMETH_CALL_CUE
              nCalledBySubPtr = aCue(nCuePtr)\nCalledBySubPtr
              ; debugMsg(sProcName, "aCue(" + getCueLabel(nCuePtr) + ")\nCalledBySubPtr=" + getSubLabel(nCalledBySubPtr))
              If nCalledBySubPtr >= 0
                nCalledByCuePtr = aSub(nCalledBySubPtr)\nCueIndex
                Select aCue(nCalledByCuePtr)\nActivationMethod
                  Case #SCS_ACMETH_HK_NOTE, #SCS_ACMETH_EXT_NOTE
                    bSetPlayingState = #True
                    bSavePreHotkeyNoteValues = #True
                  Case #SCS_ACMETH_HK_TOGGLE, #SCS_ACMETH_EXT_TOGGLE
                    bSavePreHotkeyNoteValues = #True
                EndSelect
              EndIf
          EndSelect
          ; Added 13Jun2024 11.10.3al
          If bUsePreHotkeyValues
            bSavePreHotkeyNoteValues = #False
          EndIf
          ; End added 13Jun2024 11.10.3al
          ; debugMsg(sProcName, "bSetPlayingState=" + strB(bSetPlayingState) + ", bSavePreHotkeyNoteValues=" + strB(bSavePreHotkeyNoteValues))
        EndIf
        nSubLength = getSubLength(pSubPtr)  ; reinstated 20Sep2016 11.5.2.1 (was incorrectly removed in 11.5.2, which resulted in nSubLength remaining 0, causing the sub to be ended immediately)
        If \bChase
          Select \nLTEntryType
            Case #SCS_LT_ENTRY_TYPE_DMX_ITEMS, #SCS_LT_ENTRY_TYPE_DMX_CAPTURE_SEQ, #SCS_LT_ENTRY_TYPE_DMX_CAPTURE_SNAP
              ; debugMsg(sProcName, "calling DMX_loadDMXChaseItems(" + getSubLabel(pSubPtr) + ")")
              DMX_loadDMXChaseItems(pSubPtr)
            Default
              ; debugMsg(sProcName, "calling DMX_loadDMXChaseItemsFI(" + getSubLabel(pSubPtr) + ")")
              DMX_loadDMXChaseItemsFI(pSubPtr)
          EndSelect
          bSetPlayingState = #True
        Else
          If aCue(\nCueIndex)\nActivationMethod = #SCS_ACMETH_EXT_FADER
            If \bLTApplyCurrValuesAsMins
              primeSubLTCurrChanValueArray(pSubPtr, #True)
            Else
              \nLTMaxCurrChanValue = -1
            EndIf
            nDMXPercentage = 0
;             ; debugMsg(sProcName, "calling DMX_prepareDMXForSend(" + getSubLabel(pSubPtr) + ", " + strB(bDMXSendMutexLocked) + ", #False, " + strB(bSetPreSubValues) + ", #False, #False, 0, " + strB(bSavePreHotkeyNoteValues) + ", #False, " + nDMXPercentage + ")")
;             bDMXValueChange = DMX_prepareDMXForSend(pSubPtr, bDMXSendMutexLocked, #False, bSetPreSubValues, #False, #False, 0, bSavePreHotkeyNoteValues, #False, nDMXPercentage)
            debugMsg(sProcName, "calling DMX_prepareDMXForSend(" + getSubLabel(pSubPtr) + ", " + strB(bDMXSendMutexLocked) + ", " + strB(bUsePreHotkeyValues) + ", " + strB(bSetPreSubValues) + ", #False, #False, 0, " + strB(bSavePreHotkeyNoteValues) + ", #False, " + nDMXPercentage + ")")
            bDMXValueChange = DMX_prepareDMXForSend(pSubPtr, bDMXSendMutexLocked, #False, bSetPreSubValues, #False, #False, 0, bSavePreHotkeyNoteValues, bUsePreHotkeyValues, nDMXPercentage)
            ; If under the control of an external fader, then leave the sub (and therefore the cue) as 'playing'
            bSetPlayingState = #True
          Else
            debugMsg(sProcName, "calling DMX_prepareDMXForSend(" + getSubLabel(pSubPtr) + ", " + strB(bDMXSendMutexLocked) + ", #False, " + strB(bSetPreSubValues) + ", #False, #False, 0, " + strB(bSavePreHotkeyNoteValues) +
                                ", " + strB(bUsePreHotkeyValues) + ")")
            bDMXValueChange = DMX_prepareDMXForSend(pSubPtr, bDMXSendMutexLocked, #False, bSetPreSubValues, #False, #False, 0, bSavePreHotkeyNoteValues, bUsePreHotkeyValues) ; Added bUsePreHotkeyValues 13Jun2024 11.10.3al
          EndIf
        EndIf
        grDMX\bDMXReadyToSend = #True ; must be set (or cleared) while gnDMXSendMutex is locked
        ; debugMsg(sProcName, "grDMX\bDMXReadyToSend=" + strB(grDMX\bDMXReadyToSend))
        UnlockDMXSendMutex()
        bDMXSendMutexLocked = #False
        If gbInCalcCueStartValues = #False
          If THR_getThreadState(#SCS_THREAD_DMX_SEND) <> #SCS_THREAD_STATE_ACTIVE
            debugMsg3(sProcName, "calling THR_createOrResumeAThread(#SCS_THREAD_DMX_SEND)")
            THR_createOrResumeAThread(#SCS_THREAD_DMX_SEND)
          EndIf
        EndIf
        
      EndIf
      
      Select grSession\nDMXOutEnabled
        Case #SCS_DEVTYPE_DISABLED
          sLightingInfoMsg = "DMX NOT SENT - DMX Send currently disabled"
          nInfoStatus = #SCS_STATUS_WARN
        Case #SCS_DEVTYPE_NOT_REQD
          sLightingInfoMsg = "DMX NOT SENT - no DMX connection open"
          nInfoStatus = #SCS_STATUS_ERROR
      EndSelect
      
      If bSetPlayingState
        \nSubState = #SCS_CUE_PLAYING
      ElseIf nSubLength = 0
        setSubStateForEndOfSub(pSubPtr, #SCS_CUE_NOT_LOADED)
      EndIf
      
      If bCalledFromEditor = #False
        If nInfoStatus <> #SCS_STATUS_CLEAR
          ; debugMsg(sProcName, "calling WMN_setStatusField(" + nInfoStatus + ")")
          WMN_setStatusField(" " + sLightingInfoMsg, nInfoStatus)
        EndIf
      EndIf
      ; debugMsg(sProcName, "calling setCueState(" + \nCueIndex + ")")
      setCueState(\nCueIndex)
      samAddRequest(#SCS_SAM_LOAD_GRID_ROW, \nCueIndex)
      
    EndIf
    
  EndWith
  
  traceDMXChannelItems(#cTraceDMXLoadChannelInfo)
  
ProcedureReturn #True
  
EndProcedure

Procedure playExtFaderSubTypeK(pSubPtr, nDMXPercentage)
  PROCNAMECS(pSubPtr)
  Protected bLockedMutex
  Protected bDMXSendMutexLocked, bDMXValueChange
  
  ; debugMsg0(sProcName, #SCS_START + ", nDMXPercentage=" + nDMXPercentage)
  
  With aSub(pSubPtr)
    If \nSubState >= #SCS_CUE_FADING_IN And \nSubState <= #SCS_CUE_FADING_OUT
      If \bDMXSend
        If grSession\nDMXOutEnabled = #SCS_DEVTYPE_ENABLED
          \nDMXControlPtr = DMX_getDMXControlPtrForLogicalDev(\nLTDevType, \sLTLogicalDev)  ; added 17Jan2017 11.5.4 following error reported by Simon Paulekuhn
          LockDMXSendMutex(610)
          bDMXSendMutexLocked = #True
          ; debugMsg(sProcName, "calling DMX_prepareDMXForSend(" + getSubLabel(pSubPtr) + ", " + strB(bDMXSendMutexLocked) + ", #False, #False, #False, #False, 0, #False, #False, " + nDMXPercentage + ")")
          bDMXValueChange = DMX_prepareDMXForSend(pSubPtr, bDMXSendMutexLocked, #False, #False, #False, #False, 0, #False, #False, nDMXPercentage)
          grDMX\bDMXReadyToSend = #True ; must be set (or cleared) while gnDMXSendMutex is locked
          UnlockDMXSendMutex()
          bDMXSendMutexLocked = #False
          If gbInCalcCueStartValues = #False
            If THR_getThreadState(#SCS_THREAD_DMX_SEND) <> #SCS_THREAD_STATE_ACTIVE
              ; debugMsg3(sProcName, "calling THR_createOrResumeAThread(#SCS_THREAD_DMX_SEND)")
              THR_createOrResumeAThread(#SCS_THREAD_DMX_SEND)
            EndIf
          EndIf
        EndIf
      EndIf
    EndIf
  EndWith
  
EndProcedure

Procedure primeSubLTCurrChanValueArray(pSubPtr, bLoadCurrentValues)
  PROCNAMECS(pSubPtr)
  Protected nProdDevNo, nChaseStepIndex, nFixtureIndex, sFixtureCode.s, nFixtureRunTimeIndex, nFixTypeIndex, nTotalChans, nDMXStartChannel, nChanIndex, nRelChanNo, nDMXChannel, nDevStartChannelIndex
  Protected bChannelDimmable
  Protected n, nCurrChanIndex
  
  If grLicInfo\bExtFaderCueControlAvailable
    aSub(pSubPtr)\nLTMaxCurrChanValue = -1
    nProdDevNo = getDevNoForLogicalDev(@grProd, #SCS_DEVGRP_LIGHTING, aSub(pSubPtr)\sLTLogicalDev)
    nChaseStepIndex = 0 ; nb chase not available for external fader control of lighting cue, so only 'chase step' 0 is used
    For nFixtureIndex = 0 To aSub(pSubPtr)\nMaxFixture
      sFixtureCode = aSub(pSubPtr)\aLTFixture(nFixtureIndex)\sLTFixtureCode
      If sFixtureCode
        With aSub(pSubPtr)\aChaseStep(nChaseStepIndex)\aFixtureItem(nFixtureIndex)
          If \sFixtureCode = sFixtureCode
            ; should be #True
            nFixtureRunTimeIndex = DMX_getFixturesRunTimeIndex(nProdDevNo, sFixtureCode)
            If nFixtureRunTimeIndex >= 0
              ; should be #True
              nFixTypeIndex = grFixturesRunTime\aFixtureRunTime(nFixtureRunTimeIndex)\nFixTypeIndex
              nTotalChans = grFixturesRunTime\aFixtureRunTime(nFixtureRunTimeIndex)\nTotalChans
              For nDevStartChannelIndex = 0 To grFixturesRunTime\aFixtureRunTime(nFixtureRunTimeIndex)\nMaxDevStartChannelIndex
                nDMXStartChannel = grFixturesRunTime\aFixtureRunTime(nFixtureRunTimeIndex)\aDevStartChannel(nDevStartChannelIndex)
                ; nDMXStartChannel = grFixturesRunTime\aFixtureRunTime(nFixtureRunTimeIndex)\nDMXStartChannel
                For nChanIndex = 0 To nTotalChans-1
                  If \aFixChan(nChanIndex)\bRelChanIncluded
                    nRelChanNo = \aFixChan(nChanIndex)\nRelChanNo
                    bChannelDimmable = DMX_getFixTypeChanDimmable(nFixTypeIndex, nRelChanNo)
                    If bChannelDimmable
                      nDMXChannel = nDMXStartChannel + nRelChanNo - 1
                      nCurrChanIndex = -1
                      For n = 0 To aSub(pSubPtr)\nLTMaxCurrChanValue
                        If aSub(pSubPtr)\aLTCurrChanValue(n)\nDMXChannel = nDMXChannel
                          nCurrChanIndex = n
                          Break
                        EndIf
                      Next n
                      If nCurrChanIndex = -1
                        aSub(pSubPtr)\nLTMaxCurrChanValue + 1
                        nCurrChanIndex = aSub(pSubPtr)\nLTMaxCurrChanValue
                        If nCurrChanIndex > ArraySize(aSub(pSubPtr)\aLTCurrChanValue())
                          ReDim aSub(pSubPtr)\aLTCurrChanValue(nCurrChanIndex+10)
                        EndIf
                        aSub(pSubPtr)\aLTCurrChanValue(nCurrChanIndex)\nDMXChannel = nDMXChannel
                      EndIf
                      If bLoadCurrentValues
                        aSub(pSubPtr)\aLTCurrChanValue(nCurrChanIndex)\nDMXValue = gaDMXSendData(nDMXChannel)
                      Else
                        aSub(pSubPtr)\aLTCurrChanValue(nCurrChanIndex)\nDMXValue = 0
                      EndIf
                      debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\aLTCurrChanValue(" + nCurrChanIndex + ")\nDMXChannel=" + nDMXChannel + ", \nDMXValue=" + aSub(pSubPtr)\aLTCurrChanValue(nCurrChanIndex)\nDMXValue)
                    EndIf ; EndIf bChannelDimmable
                  EndIf   ; EndIf \aFixChan(nChanIndex)\bRelChanIncluded
                Next nChanIndex
              Next nDevStartChannelIndex
            EndIf ; EndIf nFixtureRunTimeIndex >= 0
          EndIf ; EndIf \sFixtureCode = sFixtureCode
        EndWith
      EndIf ; EndIf sFixtureCode
    Next nFixtureIndex
  EndIf ; EndIf grLicInfo\bExtFaderCueControlAvailable
  
EndProcedure

Procedure resetHotkeyDMXValues(pSubPtr)
  PROCNAMECS(pSubPtr)
  ; for note hotkey cues, resets DMX channel values as they were when the cue was started (eg at key down)
  Protected bDMXValueChange
  Protected bDMXSendMutexLocked
  Protected sLightingInfoMsg.s
  Protected nInfoStatus = #SCS_STATUS_CLEAR
  Protected bLockedMutex
  
  With aSub(pSubPtr)
    If \bDMXSend
      If grSession\nDMXOutEnabled = #SCS_DEVTYPE_ENABLED
        LockDMXSendMutex(620)
        bDMXSendMutexLocked = #True
        If \bChase
          debugMsg(sProcName, "calling DMX_stopChaseIfReqd(" + getSubLabel(pSubPtr) + ")")
          DMX_stopChaseIfReqd(pSubPtr)
        Else
          ; note that in the following call, the parameter 'bUseHotkeyNote' is #True so that the pre-hotkey-note DMX values will be reinstated
          debugMsg(sProcName, "calling DMX_prepareDMXForSend(" + getSubLabel(pSubPtr) + ", " + strB(bDMXSendMutexLocked) + ", #False, #False, #False, #False, 0, #False, #True)")
          bDMXValueChange = DMX_prepareDMXForSend(pSubPtr, bDMXSendMutexLocked, #False, #False, #False, #False, 0, #False, #True)
        EndIf
        grDMX\bDMXReadyToSend = #True ; must be set (or cleared) while gnDMXSendMutex is locked
        debugMsg(sProcName, "grDMX\bDMXReadyToSend=" + strB(grDMX\bDMXReadyToSend))
        UnlockDMXSendMutex()
        bDMXSendMutexLocked = #False
        If gbInCalcCueStartValues = #False
          If THR_getThreadState(#SCS_THREAD_DMX_SEND) <> #SCS_THREAD_STATE_ACTIVE
            debugMsg3(sProcName, "calling THR_createOrResumeAThread(#SCS_THREAD_DMX_SEND)")
            THR_createOrResumeAThread(#SCS_THREAD_DMX_SEND)
          EndIf
        EndIf
      EndIf
      
      Select grSession\nDMXOutEnabled
        Case #SCS_DEVTYPE_DISABLED
          sLightingInfoMsg = "DMX NOT SENT - DMX Send currently disabled"
          nInfoStatus = #SCS_STATUS_WARN
        Case #SCS_DEVTYPE_NOT_REQD
          sLightingInfoMsg = "DMX NOT SENT - no DMX connection open"
          nInfoStatus = #SCS_STATUS_ERROR
      EndSelect
      
;       If \bStartedInEditor
;         endOfSub(pSubPtr, #SCS_CUE_READY)
;       ElseIf aCue(\nCueIndex)\bNonLinearCue
;         endOfSub(pSubPtr, #SCS_CUE_NOT_LOADED)
;       Else
;         If \bHotkey Or \bExtAct Or \bCallableCue
;           endOfSub(pSubPtr, #SCS_CUE_READY)
;         Else
;           endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
;         EndIf
;       EndIf
      setSubStateForEndOfSub(pSubPtr, #SCS_CUE_NOT_LOADED)
      
      If \bStartedInEditor = #False
        If nInfoStatus <> #SCS_STATUS_CLEAR
          debugMsg(sProcName, "calling WMN_setStatusField(" + nInfoStatus + ")")
          WMN_setStatusField(" " + sLightingInfoMsg, nInfoStatus)
        EndIf
      EndIf
      debugMsg(sProcName, "calling setCueState(" + \nCueIndex + ")")
      setCueState(\nCueIndex)
      samAddRequest(#SCS_SAM_LOAD_GRID_ROW, \nCueIndex)
      
    EndIf
    
  EndWith
  
  ProcedureReturn #True
EndProcedure

Procedure blackOutSubTypeK(pSubPtr)
  PROCNAMECS(pSubPtr)
  ; blacks out DMX channels set by a SubTypeK
  Protected bDMXSendMutexLocked
  Protected sLightingInfoMsg.s
  Protected nInfoStatus = #SCS_STATUS_CLEAR
  Protected bLockedMutex
  
  With aSub(pSubPtr)
    If \bDMXSend
      If grSession\nDMXOutEnabled = #SCS_DEVTYPE_ENABLED
        LockDMXSendMutex(621) ; Changed 13Jul2022 11.9.4 (was 620 but 620 is used elsewhere)
        bDMXSendMutexLocked = #True
        If \bChase
          debugMsg(sProcName, "calling DMX_stopChaseIfReqd(" + getSubLabel(pSubPtr) + ")")
          DMX_stopChaseIfReqd(pSubPtr)
        Else
          debugMsg(sProcName, "calling DMX_prepareDMXForSend(" + getSubLabel(pSubPtr) + ", " + strB(bDMXSendMutexLocked) + ", #False, #False, #False, #True)")
          DMX_prepareDMXForSend(pSubPtr, bDMXSendMutexLocked, #False, #False, #False, #True)
        EndIf
        grDMX\bDMXReadyToSend = #True ; must be set (or cleared) while gnDMXSendMutex is locked
        debugMsg(sProcName, "grDMX\bDMXReadyToSend=" + strB(grDMX\bDMXReadyToSend))
        UnlockDMXSendMutex()
        bDMXSendMutexLocked = #False
        If gbInCalcCueStartValues = #False
          If THR_getThreadState(#SCS_THREAD_DMX_SEND) <> #SCS_THREAD_STATE_ACTIVE
            debugMsg3(sProcName, "calling THR_createOrResumeAThread(#SCS_THREAD_DMX_SEND)")
            THR_createOrResumeAThread(#SCS_THREAD_DMX_SEND)
          EndIf
        EndIf
      EndIf
      
      Select grSession\nDMXOutEnabled
        Case #SCS_DEVTYPE_DISABLED
          sLightingInfoMsg = "DMX NOT SENT - DMX Send currently disabled"
          nInfoStatus = #SCS_STATUS_WARN
        Case #SCS_DEVTYPE_NOT_REQD
          sLightingInfoMsg = "DMX NOT SENT - no DMX connection open"
          nInfoStatus = #SCS_STATUS_ERROR
      EndSelect
      
;       If \bStartedInEditor
;         endOfSub(pSubPtr, #SCS_CUE_READY)
;       ElseIf aCue(\nCueIndex)\bNonLinearCue
;         endOfSub(pSubPtr, #SCS_CUE_NOT_LOADED)
;       Else
;         If \bHotkey Or \bExtAct Or \bCallableCue
;           endOfSub(pSubPtr, #SCS_CUE_READY)
;         Else
;           endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
;         EndIf
;       EndIf
      setSubStateForEndOfSub(pSubPtr, #SCS_CUE_NOT_LOADED)
      
      If \bStartedInEditor = #False
        If nInfoStatus <> #SCS_STATUS_CLEAR
          debugMsg(sProcName, "calling WMN_setStatusField(" + nInfoStatus + ")")
          WMN_setStatusField(" " + sLightingInfoMsg, nInfoStatus)
        EndIf
      EndIf
      debugMsg(sProcName, "calling setCueState(" + \nCueIndex + ")")
      setCueState(\nCueIndex)
      samAddRequest(#SCS_SAM_LOAD_GRID_ROW, \nCueIndex)
      
    EndIf
    
  EndWith
  
  ProcedureReturn #True
EndProcedure

Procedure playSubTypeL(pSubPtr, bCalledFromEditor)
  ; SubType L = Level Change
  PROCNAMECS(pSubPtr)
  Protected d, d2, i, j, k
  Protected bAllInactive
  Protected nMyCueIndex
  Protected sDevPXChanListLeft.s, sDevPXChanListRight.s
  Protected sDevXChanListLeft.s, sDevXChanListRight.s
  Protected sAudSetGainCommandString.s, sSetCommandItem.s, sLevelInfo.s
  Protected sSetGainCommandString.s, sSubFinalSetGainCommandString.s
  Protected nLCSubPtr, nLCAudPtr
  Protected nLogicalDevPtr
  Protected nInputDevMapDevPtr, nOutputDevMapDevPtr
  Protected fReqdBVLevel.f, fReqdPan.f, nReqdTime
  Protected sField1.s, sField2.s, sField3.s, sField4.s
  Protected bEndThisSub, bTempoEtc
  
  debugMsg(sProcName, #SCS_START)
  
  If bCalledFromEditor
    ; do not 'play' subtype L if in edit window
    ProcedureReturn
  EndIf
  
  With aSub(pSubPtr)
    nLCSubPtr = \nLCSubPtr
    nLCAudPtr = \nLCAudPtr
    
    ; Added 8Oct2024 11.10.6ah
    aAud(nLCAudPtr)\nRequestedBySubPtr = pSubPtr
    debugMsg(sProcName, "aAud(" + getAudLabel(nLCAudPtr) + ")\nRequestedBySubPtr=" + getSubLabel(aAud(nLCAudPtr)\nRequestedBySubPtr))
    ; End added 8Oct2024 11.10.6ah
    
    Select \nLCAction
      Case #SCS_LC_ACTION_TEMPO, #SCS_LC_ACTION_PITCH, #SCS_LC_ACTION_FREQ
        bTempoEtc = #True
    EndSelect
    If bTempoEtc
      ; debugMsg0(sProcName, "calling setAudTempoEtcForLvlChgSub(" + getSubLabel(pSubPtr) + ")")
      setAudTempoEtcForLvlChgSub(pSubPtr)
      
    ElseIf (\bLCTargetIsF) And (aAud(nLCAudPtr)\nSourceAltChannel <> 0)
      aAud(nLCAudPtr)\bFadeInProgress = #False  ; temporarily prevent another thread from processing a related fade on this Aud
;       aAud(nLCAudPtr)\nRequestedBySubPtr = pSubPtr
; debugMsg(sProcName, "aAud(" + getAudLabel(nLCAudPtr) + ")\nRequestedBySubPtr=" + getSubLabel(aAud(nLCAudPtr)\nRequestedBySubPtr))
      aAud(nLCAudPtr)\nFadeType = \nLCType
      aAud(nLCAudPtr)\qTimeFadeStarted = gqTimeNow
      For d = 0 To grLicInfo\nMaxAudDevPerAud
        If \bLCInclude[d]
          debugMsg(sProcName, "aAud(" + getAudLabel(nLCAudPtr) + ")\fCueTotalVolNow[" + d + "]=" + traceLevel(aAud(nLCAudPtr)\fCueTotalVolNow[d]))
          \fLCBVLevelWhenStarted[d] = aAud(nLCAudPtr)\fCueTotalVolNow[d]
          If \fLCBVLevelWhenStarted[d] < grLevels\fMinBVLevel
            ; Added 30Dec2024 11.10.6ca
            \fLCBVLevelWhenStarted[d] = grLevels\fMinBVLevel
          EndIf
          \fLCPanWhenStarted[d] = aAud(nLCAudPtr)\fCuePanNow[d]
          If (aAud(nLCAudPtr)\sLogicalDev[d]) And (\bLCInclude[d])
            aAud(nLCAudPtr)\fPreFadeBVLevel[d] = aAud(nLCAudPtr)\fCueTotalVolNow[d]
            aAud(nLCAudPtr)\fPreFadePan[d] = aAud(nLCAudPtr)\fCuePanNow[d]
            If \nLCAction = #SCS_LC_ACTION_ABSOLUTE
              \fLCTargetBVLevel[d] = \fLCReqdBVLevel[d]
              aAud(nLCAudPtr)\fTargetBVLevel[d] = \fLCReqdBVLevel[d]
            Else
              \fLCTargetBVLevel[d] = convertDBLevelToBVLevel(convertBVLevelToDBLevel(\fLCBVLevelWhenStarted[d]) + Val(\sLCReqdDBLevel[d]))
              If \fLCTargetBVLevel[d] > grLevels\fMaxBVLevel
                \fLCTargetBVLevel[d] = grLevels\fMaxBVLevel
              EndIf
              If \fLCTargetBVLevel[d] < #SCS_MINVOLUME_SINGLE
                \fLCTargetBVLevel[d] = #SCS_MINVOLUME_SINGLE
              EndIf
              aAud(nLCAudPtr)\fTargetBVLevel[d] = \fLCTargetBVLevel[d]
            EndIf
            aAud(nLCAudPtr)\fTargetPan[d] = \fLCReqdPan[d]
            aAud(nLCAudPtr)\nReqdFadeTime[d] = \nLCTime[d]
            aAud(nLCAudPtr)\bFadeCompleted[d] = #False
          Else
            aAud(nLCAudPtr)\bFadeCompleted[d] = #True
          EndIf
        Else
          aAud(nLCAudPtr)\bFadeCompleted[d] = #True
        EndIf
      Next d
      aAud(nLCAudPtr)\qTimeForNextFadeCheck = gqTimeNow
      aAud(nLCAudPtr)\bFadeRequested = #True
      aAud(nLCAudPtr)\bFadeInProgress = #True   ; now turn on this fading
      
    ElseIf \bLCTargetIsF Or \bLCTargetIsI ; \bLCTargetIsF or \bLCTargetIsI
      For d = 0 To grLicInfo\nMaxAudDevPerAud
        If \bLCInclude[d]
          debugMsg(sProcName, "aAud(" + getAudLabel(nLCAudPtr) + ")\fCueTotalVolNow[" + d + "]=" + traceLevel(aAud(nLCAudPtr)\fCueTotalVolNow[d]))
          \fLCBVLevelWhenStarted[d] = aAud(nLCAudPtr)\fCueTotalVolNow[d]
          If \fLCBVLevelWhenStarted[d] < grLevels\fMinBVLevel
            ; Added 30Dec2024 11.10.6ca
            \fLCBVLevelWhenStarted[d] = grLevels\fMinBVLevel
          EndIf
          \fLCPanWhenStarted[d] = aAud(nLCAudPtr)\fCuePanNow[d]
          If \nLCAction = #SCS_LC_ACTION_ABSOLUTE
            \fLCTargetBVLevel[d] = \fLCReqdBVLevel[d]
          Else
            \fLCTargetBVLevel[d] = convertDBLevelToBVLevel(convertBVLevelToDBLevel(\fLCBVLevelWhenStarted[d]) + Val(\sLCReqdDBLevel[d]))
            If \fLCTargetBVLevel[d] > grLevels\fMaxBVLevel
              \fLCTargetBVLevel[d] = grLevels\fMaxBVLevel
            EndIf
            If \fLCTargetBVLevel[d] < #SCS_MINVOLUME_SINGLE
              \fLCTargetBVLevel[d] = #SCS_MINVOLUME_SINGLE
            EndIf
         EndIf
        EndIf
      Next d
      
    ElseIf \bLCTargetIsA  ; \bLCTargetIsA
      For d = 0 To grLicInfo\nMaxAudDevPerAud
        If \bLCInclude[d]
          \fLCBVLevelWhenStarted[d] = aSub(nLCSubPtr)\fSubBVLevelNow[d]
          If \fLCBVLevelWhenStarted[d] < grLevels\fMinBVLevel
            ; Added 30Dec2024 11.10.6ca
            \fLCBVLevelWhenStarted[d] = grLevels\fMinBVLevel
          EndIf
          \fLCPanWhenStarted[d] = aSub(nLCSubPtr)\fSubPanNow[d]
          If \nLCAction = #SCS_LC_ACTION_ABSOLUTE
            \fLCTargetBVLevel[d] = \fLCReqdBVLevel[d]
          Else
            \fLCTargetBVLevel[d] = convertDBLevelToBVLevel(convertBVLevelToDBLevel(\fLCBVLevelWhenStarted[d]) + Val(\sLCReqdDBLevel[d]))
            If \fLCTargetBVLevel[d] > grLevels\fMaxBVLevel
              \fLCTargetBVLevel[d] = grLevels\fMaxBVLevel
            EndIf
            If \fLCTargetBVLevel[d] < #SCS_MINVOLUME_SINGLE
              \fLCTargetBVLevel[d] = #SCS_MINVOLUME_SINGLE
            EndIf
            ; debugMsg(sProcName, "\fLCBVLevelWhenStarted[" + d + "]=" + formatLevel(\fLCBVLevelWhenStarted[d]) + ", \sLCReqdDBLevel[" + d + "]=" + \sLCReqdDBLevel[d] + ", \fLCTargetBVLevel[" + d + "]=" + formatLevel(\fLCTargetBVLevel[d]))
          EndIf
        EndIf
      Next d
      aSub(nLCSubPtr)\nLCCtrlSubPtr = pSubPtr
      debugMsg(sProcName, "aSub(" + getSubLabel(nLCSubPtr) + ")\nLCCtrlSubPtr=" + getSubLabel(aSub(nLCSubPtr)\nLCCtrlSubPtr))
      
    ElseIf \bLCTargetIsP  ; \bLCTargetIsP
      For d = 0 To grLicInfo\nMaxAudDevPerAud
        If \bLCInclude[d]
          \fLCBVLevelWhenStarted[d] = aSub(nLCSubPtr)\fSubBVLevelNow[d]
          If \fLCBVLevelWhenStarted[d] < grLevels\fMinBVLevel
            ; Added 30Dec2024 11.10.6ca
            \fLCBVLevelWhenStarted[d] = grLevels\fMinBVLevel
          EndIf
          \fLCPanWhenStarted[d] = aSub(nLCSubPtr)\fSubPanNow[d]
          If \nLCAction = #SCS_LC_ACTION_ABSOLUTE
            \fLCTargetBVLevel[d] = \fLCReqdBVLevel[d]
          Else
            \fLCTargetBVLevel[d] = convertDBLevelToBVLevel(convertBVLevelToDBLevel(\fLCBVLevelWhenStarted[d]) + Val(\sLCReqdDBLevel[d]))
            If \fLCTargetBVLevel[d] > grLevels\fMaxBVLevel
              \fLCTargetBVLevel[d] = grLevels\fMaxBVLevel
            EndIf
            If \fLCTargetBVLevel[d] < #SCS_MINVOLUME_SINGLE
              \fLCTargetBVLevel[d] = #SCS_MINVOLUME_SINGLE
            EndIf
            ; debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\fLCBVLevelWhenStarted[" + d + "]=" + traceLevel(\fLCBVLevelWhenStarted[d]) + ", \sLCReqdDBLevel[" + d + "]=" + \sLCReqdDBLevel[d] +
            ;                     ", \fLCTargetBVLevel[" + d + "]=" + traceLevel(\fLCTargetBVLevel[d]))
          EndIf
        EndIf
      Next d
      aSub(nLCSubPtr)\nLCCtrlSubPtr = pSubPtr
    EndIf
    
    If bTempoEtc = #False
      For d = 0 To grLicInfo\nMaxAudDevPerAud
        \bLCActive[d] = \bLCInclude[d]
        If \bLCInclude[d]
          \nLCPosition[d] = 0
        EndIf
      Next d
    EndIf
    \nLCPositionMax = 0
    
    ; if target aud(s) fading in then switch to playing to stop fading in
    k = aSub(nLCSubPtr)\nFirstPlayIndex
    While k >= 0
      If (aAud(k)\nAudState = #SCS_CUE_FADING_IN) Or (aAud(k)\nAudState = #SCS_CUE_TRANS_FADING_IN)
        aAud(k)\nAudState = #SCS_CUE_PLAYING
      EndIf
      k = aAud(k)\nNextPlayIndex
    Wend
    If \nLCCuePtr <> \nCueIndex
      setCueState(\nLCCuePtr)
      updateGrid(\nLCCuePtr)
    EndIf
    
    If bTempoEtc = #False
      If (aSub(nLCSubPtr)\bSubTypeF) Or (aSub(nLCSubPtr)\bSubTypeI)
        For d = 0 To grLicInfo\nMaxAudDevPerAud
          If \bLCInclude[d]
            aAud(nLCAudPtr)\bCueVolManual[d] = #False
            aAud(nLCAudPtr)\bCuePanManual[d] = #False
            aAud(nLCAudPtr)\bCueLevelLC[d] = #True
            aAud(nLCAudPtr)\fLCBVLevel[d] = \fLCTargetBVLevel[d]
            aAud(nLCAudPtr)\bCuePanLC[d] = #True
            aAud(nLCAudPtr)\fLCPan[d] = \fLCReqdPan[d]
          EndIf
        Next d
        aAud(nLCAudPtr)\bAffectedByLevelChange = #True
        aAud(nLCAudPtr)\nLevelChangeSubPtr = pSubPtr
        aAud(nLCAudPtr)\bIncDecLevelSet = #False
        ; Commented out 27Sep2023 following test of "nanoKONTROL2 Test.scs11" where NK2 changes were made to Q1 (type F) levels were not saved following
        ; NK2 changes made to Q1A (type L) which adjusted Q1's levels. Both manual changes should be saved.
;         If inSaveSettings(nLCSubPtr)
;           debugMsg(sProcName, "calling removeFromSaveSettings(" + getSubLabel(nLCSubPtr) + ")")
;           removeFromSaveSettings(nLCSubPtr)
;           setSaveSettings()
;         EndIf
      EndIf
    EndIf
    
    ; if any prior level change for the target is running then terminate it
    For i = 1 To \nCueIndex
      j = aCue(i)\nFirstSubIndex
      While j >= 0
        If (i < \nCueIndex) Or (aSub(j)\nSubNo < \nSubNo)
          If aSub(j)\bExists And aSub(j)\bSubEnabled
            If aSub(j)\bSubTypeL
              If ((aSub(j)\bSubTypeA) And (aSub(j)\nLCSubPtr = nLCSubPtr)) Or ((aSub(j)\bSubTypeF) And (aSub(j)\nLCAudPtr = nLCAudPtr)) Or ((aSub(j)\bSubTypeP) And (aSub(j)\nLCSubPtr = nLCSubPtr)) Or ((aSub(j)\bSubTypeI) And (aSub(j)\nLCAudPtr = nLCAudPtr))
                bAllInactive = #True
                For d = 0 To grLicInfo\nMaxAudDevPerAud
                  If (aSub(j)\bLCActive[d]) And (aSub(nLCSubPtr)\bLCActive[d])
                    debugMsg(sProcName, "setting " + aSub(j)\sSubLabel + " device " + d + " inactive")
                    aSub(j)\bLCActive[d] = #False
                  EndIf
                  If aSub(j)\bLCActive[d]
                    bAllInactive = #False
                  EndIf
                Next d
                If (bAllInactive) And (\nSubState > #SCS_CUE_NOT_LOADED) And (\nSubState < #SCS_CUE_COMPLETED)
                  If aCue(\nCueIndex)\bNonLinearCue
                    endOfSub(j, #SCS_CUE_NOT_LOADED)
                  Else
                    If aSub(j)\bHotkey Or aSub(j)\bExtAct Or aSub(j)\bCallableCue
                      endOfSub(j, #SCS_CUE_READY)
                    Else
                      endOfSub(j, #SCS_CUE_COMPLETED)
                    EndIf
                  EndIf
                  nMyCueIndex = aSub(j)\nCueIndex
                  setCueState(nMyCueIndex)
                  If aCue(nMyCueIndex)\nCueState = #SCS_CUE_COMPLETED
                    closeCue(nMyCueIndex)
                    debugMsg(sProcName, "calling updateGrid(" + Str(nMyCueIndex) + ")")
                    updateGrid(nMyCueIndex)
                    gnCallOpenNextCues = 1
                    debugMsg(sProcName, "gnCallOpenNextCues=" + gnCallOpenNextCues)
                  EndIf
                EndIf
              EndIf
            EndIf
          EndIf
        EndIf
        j = aSub(j)\nNextSubIndex
      Wend
    Next i
    
    If aSub(nLCSubPtr)\nSubState >= #SCS_CUE_COMPLETED
;       If aCue(\nCueIndex)\bNonLinearCue
;         endOfSub(pSubPtr, #SCS_CUE_NOT_LOADED)
;       Else
;         If aSub(pSubPtr)\bHotkey Or aSub(pSubPtr)\bExtAct Or aSub(pSubPtr)\bCallableCue
;           endOfSub(pSubPtr, #SCS_CUE_READY)
;         Else
;           endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
;         EndIf
;       EndIf
      setSubStateForEndOfSub(pSubPtr, #SCS_CUE_NOT_LOADED)
      setCueState(\nCueIndex)
    Else
      \nSubState = #SCS_CUE_CHANGING_LEVEL
      setCueState(\nCueIndex)
      ; debugMsg(sProcName, "calling updateGrid(" + \nCueIndex + ")")
      updateGrid(\nCueIndex)
      
      If bTempoEtc = #False
        If aSub(nLCSubPtr)\bSubTypeA  ; \bSubTypeA
          d = 0
          ; debugMsg(sProcName, "\bLCActive(" + d + ")=" + strB(\bLCActive[d]))
          If \bLCActive[d]
            \fLCBVLevelWhenStarted[d] = aAud(nLCAudPtr)\fCueVolNow[d]
            If \fLCBVLevelWhenStarted[d] < grLevels\fMinBVLevel
              ; Added 30Dec2024 11.10.6ca
              \fLCBVLevelWhenStarted[d] = grLevels\fMinBVLevel
            EndIf
            \fLCPanWhenStarted[d] = aAud(nLCAudPtr)\fCuePanNow[d]
            ; debugMsg(sProcName, "\fLCBVLevelWhenStarted(" + d + ")=" + traceLevel(\fLCBVLevelWhenStarted[d]) + ", \fLCPanWhenStarted(" + d + ")=" + formatPan(\fLCPanWhenStarted[d]))
          EndIf
          
        ElseIf aSub(nLCSubPtr)\bSubTypeF  ; \bSubTypeF
          For d = 0 To grLicInfo\nMaxAudDevPerAud
            If \bLCActive[d]
              \fLCBVLevelWhenStarted[d] = aAud(nLCAudPtr)\fCueTotalVolNow[d]
              If \fLCBVLevelWhenStarted[d] < grLevels\fMinBVLevel
                ; Added 30Dec2024 11.10.6ca
                \fLCBVLevelWhenStarted[d] = grLevels\fMinBVLevel
              EndIf
              \fLCPanWhenStarted[d] = aAud(nLCAudPtr)\fCuePanNow[d]
              If gbUseBASS  ; BASS
                If aAud(nLCAudPtr)\nBassChannel[d] <> 0
                  ; debugMsg(sProcName, "\fLCBVLevelWhenStarted(" + d + ")=" + traceLevel(\fLCBVLevelWhenStarted[d]) + ", \fLCPanWhenStarted(" + d + ")=" + formatPan(\fLCPanWhenStarted[d]))
                  If (\nLCType = #SCS_FADE_LIN) Or (\nLCTime[d] < 75)
                    slideChannelAttributes(nLCAudPtr, d, \fLCTargetBVLevel[d], \fLCReqdPan[d], \nLCTime[d], 200001)
                  Else
                    slideChannelAttributes(nLCAudPtr, d, #SCS_NOVOLCHANGE_SINGLE, \fLCReqdPan[d], \nLCTime[d], 200002)
                  EndIf
                EndIf
              Else  ; SM-S
                sLevelInfo = setLevelsForSMSOutputDev(nLCAudPtr, d, \fLCTargetBVLevel[d], \fLCReqdPan[d], \nLCTime[d], \nLCType)
                ; debugMsg(sProcName, "d=" + d + ", sLevelInfo=" + sLevelInfo)
                sDevPXChanListLeft = aAud(nLCAudPtr)\sDevPXChanListLeft[d]
                sDevPXChanListRight = aAud(nLCAudPtr)\sDevPXChanListRight[d]
                If sDevPXChanListLeft
                  If \fLCReqdPan[d] = #SCS_PANCENTRE_SINGLE
                    sSetCommandItem = " chan " + sDevPXChanListLeft + " " + sDevPXChanListRight + " " + StringField(sLevelInfo, 1, "|")
                  Else
                    sSetCommandItem = " chan " + sDevPXChanListLeft + " " + StringField(sLevelInfo, 1, "|")
                    If sDevPXChanListRight
                      sSetCommandItem + " chan " + sDevPXChanListRight + " " + StringField(sLevelInfo, 2, "|")
                    EndIf
                  EndIf
                  debugMsg(sProcName, "sSetCommandItem=" + sSetCommandItem)
                  sAudSetGainCommandString + sSetCommandItem
                EndIf
              EndIf
            EndIf
          Next d
          
        ElseIf aSub(nLCSubPtr)\bSubTypeI  ; \bSubTypeI
          For d2 = aAud(nLCAudPtr)\nFirstInputDev To aAud(nLCAudPtr)\nLastInputDev
            If aAud(nLCAudPtr)\bInputCurrentlyOff[d2] = #False  ; added this test 12/02/2015 11.3.8g following bug report from Brain Larsen
              nInputDevMapDevPtr = aAud(nLCAudPtr)\nInputDevMapDevPtr[d2]
              If nInputDevMapDevPtr >= 0
                For d = 0 To grLicInfo\nMaxAudDevPerAud
                  If \bLCActive[d]
                    \fLCBVLevelWhenStarted[d] = aAud(nLCAudPtr)\fCueVolNow[d]
                    If \fLCBVLevelWhenStarted[d] < grLevels\fMinBVLevel
                      ; Added 30Dec2024 11.10.6ca
                      \fLCBVLevelWhenStarted[d] = grLevels\fMinBVLevel
                    EndIf
                    \fLCPanWhenStarted[d] = aAud(nLCAudPtr)\fCuePanNow[d]
                    If gbUseSMS  ; SM-S
                      If (aAud(nLCAudPtr)\sLogicalDev[d]) And (aAud(nLCAudPtr)\bIgnoreDev[d] = #False)
                        nLogicalDevPtr = getProdLogicalDevPtrForLogicalDev(aAud(nLCAudPtr)\sLogicalDev[d])
                        debugMsg(sProcName, "\sLogicalDev(" + d + ")=" + aAud(nLCAudPtr)\sLogicalDev[d] + ", nLogicalDevPtr=" + nLogicalDevPtr)
                        If nLogicalDevPtr >= 0
                          nOutputDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_AUDIO_OUTPUT, aAud(nLCAudPtr)\sLogicalDev[d])
                          If nOutputDevMapDevPtr < 0
                            ; shouldn't happen
                            Continue
                          EndIf
                          fReqdBVLevel = \fLCTargetBVLevel[d]
                          fReqdPan = \fLCReqdPan[d]
                          nReqdTime = \nLCTime[d]
                          debugMsg(sProcName, "aAud(" + getAudLabel(nLCAudPtr) + ")\sDevXChanListLeft[" + d + "]=" + aAud(nLCAudPtr)\sDevXChanListLeft[d] +
                                              ", \sDevXChanListLeft[" + d + "]=" + aAud(nLCAudPtr)\sDevXChanListLeft[d])
                          sDevXChanListLeft = aAud(nLCAudPtr)\sDevXChanListLeft[d]
                          sDevXChanListRight = aAud(nLCAudPtr)\sDevXChanListRight[d]
                          sLevelInfo = setLevelsForSMSOutputDev(nLCAudPtr, d, fReqdBVLevel, fReqdPan, nReqdTime, \nLCType, d2)
                          ; debugMsg(sProcName, "d=" + d + ", sLevelInfo=" + sLevelInfo)
                          sField1 = StringField(sLevelInfo, 1, "|")
                          sField2 = StringField(sLevelInfo, 2, "|")
                          sField3 = StringField(sLevelInfo, 3, "|")
                          sField4 = StringField(sLevelInfo, 4, "|")
                          If fReqdPan = #SCS_PANCENTRE_SINGLE
                            sSetCommandItem = " chan " + sDevXChanListLeft + " " + sDevXChanListRight + " " + sField1
                            If sField3
                              sSubFinalSetGainCommandString + " chan " + sDevXChanListLeft + " " + sDevXChanListRight + " " + sField3
                            EndIf
                          Else
                            sSetCommandItem = " chan " + sDevXChanListLeft + " " + sField1
                            If sDevXChanListRight
                              sSetCommandItem + " chan " + sDevXChanListRight + " " + sField2
                            EndIf
                            If sField3
                              sSubFinalSetGainCommandString + " chan " + sDevXChanListLeft + " " + sField3
                              If sDevXChanListRight
                                sSubFinalSetGainCommandString + " chan " + sDevXChanListRight + " " + sField4
                              EndIf
                            EndIf
                          EndIf
                          debugMsg(sProcName, "sSetCommandItem=" + sSetCommandItem)
                          If sSubFinalSetGainCommandString
                            debugMsg(sProcName, "sSubFinalSetGainCommandString=" + sSubFinalSetGainCommandString)
                          EndIf
                          sAudSetGainCommandString + sSetCommandItem
                        EndIf
                        
                      EndIf
                    EndIf
                  EndIf
                Next d
              EndIf
            EndIf
          Next d2
          
        Else
          For d = 0 To grLicInfo\nMaxAudDevPerAud
            \fLCBVLevelWhenStarted[d] = aSub(nLCSubPtr)\fSubBVLevelNow[d]
            If \fLCBVLevelWhenStarted[d] < grLevels\fMinBVLevel
              ; Added 30Dec2024 11.10.6ca
              \fLCBVLevelWhenStarted[d] = grLevels\fMinBVLevel
            EndIf
            \fLCPanWhenStarted[d] = aSub(nLCSubPtr)\fSubPanNow[d]
          Next d
        EndIf
        
        If gbUseSMS ; SM-S
          \sSubFinalSetGainCommandString = sSubFinalSetGainCommandString
          If sAudSetGainCommandString
            ; tidy up sAudSetGainCommandString, converting double-spaces to single-spaces, and trimming result
            sSetGainCommandString = Trim(ReplaceString(sAudSetGainCommandString, "  ", " "))
            sendSMSCommand("set " + sSetGainCommandString)
          EndIf
        EndIf
        
      EndIf ; EndIf bTempoEtc = #False
    EndIf ; EndIf aSub(nLCSubPtr)\nSubState >= #SCS_CUE_COMPLETED / Else
    
  EndWith
  
  debugMsg(sProcName, #SCS_END)
  
  ProcedureReturn #True
  
EndProcedure

Procedure processCtrlSendThreadItem(pCtrlSendThreadItemIndex)
  PROCNAMEC()
  Protected nSubPtr, nCtrlSendIndex, nState, nStringFormat
  Protected nPhysicalDevPtr
  Protected nHTTPResult.i
  Protected bLockedMutex
  
  With gaCtrlSendThreadItem(pCtrlSendThreadItemIndex)
    nSubPtr = \nSubPtr
    nCtrlSendIndex = \nCtrlSendIndex
    nState = \nState
  EndWith
  
  If (nSubPtr >= 0) And (nCtrlSendIndex >= 0)
    With aSub(nSubPtr)\aCtrlSend[nCtrlSendIndex]
      grCtrlSendSubData\sCtrlSendPortName = ""
      If \bMIDISend
        grCtrlSendSubData\nMidiCount + 1
        debugMsg(sProcName, "\aCtrlSend[" + nCtrlSendIndex + "]\nMSMsgType=" + decodeMsgType(\nMSMsgType))
        If grSession\nMidiOutEnabled = #SCS_DEVTYPE_ENABLED
          nPhysicalDevPtr = getPhysDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_CTRL_SEND, \sCSLogicalDev)
          If nPhysicalDevPtr >= 0
            If gnMTCSendMutex
              LockMTCSendMutex(510, #True)
            EndIf
            Select \nMSMsgType
              Case #SCS_MSGTYPE_PC127, #SCS_MSGTYPE_PC128
                grCtrlSendSubData\sCtrlSendPortName = SendProgChange(nPhysicalDevPtr, \nMSParam1, \nMSChannel)
              Case #SCS_MSGTYPE_CC
                grCtrlSendSubData\sCtrlSendPortName = SendCtrlChange(nPhysicalDevPtr, \nMSParam1, \nMSParam2, \nMSChannel)
              Case #SCS_MSGTYPE_ON
                grCtrlSendSubData\sCtrlSendPortName = SendNoteOn(nPhysicalDevPtr, \nMSParam1, \nMSParam2, \nMSChannel)
              Case #SCS_MSGTYPE_OFF
                grCtrlSendSubData\sCtrlSendPortName = SendNoteOff(nPhysicalDevPtr, \nMSParam1, \nMSParam2, \nMSChannel)
              Case #SCS_MSGTYPE_MMC
                ;- to be done (MMC)
              Case #SCS_MSGTYPE_MSC
                grCtrlSendSubData\sCtrlSendPortName = SendMSC(nPhysicalDevPtr, \nMSChannel - 1, \nMSParam1, \nMSParam2, \sMSQNumber, \sMSQList, \sMSQPath, \nMSMacro)
              Case #SCS_MSGTYPE_FREE
                grCtrlSendSubData\sCtrlSendPortName = SendMIDIFreeFormat(nPhysicalDevPtr, \sEnteredString)
              Case #SCS_MSGTYPE_NRPN_GEN, #SCS_MSGTYPE_NRPN_YAM
                grCtrlSendSubData\sCtrlSendPortName = SendMidiNRPN(nPhysicalDevPtr, @aSub(nSubPtr)\aCtrlSend[nCtrlSendIndex])
              Case #SCS_MSGTYPE_FILE
                If \nAudPtr >= 0
                  debugMsg(sProcName, "calling playAud(" + getAudLabel(\nAudPtr) + ")")
                  playAud(\nAudPtr)
                  grCtrlSendSubData\sCtrlSendPortName = gaMidiOutDevice(nPhysicalDevPtr)\sName
                EndIf
            EndSelect
            If gnMTCSendMutex
              UnlockMTCSendMutex(#True)
            EndIf
          EndIf
          debugMsg(sProcName, "MIDI grCtrlSendSubData\sCtrlSendPortName=" + grCtrlSendSubData\sCtrlSendPortName)
          If grCtrlSendSubData\sCtrlSendPortName
            grCtrlSendSubData\nMidiSent + 1
          EndIf
        EndIf
      EndIf
      
      If \bRS232Send
        grCtrlSendSubData\nRS232Count + 1
        grCtrlSendSubData\sCtrlSendPortName = ""
        If grSession\nRS232OutEnabled = #SCS_DEVTYPE_ENABLED
          If \Buffer
            grCtrlSendSubData\sCtrlSendPortName = sendRS232Data(\sCSLogicalDev, \Buffer, \nBufLen)
            debugMsg(sProcName, "RS232(data) grCtrlSendSubData\sCtrlSendPortName=" + grCtrlSendSubData\sCtrlSendPortName)
          Else
            grCtrlSendSubData\sCtrlSendPortName = sendRS232String(\sCSLogicalDev, \sSendString)
            debugMsg(sProcName, "RS232(string) grCtrlSendSubData\sCtrlSendPortName=" + grCtrlSendSubData\sCtrlSendPortName)
          EndIf
          If (grCtrlSendSubData\sCtrlSendPortName) And (grCtrlSendSubData\sCtrlSendPortName <> #SCS_RS232_PORT_NOT_OPEN)
            grCtrlSendSubData\nRS232Sent + 1
          EndIf
        EndIf
      EndIf
      
      If \bNetworkSend
        grCtrlSendSubData\nNetworkCount + 1
        grCtrlSendSubData\sCtrlSendPortName = ""
        If grSession\nNetworkOutEnabled = #SCS_DEVTYPE_ENABLED
          nPhysicalDevPtr = getPhysDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_CTRL_SEND, \sCSLogicalDev)
          debugMsg(sProcName, "\aCtrlSend[" + Str(nCtrlSendIndex) + "]\sLogicalDev=" + \sCSLogicalDev + ", nPhysicalDevPtr=" + Str(nPhysicalDevPtr))
          If nPhysicalDevPtr >= 0
            ; added 14Apr2020 11.8.2.3ar
            If \nEntryMode = #SCS_ENTRYMODE_UTF8
              nStringFormat = #PB_UTF8
            Else
              nStringFormat = #PB_Ascii
            EndIf
            ; end added 14Apr2020 11.8.2.3ar
            If \bIsOSC
              debugMsg(sProcName, "calling sendOSCCtrlMessage(" + getSubLabel(nSubPtr) + ", nCtrlSendIndex=" + nCtrlSendIndex + ")")
              grCtrlSendSubData\sCtrlSendPortName = sendOSCCtrlMessage(nSubPtr, nCtrlSendIndex)
            Else
              ; NB nPhysicalDevPtr = nNetworkControlPtr for network devices
              debugMsg(sProcName, "calling sendNetworkMessage(" + nPhysicalDevPtr + ", \sSendString, #False, nStringFormat)")
              grCtrlSendSubData\sCtrlSendPortName = sendNetworkMessage(nPhysicalDevPtr, \sSendString, #False, nStringFormat) ; nStringFormat added 14Apr2020 11.8.2.3ar
            EndIf
          EndIf
          debugMsg(sProcName, "Network grCtrlSendSubData\sCtrlSendPortName=" + grCtrlSendSubData\sCtrlSendPortName)
          If (Len(grCtrlSendSubData\sCtrlSendPortName) > 0) And (grCtrlSendSubData\sCtrlSendPortName <> #SCS_NETWORK_CONNECTION_NOT_OPEN)
            grCtrlSendSubData\nNetworkSent + 1
          EndIf
        EndIf
      EndIf
      
      If \bHTTPSend
        grCtrlSendSubData\nHTTPCount + 1
        nHTTPResult = sendHTTPString(\sSendString, nSubPtr, #False)
        debugMsg(sProcName, "nHTTPResult=" + nHTTPResult)
        If nHTTPResult
          grCtrlSendSubData\nHTTPSent + 1
        EndIf
      EndIf
      
      If (\bMIDISend) Or (\bRS232Send) Or (\bNetworkSend)
        If (Len(grCtrlSendSubData\sCtrlSendPortName) = 0) Or
           (grCtrlSendSubData\sCtrlSendPortName = #SCS_RS232_PORT_NOT_OPEN) Or
           (grCtrlSendSubData\sCtrlSendPortName = #SCS_NETWORK_CONNECTION_NOT_OPEN)
          grCtrlSendSubData\bCtrlSendError = #True
          If grCtrlSendSubData\sCtrlSendSeqFails = ""
            grCtrlSendSubData\sCtrlSendSeqFails = "#" + Str(nCtrlSendIndex+1)
          Else
            grCtrlSendSubData\sCtrlSendSeqFails + ", #" + Str(nCtrlSendIndex+1)
          EndIf
          If grCtrlSendSubData\sCtrlSendPortName = #SCS_RS232_PORT_NOT_OPEN
            grCtrlSendSubData\sCtrlSendSeqFails + " (port not open)"
          EndIf
        Else
          grCtrlSendSubData\nCtrlSendCount + 1
          If grCtrlSendSubData\nCtrlSendPortCount = 0
            grCtrlSendSubData\sCtrlSendPorts = "'" + grCtrlSendSubData\sCtrlSendPortName + "'"
            grCtrlSendSubData\nCtrlSendPortCount = 1
          ElseIf FindString(grCtrlSendSubData\sCtrlSendPorts, "'" + grCtrlSendSubData\sCtrlSendPortName + "'") = 0
            grCtrlSendSubData\sCtrlSendPorts + ", '" + grCtrlSendSubData\sCtrlSendPortName + "'"
            grCtrlSendSubData\nCtrlSendPortCount + 1
          EndIf
        EndIf
        
      ElseIf \bHTTPSend
        If nHTTPResult
          grCtrlSendSubData\bCtrlSendError = #True
          If grCtrlSendSubData\sCtrlSendSeqFails = ""
            grCtrlSendSubData\sCtrlSendSeqFails = "#" + Str(nCtrlSendIndex+1)
          Else
            grCtrlSendSubData\sCtrlSendSeqFails + ", #" + Str(nCtrlSendIndex+1)
          EndIf
        Else
          grCtrlSendSubData\nCtrlSendCount + 1
        EndIf
        
      EndIf
    EndWith
  EndIf
  
EndProcedure

Procedure playSubTypeM(pSubPtr, bCalledFromEditor, pCtrlSendIndex, bMayBypassSendingForM2T=#False)
  ; SubType M = Control Send
  PROCNAMECS(pSubPtr)
  Protected nThisIndex, m
  Protected nAudPtr
  Protected nStartIndex, nEndIndex
  Protected sCtrlSendPorts.s, nCtrlSendPortCount
  Protected nMidiCount, nRS232Count, nNetworkCount, nHTTPCount
  Protected nMidiSent, nRS232Sent, nNetworkSent, nHTTPSent
  Protected sCtrlSendSeqFails.s
  Protected nFailCount, nPlaceHolderFailCount
  Protected bCtrlSendError
  Protected nPhysicalDevPtr, nLogicalDevPtr
  Protected nDevMapDevPtr, bIgnoreDevThisRun, nIgnoreDevItemCount, nCtrlSendItemCount
  Protected nHTTPResult.i
  Protected sCRLF.s, nStringFormat
  Protected nInfoStatus, nExtraDisplayTime
  Protected bResult
  Protected nSubLength
  Protected bLockedMutex
  Protected nCtrlSendDelay = 100
  Protected bProcessThisCtrlSendMsg, nScribbleStripCount
  Static Dim aOpenedDev(2) ; may be expanded but unlikely in practice
  Static nMaxOpenedDev
  Protected n
  Protected nCtrlSendIndex, qDelayedStartTime.q
  Protected bUseInfoColor ; Added 6Jan2024 11.10.6cg
  Static nCtrlSendCount
  
  debugMsg(sProcName, #SCS_START + ", bCalledFromEditor=" + strB(bCalledFromEditor) + ", pCtrlSendIndex=" + pCtrlSendIndex + ", bMayBypassSendingForM2T=" + strB(bMayBypassSendingForM2T))
  
  With aSub(pSubPtr)
    
    \nSubState = #SCS_CUE_PLAYING    ; prevents statusChecks() re-calling playSub()
    
    grCtrlSendSubData = grCtrlSendSubDataDef  ; clear all counts, etc
    grCtrlSendSubData\nSubPtr = pSubPtr
    
    If pCtrlSendIndex < 10000
      nCtrlSendIndex = pCtrlSendIndex
      nCtrlSendCount = 0
    Else
      nCtrlSendIndex = pCtrlSendIndex - 10000
      ; Causes TCP ctrl send items that have a delay time (set in nCtrlSendDelay) to be delayed via SAM to avoid the Delay() command locking up SCS
      ; (Lock-up reported by Jason Mai 22Jun2024)
    EndIf
    
    If pCtrlSendIndex = -1
      nStartIndex = 0
      nEndIndex = #SCS_MAX_CTRL_SEND
    Else
      nStartIndex = nCtrlSendIndex
      If pCtrlSendIndex < 10000
        nEndIndex = nCtrlSendIndex
      Else
        nEndIndex = #SCS_MAX_CTRL_SEND
      EndIf
    EndIf
    
    If pCtrlSendIndex <= 0
      nMaxOpenedDev = -1
    EndIf
    
    For nThisIndex = nStartIndex To nEndIndex
      bProcessThisCtrlSendMsg = #True
      nPhysicalDevPtr = getPhysDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_CTRL_SEND, \aCtrlSend[nThisIndex]\sCSLogicalDev)
      If nPhysicalDevPtr >= 0
        ; debugMsg(sProcName, "nPhysicalDevPtr=" + nPhysicalDevPtr + ", nDevMapDevPtr=" + nDevMapDevPtr + ", bIgnoreDevThisRun=" + strB(bIgnoreDevThisRun))
        If bMayBypassSendingForM2T
          nLogicalDevPtr = getProdLogicalDevPtrForLogicalDev(\aCtrlSend[nThisIndex]\sCSLogicalDev, #SCS_DEVGRP_CTRL_SEND)
          ; debugMsg(sProcName, "nLogicalDevPtr=" + nLogicalDevPtr)
          If nLogicalDevPtr >= 0
            ; debugMsg(sProcName, "grProd\aCtrlSendLogicalDevs(" + nLogicalDevPtr + ")\bM2TSkipEarlierCtrlMsgs=" + strB(grProd\aCtrlSendLogicalDevs(nLogicalDevPtr)\bM2TSkipEarlierCtrlMsgs))
            If grProd\aCtrlSendLogicalDevs(nLogicalDevPtr)\bM2TSkipEarlierCtrlMsgs = #True
              bProcessThisCtrlSendMsg = #False
            EndIf
          Else
            bProcessThisCtrlSendMsg = #False
          EndIf
        EndIf
      Else
        bProcessThisCtrlSendMsg = #False
      EndIf
      
      ; debugMsg(sProcName, "nThisIndex=" + nThisIndex + ", bProcessThisCtrlSendMsg=" + strB(bProcessThisCtrlSendMsg))
      If bProcessThisCtrlSendMsg
        
        nCtrlSendItemCount + 1
        grCtrlSendSubData\sCtrlSendPortName = ""
        
        nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_CTRL_SEND, \aCtrlSend[nThisIndex]\sCSLogicalDev)
        ; debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\aCtrlSend[" + nThisIndex + "]\sCSLogicalDev=" + \aCtrlSend[nThisIndex]\sCSLogicalDev + ", nDevMapDevPtr=" + nDevMapDevPtr)
        If nDevMapDevPtr >= 0
          ; should be #True
          bIgnoreDevThisRun = grMaps\aDev(nDevMapDevPtr)\bIgnoreDevThisRun
        Else
          bIgnoreDevThisRun = #True
        EndIf
        If bIgnoreDevThisRun
          nIgnoreDevItemCount + 1
        EndIf
        
        debugMsg(sProcName, "\aCtrlSend[" + nThisIndex + "]\bMIDISend=" + strB(\aCtrlSend[nThisIndex]\bMIDISend) + ", \bRS232Send=" + strB(\aCtrlSend[nThisIndex]\bRS232Send) + ", \bNetworkSend=" + strB(\aCtrlSend[nThisIndex]\bNetworkSend) +
                            ", \aCtrlSend[" + nThisIndex + "]\nMSMsgType=" + decodeMsgType(\aCtrlSend[nThisIndex]\nMSMsgType))
        If \aCtrlSend[nThisIndex]\bMIDISend
          ;{
          debugMsg(sProcName, "\aCtrlSend(" + nThisIndex + ")\nMSMsgType=" + decodeMsgType(\aCtrlSend[nThisIndex]\nMSMsgType) + ", \nRemDevMsgType=" + CSRD_DecodeRemDevMsgType(\aCtrlSend[nThisIndex]\nRemDevMsgType))
          If \aCtrlSend[nThisIndex]\nMSMsgType = #SCS_MSGTYPE_SCRIBBLE_STRIP
            nScribbleStripCount + 1
          Else
            nMidiCount + 1
            If grSession\nMidiOutEnabled = #SCS_DEVTYPE_ENABLED
              If (nPhysicalDevPtr >= 0) And (bIgnoreDevThisRun = #False) ; added bIgnoreDevThisRun test 17Mar2020 11.8.2.3aa
                If gnMTCSendMutex
                  LockMTCSendMutex(511, #True)
                EndIf
                If \aCtrlSend[nThisIndex]\nMSMsgType = #SCS_MSGTYPE_NONE And \aCtrlSend[nThisIndex]\nRemDevMsgType > 0
                  grCtrlSendSubData\sCtrlSendPortName = SendMidiRemDevMsg(nPhysicalDevPtr, @\aCtrlSend[nThisIndex])
                Else
                  Select \aCtrlSend[nThisIndex]\nMSMsgType
                    Case #SCS_MSGTYPE_PC127, #SCS_MSGTYPE_PC128
                      grCtrlSendSubData\sCtrlSendPortName = SendProgChange(nPhysicalDevPtr, \aCtrlSend[nThisIndex]\nMSParam1, \aCtrlSend[nThisIndex]\nMSChannel)
                    Case #SCS_MSGTYPE_CC
                      grCtrlSendSubData\sCtrlSendPortName = SendCtrlChange(nPhysicalDevPtr, \aCtrlSend[nThisIndex]\nMSParam1, \aCtrlSend[nThisIndex]\nMSParam2, \aCtrlSend[nThisIndex]\nMSChannel)
                    Case #SCS_MSGTYPE_ON
                      grCtrlSendSubData\sCtrlSendPortName = SendNoteOn(nPhysicalDevPtr, \aCtrlSend[nThisIndex]\nMSParam1, \aCtrlSend[nThisIndex]\nMSParam2, \aCtrlSend[nThisIndex]\nMSChannel)
                    Case #SCS_MSGTYPE_OFF
                      grCtrlSendSubData\sCtrlSendPortName = SendNoteOff(nPhysicalDevPtr, \aCtrlSend[nThisIndex]\nMSParam1, \aCtrlSend[nThisIndex]\nMSParam2, \aCtrlSend[nThisIndex]\nMSChannel)
                    Case #SCS_MSGTYPE_MMC
                      ;- to be done (MMC)
                    Case #SCS_MSGTYPE_MSC
                      grCtrlSendSubData\sCtrlSendPortName = SendMSC(nPhysicalDevPtr, \aCtrlSend[nThisIndex]\nMSChannel - 1, \aCtrlSend[nThisIndex]\nMSParam1, \aCtrlSend[nThisIndex]\nMSParam2,
                                                                    \aCtrlSend[nThisIndex]\sMSQNumber, \aCtrlSend[nThisIndex]\sMSQList, \aCtrlSend[nThisIndex]\sMSQPath, \aCtrlSend[nThisIndex]\nMSMacro)
                    Case #SCS_MSGTYPE_FREE
                      grCtrlSendSubData\sCtrlSendPortName = SendMIDIFreeFormat(nPhysicalDevPtr, \aCtrlSend[nThisIndex]\sEnteredString)
                      
                    Case #SCS_MSGTYPE_NRPN_GEN, #SCS_MSGTYPE_NRPN_YAM
                      grCtrlSendSubData\sCtrlSendPortName = SendMidiNRPN(nPhysicalDevPtr, @\aCtrlSend[nThisIndex])
                      
                    Case #SCS_MSGTYPE_FILE
                      nAudPtr = \aCtrlSend[nThisIndex]\nAudPtr
                      If nAudPtr >= 0
                        debugMsg(sProcName, "calling playAud(" + getAudLabel(nAudPtr) + ", #False, #False, -1, #False, #True, " + nThisIndex + ")")
                        playAud(nAudPtr, #False, #False, -1, #False, #True, nThisIndex)
                        grCtrlSendSubData\sCtrlSendPortName = gaMidiOutDevice(nPhysicalDevPtr)\sName
                      EndIf
                  EndSelect
                EndIf
                If gnMTCSendMutex
                  UnlockMTCSendMutex(#True)
                EndIf
              EndIf
              ; debugMsg(sProcName, "MIDI grCtrlSendSubData\sCtrlSendPortName=" + grCtrlSendSubData\sCtrlSendPortName)
              If grCtrlSendSubData\sCtrlSendPortName
                nMidiSent + 1
              EndIf
            EndIf ; EndIf grSession\nMidiOutEnabled = #SCS_DEVTYPE_ENABLED
          EndIf ; EndIf \aCtrlSend[nThisIndex]\nMSMsgType = #SCS_MSGTYPE_SCRIBBLE_STRIP / Else
          ;}
        EndIf
        
        If \aCtrlSend[nThisIndex]\bRS232Send
          ;{
          nRS232Count + 1
          grCtrlSendSubData\sCtrlSendPortName = ""
          If grSession\nRS232OutEnabled = #SCS_DEVTYPE_ENABLED
            If \aCtrlSend[nThisIndex]\Buffer
              grCtrlSendSubData\sCtrlSendPortName = sendRS232Data(\aCtrlSend[nThisIndex]\sCSLogicalDev, \aCtrlSend[nThisIndex]\Buffer, \aCtrlSend[nThisIndex]\nBufLen)
              ; debugMsg(sProcName, "RS232(data) grCtrlSendSubData\sCtrlSendPortName=" + grCtrlSendSubData\sCtrlSendPortName)
            Else
              grCtrlSendSubData\sCtrlSendPortName = sendRS232String(\aCtrlSend[nThisIndex]\sCSLogicalDev, \aCtrlSend[nThisIndex]\sSendString)
              ; debugMsg(sProcName, "RS232(string) grCtrlSendSubData\sCtrlSendPortName=" + grCtrlSendSubData\sCtrlSendPortName)
            EndIf
            If (grCtrlSendSubData\sCtrlSendPortName) And (grCtrlSendSubData\sCtrlSendPortName <> #SCS_RS232_PORT_NOT_OPEN)
              nRS232Sent + 1
            EndIf
          EndIf
          ;}
        EndIf
        
        If \aCtrlSend[nThisIndex]\bNetworkSend
          ;{
          If nPhysicalDevPtr >= 0 And nDevMapDevPtr >= 0
            If gaNetworkControl(nPhysicalDevPtr)\bNetworkDevInitialized = #False And gaNetworkControl(nPhysicalDevPtr)\bNWDummy = #False ; Added \bNWDummy test 8Nov2022 11.9.7ab
              If gaNetworkControl(nPhysicalDevPtr)\bConnectWhenReqd = #False
                debugMsg(sProcName, "calling openNetworkConnectionIfReqd(@\aCtrlSend[" + nThisIndex + "], #False), nPhysicalDevPtr=" + nPhysicalDevPtr)
              EndIf
              openNetworkConnectionIfReqd(@\aCtrlSend[nThisIndex], #False)
              If gaNetworkControl(nPhysicalDevPtr)\bNetworkDevInitialized
                bIgnoreDevThisRun = #False
                grMaps\aDev(nDevMapDevPtr)\bIgnoreDevThisRun = #False
                ; Added 1Feb2024 11.10.2ad
                ; debugMsg(sProcName, "grMaps\aDev(" + nDevMapDevPtr + ")\bConnectWhenReqd=" + strB(grMaps\aDev(nDevMapDevPtr)\bConnectWhenReqd))
                If grMaps\aDev(nDevMapDevPtr)\bConnectWhenReqd
                  ; hold info for closing the network connection after sending
                  nMaxOpenedDev + 1
                  If nMaxOpenedDev > ArraySize(aOpenedDev())
                    ReDim aOpenedDev(nMaxOpenedDev)
                  EndIf
                  aOpenedDev(nMaxOpenedDev) = nPhysicalDevPtr
                EndIf
                ; End added 1Feb2024 11.10.2ad
              EndIf
            EndIf
          EndIf
          
          If nNetworkCount > 0
            If (nPhysicalDevPtr >= 0) And (bIgnoreDevThisRun = #False) ; added bIgnoreDevThisRun test 17Mar2020 11.8.2.3aa
              If gaNetworkControl(nPhysicalDevPtr)\nCtrlNetworkRemoteDev = #SCS_CS_NETWORK_REM_OSC_OTHER
                ; Test added 22Jun2024 11.10.3ao following emails from Jason Mai
                ; No delay required for 'OSC OTHER' as this will always apply a message size (for OSC 1.0) or SPLIT (for OSC 1.1)
                nCtrlSendDelay = 0
              Else
                nCtrlSendDelay = gaNetworkControl(nPhysicalDevPtr)\nCtrlSendDelay
                If nCtrlSendDelay < 0
                  If gaNetworkControl(nPhysicalDevPtr)\nNetworkProtocol = #SCS_NETWORK_PR_UDP
                    ; UDP preserves message boundaries so no delay should be necessary
                    nCtrlSendDelay = #SCS_NETWORK_DELAY_UDP ; 0ms at time of coding (13Apr2019 11.8.1)
                  Else
                    ; TCP does not preserve message boundaries, so a delay of 100ms seems to work in separating messages
                    ; see https://stackoverflow.com/questions/9563563/what-is-a-message-boundary for more info
                    nCtrlSendDelay = #SCS_NETWORK_DELAY_TCP ; 100ms at time of coding (13Apr2019 11.8.1)
                  EndIf
                EndIf
              EndIf
            Else
              nCtrlSendDelay = 0 ; changed 17Mar2020 11.8.2.3aa - was #SCS_NETWORK_DELAY_TCP but no reason for delaying if nothing sent
            EndIf
            ; debugMsg(sProcName, "nThisIndex=" + nThisIndex + ", nCtrlSendDelay=" + nCtrlSendDelay)
            If nCtrlSendDelay > 0
              ; Delay(nCtrlSendDelay)
              qDelayedStartTime = ElapsedMilliseconds() + nCtrlSendDelay
              ; debugMsg(sProcName, "calling samAddRequest(#SCS_SAM_PLAY_CTRL_SEND_ITEM_DELAYED, " + getSubLabel(pSubPtr) + ", 0, " + Str(nThisIndex + 10000) + ", " + #DQUOTE$ + #DQUOTE$ + ", " + traceTime(qDelayedStartTime) + ")")
              samAddRequest(#SCS_SAM_PLAY_CTRL_SEND_ITEM_DELAYED, pSubPtr, 0, (nThisIndex + 10000), "", qDelayedStartTime, 0, -1, #True, #True)
              setCueState(aSub(pSubPtr)\nCueIndex)
              ; debugMsg(sProcName, "exit now")
              ProcedureReturn
            EndIf
          EndIf
          nNetworkCount + 1
          grCtrlSendSubData\sCtrlSendPortName = ""
          If \aCtrlSend[nThisIndex]\bIsOSC
            grCtrlSendSubData\bOSCItemPlaceHolder = \aCtrlSend[nThisIndex]\bOSCItemPlaceHolder
          Else
            grCtrlSendSubData\bOSCItemPlaceHolder = #False
          EndIf
          ; added 14Apr2020 11.8.2.3ar
          If \aCtrlSend[nThisIndex]\nEntryMode = #SCS_ENTRYMODE_UTF8
            nStringFormat = #PB_UTF8
          ElseIf \aCtrlSend[nThisIndex]\nEntryMode = #SCS_ENTRYMODE_HEX
            nStringFormat = #PB_UTF8
          ElseIf nPhysicalDevPtr >= 0
            If gaNetworkControl(nPhysicalDevPtr)\nCtrlNetworkRemoteDev = #SCS_CS_NETWORK_REM_OSC_X32TC
              nStringFormat = #PB_UTF8
            Else
              nStringFormat = #PB_Ascii
            EndIf
          Else
            nStringFormat = #PB_Ascii
          EndIf
          ; end added 14Apr2020 11.8.2.3ar
          If (grSession\nNetworkOutEnabled = #SCS_DEVTYPE_ENABLED) And (grCtrlSendSubData\bOSCItemPlaceHolder = #False)
            If (nPhysicalDevPtr >= 0) And (bIgnoreDevThisRun = #False) ; added bIgnoreDevThisRun test 17Mar2020 11.8.2.3aa
              If \aCtrlSend[nThisIndex]\bIsOSC
                debugMsg(sProcName, "calling sendOSCCtrlMessage(" + getSubLabel(pSubPtr) + ", nCtrlSendIndex=" + nThisIndex + ")")
                grCtrlSendSubData\sCtrlSendPortName = sendOSCCtrlMessage(pSubPtr, nThisIndex)
              ElseIf \aCtrlSend[nThisIndex]\nEntryMode = #SCS_ENTRYMODE_HEX
                ; Added 24Nov2020 11.8.3.3an
                debugMsg(sProcName, "calling sendNetworkDataMessage(" + nPhysicalDevPtr + ", " + getSubLabel(pSubPtr) + ", " + nThisIndex + ")")
                grCtrlSendSubData\sCtrlSendPortName = sendNetworkDataMessage(nPhysicalDevPtr, pSubPtr, nThisIndex)
                ; End added 24Nov2020 11.8.3.3an
              Else
                ; NB nPhysicalDevPtr = nNetworkControlPtr for network devices
                debugMsg(sProcName, "calling sendNetworkMessage(" + nPhysicalDevPtr + ", \aCtrlSend[" + nThisIndex + "]\sSendString, #False, nStringFormat)")
                grCtrlSendSubData\sCtrlSendPortName = sendNetworkMessage(nPhysicalDevPtr, \aCtrlSend[nThisIndex]\sSendString, #False, nStringFormat) ; added nStringFormat 14Apr2020 11.8.2.3ar
              EndIf
            EndIf
            ; debugMsg(sProcName, "Network grCtrlSendSubData\sCtrlSendPortName=" + grCtrlSendSubData\sCtrlSendPortName)
            If (grCtrlSendSubData\sCtrlSendPortName) And (grCtrlSendSubData\sCtrlSendPortName <> #SCS_NETWORK_CONNECTION_NOT_OPEN)
              nNetworkSent + 1
            EndIf
          EndIf
          ;}
        EndIf
        
        If \aCtrlSend[nThisIndex]\bHTTPSend
          CompilerIf #c_httpsend_in_own_thread
            If nHTTPCount = 0
              ; first http send for this subcue
              LockHTTPSendMutex(800)
            EndIf
            nHTTPCount + 1
            addHTTPStringToArray(\aCtrlSend[nThisIndex]\sSendString, pSubPtr, #False, bCalledFromEditor)
          CompilerElse
            nHTTPCount + 1
            nHTTPResult = sendHTTPString(\aCtrlSend[nThisIndex]\sSendString, pSubPtr, #False, bCalledFromEditor)
            debugMsg(sProcName, "nHTTPResult=" + nHTTPResult)
            If nHTTPResult
              nHTTPSent + 1
            EndIf
          CompilerEndIf
        EndIf ; EndIf \aCtrlSend[nThisIndex]\bHTTPSend
        
        If (\aCtrlSend[nThisIndex]\bMIDISend) And (\aCtrlSend[nThisIndex]\nMSMsgType = #SCS_MSGTYPE_SCRIBBLE_STRIP)
          ; no further action in this iteration of the nThisIndex loop
          Continue
        EndIf
        
        If (\aCtrlSend[nThisIndex]\bMIDISend And \aCtrlSend[nThisIndex]\nMSMsgType <> #SCS_MSGTYPE_NONE) Or (\aCtrlSend[nThisIndex]\bRS232Send) Or (\aCtrlSend[nThisIndex]\bNetworkSend) ; Changed 14Jun2022 11.9.4
          If (Len(grCtrlSendSubData\sCtrlSendPortName) = 0) Or
             (grCtrlSendSubData\sCtrlSendPortName = #SCS_RS232_PORT_NOT_OPEN) Or
             (grCtrlSendSubData\sCtrlSendPortName = #SCS_NETWORK_CONNECTION_NOT_OPEN)
            bCtrlSendError = #True
            nFailCount + 1
            If sCtrlSendSeqFails = ""
              sCtrlSendSeqFails = "#" + Str(nThisIndex+1)
            Else
              sCtrlSendSeqFails + ", #" + Str(nThisIndex+1)
            EndIf
            If grCtrlSendSubData\sCtrlSendPortName = #SCS_RS232_PORT_NOT_OPEN
              sCtrlSendSeqFails + " (port not open)"
            EndIf
            If (\aCtrlSend[nThisIndex]\bNetworkSend) And (grCtrlSendSubData\bOSCItemPlaceHolder)
              sCtrlSendSeqFails + " " + grText\sTextPlaceHolder
              nPlaceHolderFailCount + 1
            EndIf
          Else
            nCtrlSendCount + 1
            If nCtrlSendPortCount = 0
              sCtrlSendPorts = "'" + grCtrlSendSubData\sCtrlSendPortName + "'"
              nCtrlSendPortCount = 1
            ElseIf FindString(sCtrlSendPorts, "'" + grCtrlSendSubData\sCtrlSendPortName + "'") = 0
              sCtrlSendPorts + ", '" + grCtrlSendSubData\sCtrlSendPortName + "'"
              nCtrlSendPortCount + 1
            EndIf
          EndIf
          
        ElseIf \aCtrlSend[nThisIndex]\bHTTPSend
          CompilerIf #c_httpsend_in_own_thread
            nCtrlSendCount + 1
          CompilerElse
            If nHTTPResult
              bCtrlSendError = #True
              If sCtrlSendSeqFails = ""
                sCtrlSendSeqFails = "#" + Str(nThisIndex+1)
              Else
                sCtrlSendSeqFails + ", #" + Str(nThisIndex+1)
              EndIf
            Else
              nCtrlSendCount + 1
            EndIf
          CompilerEndIf
          
        EndIf
        
      EndIf ; EndIf bProcessThisCtrlSendMsg
    Next nThisIndex
    
    If nCtrlSendCount > 0 Or nFailCount > 0
      grCtrlSendSubData\sCtrlSendInfo = ""
      If nMidiCount > 0
        If grSession\nMidiOutEnabled = #SCS_DEVTYPE_NOT_REQD
          If nMidiCount = 1
            grCtrlSendSubData\sCtrlSendInfo = "MIDI message NOT SENT - no MIDI port available"
          Else
            grCtrlSendSubData\sCtrlSendInfo = "MIDI messages NOT SENT - no MIDI port available"
          EndIf
          bUseInfoColor = #True ; Added 6Jan2025 11.10.6cg
        ElseIf grSession\nMidiOutEnabled = #SCS_DEVTYPE_DISABLED
          If nMidiCount = 1
            grCtrlSendSubData\sCtrlSendInfo = "MIDI message NOT SENT - MIDI currently disabled"
          Else
            grCtrlSendSubData\sCtrlSendInfo = "MIDI messages NOT SENT - MIDI currently disabled"
          EndIf
          bUseInfoColor = #True ; Added 6Jan2025 11.10.6cg
        EndIf
      EndIf
      
      If nRS232Count > 0
        If grSession\nRS232OutEnabled = #SCS_DEVTYPE_NOT_REQD
          If nRS232Count = 1
            grCtrlSendSubData\sCtrlSendInfo = Trim(grCtrlSendSubData\sCtrlSendInfo + "  " + "RS232 message NOT SENT - no RS232 port available")
          Else
            grCtrlSendSubData\sCtrlSendInfo = Trim(grCtrlSendSubData\sCtrlSendInfo + "  " + "RS232 messages NOT SENT - no RS232 available")
          EndIf
          bUseInfoColor = #True ; Added 6Jan2025 11.10.6cg
        ElseIf grSession\nRS232OutEnabled = #SCS_DEVTYPE_DISABLED
          If nRS232Count = 1
            grCtrlSendSubData\sCtrlSendInfo = Trim(grCtrlSendSubData\sCtrlSendInfo + "  " + "RS232 message NOT SENT - RS232 currently disabled")
          Else
            grCtrlSendSubData\sCtrlSendInfo = Trim(grCtrlSendSubData\sCtrlSendInfo + "  " + "RS232 messages NOT SENT - RS232 currently disabled")
          EndIf
          bUseInfoColor = #True ; Added 6Jan2025 11.10.6cg
        EndIf
      EndIf
      
      If nNetworkCount > 0
        If grSession\nNetworkOutEnabled = #SCS_DEVTYPE_NOT_REQD
          If nNetworkCount = 1
            grCtrlSendSubData\sCtrlSendInfo = Trim(grCtrlSendSubData\sCtrlSendInfo + "  " + "Network message NOT SENT - no Network connection open")
          Else
            grCtrlSendSubData\sCtrlSendInfo = Trim(grCtrlSendSubData\sCtrlSendInfo + "  " + "Network messages NOT SENT - no Network connection open")
          EndIf
          bUseInfoColor = #True ; Added 6Jan2025 11.10.6cg
        ElseIf grSession\nNetworkOutEnabled = #SCS_DEVTYPE_DISABLED
          If nNetworkCount = 1
            grCtrlSendSubData\sCtrlSendInfo = Trim(grCtrlSendSubData\sCtrlSendInfo + "  " + "Network message NOT SENT - Network currently disabled")
          Else
            grCtrlSendSubData\sCtrlSendInfo = Trim(grCtrlSendSubData\sCtrlSendInfo + "  " + "Network messages NOT SENT - Network currently disabled")
          EndIf
          bUseInfoColor = #True ; Added 6Jan2025 11.10.6cg
        EndIf
      EndIf
      
      If nHTTPCount > 0
        CompilerIf #c_httpsend_in_own_thread
          If THR_getThreadState(#SCS_THREAD_HTTP_SEND) <> #SCS_THREAD_STATE_ACTIVE
            debugMsg(sProcName, "calling THR_createOrResumeAThread(#SCS_THREAD_HTTP_SEND)")
            THR_createOrResumeAThread(#SCS_THREAD_HTTP_SEND)
          EndIf
          UnlockHTTPSendMutex()
        CompilerElse
          grCtrlSendSubData\sCtrlSendInfo = Str(nHTTPResult)
        CompilerEndIf
      EndIf
      
      If (grCtrlSendSubData\sCtrlSendInfo) And (nCtrlSendCount > 0)
        sCRLF = #CRLF$
      Else
        sCRLF = ""
      EndIf
      
      If sCtrlSendPorts
        If nCtrlSendCount = 1
          If nCtrlSendIndex >= 0
            grCtrlSendSubData\sCtrlSendInfo + sCRLF + "Control message #" + Str(nCtrlSendIndex + 1) + " sent via " + sCtrlSendPorts
          Else
            grCtrlSendSubData\sCtrlSendInfo + sCRLF + "Control message sent via " + sCtrlSendPorts
          EndIf
        ElseIf nCtrlSendCount > 1
          grCtrlSendSubData\sCtrlSendInfo + sCRLF + nCtrlSendCount + " control messages sent via " + sCtrlSendPorts
        EndIf
      Else
        If nCtrlSendCount = 1
          If nCtrlSendIndex >= 0
            grCtrlSendSubData\sCtrlSendInfo + sCRLF + "Control message #" + Str(nCtrlSendIndex + 1) + " sent"
          Else
            grCtrlSendSubData\sCtrlSendInfo + sCRLF + "Control message sent"
          EndIf
        ElseIf nCtrlSendCount > 1
          grCtrlSendSubData\sCtrlSendInfo + sCRLF + nCtrlSendCount + " control messages sent"
        EndIf
      EndIf
      
      If Trim(sCtrlSendSeqFails)
        If grCtrlSendSubData\sCtrlSendInfo
          If Right(grCtrlSendSubData\sCtrlSendInfo,1) <> "."
            grCtrlSendSubData\sCtrlSendInfo + ". "
          EndIf
        EndIf
        grCtrlSendSubData\sCtrlSendInfo + sCRLF + "Failed to send " + sCtrlSendSeqFails
        ; added/modified 17Mar2020 11.8.2.3aa
        If nIgnoreDevItemCount > 0
          If nIgnoreDevItemCount = nCtrlSendItemCount
            grCtrlSendSubData\sCtrlSendInfo + " (Device ignored this run)"
          EndIf
        EndIf
        ; end added 17Mar2020 11.8.2.3aa
      EndIf
      
      debugMsg(sProcName, "grCtrlSendSubData\sCtrlSendInfo=" + ReplaceString(grCtrlSendSubData\sCtrlSendInfo, sCRLF, " "))
      
    EndIf ; EndIf nCtrlSendCount > 0 Or nFailCount > 0
    
    If nSubLength = 0
      setSubStateForEndOfSub(pSubPtr, #SCS_CUE_NOT_LOADED)
    EndIf
    
    If pSubPtr >= 0
      If bCalledFromEditor = #False
        If nCtrlSendCount > 0 Or nFailCount > 0
          nInfoStatus = 9999
          If bUseInfoColor ; Added 6Jan2025 11.10.6cg
            nInfoStatus = #SCS_STATUS_INFO
          ElseIf bCtrlSendError
            If Len(gsMidiSendError) = 0
              If (nFailCount > 0) And (nPlaceHolderFailCount = nFailCount Or bIgnoreDevThisRun) ; added bIgnoreDevThisRun test 17Mar2020 11.8.2.3aa
                ; only errors are due to placeholders or ignored device, so just display a 'warning' message (not an 'error' message), but extend the display time
                nInfoStatus = #SCS_STATUS_WARN
                nExtraDisplayTime = 6000
              Else
                nInfoStatus = #SCS_STATUS_ERROR
              EndIf
            EndIf
          CompilerIf #c_httpsend_in_own_thread = #False
          ElseIf (nHTTPSent > 0) And (gnHTTPGetStatusCode <> 200)
            nInfoStatus = #SCS_STATUS_WARN
            nExtraDisplayTime = 6000
          CompilerEndIf
          Else
            nInfoStatus = #SCS_STATUS_INFO
          EndIf
          If nInfoStatus <> 9999
            ; debugMsg(sProcName, "calling WMN_setStatusField(" + nInfoStatus + ", " + nExtraDisplayTime + ")")
            WMN_setStatusField(" " + grCtrlSendSubData\sCtrlSendInfo, nInfoStatus, nExtraDisplayTime)
          EndIf
        EndIf ; EndIf nCtrlSendCount > 0 Or nFailCount > 0
      EndIf ; EndIf bCalledFromEditor = #False
      ; debugMsg(sProcName, "calling setCueState(" + \nCueIndex + ")")
      setCueState(\nCueIndex)
      If aCue(\nCueIndex)\nHideCueOpt <> #SCS_HIDE_ENTIRE_CUE
        samAddRequest(#SCS_SAM_LOAD_GRID_ROW, \nCueIndex)
      EndIf
    EndIf
    
    ; Added 1Feb2024 11.10.2ad
    debugMsg(sProcName, "nMaxOpenedDev=" + nMaxOpenedDev)
    If nMaxOpenedDev >= 0
      For n = 0 To nMaxOpenedDev
        nPhysicalDevPtr = aOpenedDev(n)
        ; debugMsg(sProcName, "calling closeANetworkConnection(" + nPhysicalDevPtr + ")")
        closeANetworkConnection(nPhysicalDevPtr, #False)
      Next n
    EndIf
    ; End added 1Feb2024 11.10.2ad
    
  EndWith
  
  debugMsg(sProcName, #SCS_END)
  
  ProcedureReturn #True
  
EndProcedure

Procedure playSubTypeN(pSubPtr, bCalledFromEditor)
  ; SubType N = Note
  PROCNAMECS(pSubPtr)
  Protected sNote.s
  Protected sCommand.s, sFirstCue.s, sDash.s, sLastCue.s
  Protected nFirstCuePtr, nLastCuePtr
  Protected bEnable, nCuesChanged
  ; for http notes:
  Protected sFullCommand.s
  Protected nResult.i
  Protected *pHttpResponseBuffer
  
  debugMsg(sProcName, #SCS_START)
  
  With aSub(pSubPtr)
    sNote = Trim(aCue(\nCueIndex)\sCueDescr)
    If Len(sNote) > 7
      If LCase(Left(sNote,6)) = "$http:"
        sFullCommand = Mid(sNote,2) ; ignore "$" at start
        nResult = addHTTPStringToArray(sFullCommand, 0)
        debugMsg3(sProcName, "SimpleHTTP_GET(" + sFullCommand + ", " + strB(#cTraceHTTP) + ") returned " + nResult)
        
      ElseIf Left(sNote,1) = "$"
        sCommand = LCase(StringField(sNote,1," "))
        Select sCommand
          Case "$enable", "$disable"
            If grLicInfo\nLicLevel >= #SCS_LIC_PRO
              sFirstCue = StringField(sNote,2," ")
              sDash = StringField(sNote,3," ")
              sLastCue = StringField(sNote,4," ")
              nFirstCuePtr = getCuePtr(sFirstCue)
              If nFirstCuePtr >= 0
                nLastCuePtr = nFirstCuePtr
                If sDash = "-"
                  nLastCuePtr = getCuePtr(sLastCue)
                EndIf
                If nLastCuePtr >= nFirstCuePtr
                  If sCommand = "$enable"
                    bEnable = #True
                  Else
                    bEnable = #False
                  EndIf
                  debugMsg(sProcName, "calling EnableDisableCues(" + strB(bEnable) + ", " + getCueLabel(nFirstCuePtr) + ", " + getCueLabel(nLastCuePtr) + ")")
                  nCuesChanged = EnableDisableCues(bEnable, nFirstCuePtr, nLastCuePtr)
                  ; Added 1Feb2021 11.8.3.5 - see comments in EnableDisableCues()
                  If nCuesChanged > 0
                    debugMsg(sProcName, "calling setCueDetailsInMain()")
                    setCueDetailsInMain()
                    debugMsg(sProcName, "calling ONC_openNextCues()")
                    ONC_openNextCues()
                  EndIf
                  ; End added 1Feb2021 11.8.3.5
                EndIf
              EndIf
            EndIf
        EndSelect
      EndIf
    EndIf
    
    If aCue(\nCueIndex)\bNonLinearCue
      endOfSub(pSubPtr, #SCS_CUE_READY)
    Else
      endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
    EndIf
    If pSubPtr >= 0
      setCueState(\nCueIndex)
      updateGrid(\nCueIndex)
    EndIf
  EndWith
  
  debugMsg(sProcName, #SCS_END)
  
  ProcedureReturn #True
  
EndProcedure

Procedure playSubTypeP(pSubPtr, bCalledFromEditor, bUseCas, nCasGroupId, nStartAtTrkNo)
  ; SubType P = Playlist
  PROCNAMECS(pSubPtr)
  Protected d, k
  Protected nAudPtr
  Protected nMyPLMastFadeInTime
  Protected nMyFirstPlayIndex
  Protected nMyPrevPlayIndex
  
  debugMsg(sProcName, #SCS_START + ", bCalledFromEditor=" + strB(bCalledFromEditor) + ", bUseCas=" + strB(bUseCas) + ", nCasGroupId=" + nCasGroupId + ", nStartAtTrkNo=" + nStartAtTrkNo)
  
  With aSub(pSubPtr)
    
    Select \nSubState
      Case #SCS_CUE_PLAYING, #SCS_CUE_FADING_IN, #SCS_CUE_TRANS_FADING_IN, #SCS_CUE_TRANS_FADING_OUT, #SCS_CUE_TRANS_MIXING_OUT
        ; cue already playing - ignore this 'playsub' request
        ProcedureReturn
        
      ; Case #SCS_CUE_SUB_COUNTDOWN_TO_START
        ; ; initially set to nSubState to SCS_CUE_PLAYING so setCueState will drill down to any aud's to determine state
        ; \nSubState = #SCS_CUE_PLAYING
        
    EndSelect
    
    If \bPLRandom
      logListEvent(sProcName, "PlayOrder=" + \sPlayOrder)
    EndIf
    
    nMyPLMastFadeInTime = \nPLFadeInTime
    nMyFirstPlayIndex = \nFirstPlayIndex
    \bPLFadingIn = #False
    \bPLFadingOut = #False
    \nPLCurrFadeInTime = \nPLFadeInTime
    \nPLCurrFadeOutTime = \nPLFadeOutTime
    
    ; reset 'completed' auds to 'pl_ready' which is necessary if restarting after stopping the sub, eg after hitting ESC
    k = \nFirstPlayIndex
    nAudPtr = \nFirstPlayIndex
    While k >= 0
      aAud(k)\bIgnoreInStatusCheck = #False
      ; debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\bIgnoreInStatusCheck=" + strB(aAud(k)\bIgnoreInStatusCheck))
      If aAud(k)\nAudNo = nStartAtTrkNo
        nAudPtr = k
      EndIf
      If (aAud(k)\nAudState = #SCS_CUE_COMPLETED) Or (aAud(k)\nAudState = #SCS_CUE_READY)
        If aAud(k)\nAudNo < nStartAtTrkNo
          ; If aSub(pSubPtr)\bPLRepeat
          If getPLRepeatActive(pSubPtr)
            aAud(k)\nAudState = #SCS_CUE_PL_READY
          Else
            aAud(k)\nAudState = #SCS_CUE_COMPLETED
            debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nAudState=" + decodeCueState(aAud(k)\nAudState))
          EndIf
        Else
          If aAud(k)\nPrevPlayIndex < 0
            If aAud(k)\nAudState <> #SCS_CUE_READY
              debugMsg(sProcName, "(f1) changing " + aAud(k)\sAudLabel + " \nAudState from " + decodeCueState(aAud(k)\nAudState) + " to " + decodeCueState(#SCS_CUE_READY))
              aAud(k)\nAudState = #SCS_CUE_READY
            EndIf
          Else
            If aAud(k)\nAudState <> #SCS_CUE_PL_READY
              debugMsg(sProcName, "(f2) changing " + aAud(k)\sAudLabel + " \nAudState from " + decodeCueState(aAud(k)\nAudState) + " to " + decodeCueState(#SCS_CUE_PL_READY))
              aAud(k)\nAudState = #SCS_CUE_PL_READY
            EndIf
          EndIf
        EndIf
        
        For d = 0 To grLicInfo\nMaxAudDevPerAud
          If k = nMyFirstPlayIndex
            If nMyPLMastFadeInTime > 0
              aAud(k)\fCueVolNow[d] = #SCS_MINVOLUME_SINGLE
            Else
              aAud(k)\fCueVolNow[d] = aAud(k)\fBVLevel[d]
            EndIf
          ElseIf (aAud(k)\nFadeInTime > 0) Or ((k = aSub(pSubPtr)\nFirstPlayIndex) And (aSub(pSubPtr)\nPLFadeInTime > 0))
            aAud(k)\fCueVolNow[d] = #SCS_MINVOLUME_SINGLE
          Else
            aAud(k)\fCueVolNow[d] = aAud(k)\fBVLevel[d]
          EndIf
          aAud(k)\fCueAltVolNow[d] = #SCS_MINVOLUME_SINGLE
          aAud(k)\fCueTotalVolNow[d] = aAud(k)\fCueVolNow[d]
          CompilerIf #cTraceCueTotalVolNow
            debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\fCueTotalVolNow[" + d + "]=" + traceLevel(aAud(k)\fCueTotalVolNow[d]))
          CompilerEndIf
          aAud(k)\fCuePanNow[d] = aAud(k)\fPan[d]
        Next d
      EndIf
      If k = nMyFirstPlayIndex And nMyPLMastFadeInTime > 0
        aAud(k)\nCurrFadeInTime = nMyPLMastFadeInTime
      EndIf
      k = aAud(k)\nNextPlayIndex
    Wend
    
    For d = 0 To grLicInfo\nMaxAudDevPerAud
      \fSubBVLevelNow[d] = \fSubMastBVLevel[d]
      \fSubPanNow[d] = \fPLPan[d]
    Next d
    
    debugMsg(sProcName, "nAudPtr=" + getAudLabel(nAudPtr))
    \nCurrPlayIndex = nAudPtr
    debugMsg(sProcName, "\nCurrPlayIndex=" + getAudLabel(\nCurrPlayIndex))
    
    If (\bStartedInEditor) And (gnPLTestMode = #SCS_PLTESTMODE_HIGHLIGHTED_FILE)
      nAudPtr = nEditAudPtr
    EndIf
    debugMsg(sProcName, "calling calcPLTotalTime(" + getSubLabel(pSubPtr) + ")")
    calcPLTotalTime(pSubPtr)
    
    If nAudPtr >= 0
      ; debugMsg(sProcName, "calling playAud(" + GetAudLabel(nAudPtr) + ")")
      ; playAud(nAudPtr, bUseCas, #True, nCasGroupId)
      ; Changed the above 22Oct2021 11.8.6be
      debugMsg(sProcName, "calling playAud(" + GetAudLabel(nAudPtr) + strB(bUseCas) + ", " + nCasGroupId + ", #True)")
      playAud(nAudPtr, bUseCas, #True, nCasGroupId, #True) ; set bTopLevelCall = #True to force SM-S play to be issued
      ; End of changed 22Oct2021 11.8.6be
      debugMsg(sProcName, "aAud(" + GetAudLabel(nAudPtr) + ")\nAudState=" + decodeCueState(aAud(nAudPtr)\nAudState))
    EndIf
    
    If (nAudPtr = -1) And (\bSubPlaceHolder)
      endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
    EndIf
    setCueState(\nCueIndex, #True)
    samAddRequest(#SCS_SAM_LOAD_GRID_ROW, \nCueIndex)
    debugMsg(sProcName, "calling calcPLUnplayedFilesTime(" + getSubLabel(pSubPtr) + ")")
    calcPLUnplayedFilesTime(pSubPtr)
    
    If nAudPtr >= 0
      aAud(nAudPtr)\qTimeAudStarted = gqTimeNow
      aAud(nAudPtr)\bTimeAudEndedSet = #False
      If aAud(nAudPtr)\bCheckProgSlider
        aAud(nAudPtr)\qTimeAudRestarted = aAud(nAudPtr)\qTimeAudStarted - aAud(nAudPtr)\nRelFilePos
        aAud(nAudPtr)\bCheckProgSlider = #False
        debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\bCheckProgSlider=" + strB(aAud(nAudPtr)\bCheckProgSlider))
      Else
        aAud(nAudPtr)\qTimeAudRestarted = aAud(nAudPtr)\qTimeAudStarted
      EndIf
      debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\qTimeAudRestarted=" + traceTime(aAud(nAudPtr)\qTimeAudRestarted))
      aAud(nAudPtr)\nTotalTimeOnPause = 0
      aAud(nAudPtr)\nPriorTimeOnPause = 0
      aAud(nAudPtr)\nPreFadeInTimeOnPause = 0
      aAud(nAudPtr)\nPreFadeOutTimeOnPause = 0
      aAud(nAudPtr)\nCuePosAtLoopStart = 0
      
      If (\nPLFadeInTime > 0) And (nAudPtr = \nFirstPlayIndex)
        \qPLTimeFadeInStarted = gqTimeNow
        aAud(nAudPtr)\qTimeFadeInStarted = gqTimeNow
        aAud(nAudPtr)\nCuePosAtFadeStart = aAud(nAudPtr)\nCuePos
        debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\qTimeFadeInStarted=" + traceTime(aAud(nAudPtr)\qTimeFadeInStarted) + ", \nCuePosAtFadeStart=" + aAud(nAudPtr)\nCuePosAtFadeStart)
        aAud(nAudPtr)\bTimeFadeInStartedSet = #True
        aAud(nAudPtr)\nPreFadeInTimeOnPause = aAud(nAudPtr)\nTotalTimeOnPause
      EndIf
      
      If gbUseBASSMixer = #False
        samAddRequest(#SCS_SAM_BUILD_DEV_CHANNEL_LIST)
      EndIf
      startVUDisplayIfReqd()
    EndIf
    
  EndWith
  
  ProcedureReturn #True
  
EndProcedure

Procedure playSubTypeQ(pSubPtr, bCalledFromEditor)
  ; SubType Q = Call Cue
  PROCNAMECS(pSubPtr)
  Protected nCuePtr
  Protected bSubrCalled
  
  debugMsg(sProcName, #SCS_START)
  
  If pSubPtr >= 0
    If bCalledFromEditor = #False
      With aSub(pSubPtr)
        Select \nCallCueAction
          Case #SCS_QQ_CALLCUE
            nCuePtr = getCuePtr(\sCallCue)
            \nCallCuePtr = nCuePtr
            debugMsg(sProcName, "\sCallCue=" + \sCallCue + ", \nCallCuePtr=" + getCueLabel(\nCallCuePtr))
            If nCuePtr >= 0
              ; debugMsg(sProcName, "aCue(" + getCueLabel(nCuePtr) + ")\bCueCurrentlyEnabled=" + strB(aCue(nCuePtr)\bCueCurrentlyEnabled))
              If aCue(nCuePtr)\bCueCurrentlyEnabled = #False
                ; the subroutine is currently disabled
                nCuePtr = -1
              EndIf
            EndIf
            
            If nCuePtr < 0
              WMN_setStatusField(LangPars("Errors", "CueNotFound", \sCallCue), #SCS_STATUS_ERROR)
            Else
              aCue(nCuePtr)\nCalledBySubPtr = pSubPtr
              ; debugMsg(sProcName, "aCue(" + getCueLabel(nCuePtr) + ")\nCalledBySubPtr=" + getSubLabel(aCue(nCuePtr)\nCalledBySubPtr))
              If bCalledFromEditor = #False
                debugMsg(sProcName, "calling applyCallCueParameters(pSubPtr)")
                applyCallCueParameters(pSubPtr)
              EndIf
              debugMsg(sProcName, "calling playCueViaCas(" + getCueLabel(nCuePtr) + ")")
              playCueViaCas(nCuePtr)
              bSubrCalled = #True
            EndIf
            
          Case #SCS_QQ_SELHKBANK
            If (\nSelHKBank > 0) And (\nSelHKBank <= grLicInfo\nMaxHotkeyBank)
              samAddRequest(#SCS_SAM_SET_HOTKEY_BANK, \nSelHKBank)
            EndIf
            
        EndSelect
        
        
        ; debugMsg(sProcName, "bSubrCalled=" + strB(bSubrCalled))
        If bSubrCalled
          \qTimeSubStarted = gqTimeNow
          \qAdjTimeSubStarted = gqTimeNow
          \bTimeSubStartedSet = #True
          \qTimeSubRestarted = \qTimeSubStarted
          \nSubTotalTimeOnPause = 0
          \nSubPriorTimeOnPause = 0
          \nSubState = #SCS_CUE_PLAYING
        Else
          If aCue(\nCueIndex)\bNonLinearCue
            endOfSub(pSubPtr, #SCS_CUE_READY)
          Else
            Select \nCallCueAction
              Case #SCS_QQ_CALLCUE
                If aCue(\nCueIndex)\nActivationMethod = #SCS_ACMETH_HK_STEP
                  endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
                ElseIf (\bHotkey) Or (\bExtAct) Or (\bCallableCue) Or (nCuePtr < \nCueIndex)
                  endOfSub(pSubPtr, #SCS_CUE_READY)
                Else
                  endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
                EndIf
              Case #SCS_QQ_SELHKBANK
                If aCue(\nCueIndex)\nActivationMethod = #SCS_ACMETH_HK_STEP
                  endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
                ElseIf (\bHotkey) Or (\bExtAct) Or (\bCallableCue)
                  endOfSub(pSubPtr, #SCS_CUE_READY)
                Else
                  endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
                EndIf
            EndSelect
          EndIf
        EndIf
        
        setCueState(\nCueIndex)
        updateGrid(\nCueIndex)
        If bSubrCalled
          aCue(\nCueIndex)\bStopOpenNextCuesHere = #True
          debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\bStopOpenNextCuesHere=#True")
          If getHideCueOpt(\nCueIndex) = #SCS_HIDE_NO ; test added 20Jul2018 11.7.1.1ad following email from Llus Vilarrasa
            ; request 'load display panels' to allow called cue to be displayed
            debugMsg(sProcName, "setting gbCallLoadDispPanels=#True")
            gbCallLoadDispPanels = #True
          EndIf
        EndIf
        
      EndIf
      
    EndWith
  EndIf
  
  debugMsg(sProcName, #SCS_END + ", aSub(" + getSubLabel(pSubPtr) + ")\nSubState=" + decodeCueState(aSub(pSubPtr)\nSubState) + ", returning #True")
  ProcedureReturn #True
  
EndProcedure

Procedure playSubTypeR(pSubPtr, bCalledFromEditor)
  ; SubType R - Run External Program
  PROCNAMECS(pSubPtr)
  Protected nResult
  Protected sMyRPFileName.s, sMyRPParams.s, sMyRPStartFolder.s
  Protected nOrigActiveWindow, nCurrActiveWindow
  
  debugMsg(sProcName, #SCS_START + ", bCalledFromEditor=" + strB(bCalledFromEditor))
  
  With aSub(pSubPtr)
    nOrigActiveWindow = GetActiveWindow() ; added 11Jun2019 11.8.1.2ad
    debugMsg(sProcName, "nOrigActiveWindow=" + decodeWindow(nOrigActiveWindow))
    
    sMyRPFileName = decodeFileName(\sRPFileName)
    sMyRPParams = decodeFileName(\sRPParams, #True, #False)
    sMyRPStartFolder = decodeFileName(\sRPStartFolder)
    
    If \bRPHideSCS
      setScreenWindowsVisible(2, #False)
    EndIf
    
    If \bRPInvisible
      nResult = RunProgram(sMyRPFileName, sMyRPParams, sMyRPStartFolder, #PB_Program_Hide)
      debugMsg2(sProcName, "RunProgram(" + #DQUOTE$ + sMyRPFileName + #DQUOTE$ + ", " + #DQUOTE$ + sMyRPParams + #DQUOTE$ + ", " + #DQUOTE$ + sMyRPStartFolder + #DQUOTE$ + ", #PB_Program_Hide)", nResult)
    Else
      nResult = RunProgram(sMyRPFileName, sMyRPParams, sMyRPStartFolder)
      debugMsg2(sProcName, "RunProgram(" + #DQUOTE$ + sMyRPFileName + #DQUOTE$ + ", " + #DQUOTE$ + sMyRPParams + #DQUOTE$ + ", " + #DQUOTE$ + sMyRPStartFolder + #DQUOTE$ + ")", nResult)
    EndIf
    If nResult = 0
      WMN_setStatusField(LangPars("Errors", "RunProgFailed", sMyRPFileName), #SCS_STATUS_ERROR)
    EndIf
    
;     If aCue(\nCueIndex)\bNonLinearCue
;       endOfSub(pSubPtr, #SCS_CUE_READY)
;     Else
;       If \bHotkey Or \bExtAct Or \bCallableCue
;         endOfSub(pSubPtr, #SCS_CUE_READY)
;       Else
;         endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
;       EndIf
;     EndIf
    setSubStateForEndOfSub(pSubPtr, #SCS_CUE_READY)
    debugMsg(sProcName, "calling setCueState(" + getCueLabel(\nCueIndex) + ")")
    setCueState(\nCueIndex)
    debugMsg(sProcName, "calling updateGrid(" + getCueLabel(\nCueIndex) + ")")
    updateGrid(\nCueIndex)
  EndWith
  
  If bCalledFromEditor = #False
    If nOrigActiveWindow <> -1
      nCurrActiveWindow = GetActiveWindow()
      debugMsg(sProcName, "nCurrActiveWindow=" + decodeWindow(nCurrActiveWindow))
      If nCurrActiveWindow <> nOrigActiveWindow
        debugMsg(sProcName, "calling Delay(250)")
        Delay(250)  ; give program time to take focus before we grab it back
        debugMsg(sProcName, "calling SetForegroundWindow_(WindowID(nOrigActiveWindow))")
        SetForegroundWindow_(WindowID(nOrigActiveWindow))
        SAW(nOrigActiveWindow)
        SAG(-1)
      EndIf
    EndIf
  EndIf
  
  debugMsg(sProcName, #SCS_END)
  
  ProcedureReturn #True
  
EndProcedure

Procedure playSubTypeS(pSubPtr, bCalledFromEditor, bUseCas, nCasGroupId, nHotkeyToggleState=-1)
  ; SubType S = SFR (Stop/Fade-Out/Loop-Release)
  PROCNAMECS(pSubPtr)
  Protected d, i, j, k, m, h
  Protected nSFRCueType, sSFRCue.s, nSFRSubNo, nSFRSubPtr, nSFRAction, nSFRLoopNo, nSFRLoopIndex
  Protected bSFRStop, bSFRFadeOut, bSFRRelease, bSFRTrack
  Protected bSFRFadeIn
  Protected bExcludeSFRCueList
  Protected nFromCuePtr, nUptoCuePtr
  Protected nTmpCuePtr
  Protected nNextManualCuePtr
  Protected bAnyCues, bPlayingCuesOnly, bAudioOnly, bVideoOnly, bLiveOnly
  Protected bPause
  Protected bFound, bFadeIn
  Protected fTmpLevel.f
  Protected bWantThisSub
  Protected nCuePtr
  Protected nVidPicTarget
  
  debugMsg(sProcName, #SCS_START)
  
  If bCalledFromEditor
    ; do not 'play' subtype S if in edit window
    ProcedureReturn
  EndIf
  
  With aSub(pSubPtr)
    
    ; set all time overrides first
    grMMedia\nSFRCueMax = -1
    ; If \nSFRTimeOverride >= 0 ; commented out this test 18Mar2019 11.8.0.2ce because the aAud(k)\nCurrFadeInTime (or \nCurrFadeOutTime) may need to be set for Playlist and Video/Image cues, and that will be set in setTimeOverrides()
      For h = 0 To #SCS_MAX_SFR
        nSFRAction = \nSFRAction[h]
        If nSFRAction = #SCS_SFR_ACT_NA
          Continue
        EndIf
        If nHotkeyToggleState = 0
          ; even press, eg 2nd, 4th, 6th etc
          Select nSFRAction
            Case #SCS_SFR_ACT_PAUSE
              nSFRAction = #SCS_SFR_ACT_RESUME
            Case #SCS_SFR_ACT_PAUSEHIB, #SCS_SFR_ACT_FADEOUTHIB
              nSFRAction = #SCS_SFR_ACT_RESUMEHIB
          EndSelect
        EndIf
        
        Select nSFRAction
          Case #SCS_SFR_ACT_STOPALL, #SCS_SFR_ACT_FADEALL, #SCS_SFR_ACT_PAUSEALL, #SCS_SFR_ACT_STOPMTC
            nSFRCueType = -1
          Default
            nSFRCueType = \nSFRCueType[h]
        EndSelect
        debugMsg(sProcName, "h=" + h + ", nHotkeyToggleState=" + nHotkeyToggleState + ", nSFRAction=" + decodeSFRAction(nSFRAction) + ", nSFRCueType=" + decodeSFRCueType(nSFRCueType))
        
        If nSFRCueType = #SCS_SFR_CUE_SEL
          sSFRCue = \sSFRCue[h]
          nSFRSubNo = \nSFRSubNo[h]
          nSFRSubPtr = \nSFRSubPtr[h]
          nSFRLoopNo = \nSFRLoopNo[h]
        Else
          sSFRCue = ""
          nSFRSubNo = -1
          nSFRSubPtr = -1
          nSFRLoopNo = 0
        EndIf
        nSFRLoopIndex = nSFRLoopNo - 1
        
        If (nSFRCueType = #SCS_SFR_CUE_ALLEXCEPT) Or (nSFRCueType = #SCS_SFR_CUE_PLAYEXCEPT)
          bExcludeSFRCueList = #True
        Else
          bExcludeSFRCueList = #False
        EndIf
        
        Select nSFRCueType
          Case #SCS_SFR_CUE_ALL_FIRST To #SCS_SFR_CUE_ALL_LAST, #SCS_SFR_CUE_PLAY_FIRST To #SCS_SFR_CUE_PLAY_LAST, #SCS_SFR_CUE_ALLEXCEPT, #SCS_SFR_CUE_PLAYEXCEPT  ; all, play, allexcept, playexcept
            nTmpCuePtr = gnCueEnd
            If aCue(\nCueIndex)\bNonLinearCue = #False
              Select nSFRCueType
                Case #SCS_SFR_CUE_ALL_FIRST To #SCS_SFR_CUE_ALL_LAST, #SCS_SFR_CUE_ALLEXCEPT
                  nTmpCuePtr = \nCueIndex
              EndSelect
            EndIf
            
            debugMsg(sProcName, "\bHotkey=" + strB(\bHotkey) + ", gnCueToGo=" + getCueLabel(gnCueToGo))
            If (\bHotkey Or \bExtAct Or \bCallableCue) And (gnCueToGo >= 0)
              Select nSFRCueType
                Case #SCS_SFR_CUE_ALL_FIRST To #SCS_SFR_CUE_ALL_LAST, #SCS_SFR_CUE_ALLEXCEPT
                  nTmpCuePtr = gnCueToGo
              EndSelect
            EndIf
            
            Select nSFRCueType
              Case #SCS_SFR_CUE_PLAY_FIRST To #SCS_SFR_CUE_PLAY_LAST, #SCS_SFR_CUE_PLAYEXCEPT
                bPlayingCuesOnly = #True
            EndSelect
            
            nFromCuePtr = 1
            nUptoCuePtr = nTmpCuePtr - 1
            Select nSFRAction
              Case #SCS_SFR_ACT_FADEOUT
                ; Changed 31Jul2024 11.10.3aw following bug reported by Dave Korman 17Jun2024 'Stop All Playing Cues subcue does not stop earlier subcues'.
                ; NB Also found that bExcludeSFRCueList is not used in setTimeOverrides()
                ; setTimeOverrides(#SCS_FADE_OUT_FIELD, \nSFRAction[h], \nSFRTimeOverride, nFromCuePtr, nUptoCuePtr, nSFRCueType, nSFRSubNo, \nCueIndex, bExcludeSFRCueList)
                setTimeOverrides(#SCS_FADE_OUT_FIELD, \nSFRAction[h], \nSFRTimeOverride, nFromCuePtr, nUptoCuePtr, nSFRCueType, nSFRSubNo)
                ; End changed 31Jul2024 11.10.3aw
                
              Case #SCS_SFR_ACT_FADEOUTHIB
                setTimeOverrides(#SCS_FADE_OUT_FIELD, \nSFRAction[h], \nSFRTimeOverride, nFromCuePtr, nUptoCuePtr, nSFRCueType, nSFRSubNo)
                
              Case #SCS_SFR_ACT_RESUMEHIB
                setTimeOverrides(#SCS_FADE_IN_FIELD, \nSFRAction[h], \nSFRTimeOverride, nFromCuePtr, nUptoCuePtr, nSFRCueType, nSFRSubNo)
                
              Case #SCS_SFR_ACT_RESUMEHIBNEXT
                setTimeOverrides(#SCS_FADE_IN_FIELD, \nSFRAction[h], \nSFRTimeOverride, nFromCuePtr, nUptoCuePtr, nSFRCueType, nSFRSubNo)
                
            EndSelect
            
          Case #SCS_SFR_CUE_SEL, #SCS_SFR_CUE_PREV ; sel or prev
            debugMsg(sProcName, "\nSFRCuePtr[" + h + "]=" + getCueLabel(\nSFRCuePtr[h]))
            If (\nSFRCueType = #SCS_SFR_CUE_PREV) And (\nSFRCuePtr[h] = -1)
              setCuePtrForSFRPrevCueType(pSubPtr, h)
            EndIf
            sSFRCue = \sSFRCue[h]
            If sSFRCue
              grMMedia\nSFRCueMax + 1
              debugMsg(sProcName, "grMMedia\nSFRCueMax=" + grMMedia\nSFRCueMax + ", h=" + h)
              nCuePtr = \nSFRCuePtr[h]
              grMMedia\anSFRCuePtr[grMMedia\nSFRCueMax] = nCuePtr
              For m = 1 To gnLastCue
                If aCue(m)\sCue = sSFRCue
                  nFromCuePtr = m
                  nUptoCuePtr = m
                  Select nSFRAction
                    Case #SCS_SFR_ACT_FADEOUT
                      setTimeOverrides(#SCS_FADE_OUT_FIELD, \nSFRAction[h], \nSFRTimeOverride, nFromCuePtr, nUptoCuePtr, nSFRCueType, nSFRSubNo)
                      
                    Case #SCS_SFR_ACT_FADEOUTHIB
                      setTimeOverrides(#SCS_FADE_OUT_FIELD, \nSFRAction[h], \nSFRTimeOverride, nFromCuePtr, nUptoCuePtr, nSFRCueType, nSFRSubNo)
                      
                    Case #SCS_SFR_ACT_RESUMEHIB
                      setTimeOverrides(#SCS_FADE_IN_FIELD, \nSFRAction[h], \nSFRTimeOverride, nFromCuePtr, nUptoCuePtr, nSFRCueType, nSFRSubNo)
                      
                    Case #SCS_SFR_ACT_RESUMEHIBNEXT
                      setTimeOverrides(#SCS_FADE_IN_FIELD, \nSFRAction[h], \nSFRTimeOverride, nFromCuePtr, nUptoCuePtr, nSFRCueType, nSFRSubNo)
                      
                  EndSelect
                  
                EndIf
              Next m
            EndIf
            
        EndSelect
        
      Next h
    ; EndIf ; commented out 18Mar2019 11.8.0.2ce - see note at 'If'
    
    ; now perform SFR action
    grMMedia\nSFRCueMax = -1
    ; debugMsg(sProcName, "grMMedia\nSFRCueMax=" + grMMedia\nSFRCueMax)
    For h = 0 To #SCS_MAX_SFR
      nSFRAction = \nSFRAction[h]
      If nSFRAction = #SCS_SFR_ACT_NA
        Continue
      EndIf
      If nSFRAction = #SCS_SFR_ACT_STOPALL
        gqMainThreadRequest | #SCS_MTH_STOP_ALL
        Continue
      EndIf
      If nSFRAction = #SCS_SFR_ACT_FADEALL
        If \nSFRTimeOverride >= 0
          gnFadeEverythingTime = \nSFRTimeOverride
        Else
          gnFadeEverythingTime = grGeneralOptions\nFadeAllTime
        EndIf
        debugMsg(sProcName, "added #SCS_MTH_FADE_ALL to gqMainThreadRequest")
        gqMainThreadRequest | #SCS_MTH_FADE_ALL
        Continue
      EndIf
      If nSFRAction = #SCS_SFR_ACT_PAUSEALL
        gqMainThreadRequest | #SCS_MTH_PAUSE_RESUME_ALL
        Continue
      EndIf
      If nSFRAction = #SCS_SFR_ACT_STOPMTC
        gqMainThreadRequest | #SCS_MTH_STOP_MTC
        Continue
      EndIf
      
      If nHotkeyToggleState = 0
        ; even press, eg 2nd, 4th, 6th etc
        Select nSFRAction
          Case #SCS_SFR_ACT_PAUSE
            nSFRAction = #SCS_SFR_ACT_RESUME
          Case #SCS_SFR_ACT_PAUSEHIB, #SCS_SFR_ACT_FADEOUTHIB
            nSFRAction = #SCS_SFR_ACT_RESUMEHIB
        EndSelect
      EndIf
      nSFRCueType = \nSFRCueType[h]
      debugMsg(sProcName, "h=" + h + ", nHotkeyToggleState=" + Str(nHotkeyToggleState) + ", nSFRAction=" + decodeSFRAction(nSFRAction) + ", nSFRCueType=" + decodeSFRCueType(nSFRCueType))
      
      If nSFRCueType = #SCS_SFR_CUE_SEL
        sSFRCue = \sSFRCue[h]
        nSFRSubNo = \nSFRSubNo[h]
        nSFRSubPtr = \nSFRSubPtr[h]
        nSFRLoopNo = \nSFRLoopNo[h]
      Else
        sSFRCue = ""
        nSFRSubNo = -1
        nSFRSubPtr = -1
        nSFRLoopNo = 0
      EndIf
      nSFRLoopIndex = nSFRLoopNo - 1
      
      If (nSFRCueType = #SCS_SFR_CUE_ALLEXCEPT) Or (nSFRCueType = #SCS_SFR_CUE_PLAYEXCEPT)
        bExcludeSFRCueList = #True
      Else
        bExcludeSFRCueList = #False
      EndIf
      
      setProcSFRFlags(nSFRCueType)  ; macro sets bPlayingCuesOnly, bAudioOnly and bVideoOnly, based on nSFRCueType
      debugMsg(sProcName, "bPlayingCuesOnly=" + strB(bPlayingCuesOnly) + ", bAudioOnly=" + strB(bAudioOnly) + ", bVideoOnly=" + strB(bVideoOnly) + ", bLiveOnly=" + strB(bLiveOnly))
      
      Select nSFRCueType
        Case #SCS_SFR_CUE_ALL_FIRST To #SCS_SFR_CUE_ALL_LAST, #SCS_SFR_CUE_PLAY_FIRST To #SCS_SFR_CUE_PLAY_LAST, #SCS_SFR_CUE_ALLEXCEPT, #SCS_SFR_CUE_PLAYEXCEPT  ; all, play, allexcept, playexcept
          ;{
          nTmpCuePtr = gnCueEnd
          If aCue(\nCueIndex)\bNonLinearCue = #False
            Select nSFRCueType
              Case #SCS_SFR_CUE_ALL_FIRST To #SCS_SFR_CUE_ALL_LAST, #SCS_SFR_CUE_ALLEXCEPT
                nTmpCuePtr = \nCueIndex
            EndSelect
          EndIf
          
          debugMsg(sProcName, "\bHotkey=" + strB(\bHotkey) + ", gnCueToGo=" + getCueLabel(gnCueToGo))
          If (\bHotkey Or \bExtAct Or \bCallableCue) And (gnCueToGo >= 0)
            Select nSFRCueType
              Case #SCS_SFR_CUE_ALL_FIRST To #SCS_SFR_CUE_ALL_LAST, #SCS_SFR_CUE_ALLEXCEPT
                nTmpCuePtr = gnCueToGo
            EndSelect
          EndIf
          
          nFromCuePtr = 1
          nUptoCuePtr = nTmpCuePtr - 1
          debugMsg(sProcName, "nSFRAction=" + decodeSFRAction(nSFRAction))
          Select nSFRAction
            Case #SCS_SFR_ACT_STOP
              ;{
              debugMsg(sProcName, "nSFRAction=#SCS_SFR_ACT_STOP")
              bSFRStop = #True
              ; stopAllEarlierCues(nTmpCuePtr, #False, "ALL", #True, #True, #False, nSFRCueType, \nCueIndex, bExcludeSFRCueList, \bSFRCompleteAssocAutoStartCues, \bSFRHoldAssocAutoStartCues)
              stopAllEarlierCues(nTmpCuePtr, #False, "ALL", #True, #True, #False, nSFRCueType, -99, pSubPtr, bExcludeSFRCueList, \bSFRCompleteAssocAutoStartCues, \bSFRHoldAssocAutoStartCues)
              ;}
              
            Case #SCS_SFR_ACT_FADEOUT
              ;{
              debugMsg(sProcName, "nSFRAction=#SCS_SFR_ACT_FADEOUT")
              bSFRFadeOut = #True
              ; fadeOutAllEarlierCues(nTmpCuePtr, #False, "ALL", #True, #True, #False, nSFRCueType, \nCueIndex, bExcludeSFRCueList, \bSFRCompleteAssocAutoStartCues, \bSFRHoldAssocAutoStartCues)
              fadeOutAllEarlierCues(nTmpCuePtr, #False, "ALL", #True, #True, #False, nSFRCueType, \nCueIndex, pSubPtr, bExcludeSFRCueList, \bSFRCompleteAssocAutoStartCues, \bSFRHoldAssocAutoStartCues)
              ;}
              
            Case #SCS_SFR_ACT_RELEASE
              ;{
              debugMsg(sProcName, "nSFRAction=#SCS_SFR_ACT_RELEASE")
              bSFRRelease = #True
              \nSFRReleasedLoopInfoIndex[h] = -1
              debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\nSFRReleasedLoopInfoIndex[" + h + "]=" + \nSFRReleasedLoopInfoIndex[h])
              releaseAllEarlierCues(nTmpCuePtr, #False, "ALL", #True, #True, nSFRCueType, \nCueIndex, bExcludeSFRCueList)
              ;}
              
            Case #SCS_SFR_ACT_TRACK
              ;{
              debugMsg(sProcName, "nSFRAction=#SCS_SFR_ACT_TRACK")
              bSFRTrack = #True
              stopAtTrackEndAllEarlierCues(nTmpCuePtr, nSFRCueType, \nCueIndex, bExcludeSFRCueList)
              ;}
              
            Case #SCS_SFR_ACT_PAUSE
              ;{
              debugMsg(sProcName, "nSFRAction=#SCS_SFR_ACT_PAUSE")
              ; Pause
              bSFRStop = #True
              pauseAllEarlierCues(nTmpCuePtr, nSFRCueType, \nCueIndex, bExcludeSFRCueList, #False)
              ;}
              
            Case #SCS_SFR_ACT_PAUSEHIB
              ;{
              debugMsg(sProcName, "nSFRAction=#SCS_SFR_ACT_PASUEHIB")
              ; Pause and hibernate
              bSFRStop = #True
              pauseAllEarlierCues(nTmpCuePtr, nSFRCueType, \nCueIndex, bExcludeSFRCueList, #True)
              ;}
              
            Case #SCS_SFR_ACT_FADEOUTHIB
              ;{
              debugMsg(sProcName, "nSFRAction=#SCS_SFR_ACT_FADEOUTHIB")
              ; Fade out, pause and hibernate
              bSFRFadeOut = #True
              ; setTimeOverrides(1, \nSFRTimeOverride, nFromCuePtr, nUptoCuePtr)
              For i = nFromCuePtr To nUptoCuePtr
                debugMsg(sProcName, "aCue(" + getCueLabel(i) + ")\nCueState=" + decodeCueState(aCue(i)\nCueState))
                If (aCue(i)\nCueState < #SCS_CUE_COMPLETED) And (aCue(i)\nCueState <> #SCS_CUE_HIBERNATING)
                  j = aCue(i)\nFirstSubIndex
                  While j >= 0
                    setWantThisSub(j) ; set bWantThisSub according to settings for 'audio only' and 'video only'
                    debugMsg(sProcName, "bWantThisSub=" + strB(bWantThisSub) + ", aSub(" + getSubLabel(j) + ")\nSubState=" + decodeCueState(aSub(j)\nSubState))
                    If (bWantThisSub) And (aSub(j)\nSubState >= #SCS_CUE_FADING_IN) And (aSub(j)\nSubState <= #SCS_CUE_FADING_OUT)
                      If aSub(j)\bSubTypeA
                        ; cancel any 'complete aud' requests in SAM (refer Martin Norris 'Chicago' cue list, 20May2016, which had an SFR sub-cue to fade and hibernate
                        ; following an image sub-cue that had already triggered a request to complete a prior image cue)
                        k = aSub(j)\nFirstPlayIndex
                        While k >= 0
                          samCancelRequest(#SCS_SAM_COMPLETE_AUD, k)
                          k = aAud(k)\nNextPlayIndex
                        Wend
                      EndIf
                      bPause = #False
                      If aSub(j)\bSubTypeAorP
                        aSub(j)\bPLFadingIn = #False
                        If aSub(j)\nPLCurrFadeOutTime > 0
                          aSub(j)\bPLFadingOut = #True
                        Else
                          bPause = #True
                        EndIf
                      Else
                        k = aSub(j)\nFirstAudIndex
                        If k >= 0
                          If aAud(k)\nCurrFadeOutTime <= 0
                            bPause = #True
                          EndIf
                        EndIf
                      EndIf
                      If bPause
                        bSFRStop = #True
                        bSFRFadeOut = #False
                        pauseSub(j, #True)
                        aSub(j)\bSFRFadeInOnResume = #False
                        debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\bSFRFadeInOnResume=" + strB(aSub(j)\bSFRFadeInOnResume))
                        If aSub(j)\bSubTypeAorP
                          ; aSub(j)\bSFRFadeInOnResume = #False
                          ; debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\bSFRFadeInOnResume=" + strB(aSub(j)\bSFRFadeInOnResume))
                          aSub(j)\nPLCurrFadeInTime = 0
                        EndIf
                      Else
                        fadeOutSub(j, #False, #True, #True, #False, pSubPtr)
                        ; If aSub(j)\bSubTypeAorP
                          aSub(j)\bSFRFadeInOnResume = #True
                          debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\bSFRFadeInOnResume=" + strB(aSub(j)\bSFRFadeInOnResume))
                        ; EndIf
                      EndIf
                    ElseIf aSub(j)\nSubState = #SCS_CUE_PL_COUNTDOWN_TO_START
                      bSFRStop = #True
                      bSFRFadeOut = #False
                      pauseSub(j, #True)
                    EndIf
                    j = aSub(j)\nNextSubIndex
                  Wend
                EndIf
              Next i
              ;}
              
            Case #SCS_SFR_ACT_RESUME
              ;{
              debugMsg(sProcName, "nSFRAction=#SCS_SFR_ACT_RESUME")
              ; Resume paused cues
              For i = nFromCuePtr To nUptoCuePtr
                If aCue(i)\nCueState = #SCS_CUE_PAUSED Or aCue(i)\bCueCountDownPaused
                  debugMsg(sProcName, "resume paused cue: " + aCue(i)\sCue)
                  If aCue(i)\bCueCountDownPaused
                    resetCueTimeToStart(i)
                    aCue(i)\bCueCountDownPaused = #False
                  EndIf
                  j = aCue(i)\nFirstSubIndex
                  While j >= 0
                    setWantThisSub(j) ; set bWantThisSub according to settings for 'audio only' and 'video only'
                    If bWantThisSub
                      debugMsg(sProcName, "\nSubState=" + decodeCueState(aSub(j)\nSubState))
                      If aSub(j)\bSubCountDownPaused
                        resetSubTimeToStart(j)
                        aSub(j)\bSubCountDownPaused = #False
                      EndIf
                      k = aSub(j)\nFirstPlayIndex
                      While k >= 0
                        debugMsg(sProcName, aAud(k)\sAudLabel + ", \nAudState=" + decodeCueState(aAud(k)\nAudState))
                        If aAud(k)\nAudState = #SCS_CUE_PAUSED
                          debugMsg(sProcName, "calling resumeAud(" + getAudLabel(k) + ")")
                          resumeAud(k)
                        EndIf
                        k = aAud(k)\nNextPlayIndex
                      Wend
                    EndIf
                    j = aSub(j)\nNextSubIndex
                  Wend
                EndIf
              Next i
              ;}
              
            Case #SCS_SFR_ACT_RESUMEHIB
              ;{
              debugMsg(sProcName, "nSFRAction=#SCS_SFR_ACT_RESUMEHIB")
              ; Resume hibernating cues
              debugMsg(sProcName, "nFromCuePtr=" + getCueLabel(nFromCuePtr) + ", nUptoCuePtr=" + getCueLabel(nUptoCuePtr))
              For i = nFromCuePtr To nUptoCuePtr
                debugMsg(sProcName, "aCue(" + getCueLabel(i) + ")\nCueState=" + decodeCueState(aCue(i)\nCueState))
                If aCue(i)\nCueState = #SCS_CUE_HIBERNATING
                  gnHibernatedCueResumed = i
                  debugMsg(sProcName, "resume hibernated cue: " + aCue(i)\sCue)
                  If aCue(i)\bCueCountDownPaused
                    resetCueTimeToStart(i)
                    aCue(i)\bCueCountDownPaused = #False
                  EndIf
                  j = aCue(i)\nFirstSubIndex
                  debugMsg(sProcName, "aCue(" + getCueLabel(i) + ")\nFirstSubIndex=" + getSubLabel(j))
                  While j >= 0
                    setWantThisSub(j) ; set bWantThisSub according to settings for 'audio only' and 'video only'
                    debugMsg(sProcName, "aSub(" + getSubLabel(j) + "), bWantThisSub=" + strB(bWantThisSub))
                    If bWantThisSub
                      debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\nSubState=" + decodeCueState(aSub(j)\nSubState))
                      If aSub(j)\bSubCountDownPaused
                        resetSubTimeToStart(j)
                        aSub(j)\bSubCountDownPaused = #False
                      EndIf
                      aSub(j)\bHibernating = #False
                      bFadeIn = #False
                      If aSub(j)\bSubTypeAorP
                        aSub(j)\bPLFadingOut = #False
                        aSub(j)\bPLTerminating = #False
                        debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\nPLCurrFadeInTime=" + Str(aSub(j)\nPLCurrFadeInTime) + ", \bSFRFadeInOnResume=" + strB(\bSFRFadeInOnResume))
                        If (aSub(j)\nPLCurrFadeInTime > 0) And (aSub(j)\bSFRFadeInOnResume)
                          aSub(j)\bPLFadingIn = #True
                          aSub(j)\qPLTimeFadeInStarted = gqTimeNow
                          bFadeIn = #True
                          bSFRFadeIn = #True
                        EndIf
                      EndIf
                      debugMsg(sProcName, "bFadeIn=" + strB(bFadeIn) + ", bSFRFadeIn=" + strB(bSFRFadeIn))
                      k = aSub(j)\nFirstPlayIndex
                      While k >= 0
                        debugMsg(sProcName, aAud(k)\sAudLabel + ", \nAudState=" + decodeCueState(aAud(k)\nAudState) + ", \nCurrFadeInTime=" + Str(aAud(k)\nCurrFadeInTime))
                        If aAud(k)\nAudState = #SCS_CUE_HIBERNATING
                          debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nCurrFadeInTime=" + Str(aAud(k)\nCurrFadeInTime) + ", aSub(" + getSubLabel(j) + ")\bSFRFadeInOnResume=" + strB(aSub(j)\bSFRFadeInOnResume))
                          If (aAud(k)\nCurrFadeInTime > 0) And (aSub(j)\bSFRFadeInOnResume)
                            For d = aAud(k)\nFirstSoundingDev To aAud(k)\nLastSoundingDev
                              If aAud(k)\nBassChannel[d] <> 0
                                aAud(k)\bFading[d] = #True
                                aAud(k)\bCueVolManual[d] = #False
                                aAud(k)\bCuePanManual[d] = #False
                              EndIf
                            Next d
                            aAud(k)\qTimeFadeInStarted = gqTimeNow
                            aAud(k)\nCuePosAtFadeStart = aAud(k)\nCuePos
                            debugMsg(sProcName, "(c2) aAud(" + getAudLabel(k) + ")\qTimeFadeInStarted=" + traceTime(aAud(k)\qTimeFadeInStarted) + ", \nCuePosAtFadeStart=" + aAud(k)\nCuePosAtFadeStart)
                            aAud(k)\bTimeFadeInStartedSet = #True
                            aAud(k)\nPreFadeInTimeOnPause = aAud(k)\nTotalTimeOnPause
                            aAud(k)\bFadingInFromHibernate = #True
                            CompilerIf #c_include_tvg
                              If grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG And aAud(k)\bAudTypeA
                                debugMsg(sProcName, "calling addAudToTVGFadeAudArray(" + getAudLabel(k) + ")")
                                addAudToTVGFadeAudArray(k)
                              EndIf
                            CompilerEndIf
                            bFadeIn = #True
                            bSFRFadeIn = #True
                          Else
                            For d = aAud(k)\nFirstSoundingDev To aAud(k)\nLastSoundingDev
                              If Len(aAud(k)\sLogicalDev[d]) > 0
                                If aAud(k)\bCueVolManual[d]
                                  fTmpLevel = aAud(k)\fBVLevel[d]
                                ElseIf aAud(k)\bCueLevelLC[d]
                                  fTmpLevel = aAud(k)\fLCBVLevel[d]
                                Else
                                  fTmpLevel = aAud(k)\fBVLevel[d]
                                EndIf
                                setLevelsAny(k, d, fTmpLevel, #SCS_NOPANCHANGE_SINGLE)
                                aAud(k)\bFading[d] = #False
                              EndIf
                            Next d
                            aAud(k)\bFadingInFromHibernate = #False
                            bFadeIn = #False
                            bSFRFadeIn = #False
                          EndIf
                          aAud(k)\bFinalFadeOut = #False
                          aAud(k)\bFinalSlide = #False
                          debugMsg(sProcName, "calling resumeAud(" + getAudLabel(k) + ", " + strB(bFadeIn) + ")")
                          resumeAud(k, bFadeIn)
                          If aSub(j)\bSubTypeA
                            If (aSub(j)\bStartedInEditor) And (gbPreviewOnOutputScreen = #False)
                              nVidPicTarget = #SCS_VID_PIC_TARGET_P
                            Else
                              nVidPicTarget = getVidPicTargetForOutputScreen(aSub(j)\nOutputScreen)
                            EndIf
                            grVidPicTarget(nVidPicTarget)\nPrevPrimaryAudPtr = grVidPicTarget(nVidPicTarget)\nPrimaryAudPtr
                            grVidPicTarget(nVidPicTarget)\nPrevPlayingSubPtr = grVidPicTarget(nVidPicTarget)\nPlayingSubPtr
                            grVidPicTarget(nVidPicTarget)\nPrimaryAudPtr = k
                            debugMsg(sProcName, "grVidPicTarget(" + decodeVidPicTarget(nVidPicTarget) + ")\nPrimaryAudPtr=" + getAudLabel(grVidPicTarget(nVidPicTarget)\nPrimaryAudPtr))
                            grVidPicTarget(nVidPicTarget)\nPlayingSubPtr = -1   ; \nPlayingSubPtr only required for memo cues
                            Select nVidPicTarget
                              Case #SCS_VID_PIC_TARGET_F2 To #SCS_VID_PIC_TARGET_LAST
                                debugMsg(sProcName, "calling makeVidPicVisible(" + decodeVidPicTarget(nVidPicTarget) + ", #True, " + getAudLabel(k) + ")")
                                makeVidPicVisible(nVidPicTarget, #True, k)
                            EndSelect
                            debugMsg(sProcName, "calling closeWhatWasPlayingOnVidPicTarget(" + decodeVidPicTarget(nVidPicTarget) +
                                                ", " + getAudLabel(grVidPicTarget(nVidPicTarget)\nPrevPrimaryAudPtr) + ", " + getSubLabel(grVidPicTarget(nVidPicTarget)\nPrevPlayingSubPtr) + ")")
                            closeWhatWasPlayingOnVidPicTarget(nVidPicTarget, grVidPicTarget(nVidPicTarget)\nPrevPrimaryAudPtr, grVidPicTarget(nVidPicTarget)\nPrevPlayingSubPtr)
                          EndIf
                        EndIf
                        k = aAud(k)\nNextPlayIndex
                      Wend
                      If aSub(j)\bSubTypeAorP
                        aSub(j)\bSFRFadeInOnResume = #False
                        debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\bSFRFadeInOnResume=" + strB(aSub(j)\bSFRFadeInOnResume))
                      EndIf
                    EndIf
                    j = aSub(j)\nNextSubIndex
                  Wend
                EndIf
              Next i
              ;}
              
            Case #SCS_SFR_ACT_RESUMEHIBNEXT
              ;{

              debugMsg(sProcName, "nSFRAction=#SCS_SFR_ACT_RESUMEHIBNEXT")
              ; Resume hibernating cue at next track
              ; setTimeOverrides(0, \nSFRTimeOverride, nFromCuePtr, nUptoCuePtr)
              For i = nFromCuePtr To nUptoCuePtr
                If aCue(i)\nCueState = #SCS_CUE_HIBERNATING
                  gnHibernatedCueResumed = i
                  If aCue(i)\bCueCountDownPaused
                    resetCueTimeToStart(i)
                    aCue(i)\bCueCountDownPaused = #False
                  EndIf
                  j = aCue(i)\nFirstSubIndex
                  While j >= 0
                    setWantThisSub(j) ; set bWantThisSub according to settings for 'audio only' and 'video only'
                    If bWantThisSub
                      If aSub(j)\bSubCountDownPaused
                        resetSubTimeToStart(j)
                        aSub(j)\bSubCountDownPaused = #False
                      EndIf
                      aSub(j)\bHibernating = #False
                      If aSub(j)\bSubTypeAorP
                        aSub(j)\bPLFadingOut = #False
                        aSub(j)\bPLTerminating = #False
                        If (aSub(j)\nPLCurrFadeInTime > 0) And (aSub(j)\bSFRFadeInOnResume)
                          aSub(j)\bPLFadingIn = #True
                          aSub(j)\qPLTimeFadeInStarted = gqTimeNow
                          bSFRFadeIn = #True
                        EndIf
                      EndIf
                      bFound = #False
                      k = aSub(j)\nFirstPlayIndex
                      While (k >= 0) And (bFound = #False)
                        If (aAud(k)\nAudState = #SCS_CUE_HIBERNATING) Or (aAud(k)\nAudState = #SCS_CUE_PAUSED)
                          bFound = #True
                          debugMsg(sProcName, "calling stopAud(" + k + ")")
                          stopAud(k)
                        EndIf
                        k = aAud(k)\nNextPlayIndex
                        If bFound
                          If k >= 0
                            playAud(k, bUseCas, #False, nCasGroupId, #True)   ; set bTopLevelCall = #True to force SM-S play to be issued
                          ElseIf aSub(j)\bSubTypeP And getPLRepeatActive(j) ; aSub(j)\bPLRepeat
                            k = aSub(j)\nFirstPlayIndex     ; nb ok to reset k because while loop will exit due to (bFound = #True)
                            playAud(k, bUseCas, #False, nCasGroupId, #True)   ; set bTopLevelCall = #True to force SM-S play to be issued
                          EndIf
                        EndIf
                      Wend
                    EndIf
                    j = aSub(j)\nNextSubIndex
                  Wend
                EndIf
              Next i
              ;}
              
            Case #SCS_SFR_ACT_STOPCHASE
              ;{
              debugMsg(sProcName, "nSFRAction=#SCS_SFR_ACT_STOPCHASE")
              If bAudioOnly Or bVideoOnly Or bLiveOnly
                ; no actions
              Else
                For i = nFromCuePtr To nUptoCuePtr
                  If aCue(i)\bSubTypeK And aCue(i)\bCueEnabled
                    If aCue(i)\nCueState >= #SCS_CUE_FADING_IN And aCue(i)\nCueState <= #SCS_CUE_FADING_OUT
                      j = aCue(i)\nFirstSubIndex
                      While j >= 0
                        If aSub(j)\bSubTypeK And aSub(j)\bChase And aSub(j)\bSubEnabled
                          If aSub(j)\nSubState = #SCS_CUE_PLAYING
                            debugMsg(sProcName, "calling stopSub(" + getSubLabel(j) + ", 'K', #False, #False)")
                            stopSub(j, "K", #False, #False)
                          EndIf
                        EndIf
                        j = aSub(j)\nNextSubIndex
                      Wend
                    EndIf
                  EndIf
                Next i
              EndIf
              ;}
              
          EndSelect
          ;}
          
        Case #SCS_SFR_CUE_SEL, #SCS_SFR_CUE_PREV ; sel or prev
          ;{
          If (\nSFRCueType = #SCS_SFR_CUE_PREV) And (\nSFRCuePtr[h] = -1)
            setCuePtrForSFRPrevCueType(pSubPtr, h)
          EndIf
          sSFRCue = \sSFRCue[h]
          debugMsg(sProcName, "sSFRCue=" + sSFRCue + ", nSFRSubPtr=" + getSubLabel(nSFRSubPtr))
          If sSFRCue
            grMMedia\nSFRCueMax + 1
            ; debugMsg(sProcName, "grMMedia\nSFRCueMax=" + grMMedia\nSFRCueMax)
            grMMedia\anSFRCuePtr[grMMedia\nSFRCueMax] = \nSFRCuePtr[h]
            For m = 1 To gnLastCue
              If aCue(m)\sCue = sSFRCue
                nFromCuePtr = m
                nUptoCuePtr = m
                Select nSFRAction
                  Case #SCS_SFR_ACT_STOP
                    ;{
                    bSFRStop = #True
                    If nSFRSubPtr = -1
                      debugMsg(sProcName, "calling stopCue(" + getCueLabel(m) + ", 'ALL', #False)")
                      stopCue(m, "ALL", #False)
                    Else
                      debugMsg(sProcName, "calling stopSub(" + getSubLabel(nSFRSubPtr) + ", 'ALL', #False, #False)")
                      stopSub(nSFRSubPtr, "ALL", #False, #False)
                    EndIf
                    ;}
                    
                  Case #SCS_SFR_ACT_FADEOUT
                    ;{
                    debugMsg(sProcName, "aCue(" + getCueLabel(m) + ")\nFirstSubIndex=" + getSubLabel(aCue(m)\nFirstSubIndex))
                    j = aCue(m)\nFirstSubIndex
                    While j >= 0
                      setWantThisSub(j) ; added 17Oct2016 11.5.2.3 following email from Alex Irwin about Level Change cues being stopped by an SFR cue
                      debugMsg(sProcName, ">> aSub(" + getSubLabel(j) + ")\nSubState=" + decodeCueState(aSub(j)\nSubState) + ", bWantThisSub=" + strB(bWantThisSub))
                      If bWantThisSub   ; test added 17Oct2016 11.5.2.3
                        If nSFRSubPtr = -1 Or nSFRSubPtr = j
                          bSFRFadeOut = #True
                          ; added 20Dec2019 11.8.2.1an following email from Christian Peters aboubt an SFR cue that didn't stop all of playing cue
                          ; which was because a sub-cue of that playing cue ha an auto-start time exactly the same as the auto-start time of the SFR cue
                          ; and this auto-start sub-cue had already had \bPlaySubInMainThread set #True so then was started AFTER the completion of the SFR cue.
                          If aSub(j)\bPlaySubInMainThread
                            aSub(j)\bPlaySubInMainThread = #False
                            debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\bPlaySubInMainThread=" + strB(aSub(j)\bPlaySubInMainThread))
                          EndIf
                          ; end added 20Dec2019 11.8.2.1an
                          fadeOutSub(j, #False, #True, #False, #False, pSubPtr)
                        EndIf
                      EndIf
                      j = aSub(j)\nNextSubIndex
                    Wend
                    ;}
                    
                  Case #SCS_SFR_ACT_RELEASE
                    ;{
                    \nSFRReleasedLoopInfoIndex[h] = -1
                    debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\nSFRReleasedLoopInfoIndex[" + h + "]=" + \nSFRReleasedLoopInfoIndex[h])
                    j = aCue(m)\nFirstSubIndex
                    While j >= 0
                      If (nSFRSubPtr = -1) Or (nSFRSubPtr = j)
                        If aSub(j)\bSubTypeF And aSub(j)\bSubEnabled
                          k = aSub(j)\nFirstAudIndex
                          If (k >= 0) And (aAud(k)\bAudPlaceHolder = #False)
                            If aAud(k)\nMaxLoopInfo >= 0
                              bSFRRelease = #True
                              If (nSFRLoopIndex >= 0) And (nSFRLoopIndex <> aAud(k)\nCurrLoopInfoIndex)
                                debugMsg(sProcName, "calling releaseAudLoop(" + getAudLabel(k) + ", " + nSFRLoopNo + ")")
                                releaseAudLoop(k, nSFRLoopNo)
                                If \nSFRReleasedLoopInfoIndex[h] = -1
                                  \nSFRReleasedLoopInfoIndex[h] = nSFRLoopIndex
                                  debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\nSFRReleasedLoopInfoIndex[" + h + "]=" + \nSFRReleasedLoopInfoIndex[h])
                                EndIf
                              Else
                                debugMsg(sProcName, "calling releaseAudLoop(" + getAudLabel(k) + ")")
                                releaseAudLoop(k)
                                If \nSFRReleasedLoopInfoIndex[h] = -1
                                  \nSFRReleasedLoopInfoIndex[h] = aAud(k)\nCurrLoopInfoIndex
                                  debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\nSFRReleasedLoopInfoIndex[" + h + "]=" + \nSFRReleasedLoopInfoIndex[h])
                                EndIf
                              EndIf
                            EndIf
                          EndIf
                        EndIf
                      EndIf
                      j = aSub(j)\nNextSubIndex
                    Wend
                    ;}
                    
                  Case #SCS_SFR_ACT_CANCELREPEAT ; Added 5Aug2024 11.10.3bb
                    ;{
                    j = aCue(m)\nFirstSubIndex
                    While j >= 0
                      If nSFRSubPtr = -1 Or nSFRSubPtr = j
                        If aSub(j)\bSubTypeAorP And aSub(j)\bSubEnabled
                          If aSub(j)\nSubState >= #SCS_CUE_FADING_IN And aSub(j)\nSubState <= #SCS_CUE_FADING_OUT
                            aSub(j)\bPLRepeatCancelled = #True
                            debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\bPLRepeatCancelled=" + strB(aSub(j)\bPLRepeatCancelled))
                          EndIf
                        EndIf
                      EndIf
                      j = aSub(j)\nNextSubIndex
                    Wend
                    ;}
                    
                  Case #SCS_SFR_ACT_TRACK
                    ;{
                    j = aCue(m)\nFirstSubIndex
                    While j >= 0
                      If nSFRSubPtr = -1 Or nSFRSubPtr = j
                        If aSub(j)\bSubTypeAorP And aSub(j)\bSubEnabled
                          If aSub(j)\nSubState >= #SCS_CUE_FADING_IN And aSub(j)\nSubState <= #SCS_CUE_FADING_OUT
                            bSFRTrack = #True
                            aSub(j)\bPLTerminating = #True
                            debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\bPLTerminating=" + strB(aSub(j)\bPLTerminating))
                          EndIf
                        EndIf
                      EndIf
                      j = aSub(j)\nNextSubIndex
                    Wend
                    ;}
                    
                  Case #SCS_SFR_ACT_PAUSE
                    ;{
                    ; Pause
                    If nSFRSubPtr = -1
                      debugMsg(sProcName, "Pause cue " + getCueLabel(m) + ", \nCueState=" + decodeCueState(aCue(m)\nCueState))
                      ; If (aCue(m)\nCueState >= #SCS_CUE_FADING_IN) And (aCue(m)\nCueState <= #SCS_CUE_FADING_OUT)
                      If (aCue(m)\nCueState > #SCS_CUE_READY) And (aCue(m)\nCueState <= #SCS_CUE_FADING_OUT)
                        bSFRStop = #True
                        pauseCue(m)
                      EndIf
                    Else
                      debugMsg(sProcName, "Pause sub " + getSubLabel(nSFRSubPtr) + ", \nSubState=" + decodeCueState(aSub(nSFRSubPtr)\nSubState))
                      ; If (aSub(nSFRSubPtr)\nSubState >= #SCS_CUE_FADING_IN) And (aSub(nSFRSubPtr)\nSubState <= #SCS_CUE_FADING_OUT)
                      If (aSub(nSFRSubPtr)\nSubState > #SCS_CUE_READY) And (aSub(nSFRSubPtr)\nSubState <= #SCS_CUE_FADING_OUT)
                        bSFRStop = #True
                        pauseSub(nSFRSubPtr)
                      EndIf
                    EndIf
                    ;}
                    
                  Case #SCS_SFR_ACT_RESUME
                    ;{
                    ; Resume
                    If nSFRSubPtr = -1
                      debugMsg(sProcName, "Resume cue " + getCueLabel(m) + ", \nCueState=" + decodeCueState(aCue(m)\nCueState) + ", \bCueCountDownPaused=" + strB(aCue(m)\bCueCountDownPaused))
                      If (aCue(m)\nCueState = #SCS_CUE_PAUSED) Or (aCue(m)\bCueCountDownPaused)
                        resumeCue(m)
                      EndIf
                    Else
                      debugMsg(sProcName, "Resume sub " + getSubLabel(nSFRSubPtr) + ", \nSubState=" + decodeCueState(aSub(nSFRSubPtr)\nSubState) + ", \bSubCountDownPaused=" + strB(aSub(nSFRSubPtr)\bSubCountDownPaused))
                      If (aSub(nSFRSubPtr)\nSubState = #SCS_CUE_PAUSED) Or (aSub(nSFRSubPtr)\bSubCountDownPaused)
                        resumeSub(nSFRSubPtr)
                      EndIf
                    EndIf
                    ;}
                    
                  Case #SCS_SFR_ACT_PAUSEHIB
                    ;{
                    ; Pause and hibernate
                    If nSFRSubPtr = -1
                      If (aCue(m)\nCueState >= #SCS_CUE_FADING_IN) And (aCue(m)\nCueState <= #SCS_CUE_FADING_OUT)
                        bSFRStop = #True
                        pauseCue(m, #True)
                      EndIf
                    Else
                      If (aSub(nSFRSubPtr)\nSubState >= #SCS_CUE_FADING_IN) And (aSub(nSFRSubPtr)\nSubState <= #SCS_CUE_FADING_OUT)
                        bSFRStop = #True
                        pauseSub(nSFRSubPtr, #True)
                      EndIf
                    EndIf
                    ;}
                    
                  Case #SCS_SFR_ACT_FADEOUTHIB
                    ;{
                    debugMsg(sProcName, "nSFRAction=#SCS_SFR_ACT_FADEOUTHIB")
                    ; Fade out, pause and hibernate
                    j = aCue(m)\nFirstSubIndex
                    While j >= 0
                      setWantThisSub(j) ; added 17Oct2016 11.5.2.3 following email from Alex Irwin about Level Change cues being stopped by an SFR cue
                      If bWantThisSub   ; test added 17Oct2016 11.5.2.3
                        If (nSFRSubPtr = -1) Or (nSFRSubPtr = j)
                          If (aSub(j)\nSubState >= #SCS_CUE_FADING_IN) And (aSub(j)\nSubState <= #SCS_CUE_FADING_OUT)
                            If aSub(j)\bSubTypeA
                              ; cancel any 'complete aud' requests in SAM (refer Martin Norris 'Chicago' cue list, 20May2016, which had an SFR sub-cue to fade and hibernate
                              ; following an image sub-cue that had already triggered a request to complete a prior image cue)
                              k = aSub(j)\nFirstPlayIndex
                              While k >= 0
                                samCancelRequest(#SCS_SAM_COMPLETE_AUD, k)
                                k = aAud(k)\nNextPlayIndex
                              Wend
                            EndIf
                            bPause = #False
                            If aSub(j)\bSubTypeAorP
                              aSub(j)\bPLFadingIn = #False
                              If aSub(j)\nPLCurrFadeOutTime > 0
                                aSub(j)\bPLFadingOut = #True
                              Else
                                bPause = #True
                              EndIf
                            Else
                              k = aSub(j)\nFirstAudIndex
                              If k >= 0
                                If aAud(k)\nCurrFadeOutTime <= 0
                                  bPause = #True
                                EndIf
                              EndIf
                            EndIf
                            If bPause
                              bSFRStop = #True
                              bSFRFadeOut = #False
                              pauseSub(j, #True)
                              aSub(j)\bSFRFadeInOnResume = #False
                              debugMsg(sProcName, "(b2) aSub(" + getSubLabel(j) + ")\bSFRFadeInOnResume=" + strB(aSub(j)\bSFRFadeInOnResume))
                              If aSub(j)\bSubTypeAorP
                                ; aSub(j)\bSFRFadeInOnResume = #False
                                ; debugMsg(sProcName, "(b2) aSub(" + getSubLabel(j) + ")\bSFRFadeInOnResume=" + strB(aSub(j)\bSFRFadeInOnResume))
                                aSub(j)\nPLCurrFadeInTime = 0
                              EndIf
                            Else
                              bSFRFadeOut = #True
                              ; added 20Dec2019 11.8.2.1an following email from Christian Peters - see comments about 11.8.2.1an further up this procedure
                              If aSub(j)\bPlaySubInMainThread
                                aSub(j)\bPlaySubInMainThread = #False
                                debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\bPlaySubInMainThread=" + strB(aSub(j)\bPlaySubInMainThread))
                              EndIf
                              ; end added 20Dec2019 11.8.2.1an
                              fadeOutSub(j, #False, #True, #True, #False, pSubPtr)
                              aSub(j)\bSFRFadeInOnResume = #True
                              debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\bSFRFadeInOnResume=" + strB(aSub(j)\bSFRFadeInOnResume))
                            EndIf
                          EndIf
                        EndIf
                      EndIf
                      j = aSub(j)\nNextSubIndex
                    Wend
                    ;}
                    
                  Case #SCS_SFR_ACT_RESUMEHIB
                    ;{
                    debugMsg(sProcName, "nSFRAction=#SCS_SFR_ACT_RESUMEHIB")
                    ; Resume hibernating cue
                    gnHibernatedCueResumed = m
                    debugMsg(sProcName, "resume hibernated cue: " + aCue(m)\sCue)
                    If aCue(m)\bCueCountDownPaused
                      resetCueTimeToStart(m)
                      aCue(m)\bCueCountDownPaused = #False
                    EndIf
                    j = aCue(m)\nFirstSubIndex
                    While j >= 0
                      setWantThisSub(j) ; added 17Oct2016 11.5.2.3 following email from Alex Irwin about Level Change cues being stopped by an SFR cue
                      If bWantThisSub   ; test added 17Oct2016 11.5.2.3
                        If (nSFRSubPtr = -1) Or (nSFRSubPtr = j)
                          debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\nSubState=" + decodeCueState(aSub(j)\nSubState))
                          If aSub(j)\bSubCountDownPaused
                            resetSubTimeToStart(j)
                            aSub(j)\bSubCountDownPaused = #False
                          EndIf
                          aSub(j)\bHibernating = #False
                          bFadeIn = #False
                          If aSub(j)\bSubTypeAorP
                            aSub(j)\bPLFadingOut = #False
                            aSub(j)\bPLTerminating = #False
                            debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\nPLCurrFadeInTime=" + Str(aSub(j)\nPLCurrFadeInTime) + ", \bSFRFadeInOnResume=" + strB(aSub(j)\bSFRFadeInOnResume))
                            If (aSub(j)\nPLCurrFadeInTime > 0) And (aSub(j)\bSFRFadeInOnResume)
                              aSub(j)\bPLFadingIn = #True
                              aSub(j)\qPLTimeFadeInStarted = gqTimeNow
                              bFadeIn = #True
                              bSFRFadeIn = #True
                            EndIf
                          EndIf
                          k = aSub(j)\nFirstPlayIndex
                          While k >= 0
                            debugMsg(sProcName, aAud(k)\sAudLabel + ", \nAudState=" + decodeCueState(aAud(k)\nAudState))
                            If (aAud(k)\nAudState = #SCS_CUE_HIBERNATING) Or (aAud(k)\nAudState = #SCS_CUE_PAUSED)
                              debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nCurrFadeInTime=" + Str(aAud(k)\nCurrFadeInTime) + ", aSub(" + getSubLabel(j) + ")\bSFRFadeInOnResume=" + strB(aSub(j)\bSFRFadeInOnResume))
                              If (aAud(k)\nCurrFadeInTime > 0) And (aSub(j)\bSFRFadeInOnResume)
                                For d = aAud(k)\nFirstSoundingDev To aAud(k)\nLastSoundingDev
                                  If aAud(k)\nBassChannel[d] <> 0
                                    aAud(k)\bFading[d] = #True
                                    aAud(k)\bCueVolManual[d] = #False
                                    aAud(k)\bCuePanManual[d] = #False
                                  EndIf
                                Next d
                                aAud(k)\qTimeFadeInStarted = gqTimeNow
                                aAud(k)\nCuePosAtFadeStart = aAud(k)\nCuePos
                                debugMsg(sProcName, "(e2) aAud(" + getAudLabel(k) + ")\qTimeFadeInStarted=" + traceTime(aAud(k)\qTimeFadeInStarted) + ", \nCuePosAtFadeStart=" + aAud(k)\nCuePosAtFadeStart)
                                aAud(k)\bTimeFadeInStartedSet = #True
                                aAud(k)\nPreFadeInTimeOnPause = aAud(k)\nTotalTimeOnPause
                                aAud(k)\bFadingInFromHibernate = #True
                                CompilerIf #c_include_tvg
                                  If grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG
                                    debugMsg(sProcName, "calling addAudToTVGFadeAudArray(" + getAudLabel(k) + ")")
                                    addAudToTVGFadeAudArray(k)
                                  EndIf
                                CompilerEndIf
                                bFadeIn = #True
                                bSFRFadeIn = #True
                              Else
                                For d = aAud(k)\nFirstSoundingDev To aAud(k)\nLastSoundingDev
                                  If Len(aAud(k)\sLogicalDev[d]) > 0
                                    If aAud(k)\bCueVolManual[d]
                                      fTmpLevel = aAud(k)\fBVLevel[d]
                                      debugMsg(sProcName, "(e1) fTmpLevel=" + formatLevel(fTmpLevel))
                                    ElseIf aAud(k)\bCueLevelLC[d]
                                      fTmpLevel = aAud(k)\fLCBVLevel[d]
                                      debugMsg(sProcName, "(e2) fTmpLevel=" + formatLevel(fTmpLevel))
                                    Else
                                      fTmpLevel = aAud(k)\fBVLevel[d]
                                      debugMsg(sProcName, "(e3) fTmpLevel=" + formatLevel(fTmpLevel))
                                    EndIf
                                    setLevelsAny(k, d, fTmpLevel, #SCS_NOPANCHANGE_SINGLE)
                                    aAud(k)\bFading[d] = #False
                                  EndIf
                                Next d
                                aAud(k)\bFadingInFromHibernate = #False
                                bFadeIn = #False
                                bSFRFadeIn = #False
                              EndIf
                              aAud(k)\bFinalFadeOut = #False
                              aAud(k)\bFinalSlide = #False
                              debugMsg(sProcName, "calling resumeAud(" + getAudLabel(k) + ", " + strB(bFadeIn) + ")")
                              resumeAud(k, bFadeIn)
                              If aSub(j)\bSubTypeA
                                If (aSub(j)\bStartedInEditor) And (gbPreviewOnOutputScreen = #False)
                                  nVidPicTarget = #SCS_VID_PIC_TARGET_P
                                Else
                                  nVidPicTarget = getVidPicTargetForOutputScreen(aSub(j)\nOutputScreen)
                                EndIf
                                grVidPicTarget(nVidPicTarget)\nPrevPrimaryAudPtr = grVidPicTarget(nVidPicTarget)\nPrimaryAudPtr
                                grVidPicTarget(nVidPicTarget)\nPrevPlayingSubPtr = grVidPicTarget(nVidPicTarget)\nPlayingSubPtr
                                grVidPicTarget(nVidPicTarget)\nPrimaryAudPtr = k
                                debugMsg(sProcName, "grVidPicTarget(" + decodeVidPicTarget(nVidPicTarget) + ")\nPrimaryAudPtr=" + getAudLabel(grVidPicTarget(nVidPicTarget)\nPrimaryAudPtr))
                                grVidPicTarget(nVidPicTarget)\nPlayingSubPtr = -1   ; \nPlayingSubPtr only required for memo cues
                                Select nVidPicTarget
                                  Case #SCS_VID_PIC_TARGET_F2 To #SCS_VID_PIC_TARGET_LAST
                                    debugMsg(sProcName, "calling makeVidPicVisible(" + decodeVidPicTarget(nVidPicTarget) + ", #True, " + getAudLabel(k) + ")")
                                    makeVidPicVisible(nVidPicTarget, #True, k)
                                EndSelect
                                debugMsg(sProcName, "calling closeWhatWasPlayingOnVidPicTarget(" + decodeVidPicTarget(nVidPicTarget) +
                                                    ", " + getAudLabel(grVidPicTarget(nVidPicTarget)\nPrevPrimaryAudPtr) + ", " + getSubLabel(grVidPicTarget(nVidPicTarget)\nPrevPlayingSubPtr) + ")")
                                closeWhatWasPlayingOnVidPicTarget(nVidPicTarget, grVidPicTarget(nVidPicTarget)\nPrevPrimaryAudPtr, grVidPicTarget(nVidPicTarget)\nPrevPlayingSubPtr)
                              EndIf
                            EndIf
                            k = aAud(k)\nNextPlayIndex
                          Wend
                        EndIf
                      EndIf
                      j = aSub(j)\nNextSubIndex
                    Wend
                    ;}
                    
                  Case #SCS_SFR_ACT_RESUMEHIBNEXT
                    ;{
                    ; Resume hibernating cue at next track
                    ; setTimeOverrides(0, \nSFRTimeOverride, nFromCuePtr, nUptoCuePtr)
                    gnHibernatedCueResumed = m
                    If aCue(m)\bCueCountDownPaused
                      resetCueTimeToStart(m)
                      aCue(m)\bCueCountDownPaused = #False
                    EndIf
                    j = aCue(m)\nFirstSubIndex
                    While j >= 0
                      setWantThisSub(j) ; added 17Oct2016 11.5.2.3 following email from Alex Irwin about Level Change cues being stopped by an SFR cue
                      If bWantThisSub   ; test added 17Oct2016 11.5.2.3
                        If nSFRSubPtr = -1 Or nSFRSubPtr = j
                          If aSub(j)\bSubCountDownPaused
                            resetSubTimeToStart(j)
                            aSub(j)\bSubCountDownPaused = #False
                          EndIf
                          aSub(j)\bHibernating = #False
                          If aSub(j)\bSubTypeAorP
                            aSub(j)\bPLFadingOut = #False
                            aSub(j)\bPLTerminating = #False
                            If aSub(j)\nPLCurrFadeInTime > 0 And aSub(j)\bSFRFadeInOnResume
                              aSub(j)\bPLFadingIn = #True
                              aSub(j)\qPLTimeFadeInStarted = gqTimeNow
                              bSFRFadeIn = #True
                            EndIf
                          EndIf
                          bFound = #False
                          k = aSub(j)\nFirstPlayIndex
                          While (k >= 0) And (bFound = #False)
                            If aAud(k)\nAudState = #SCS_CUE_HIBERNATING Or aAud(k)\nAudState = #SCS_CUE_PAUSED
                              bFound = #True
                              stopAud(k)
                            EndIf
                            k = aAud(k)\nNextPlayIndex
                            If bFound
                              If k >= 0
                                playAud(k, bUseCas, #False, nCasGroupId, #True)   ; set bTopLevelCall = #True to force SM-S play to be issued
                              ElseIf aSub(j)\bSubTypeP And getPLRepeatActive(j) ; aSub(j)\bPLRepeat
                                k = aSub(j)\nFirstPlayIndex     ; nb ok to reset k because While loop will exit due to (bFound = #True)
                                playAud(k, bUseCas, #False, nCasGroupId, #True)   ; set bTopLevelCall = #True to force SM-S play to be issued
                              EndIf
                              debugMsg(sProcName, "calling ONC_openNextCues(" + getCueLabel(m) + ", " + getCueLabel(m) + ", -2, #True, #False)")
                              ONC_openNextCues(m, m, -2, #True, #False) ; make sure next but one aud is opened
                            EndIf
                          Wend
                        EndIf
                      EndIf
                      j = aSub(j)\nNextSubIndex
                    Wend
                    ;}
                    
                  Case #SCS_SFR_ACT_STOPCHASE
                    ;{
                    If nSFRSubPtr = -1
                      debugMsg(sProcName, "calling stopCue(" + getCueLabel(m) + ", 'K', #False)")
                      stopCue(m, "K", #False)
                    Else
                      debugMsg(sProcName, "calling stopSub(" + getSubLabel(nSFRSubPtr) + ", 'K', #False, #False)")
                      stopSub(nSFRSubPtr, "K", #False, #False)
                    EndIf
                    ;}

                EndSelect
                Break
              EndIf
            Next m
          EndIf
          ;}
          
      EndSelect
    Next h
    
    ; commented out the following so they only act on cues identified within the SFR cue (eg 'all earlier cues'),
    ; and not on auto-start cues related to the SFR cue itself
; ;     If \bSFRCompleteAssocAutoStartCues
; ;       completeAssocAutoStartCues(\nCueIndex)
; ;     EndIf
;     If \bSFRCompleteAssocAutoStartCues
;       debugMsg(sProcName, "calling completeAssocAutoStartCues(" + getCueLabel(\nCueIndex) + ")")
;       completeAssocAutoStartCues(\nCueIndex)
;     ElseIf \bSFRHoldAssocAutoStartCues
;       debugMsg(sProcName, "calling holdAssocAutoStartCues(" + getCueLabel(\nCueIndex) + ")")
;       holdAssocAutoStartCues(\nCueIndex)
;     EndIf
    
    If \bSFRGoNext
      If gnCueToGo <> \nCueIndex
        nNextManualCuePtr = gnCueToGo
      Else
        nNextManualCuePtr = getNextManualCue(\nCueIndex)
      EndIf
      debugMsg(sProcName, "\bSFRGoNext=" + strB(\bSFRGoNext) + ", \nSFRGoNextDelay=" + Str(\nSFRGoNextDelay) + ", nNextManualCuePtr=" + getCueLabel(nNextManualCuePtr))
      If (nNextManualCuePtr >= 0) And (nNextManualCuePtr < gnCueEnd)
        samAddRequest(#SCS_SAM_GO_WHEN_OK, nNextManualCuePtr, 0.0, 0, "", 0, 0, -1, #True, #False, (gqTimeNow + \nSFRGoNextDelay))
      EndIf
    EndIf
    
    If bSFRRelease
      \nSubState = #SCS_CUE_RELEASING
    ElseIf bSFRTrack
      \nSubState = #SCS_CUE_STOPPING
    ElseIf bSFRFadeIn
      \nSubState = #SCS_CUE_FADING_IN
    ElseIf bSFRFadeOut
      \nSubState = #SCS_CUE_FADING_OUT
    Else
      If aCue(\nCueIndex)\bNonLinearCue
        endOfSub(pSubPtr, #SCS_CUE_READY)
      Else
        If aCue(\nCueIndex)\nActivationMethod = #SCS_ACMETH_HK_STEP
          endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
        ElseIf \bHotkey Or \bExtAct Or \bCallableCue
          endOfSub(pSubPtr, #SCS_CUE_READY)
        Else
          endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
        EndIf
      EndIf
    EndIf
    
    setCueState(\nCueIndex)
    ; debugMsg(sProcName, "calling updateGrid(" + \nCueIndex + ")")
    updateGrid(\nCueIndex)
    
    ; Added 29Mar2021 11.8.4.1ai following test of Malcolm Gordon's cue file where an SFR cue resumed a hibernated cue, and the hibernated cue was not immediately re-displayed
    If gnHibernatedCueResumed >= 0
      If getHideCueOpt(\nCueIndex) = #SCS_HIDE_NO
        debugMsg(sProcName, "gnHibernatedCueResumed=" + getCueLabel(gnHibernatedCueResumed) + ", setting gbCallLoadDispPanels=#True")
        gbCallLoadDispPanels = #True
      EndIf
    EndIf
    ; End added 29Mar2021 11.8.4.1ai
    
  EndWith
  
  debugMsg(sProcName, #SCS_END + ", returning #True")
  ProcedureReturn #True
  
EndProcedure

Procedure reposCue(pCuePtr, nSetPosTime, bRelativeTime=#False, bBeforeEnd=#False, nSetPosCueType=#SCS_SETPOS_CUETYPE_NA)
  ; Changed 7Jun2022 11.9.2
  PROCNAMECQ(pCuePtr)
  Protected j, k
  Protected nCurrPos, nReqdCuePos
  
  debugMsg(sProcName, #SCS_START + ", nSetPosTime=" + nSetPosTime + ", bRelativeTime=" + strB(bRelativeTime) + ", bBeforeEnd=" + strB(bBeforeEnd) + ", nSetPosCueType=" + decodeSetPosSetPosCueType(nSetPosCueType))
  
  If pCuePtr >= 0
    j = aCue(pCuePtr)\nFirstSubIndex
    While j >= 0
      If aSub(j)\bSubEnabled
        If aSub(j)\bSubTypeF And (nSetPosCueType = #SCS_SETPOS_CUETYPE_NA Or nSetPosCueType = #SCS_SETPOS_CUETYPE_PLAY_AUDIO)
          k = aSub(j)\nFirstAudIndex
          ; only one aud for subtype F, so no need for a k loop
          If bRelativeTime
            calcCuePositionForAud(k)
            nReqdCuePos = aAud(k)\nCuePos + nSetPosTime
          ElseIf bBeforeEnd ; Added 7Jun2022 11.9.2
            nReqdCuePos = aAud(k)\nCueDuration - nSetPosTime
            If aAud(k)\nAbsMin > 0
              nReqdCuePos + aAud(k)\nAbsMin
            EndIf
            debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nCueDuration=" + aAud(k)\nCueDuration + ", \nAbsMin=" + aAud(k)\nAbsMin + ", nSetPosTime=" + nSetPosTime + ", nReqdCuePos=" + nReqdCuePos)
          Else
            nReqdCuePos = nSetPosTime
          EndIf
          ; Added 7Jun2022 11.9.2
          If nReqdCuePos < 0
            nReqdCuePos = 0
          EndIf
          ; End added 7Jun2022 11.9.2
          debugMsg(sProcName, "calling reposAuds(" + getAudLabel(k) + ", " + nReqdCuePos + ", #True, #True)")
          reposAuds(k, nReqdCuePos, #True, #True)
          
        ElseIf aSub(j)\bSubTypeA And (nSetPosCueType = #SCS_SETPOS_CUETYPE_NA Or nSetPosCueType = #SCS_SETPOS_CUETYPE_PLAY_VIDEO_IMAGE)
          ; with subtype A, apply 'set position' if there is only one aud
          k = aSub(j)\nFirstAudIndex
          If aAud(k)\nNextAudIndex = -1
            If bRelativeTime
              calcCuePositionForAud(k)
              nReqdCuePos = aAud(k)\nCuePos + nSetPosTime
            ElseIf bBeforeEnd ; Added 7Jun2022 11.9.2
              nReqdCuePos = aAud(k)\nCueDuration - nSetPosTime
              If aAud(k)\nAbsMin > 0
                nReqdCuePos + aAud(k)\nAbsMin
              EndIf
              debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nCueDuration=" + aAud(k)\nCueDuration + ", \nAbsMin=" + aAud(k)\nAbsMin + ", nSetPosTime=" + nSetPosTime + ", nReqdCuePos=" + nReqdCuePos)
            Else
              nReqdCuePos = nSetPosTime
            EndIf
            ; Added 7Jun2022 11.9.2
            If nReqdCuePos < 0
              nReqdCuePos = 0
            EndIf
            ; End added 7Jun2022 11.9.2
            reposAuds(k, nReqdCuePos, #True, #True)
          EndIf
        EndIf
      EndIf
      j = aSub(j)\nNextSubIndex
    Wend
  EndIf
EndProcedure

Procedure playSubTypeT(pSubPtr, bCalledFromEditor)
  ; SubType T = Set Position
  ; Changed significantly 7Jun2022 11.9.2
  PROCNAMECS(pSubPtr)
  Protected nCuePtr, bRelativeTime, bBeforeEnd, bIgnore, n, nSetPos, nCueState
  
  debugMsg(sProcName, #SCS_START)
  
  With aSub(pSubPtr)
    Select \nSetPosCueType
      Case #SCS_SETPOS_CUETYPE_NA
        If \sSetPosCue
          nCuePtr = getCuePtr(\sSetPosCue)
          If nCuePtr < 0
            WMN_setStatusField(LangPars("Errors", "CueNotFound", \sCueToGoTo), #SCS_STATUS_ERROR)
            bIgnore = #True
          EndIf
          
          If \sSetPosCueMarker
            ; Jump to Cue Marker
            For n = 0 To gnMaxCueMarkerInfo
              If (gaCueMarkerInfo(n)\sHostCue = \sSetPosCue) And (gaCueMarkerInfo(n)\nHostSubNo = \nSetPosCueMarkerSubNo) And (gaCueMarkerInfo(n)\sCueMarkerName = \sSetPosCueMarker)
                debugMsg(sProcName, "sCueMarkerName " + gaCueMarkerInfo(n)\sCueMarkerName + " at  n = " + n + " audio file position = " + gaCueMarkerInfo(n)\nCueMarkerPosition)
                nSetPos = gaCueMarkerInfo(n)\nCueMarkerPosition
                Break ; Cue Marker found at index n
              ElseIf n = gnMaxCueMarkerInfo
                ; We have reached the end of the array without finding our Cue Marker
                debugMsg(sProcName, "ERROR: sSetPosCueMarker " + \sSetPosCueMarker + " does not exist in gaCueMarkerInfo array! gnMaxCueMarkerInfo = " + gnMaxCueMarkerInfo) 
                bIgnore = #True
              EndIf
            Next n        
          Else
            ; Jump to position
            nSetPos = \nSetPosTime
          EndIf
          
          If \nSetPosAbsRel = #SCS_SETPOS_RELATIVE
            bRelativeTime = #True
          ElseIf \nSetPosTime < 0
            bIgnore = #True
          EndIf
          If bIgnore = #False
            If \nSetPosAbsRel = #SCS_SETPOS_BEFORE_END
              bBeforeEnd = #True
            EndIf
            debugMsg(sProcName, "calling reposCue(" + getCueLabel(nCuePtr) + ", " + nSetPos + ", " + strB(bRelativeTime) + ", " + strB(bBeforeEnd) + ")")
            reposCue(nCuePtr, nSetPos, bRelativeTime, bBeforeEnd)
          EndIf
        EndIf
        
      Case #SCS_SETPOS_CUETYPE_PLAY_AUDIO, #SCS_SETPOS_CUETYPE_PLAY_VIDEO_IMAGE
        For nCuePtr = 1 To gnLastCue
          If nCuePtr <> \nCueIndex
            nCueState = aCue(nCuePtr)\nCueState
            If nCueState >= #SCS_CUE_FADING_IN And nCueState <= #SCS_CUE_FADING_OUT And nCueState <> #SCS_CUE_HIBERNATING
              bRelativeTime = #False
              bIgnore = #False
              If \nSetPosAbsRel = #SCS_SETPOS_RELATIVE
                bRelativeTime = #True
              ElseIf \nSetPosTime < 0
                bIgnore = #True
              EndIf
              If bIgnore = #False
                If \nSetPosAbsRel = #SCS_SETPOS_BEFORE_END
                  bBeforeEnd = #True
                EndIf
                debugMsg(sProcName, "calling reposCue(" + getCueLabel(nCuePtr) + ", " + \nSetPosTime + ", " + strB(bRelativeTime) + ", " + strB(bBeforeEnd) + ", " + decodeSetPosSetPosCueType(\nSetPosCueType) + ")")
                reposCue(nCuePtr, \nSetPosTime, bRelativeTime, bBeforeEnd, \nSetPosCueType)
              EndIf
            EndIf
          EndIf
        Next nCuePtr
        
    EndSelect
    setSubStateForEndOfSub(pSubPtr, #SCS_CUE_READY)
    setCueState(\nCueIndex)
    updateGrid(\nCueIndex)
  EndWith
  
  ProcedureReturn #True
  
EndProcedure

Procedure playSubTypeU(pSubPtr, bCalledFromEditor, bBypassSendingForM2T=#False)
  ; SubType U = MIDI time code (MTC) and Linear Time Code (LTC)
  PROCNAMECS(pSubPtr)
  Protected nPrevMTCSubPtr, nMTCType, nTCGenIndex
  Protected d
  Protected bLockedMutex
  Protected bStopCurrTimeCode, bCreateOrResumeThread, bSetSync, bStartMTCNow, nMTCLinkedToAFSubPtr, nLinkedAudPtr
  
  debugMsg(sProcName, #SCS_START + ", bCalledFromEditor=" + strB(bCalledFromEditor) + ", bBypassSendingForM2T=" + strB(bBypassSendingForM2T))
  
  nMTCType = aSub(pSubPtr)\nMTCType
  
  ;With grMTCSendControl
    If nMTCType = #SCS_MTC_TYPE_LTC
      nTCGenIndex = aSub(pSubPtr)\nTCGenIndex
      If nTCGenIndex < 0
        debugMsg(sProcName, "calling assignAndSetTimeCodeGeneratorForSub(" + getSubLabel(pSubPtr) + ", #True, #True)")
        If assignAndSetTimeCodeGeneratorForSub(pSubPtr, #True, #True)
          nTCGenIndex = aSub(pSubPtr)\nTCGenIndex
          debugMsg(sProcName, "nTCGenIndex=" + nTCGenIndex)
        EndIf
      EndIf
      If nTCGenIndex >= 0
        CompilerIf #c_scsltc
          If gn_ScsLTCAllowed = #True
            sendLTCCommand("play p" + gaSMSTCGenerator(nTCGenIndex)\sTCChannel)
          Else
            sendSMSCommand("play p" + gaSMSTCGenerator(nTCGenIndex)\sTCChannel)
          EndIf
        CompilerElse
          sendSMSCommand("play p" + gaSMSTCGenerator(nTCGenIndex)\sTCChannel)
        CompilerEndIf
      EndIf
    Else
      ; LockMTCSendMutex(512, #True) ; This mutex intended for locking access and updates to grMTCSendControl
      ; Added 3Jan2023 11.10.0ab following email from Ian Harding 12Dec2022 that showed some quarter-frame messages sent before the relevant full-frame message on starting a second MTC cue
      If grMTCSendControl\bMTCCuesPortOpen
        grMTCSendControl\bMTCSuspendThreadUntilFullFrameSent = #True
        debugMsg(sProcName, "grMTCSendControl\bMTCSuspendThreadUntilFullFrameSent=" + strB(grMTCSendControl\bMTCSuspendThreadUntilFullFrameSent))
      EndIf
      ; End added 3Jan2023 11.10.0ab
      debugMsg(sProcName, "calling initQPCIfReqd()")
      initQPCIfReqd()
      debugMsg(sProcName, "calling openMTCCuesPortAndWaitIfReqd(#False)")
      openMTCCuesPortAndWaitIfReqd(#False)
    EndIf
    
    If grOperModeOptions(gnOperMode)\nMTCDispLocn = #SCS_MTC_DISP_SEPARATE_WINDOW
      samCancelRequest(#SCS_SAM_HIDE_MTC_WINDOW_IF_INACTIVE)  ; cancel any outstanding request to hide the window
      If IsWindow(#WTC) = #False
        debugMsg(sProcName, "calling WTC_Form_Load(#True)")
        WTC_Form_Load(#True)
      EndIf
      If getWindowVisible(#WTC) = #False
        debugMsg(sProcName, "calling setWindowVisible(#WTC, #True)")
        setWindowVisible(#WTC, #True)
      EndIf
    EndIf
    
    nPrevMTCSubPtr = grMTCSendControl\nMTCSubPtr
    If nPrevMTCSubPtr >= 0
      debugMsg(sProcName, "nPrevMTCSubPtr=" + getSubLabel(nPrevMTCSubPtr))
      If (aSub(nPrevMTCSubPtr)\nSubState >= #SCS_CUE_FADING_IN) And (aSub(nPrevMTCSubPtr)\nSubState <= #SCS_CUE_FADING_OUT)
        ; nb if in the above range then only actually expecting #SCS_CUE_PLAYING
        If aSub(nPrevMTCSubPtr)\nMTCType = #SCS_MTC_TYPE_LTC ; Changed 31Jan2025 11.10.6 (was just 'nMTCType', not nMTCType of nPrevMTCSubPtr)
          bStopCurrTimeCode = #True
        Else
          ;;;;;;;;;;;; bStopCurrTimeCode = #False
          bStopCurrTimeCode = #True
        EndIf
        debugMsg(sProcName, "calling stopSub(" + getSubLabel(nPrevMTCSubPtr) + ", 'U', #False, #True, #False, " + strB(bStopCurrTimeCode) + ")")
        stopSub(nPrevMTCSubPtr, "U", #False, #True, #False, bStopCurrTimeCode)
        debugMsg(sProcName, "calling closeSub(" + getSubLabel(nPrevMTCSubPtr) + ", #False, #True, " + strB(bStopCurrTimeCode) + ")")
        closeSub(nPrevMTCSubPtr, #False, #True, bStopCurrTimeCode)
        debugMsg(sProcName, "calling setCueState(" + getCueLabel(aSub(nPrevMTCSubPtr)\nCueIndex) + ")")
        setCueState(aSub(nPrevMTCSubPtr)\nCueIndex)
      EndIf
    EndIf
    
    debugMsg(sProcName, "calling initMTCSendControlForSub(" + getSubLabel(pSubPtr) + ")")
    initMTCSendControlForSub(pSubPtr) ; sets many variables inside grMTCSendControl
    
    Select nMTCType
      Case #SCS_MTC_TYPE_LTC
        grSMS\sGetTimeCodeCommandString = "get tcgen p" + gaSMSTCGenerator(nTCGenIndex)\sTCChannel + " tc"
        grSMS\bLTCRunning = #True
        debugMsg(sProcName, "grSMS\bLTCRunning=" + strB(grSMS\bLTCRunning))
        If grMTCSendControl\nMTCSendState <> #SCS_MTC_STATE_RUNNING
          grMTCSendControl\nMTCSendState = #SCS_MTC_STATE_RUNNING
          debugMsg(sProcName, "grMTCSendControl\nMTCSendState=" + decodeMTCSendState(grMTCSendControl\nMTCSendState))
        EndIf
    EndSelect
    
    aSub(pSubPtr)\qTimeSubStarted = gqTimeNow
    aSub(pSubPtr)\bTimeSubStartedSet = #True
    aSub(pSubPtr)\qTimeSubRestarted = aSub(pSubPtr)\qTimeSubStarted
    If aSub(pSubPtr)\bSubCheckProgSlider
      aSub(pSubPtr)\qAdjTimeSubStarted = aSub(pSubPtr)\qTimeSubStarted - aSub(pSubPtr)\nSubPosition
      aSub(pSubPtr)\bSubCheckProgSlider = #False
    Else
      aSub(pSubPtr)\qAdjTimeSubStarted = aSub(pSubPtr)\qTimeSubStarted
    EndIf
    debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\qTimeSubRestarted=" + traceTime(aSub(pSubPtr)\qTimeSubRestarted))
    aSub(pSubPtr)\nSubTotalTimeOnPause = 0
    aSub(pSubPtr)\nSubPriorTimeOnPause = 0
    
    If nMTCType = #SCS_MTC_TYPE_MTC
      grMTCSendControl\qLogQtrFramesStartTime = gqTimeNow
      For d = 0 To grProd\nMaxCtrlSendLogicalDev
        Select grProd\aCtrlSendLogicalDevs(d)\nDevType
          Case #SCS_DEVTYPE_CS_MIDI_OUT, #SCS_DEVTYPE_CS_MIDI_THRU
            If grProd\aCtrlSendLogicalDevs(d)\bCtrlMidiForMTC
              grMTCSendControl\nMTCCuesPhysicalDevPtr = getPhysDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_CTRL_SEND, grProd\aCtrlSendLogicalDevs(d)\sLogicalDev)
              Break
            EndIf
        EndSelect
      Next d
      
      If bBypassSendingForM2T
        bStartMTCNow = #False
      Else
        bStartMTCNow = #True
        If gbUseSMS = #False ; Test added 17Aug2021 11.8.5.1 to bypass the following when using SM-S
          If aSub(pSubPtr)\bStartedInEditor = #False
            nMTCLinkedToAFSubPtr = aSub(pSubPtr)\nMTCLinkedToAFSubPtr
            If nMTCLinkedToAFSubPtr >= 0
              nLinkedAudPtr = aSub(nMTCLinkedToAFSubPtr)\nFirstAudIndex
              If nLinkedAudPtr >= 0
                bStartMTCNow = #False
                debugMsg(sProcName, "aAud(" + getAudLabel(nLinkedAudPtr) + ")\nAudState=" + decodeCueState(aAud(nLinkedAudPtr)\nAudState))
                ; Added 2Nov2024 11.10.6bd
                If aAud(nLinkedAudPtr)\nAudState = #SCS_CUE_NOT_LOADED
                  debugMsg(sProcName, "calling openMediaFile(" + getAudLabel(nLinkedAudPtr) + ")")
                  openMediaFile(nLinkedAudPtr)
                  debugMsg(sProcName, "aAud(" + getAudLabel(nLinkedAudPtr) + ")\nAudState=" + decodeCueState(aAud(nLinkedAudPtr)\nAudState))
                EndIf
                ; End added 2Nov2024 11.10.6bd
                If aAud(nLinkedAudPtr)\nAudState > #SCS_CUE_READY
                  debugMsg(sProcName, "calling MTC_playOrResumeMTCAndLinkedAud(" + getSubLabel(pSubPtr) + ")")
                  bSetSync = MTC_playOrResumeMTCAndLinkedAud(pSubPtr) ; Changed 4Jan2023 11.10.0ab: saved return value in bSetSync
                EndIf
              EndIf
            EndIf ; EndIf nMTCLinkedToAFSubPtr >= 0
          EndIf ; EndIf aSub(pSubPtr)\bStartedInEditor = #False
        EndIf ; EndIf gbUseSMS = #False
      EndIf
      
      ; debugMsg(sProcName, "bStartMTCNow=" + strB(bStartMTCNow))
      If bStartMTCNow = #False
        If grOperModeOptions(gnOperMode)\nMTCDispLocn = #SCS_MTC_DISP_SEPARATE_WINDOW ; Test added 7Dec2021 11.8.6cu following emails, etc from Ian Harding
          WTC_displayMTC("", pSubPtr, "", #True)
        EndIf
        bCreateOrResumeThread = #True ; Added 1Nov2024 11.10.6bb following email from Andr Grohmann where it appears the MTC thread had been suspended when an MTC sub-cue was ready to play (sub-cue 11<2>)
      Else
        debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\nSubPosition=" + aSub(pSubPtr)\nSubPosition)
        If aSub(pSubPtr)\nSubPosition > 0
          aSub(pSubPtr)\nSubState = #SCS_CUE_PLAYING
          If bSetSync
            reposTimeCode(pSubPtr, aSub(pSubPtr)\nSubPosition, #False)
          Else
            reposTimeCode(pSubPtr, aSub(pSubPtr)\nSubPosition, #True)
          EndIf
        Else
          ; added 24Aug2019 11.8.2ag - clear out any outstanding pause or stop request, following issue reported by Christian Peters where MTC was suspended when it should have been running
          If grMTCSendControl\nMTCThreadRequest & #SCS_MTC_THR_PAUSE_MTC
            grMTCSendControl\nMTCThreadRequest ! #SCS_MTC_THR_PAUSE_MTC
          EndIf
          If grMTCSendControl\nMTCThreadRequest & #SCS_MTC_THR_STOP_MTC
            grMTCSendControl\nMTCThreadRequest ! #SCS_MTC_THR_STOP_MTC
          EndIf
          ; end added 24Aug2019 11.8.2ag
          grMTCSendControl\nMTCThreadRequest | #SCS_MTC_THR_READY_MTC
          debugMsg(sProcName, "grMTCSendControl\nMTCThreadRequest=" + grMTCSendControl\nMTCThreadRequest)
        EndIf
        bCreateOrResumeThread = #True
      EndIf
      
      ; UnlockMTCSendMutex(#True)
      
      ; debugMsg(sProcName, "bCreateOrResumeThread=" + strB(bCreateOrResumeThread))
      If bCreateOrResumeThread
        debugMsg(sProcName, "calling THR_createOrResumeAThread(#SCS_THREAD_MTC_CUES)")
        THR_createOrResumeAThread(#SCS_THREAD_MTC_CUES)
      EndIf
      
    EndIf
    
  ;EndWith
  
  With aSub(pSubPtr)
    \nMTCMSAtLinkedAudStart = getCurrMTCTimeInMilliseconds()
    \nSubState = #SCS_CUE_PLAYING
    debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\nSubState=" + decodeCueState(\nSubState) + ", \nMTCMSAtLinkedAudStart=" + \nMTCMSAtLinkedAudStart)
    debugMsg(sProcName, "calling setCueState(" + \nCueIndex + ", #True)")
    setCueState(\nCueIndex, #True)
    samAddRequest(#SCS_SAM_LOAD_GRID_ROW, \nCueIndex)
  EndWith
  
  grMTCSendControl\bMTCSendRefreshDisplay = #True
  ; debugMsg(sProcName, "grMTCSendControl\bMTCSendRefreshDisplay=" + strB(grMTCSendControl\bMTCSendRefreshDisplay))
  
  debugMsg(sProcName, #SCS_END + ", returning #True")
  ProcedureReturn #True
  
EndProcedure

Procedure playDisabledSub(pSubPtr, bCalledFromEditor)
  PROCNAMECS(pSubPtr)
  
  debugMsg(sProcName, #SCS_START)
  
  With aSub(pSubPtr)
    If aCue(\nCueIndex)\bNonLinearCue
      endOfSub(pSubPtr, #SCS_CUE_READY)
    Else
      endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
    EndIf
    If pSubPtr >= 0
      setCueState(\nCueIndex)
      updateGrid(\nCueIndex)
    EndIf
  EndWith
  
  debugMsg(sProcName, #SCS_END)
  
  ProcedureReturn #True
  
EndProcedure

Procedure playSub(pSubPtr, pLCStartAt=0, bUseCas=#False, bCalledFromEditor=#False, nCtrlSendIndex=-1, nCasGroupId=-1, nStartAtTrkNo=-1, bTopLevelCall=#False, nHotkeyToggleState=-1)
  PROCNAMECS(pSubPtr)
  Protected d, d2
  Protected i, j, k, m, n, j2, k2
  Protected nMyCueIndex, bRedoCueState
  Protected bSubResult
  Protected sSMSCommandString.s
  Protected sXChanList.s
  Protected nMyStartAtTrkNo
  Protected qTimeStarted.q ; Added 20Mar2021 11.8.4ad
  Protected bUsePreHotkeyValues ; Added 13Jun2024 11.10.3al

  debugMsg(sProcName, #SCS_START + ", \sSubType=" + aSub(pSubPtr)\sSubType + ", pLCStartAt=" + pLCStartAt + ", nStartAtTrkNo=" + nStartAtTrkNo + ", nHotkeyToggleState=" + nHotkeyToggleState)
  
  If gbDemoMode
    If (gnDemoTimeCount < 1) And (gbInitialising = #False)
      scsMessageRequester(#SCS_TITLE, Lang("WMN", "SessionTimeLimit"), #MB_ICONEXCLAMATION)
      ProcedureReturn
    EndIf
  EndIf
  
  ; added 25Nov2015 11.4.1.2m following report from Coin Riebel about starting a memo cue from a network connection
  ; included "J" 26Jan2016 following report from Simone Guisti
  ; included "T" 13Jul2016 following report from Michael Arnold
  ; included "M" 14Sep2017 to ensure MIDI file playback etc is handled by the main thread
  If gnThreadNo > #SCS_THREAD_MAIN
    Select aSub(pSubPtr)\sSubType
      Case "E", "J", "K", "T", "M"
        ; the following modified 8Nov2018 11.8.0ar to provide faster call to playSub() when not called from the editor
        If bCalledFromEditor
          samAddRequest(#SCS_SAM_PLAY_SUB, pSubPtr, 0, bCalledFromEditor)
          PostEvent(#SCS_Event_WakeUp, #WMN, 0) ; wake up main thread's WaitWindowEvent()
        Else
          gqPriorityPostEventWaiting = ElapsedMilliseconds()
          PostEvent(#SCS_Event_PlaySub, #WMN, 0, 0, pSubPtr)
          debugMsg(sProcName, "PostEvent(#SCS_Event_PlaySub, #WMN, 0, 0, " + getSubLabel(pSubPtr) + "), gqPriorityPostEventWaiting=" + traceTime(gqPriorityPostEventWaiting))
        EndIf
        ProcedureReturn
    EndSelect
  EndIf
  ; end added 25Nov2015 11.4.1.2m
  
  With aSub(pSubPtr)
    
    logKeyEvent("Play Sub " + getSubLabel(pSubPtr) + ", \sSubType=" + \sSubType)
    
    \bSubCountDownPaused = #False
    \bIgnoreInStatusCheck = #True   ; will be set #False at the end of this procedure - #True prevents statusCheck() actioning partially started parts of the sub
    ; debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\bIgnoreInStatusCheck=" + strB(aSub(pSubPtr)\bIgnoreInStatusCheck))
    \sSubSetGainCommandString = ""
    ; debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\sSubSetGainCommandString=" + \sSubSetGainCommandString)
    \sSubPlayCommandString = ""
    
    If \bSubEnabled
      If (\nSubState = #SCS_CUE_NOT_LOADED) Or (\nSubState >= #SCS_CUE_COMPLETED)
        If (aCue(\nCueIndex)\nCueState = #SCS_CUE_NOT_LOADED) Or (aCue(\nCueIndex)\nCueState >= #SCS_CUE_COMPLETED)
          debugMsg(sProcName, "calling loadOneCue(" + getCueLabel(\nCueIndex) + ") because \nCueState=" + decodeCueState(aCue(\nCueIndex)\nCueState))
          loadOneCue(\nCueIndex)
        EndIf
      EndIf
      If \bSubTypeHasAuds
        If \nFirstPlayIndex >= 0
          If aAud(\nFirstPlayIndex)\nAudState = #SCS_CUE_NOT_LOADED
            debugMsg(sProcName, "calling loadOneCue(" + getCueLabel(\nCueIndex) + ") because \nCueState=" + decodeCueState(aCue(\nCueIndex)\nCueState))
            loadOneCue(\nCueIndex)
          EndIf
        EndIf
      EndIf
    EndIf
    
    \nSubDuration = getSubLength(pSubPtr) ; Added 29Dec2021 11.8.6dc
    
    ; Added 20Mar2021 11.8.4ad to allow for user clicking part-way thru an audio file before clicking GO, where there are dependent cues
    qTimeStarted = gqTimeNow
    If \bSubTypeF And \bSubPlaceHolder = #False
      k = \nFirstAudIndex
      If k >= 0
        If aAud(k)\nRelFilePos > 0
          debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nRelFilePos=" + aAud(k)\nRelFilePos + ", \nRelStartAt=" + aAud(k)\nRelStartAt)
          qTimeStarted - (aAud(k)\nRelFilePos - aAud(k)\nRelStartAt) ; 30Oct2021 11.8.6bm Added aAud(k)\nRelStartAt following email from John Cunningham
        EndIf
      EndIf
    EndIf
    ; End added 20Mar2021 11.8.4ad
    
    \qTimeSubStarted = qTimeStarted
    \qAdjTimeSubStarted = qTimeStarted
    \bTimeSubStartedSet = #True
    \qTimeSubRestarted = qTimeStarted
    \nTotalTimeOnGlobalPause = 0
    \bHibernating = #False
    \bStartedInEditor = bCalledFromEditor
    \nPLAudPlayCount = 0
    debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\nSubDuration=" + \nSubDuration + ", \qTimeSubStarted=" + traceTime(\qTimeSubStarted) + ", \bTimeSubStartedSet=" + strB(\bTimeSubStartedSet) + ", \bStartedInEditor=" + strB(\bStartedInEditor))
    
    aCue(\nCueIndex)\qTimeCueStopped = 0
    aCue(\nCueIndex)\bTimeCueStoppedSet = #False
    ; debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\bTimeCueStoppedSet=" + strB(aCue(\nCueIndex)\bTimeCueStoppedSet))
    
    If aCue(\nCueIndex)\bTimeCueStartedSet = #False
      ; first sub-cue in this cue to be started (but not necessarily the first sub-cue present)
      aCue(\nCueIndex)\qTimeCueStarted = qTimeStarted
      debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\qTimeCueStarted=" + traceTime(aCue(\nCueIndex)\qTimeCueStarted))
      aCue(\nCueIndex)\bTimeCueStartedSet = #True
      aCue(\nCueIndex)\qTimeCueLastStarted = qTimeStarted
      gnCueStartedCount + 1
      aCue(\nCueIndex)\nCueStartedCount = gnCueStartedCount
    EndIf
    
    If \bSubEnabled = #False And bCalledFromEditor = #False ; mod 15Jan2020 11.8.2.2ab - added "And bCalledFromEditor = #False"
      bSubResult = playDisabledSub(pSubPtr, bCalledFromEditor)
      
    ElseIf \bSubTypeA
      bSubResult = playSubTypeA(pSubPtr, bCalledFromEditor, bUseCas, nCasGroupId, nStartAtTrkNo)
      
    ElseIf \bSubTypeE
      bSubResult = playSubTypeE(pSubPtr, bCalledFromEditor)
      
    ElseIf \bSubTypeF
      bSubResult = playSubTypeF(pSubPtr, bCalledFromEditor, bUseCas, nCasGroupId)
      
    ElseIf \bSubTypeG
      bSubResult = playSubTypeG(pSubPtr, bCalledFromEditor)
      
    ElseIf \bSubTypeI
      bSubResult = playSubTypeI(pSubPtr, bCalledFromEditor)
      
    ElseIf \bSubTypeJ
      bSubResult = playSubTypeJ(pSubPtr, bCalledFromEditor)
      
    ElseIf \bSubTypeK
      ; Added bUsePreHotkeyValues etc 13Jun2024 11.10.3al
      If nHotkeyToggleState = 0
        bUsePreHotkeyValues = #True
      EndIf
      debugMsg(sProcName, "nHotkeyToggleState=" + nHotkeyToggleState + ", bUsePreHotkeyValues=" + strB(bUsePreHotkeyValues))
      bSubResult = playSubTypeK(pSubPtr, bCalledFromEditor, bUsePreHotkeyValues)
      ; debugMsg0(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\nSubState=" + decodeCueState(aSub(pSubPtr)\nSubState))
      
    ElseIf \bSubTypeL
      bSubResult = playSubTypeL(pSubPtr, bCalledFromEditor)
      
    ElseIf \bSubTypeM
      bSubResult = playSubTypeM(pSubPtr, bCalledFromEditor, nCtrlSendIndex)
      
    ElseIf \bSubTypeN
      bSubResult = playSubTypeN(pSubPtr, bCalledFromEditor)
      
    ElseIf \bSubTypeP
      nMyStartAtTrkNo = nStartAtTrkNo
      If nMyStartAtTrkNo = -1
        If \bStartedInEditor = #False
          If (\bPLSavePos) And (\nPLFirstPlayNoThisPass > 0)
            k = \nFirstPlayIndex
            While k >= 0
              If aAud(k)\nAudNo = \nPLFirstPlayNoThisPass
                ; k = aAud(k)\nNextPlayIndex
                ; If k >= 0
                  nMyStartAtTrkNo = aAud(k)\nAudNo
                ; EndIf
                Break
              EndIf
              k = aAud(k)\nNextPlayIndex
            Wend
          EndIf
        EndIf
      EndIf
      bSubResult = playSubTypeP(pSubPtr, bCalledFromEditor, bUseCas, nCasGroupId, nMyStartAtTrkNo)
      
    ElseIf \bSubTypeQ
      bSubResult = playSubTypeQ(pSubPtr, bCalledFromEditor)
      
    ElseIf \bSubTypeR
      bSubResult = playSubTypeR(pSubPtr, bCalledFromEditor)
      
    ElseIf \bSubTypeS
      bSubResult = playSubTypeS(pSubPtr, bCalledFromEditor, bUseCas, nCasGroupId, nHotkeyToggleState)
      
    ElseIf \bSubTypeT
      bSubResult = playSubTypeT(pSubPtr, bCalledFromEditor)
      
    ElseIf \bSubTypeU
      bSubResult = playSubTypeU(pSubPtr, bCalledFromEditor)
      
    EndIf
    
    If bSubResult = #False
      \bIgnoreInStatusCheck = #False  ; allow statusCheck() to process this sub and it's components
      ; debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\bIgnoreInStatusCheck=" + strB(aSub(pSubPtr)\bIgnoreInStatusCheck))
      ProcedureReturn
    EndIf
    
    If bCalledFromEditor
      \bIgnoreInStatusCheck = #False  ; allow statusCheck() to process this sub and it's components
      ; debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\bIgnoreInStatusCheck=" + strB(aSub(pSubPtr)\bIgnoreInStatusCheck))
      ProcedureReturn
    EndIf
    
    ; j = \nNextSubIndex
    j = getNextEnabledSub(pSubPtr) ; Changed 21Aug2024 11.10.3bk
    If j >= 0
      If aSub(j)\nRelStartMode = #SCS_RELSTART_AS_PREV_SUB
        If aSub(j)\nSubState <= #SCS_CUE_READY
          aSub(j)\qTimeToStartSub = qTimeStarted + aSub(j)\nRelStartTime
          aSub(j)\nSubState = #SCS_CUE_SUB_COUNTDOWN_TO_START
          debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\qTimeToStartSub=" + traceTime(aSub(j)\qTimeToStartSub) + ", gqTimeNo=" + traceTime(gqTimeNow) + ", \nSubState=" + decodeCueState(aSub(j)\nSubState))
          k = aSub(j)\nFirstPlayIndex
          If k >= 0
            aAud(k)\nAudState = #SCS_CUE_SUB_COUNTDOWN_TO_START
          EndIf
          bRedoCueState = #True
        EndIf
      ElseIf aSub(j)\nRelStartMode = #SCS_RELSTART_BE_PREV_SUB
        If aSub(j)\nSubState <= #SCS_CUE_READY
          aSub(j)\qTimeToStartSub = qTimeStarted + \nSubDuration - aSub(j)\nRelStartTime
          aSub(j)\nSubState = #SCS_CUE_SUB_COUNTDOWN_TO_START
          debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\nSubDuration=" + \nSubDuration + ", aSub(" + getSubLabel(j) + ")\qTimeToStartSub=" + traceTime(aSub(j)\qTimeToStartSub) + ", gqTimeNo=" + traceTime(gqTimeNow) + ", \nSubState=" + decodeCueState(aSub(j)\nSubState))
          k = aSub(j)\nFirstPlayIndex
          If k >= 0
            aAud(k)\nAudState = #SCS_CUE_SUB_COUNTDOWN_TO_START
          EndIf
          bRedoCueState = #True
        EndIf
      EndIf
    EndIf
    
    nMyCueIndex = \nCueIndex
    
  EndWith
  
  With aCue(nMyCueIndex)
    If \nCueState = #SCS_CUE_COMPLETED
      j = aCue(nMyCueIndex)\nFirstSubIndex
      While j >= 0
        If aSub(j)\bSubEnabled
          debugMsg(sProcName, "calling closeSub(" + getSubLabel(j) + ")")
          closeSub(j)
        EndIf
        j = aSub(j)\nNextSubIndex
      Wend
      debugMsg(sProcName, "[d] calling updateGrid(" + nMyCueIndex + ")")
      updateGrid(nMyCueIndex)
    EndIf
    
    If (\nCueState = #SCS_CUE_COMPLETED) Or (\bSubTypeS)
      gnCallOpenNextCues = 1
      debugMsg(sProcName, "gnCallOpenNextCues=" + gnCallOpenNextCues)
      If \nCueState = #SCS_CUE_COMPLETED
        If \nHideCueOpt = #SCS_HIDE_NO
          debugMsg(sProcName, "(2) setting gbCallLoadDispPanels=#True")
          gbCallLoadDispPanels = #True
        EndIf
      EndIf
      CompilerIf 1=2
        ; NOTE: Blocked out 18Dec2024 11.10.6bw following email from Beverley Grover about the 'next cue' moving backwards in the cue list
        ; debugMsg(sProcName, "calling setCueToGo(#True, " + getCueLabel(nMyCueIndex) + ")")
        ; setCueToGo(#True, nMyCueIndex)
        samAddRequest(#SCS_SAM_SET_CUE_TO_GO, #True, 0, nMyCueIndex)
      CompilerEndIf
      gbCallSetNavigateButtons = #True
    EndIf
    
    If \nStandby = #SCS_STANDBY_CANCEL
      If gnStandbyCuePtr >= 0
        closeCue(gnStandbyCuePtr)
        j = aCue(gnStandbyCuePtr)\nFirstSubIndex
        While j >= 0
          If aSub(j)\bSubEnabled
            If aSub(j)\bSubTypeHasAuds
              k = aSub(j)\nFirstAudIndex
              While k >= 0
                debugMsg(sProcName, "calling endOfAud(" + getAudLabel(k) + ", " + decodeCueState(#SCS_CUE_COMPLETED) + ")")
                endOfAud(k, #SCS_CUE_COMPLETED)
                k = aAud(k)\nNextAudIndex
              Wend
            EndIf
            If \bNonLinearCue
              If aSub(j)\bSubTypeHasAuds
                endOfSub(j, #SCS_CUE_NOT_LOADED)
              Else
                endOfSub(j, #SCS_CUE_READY)
              EndIf
            Else
              endOfSub(j, #SCS_CUE_COMPLETED)
            EndIf
          EndIf
          j = aSub(j)\nNextSubIndex
        Wend
        setCueState(gnStandbyCuePtr)
        updateGrid(gnStandbyCuePtr)
        gnStandbyCuePtr = -1
        debugMsg(sProcName, "calling PostEvent(#SCS_Event_SetStandbyToolbarBtn, #WMN, 0, 0, #False)")
        PostEvent(#SCS_Event_SetStandbyToolbarBtn, #WMN, 0, 0, #False)
      EndIf
    EndIf
    
  EndWith
  
  With aSub(pSubPtr)
    If gbUseSMS ; SM-S
      ; debugMsg(sProcName, ">>> bTopLevelCall=" + strB(bTopLevelCall) + ", \bSetLevelsWhenPlaySub=" + strB(\bSetLevelsWhenPlaySub))
      If bTopLevelCall = #False
        ; debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\sSubSetGainCommandString=" + \sSubSetGainCommandString)
        ; debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\sSubPlayCommandString=" + \sSubPlayCommandString)
        ; debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\sCueSetGainCommandString=" + aCue(\nCueIndex)\sCueSetGainCommandString)
        ; debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\sCuePlayCommandString=" + aCue(\nCueIndex)\sCuePlayCommandString)
        If \sSubSetGainCommandString
          aCue(\nCueIndex)\sCueSetGainCommandString + " " + Trim(\sSubSetGainCommandString)
        EndIf
        If \sSubPlayCommandString
          aCue(\nCueIndex)\sCuePlayCommandString + " " + Trim(\sSubPlayCommandString)
        EndIf
        ; debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\sCueSetGainCommandString=" + aCue(\nCueIndex)\sCueSetGainCommandString)
        ; debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\sCuePlayCommandString=" + aCue(\nCueIndex)\sCuePlayCommandString)
        ; debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\sCueLiveCommandString=" + aCue(\nCueIndex)\sCueLiveCommandString)
        If \bSetLevelsWhenPlaySub
          aCue(\nCueIndex)\bSetLevelsWhenPlayCue = #True
        EndIf
        ; debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\bSetLevelsWhenPlayCue=" + strB(aCue(\nCueIndex)\bSetLevelsWhenPlayCue))
      Else  ; bTopLevelCall = #True
        If (\bSetLevelsWhenPlaySub) And (Len(Trim(\sSubSetGainCommandString)) > 0)
          sendSMSCommand("set " + Trim(\sSubSetGainCommandString))
        EndIf
        If Trim(\sSubPlayCommandString)
          sendSMSCommand("play " + Trim(\sSubPlayCommandString))
          buildGetSMSCurrInfoCommandStrings()
        EndIf
        If \bSubTypeI
          sXChanList = buildXChanListForSub(pSubPtr)
          If sXChanList
            sendSMSCommand("set chan " + sXChanList + " mute off")
          EndIf
          WCN_setLiveOnInds()
        EndIf
        \sSubSetGainCommandString = ""
        ; debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\sSubSetGainCommandString=" + \sSubSetGainCommandString)
        \sSubPlayCommandString = ""
      EndIf
    EndIf
    
    If aCue(\nCueIndex)\bNonLinearCue
      If aCue(\nCueIndex)\nHideCueOpt = #SCS_HIDE_NO
        samAddRequest(#SCS_SAM_LOAD_CUE_PANELS)
      EndIf
    EndIf
    
    If bRedoCueState
      setCueState(\nCueIndex)
      updateGrid(\nCueIndex)
    EndIf
    
    aCue(\nCueIndex)\nCuePanelUpdateFlags | #SCS_CUEPNL_PROGRESS | #SCS_CUEPNL_TRANSPORT
    ; debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\nCuePanelUpdateFlags=" + Str(aCue(\nCueIndex)\nCuePanelUpdateFlags))
    
    ; debugMsg(sProcName, "\nSubState=" + decodeCueState(\nSubState))
    
    \bIgnoreInStatusCheck = #False  ; allow statusCheck() to process this sub and it's components
    ; debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\bIgnoreInStatusCheck=" + strB(aSub(pSubPtr)\bIgnoreInStatusCheck))
    
  EndWith
  
  SLD_clearFocusSlider()
  
  THR_resumeAThread(#SCS_THREAD_CONTROL)
  
  gbLogProcessorEvents = #True
  
  ; listStreamStatuses()
  
  debugMsg(sProcName, #SCS_END)
  ; debugMsg3(sProcName, #SCS_END)
  
EndProcedure

Procedure playSubsInMainThread()
  PROCNAMEC()
  Protected j
  Protected bCallSetCueToGo
  
  For j = 1 To gnLastSub
    If aSub(j)\bPlaySubInMainThread
      aSub(j)\bPlaySubInMainThread = #False
      debugMsg(sProcName, "calling playSub(" + getSubLabel(j) + ")")
      playSub(j)
      bCallSetCueToGo = #True
    EndIf
  Next j
  If bCallSetCueToGo
    debugMsg(sProcName, "calling setCueToGo()")
    setCueToGo()
  EndIf
  
EndProcedure

Procedure playPreview(sFileName.s)
  PROCNAMEC()
  Protected nBassResult.l
  Protected sFileExt.s
  Protected nStreamCreateFlags.l
  Protected nMixerStreamHandle.l
  Protected nLogicalDevPtr
  Protected sMsg.s
  Protected qOffset.q, qLength.q
  Protected qTmpQuad.q
  Protected sPlayableFileName.s
  Protected bPlayableFile
  Protected nPrimaryChan
  Protected sCmd.s
  Protected sTrackLength.s
  Protected nFlags.l  ; long
  Protected sTmp.s
  Protected nDevMapPtr, nDevMapDevPtr

  debugMsg(sProcName, #SCS_START + ", sFileName=" + sFileName)
  
  With grPreview
    
    nLogicalDevPtr = getProdLogicalDevPtrForLogicalDev(grProd\sPreviewDevice)
    nDevMapPtr = grProd\nSelectedDevMapPtr
    nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_AUDIO_OUTPUT, grProd\sPreviewDevice)
    If nLogicalDevPtr < 0 Or nDevMapDevPtr < 0
      ProcedureReturn
    EndIf
    
    Select gnCurrAudioDriver
      Case #SCS_DRV_BASS_DS, #SCS_DRV_BASS_WASAPI, #SCS_DRV_BASS_ASIO ; BASS_DS, BASS_WASAPI, BASS_ASIO
        
        If gbUseBASSMixer
          \nPreviewMixerStreamPtr = getMixerStreamPtrForLogicalDev(grProd\sPreviewDevice)
          If \nPreviewMixerStreamPtr < 0
            debugMsg(sProcName, "calling mapAudLogicalDevsToPhysicalDevs(" + decodeDriver(gnCurrAudioDriver) + ")")
            mapAudLogicalDevsToPhysicalDevs(gnCurrAudioDriver)
            debugMsg(sProcName, "calling setCueBassDevsAndMidiPortNos")
            setCueBassDevsAndMidiPortNos()
            ; try again
            \nPreviewMixerStreamPtr = getMixerStreamPtrForLogicalDev(grProd\sPreviewDevice)
            If \nPreviewMixerStreamPtr < 0
              sMsg = "\nPreviewMixerStreamPtr=" + Str(\nPreviewMixerStreamPtr) + ", sPreviewDevice=" + grProd\sPreviewDevice
              debugMsg(sProcName, sMsg)
              scsMessageRequester(#SCS_TITLE, sProcName + ": " + sMsg, #PB_MessageRequester_Error)
              ProcedureReturn
            EndIf
          EndIf
          
          If gaMixerStreams(\nPreviewMixerStreamPtr)\bRecreateMixerStream
            debugMsg3(sProcName, "calling createOneMixerStream(" + Str(\nPreviewMixerStreamPtr) + ", " + nDevMapDevPtr + ")")
            createOneMixerStream(\nPreviewMixerStreamPtr, nDevMapDevPtr)
            debugMsg(sProcName, "calling createMixerStreams()")
            createMixerStreams()     ; calling createMixerStreams forces any ASIO streams to be re-built
          EndIf
          
          nMixerStreamHandle = gaMixerStreams(\nPreviewMixerStreamPtr)\nMixerStreamHandle
          
        Else    ; not using mixer
          \nPreviewBassDevice = grMaps\aDev(nDevMapDevPtr)\nBassDevice
          nBassResult = BASS_SetDevice(\nPreviewBassDevice)
          debugMsg2(sProcName, "BASS_SetDevice(" + Str(\nPreviewBassDevice) + ")", nBassResult)
          
        EndIf
        
        ;free old stream (if any) and create new one
        nBassResult = BASS_StreamFree(\nPreviewChannel)
        debugMsg2(sProcName, "BASS_StreamFree(" + Str(\nPreviewChannel) + ")", nBassResult)
        freeHandle(\nPreviewChannel)
        
        ; open file
        sFileExt = LCase(GetExtensionPart(sFileName))
        If gbUseBASSMixer
          nStreamCreateFlags = #BASS_SAMPLE_FLOAT | #BASS_STREAM_DECODE
        Else
          nStreamCreateFlags = #BASS_SAMPLE_FLOAT
        EndIf
        
        nFlags = nStreamCreateFlags | #SCS_BASS_UNICODE | #BASS_ASYNCFILE
        gsFile = sFileName
        \nPreviewChannel = BASS_StreamCreateFile(#BASSFALSE, @gsFile, qOffset, qLength, nFlags)
        newHandle(#SCS_HANDLE_SOURCE, \nPreviewChannel)
        debugMsg3(sProcName, "BASS_StreamCreateFile(#BASSFALSE, " + GetFilePart(gsFile) + ", " + qOffset + ", " + qLength + ", " + decodeStreamCreateFlags(nFlags) + ") returned " + \nPreviewChannel)
        
        If \nPreviewChannel = 0
          ; cannot open file so just exit
          ProcedureReturn
        EndIf
        
        \qPreviewLengthInBytes = BASS_ChannelGetLength(\nPreviewChannel, #BASS_POS_BYTE)
        debugMsg3(sProcName, "BASS_ChannelGetLength(" + \nPreviewChannel + ", BASS_POS_BYTE) returned " + \qPreviewLengthInBytes)
        
        nBassResult = BASS_ChannelSetAttribute(\nPreviewChannel, #BASS_ATTRIB_VOL, grProd\fPreviewBVLevel)
        debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + \nPreviewChannel + ", BASS_ATTRIB_VOL, " + formatLevel(grProd\fPreviewBVLevel) + ")", nBassResult)
        If nBassResult = #BASSFALSE
          debugMsg3(sProcName, getBassErrorDesc(BASS_ErrorGetCode()))
        EndIf
        
        WFO_setPreviewPosAtTrackbarPos()
        
        qTmpQuad = 0
        gnPreviewEndSync = BASS_ChannelSetSync(\nPreviewChannel, #BASS_SYNC_END, qTmpQuad, @WFO_endSyncPreview(), 0)
        newHandle(#SCS_HANDLE_SYNC, gnPreviewEndSync)
        debugMsg2(sProcName, "BASS_ChannelSetSync(" + \nPreviewChannel + ", BASS_SYNC_END, " + qTmpQuad + ", @WFO_endSyncPreview(), 0)", gnPreviewEndSync)
        
        If gbUseBASSMixer
          ; do not include the BASS_MIXER_CHAN_PAUSE flag as we want the file to start playing immediately
          nBassResult = BASS_Mixer_StreamAddChannel(nMixerStreamHandle, \nPreviewChannel, #BASS_MIXER_CHAN_DOWNMIX | #BASS_MIXER_CHAN_BUFFER)
          debugMsg2(sProcName, "BASS_Mixer_StreamAddChannel(" + decodeHandle(nMixerStreamHandle) + ", " + \nPreviewChannel + ", BASS_MIXER_CHAN_DOWNMIX|BASS_MIXER_BUFFER)", nBassResult)
        Else
          nBassResult = BASS_ChannelPlay(\nPreviewChannel, #BASSTRUE)
          debugMsg2(sProcName, "BASS_ChannelPlay(" + \nPreviewChannel + ", BASSTRUE)", nBassResult)
        EndIf
        
        WFO_previewStarted()
        
      Case #SCS_DRV_SMS_ASIO ; SM-S
        
        setEditLogicalDevsDerivedFields()
        
        freePreviewPlaybacks()
        
        bPlayableFile = #True
        sFileExt = LCase(GetExtensionPart(sFileName))
        Select sFileExt
          Case "wav", "aif", "aiff"
            sPlayableFileName = sFileName
          Default
            debugMsg(sProcName, "gsEncFilesPath=" + gsEncFilesPath)
            sPlayableFileName = gsEncFilesPath + ignoreExtension(GetFilePart(sFileName)) + ".wav"
            If FileExists(sPlayableFileName) = #False
              debugMsg(sProcName, "file does not exist: sPlayableFileName=" + sPlayableFileName)
              bPlayableFile = convertAudioFileToWAV(sFileName, sPlayableFileName)
            EndIf
        EndSelect
        
        If bPlayableFile
          
          getInfoAboutFile(sFileName)
          nPrimaryChan = assignFileTracksToPlaybacks(-1, sPlayableFileName, grInfoAboutFile\nFileChannels, #SCS_PLB_PREVIEW)
          debugMsg(sProcName, "nPrimaryChan=" + nPrimaryChan)
          If nPrimaryChan >= 0
            \sPPrimaryChan = "p" + nPrimaryChan
            \sPChanList = gaPlayback(nPrimaryChan)\sPChanListPrimary
            debugMsg(sProcName, "calling buildPXChanList(" + decodeHandle(nPrimaryChan) + ", " + nLogicalDevPtr + ", " + #DQUOTE$ + #DQUOTE$ + ")")
            sTmp = buildPXChanList(nPrimaryChan, nLogicalDevPtr, "")
            \sPXChanList = Trim(Trim(StringField(sTmp, 1, "|")) + " " + Trim(StringField(sTmp, 2, "|")))
            debugMsg(sProcName, "\sPPrimaryChan=" + \sPPrimaryChan + ", \sPChanList=" + \sPChanList + ", \sPXChanList=" + \sPXChanList)
            sendSMSCommand("get chan " + \sPPrimaryChan + " track length")
            If grSMS\sFirstWordLC = "tracklength"
              sTrackLength = Trim(StringField(getSMSResponseField(1, 2), 2, "="))
              debugMsg(sProcName, "sTrackLength=" + sTrackLength)
              If IsNumeric(sTrackLength)
                \nPreviewTrackLengthInMS = Int(ValF(sTrackLength) * 1000)
              Else
                \nPreviewTrackLengthInMS = 0
              EndIf
              debugMsg(sProcName, "\nPreviewTrackLengthInMS=" + \nPreviewTrackLengthInMS)
            EndIf
            
            ; set gain of playback channels to full
            sendSMSCommand("set chan " + \sPChanList + " gain 1")
            
            ; set gain of playback crosspoint channels to nominated level
            sendSMSCommand("set chan " + \sPXChanList + " gain " + makeSMSGainString(grProd\fPreviewBVLevel))
            
            ; set start point
            WFO_setPreviewPosAtTrackbarPos()
            
            ; start playing preview file
            sendSMSCommand("play " + \sPChanList)
            WFO_previewStarted()  ; must call WFO_previewStarted() before buildGetSMSCurrInfoCommandStrings()
            buildGetSMSCurrInfoCommandStrings()
            
            gnPreviewEndSync = setSMSSyncPoint(-2, #SCS_SMS_SYNC_END, qTmpQuad, "WFO_endSyncPreview")
            debugMsg3(sProcName, "setSMSSyncPoint(-2, SCS_SMS_SYNC_END, 0, 'WFO_endSyncPreview') returned " + gnPreviewEndSync + ", gnMaxSMSSyncPoint=" + gnMaxSMSSyncPoint)
            
          EndIf
          
        EndIf
        
    EndSelect
    
  EndWith

  THR_resumeAThread(#SCS_THREAD_CONTROL)
  
  startVUDisplayIfReqd()

EndProcedure

Procedure stopPreview()
  PROCNAMEC()
  Protected nBassResult.l
  
  With grPreview
    
    If gbUseBASS  ; BASS
      
      If (\nPreviewChannel <> 0)
        
        If gbUseBASSMixer
          nBassResult = BASS_Mixer_ChannelFlags(\nPreviewChannel, #BASS_MIXER_CHAN_PAUSE, #BASS_MIXER_CHAN_PAUSE) ; set the pause flag
          debugMsg3(sProcName, "BASS_Mixer_ChannelFlags(" + Str(\nPreviewChannel) + ", BASS_MIXER_CHAN_PAUSE, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
          nBassResult = BASS_Mixer_ChannelRemove(\nPreviewChannel)
          debugMsg2(sProcName, "BASS_Mixer_ChannelRemove(" + Str(\nPreviewChannel) + ")", nBassResult)
        Else
          nBassResult = BASS_ChannelStop(\nPreviewChannel)
          debugMsg2(sProcName, "BASS_ChannelStop(" + Str(\nPreviewChannel) + ")", nBassResult)
        EndIf
        
        nBassResult = BASS_StreamFree(\nPreviewChannel)
        debugMsg2(sProcName, "BASS_StreamFree(" + Str(\nPreviewChannel) + ")", nBassResult)
        freeHandle(\nPreviewChannel)
        \nPreviewChannel = 0
        
      EndIf
      
    Else  ; SM-S
      
      If \sPPrimaryChan
        sendSMSCommand("stop " + \sPChanList)
        sendSMSCommand("set chan " + \sPXChanList + " gain 0")
        freePreviewPlaybacks()
        buildGetSMSCurrInfoCommandStrings()
      EndIf
      
    EndIf
    
  EndWith

  WFO_previewEnded()

EndProcedure

Procedure redoPhysicalDevs()
  PROCNAMEC()
  Protected bCuesChanged
  Protected i
  
  debugMsg(sProcName, #SCS_START)
  
  gbInRedoPhysicalDevs = #True
  
  debugMsg(sProcName, "calling stopAll(#False, #True)")
  stopAll(#False, #True)
  
  debugMsg(sProcName, "calling closeDevices(" + decodeDriver(gnPrevAudioDriver) + ")")
  closeDevices(gnPrevAudioDriver)
  
  debugMsg(sProcName, "gnCueToGo=" + getCueLabel(gnCueToGo) + ", gnLastCue=" + getCueLabel(gnLastCue))
  For i = gnCueToGo To gnLastCue
    setInitCueStates(i, -1)
  Next i

  If gnCurrAudioDriver = #SCS_DRV_SMS_ASIO
    If grSMS\nSMSClientConnection = 0
      debugMsg(sProcName, "calling openSMSConnection()")
      openSMSConnection()
    EndIf
    debugMsg(sProcName, "calling createASIOGroup()")
    createASIOGroup()
  EndIf
  
  debugMsg(sProcName, "calling initBassForAudioDriver(" + decodeDriver(gnCurrAudioDriver) + ")")
  initBassForAudioDriver(gnCurrAudioDriver)
  
  debugMsg(sProcName, "calling mapAudLogicalDevsToPhysicalDevs(" + decodeDriver(gnCurrAudioDriver) + ")")
  mapAudLogicalDevsToPhysicalDevs(gnCurrAudioDriver)
  
  debugMsg(sProcName, "calling mapVidCapLogicalDevsToPhysicalDevs()")
  mapVidCapLogicalDevsToPhysicalDevs()
  
  debugMsg(sProcName, "calling mapCtrlLogicalDevsToPhysicalDevs()")
  mapCtrlLogicalDevsToPhysicalDevs()
  
  debugMsg(sProcName, "calling mapLiveLogicalDevsToPhysicalDevs()")
  mapLiveLogicalDevsToPhysicalDevs()
  
  debugMsg(sProcName, "calling setDisplayPanFlags()")
  setDisplayPanFlags()
  
  propagateFileInfo()
  DoEvents()    ; give Windows a chance to check program is 'responding'

  debugMsg(sProcName, "calling setCueBassDevsAndMidiPortNos()")
  bCuesChanged = setCueBassDevsAndMidiPortNos()
  debugMsg(sProcName, "bCuesChanged=" + strB(bCuesChanged))
  
  setIgnoreDevInds()
  listIgnoreDevInds()
  
  If gnThreadNo = #SCS_THREAD_MAIN
    debugMsg(sProcName, "calling loadMidiControl(#False)")
    loadMidiControl(#False)
    debugMsg(sProcName, "calling openMidiPorts()")
    openMidiPorts()
  Else
    samAddRequest(#SCS_SAM_OPEN_MIDI_PORTS, #False)
  EndIf
  
  If gnThreadNo = #SCS_THREAD_MAIN
    debugMsg(sProcName, "calling setRS232InOutInds()")
    setRS232InOutInds()
    debugMsg(sProcName, "calling startRS232()")
    startRS232()
    debugMsg(sProcName, "calling checkRS232DevsForCtrlSends()")
    checkRS232DevsForCtrlSends()
  Else
    samAddRequest(#SCS_SAM_OPEN_RS232_PORTS)
  EndIf
  
  ;NOTE: do NOT re-open DMX in redoPhysicalDevs() - it has already been re-opened if necessary in applyDevMapsForDevChgs()
  ; If gbDMXAvailable
    ; samAddRequest(#SCS_SAM_OPEN_DMX_PORTS)
  ; EndIf
  
  If gnThreadNo = #SCS_THREAD_MAIN
    debugMsg(sProcName, "calling startNetwork()")
    startNetwork()
  Else
    samAddRequest(#SCS_SAM_START_NETWORK)
  EndIf
  
  If gbEditing
    ; reload DevMapsForDevCchgs
    loadDevMapsForDevChgs()
  EndIf
  
  If gnNonLinearCue > 0
    debugMsg(sProcName, "calling goToCue(" + getCueLabel(gnNonLinearCue) + ")")
    GoToCue(gnNonLinearCue)
    If gbInExternalControl = #False
      SAG(WMN\grdCues)
    EndIf
    
  ElseIf gnFirstCueStopped > 0
    debugMsg(sProcName, "calling setCuePosition(" + getCueLabel(gnFirstCueStopped) + ")")
    setCuePosition(gnFirstCueStopped)
    If gbInExternalControl = #False
      SAG(WMN\grdCues)
    EndIf
    
  Else
    debugMsg(sProcName, "Calling setGoButton")
    setGoButton()
    setNavigateButtons()
    
  EndIf
  
  debugMsg(sProcName, "calling clearVUDisplay")
  clearVUDisplay()
  
  setToolBarCurrentImageIndex(#SCS_TBMB_PAUSE_RESUME, 0)
  gbGlobalPause = #False
  debugMsg(sProcName, "gbGlobalPause=" + strB(gbGlobalPause))
  
  gbCallPopulateGrid = #True
  gnCallOpenNextCues = 1
  gbCallLoadDispPanels = #True
  debugMsg(sProcName, "gnCallOpenNextCues=" + gnCallOpenNextCues + ", gbCallLoadDispPanels=" + strB(gbCallLoadDispPanels))

  gbRedoPhysicalDevs = #False
  gbInRedoPhysicalDevs = #False
  
  setGoButton()

  ; Debug sProcName + ": End"
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure changeVideoDriverSettings()
  PROCNAMEC()
  Protected i, j, k
  Protected bStopAll
  
  For i = 1 To gnLastCue
    If (aCue(i)\nCueState > #SCS_CUE_READY) And (aCue(i)\nCueState < #SCS_CUE_COMPLETED)
      j = aCue(i)\nFirstSubIndex
      While j >= 0
        If aSub(j)\bSubTypeA And aSub(j)\bSubEnabled
          k = aSub(j)\nFirstAudIndex
          While k >= 0
            If aAud(k)\nFileFormat = #SCS_FILEFORMAT_VIDEO
              bStopAll = #True
              Break
            EndIf
            k = aAud(k)\nNextAudIndex
          Wend
          If bStopAll
            Break
          EndIf
        EndIf
        j = aSub(j)\nNextSubIndex
      Wend
      If bStopAll
        Break
      EndIf
    EndIf
  Next i
  
  If bStopAll
    debugMsg(sProcName, "calling stopAll(#False, #True)")
    stopAll(#False, #True)
  EndIf
  
  
EndProcedure

Procedure releaseAllEarlierCues(pCuePtr, bStopImmediately, pSubSubType.s, bJustStop, bStopNotLoadedCues, nSFRCueType=#SCS_SFR_CUE_ALL_ANY, nExcludeCuePtr=-1, bExcludeSFRCueList=#False)
  PROCNAMEC()
  Protected i, j, k, n
  Protected nItemState, bWantThisCue, bWantThisSub, bWantThisAud
  Protected bThisCueChanged, bAnyCueChanged
  Protected bAnyCues, bPlayingCuesOnly, bAudioOnly, bVideoOnly, bLiveOnly
  
  debugMsg(sProcName, "pCuePtr=" + pCuePtr + ", bStopImmediately=" + strB(bStopImmediately) + ", pSubSubType=" + pSubSubType + ", bJustStop=" + strB(bJustStop) +
                      ", bStopNotLoadedCues=" + strB(bStopNotLoadedCues) + ", nSFRCueType=" + decodeSFRCueType(nSFRCueType))
  
  setProcSFRFlags(nSFRCueType)  ; macro sets bPlayingCuesOnly, bAudioOnly and bVideoOnly, based on nSRCueType
  debugMsg(sProcName, "bPlayingCuesOnly=" + strB(bPlayingCuesOnly) + ", bAudioOnly=" + strB(bAudioOnly) + ", bVideoOnly=" + strB(bVideoOnly) + ", bLiveOnly=" + strB(bLiveOnly))
  
  If gbStoppingEverything = #False
    ; Test added 4Jan2020 11.8.2.1ax as this is now set at the start of StopEverythingPart1() and must NOT be reset to -1 as some cues may already have been stopped
    gnFirstCueStopped = -1
    debugMsg(sProcName, "gnFirstCueStopped=" + getCueLabel(gnFirstCueStopped))
  EndIf
  
  For i = 1 To (pCuePtr - 1)
    bThisCueChanged = #False
    nItemState = aCue(i)\nCueState
    setWantThisCue(i)
    If bWantThisCue
      If aCue(i)\nActivationMethod = #SCS_ACMETH_AUTO
        If aCue(i)\nAutoActCuePtr = nExcludeCuePtr
          bWantThisCue = #False
        EndIf
      EndIf
    EndIf
    If bExcludeSFRCueList
      For n = 0 To grMMedia\nSFRCueMax
        If grMMedia\anSFRCuePtr[n] = i
          bWantThisCue = #False
          Break
        EndIf
      Next n
    EndIf
    If bWantThisCue
      j = aCue(i)\nFirstSubIndex
      While j >= 0
        With aSub(j)
          nItemState = \nSubState
          setWantThisSub(j)
          If (bWantThisSub) And (\nSubState <> #SCS_CUE_HIBERNATING)
            If (\bSubTypeF) And (\nSubState >= #SCS_CUE_COUNTDOWN_TO_START) And (\nSubState <= #SCS_CUE_FADING_OUT)
              k = \nFirstAudIndex
              While k >= 0
                nItemState = aAud(k)\nAudState
                bWantThisAud = #False
                If bPlayingCuesOnly
                  If (nItemState >= #SCS_CUE_COUNTDOWN_TO_START) And (nItemState <= #SCS_CUE_FADING_OUT)
                    bWantThisAud = #True
                  EndIf
                Else
                  bWantThisAud = #True
                EndIf
                If bWantThisAud
                  If (aAud(k)\nAudState >= #SCS_CUE_COUNTDOWN_TO_START) And (aAud(k)\nAudState <= #SCS_CUE_FADING_OUT) And  (aAud(k)\nMaxLoopInfo >= 0) ; (aAud(k)\bContainsLoop)
                    releaseAudLoop(k)
                  Else
                    fadeOutOneAud(k)
                  EndIf
                  bThisCueChanged = #True
                  ; If (aCue(i)\nActivationMethod <> #SCS_ACMETH_TIME) And (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)
                  If (aCue(i)\nActivationMethodReqd <> #SCS_ACMETH_TIME) And (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)  ; modified 25Aug2016 11.5.2
                    ; don't set gnFirstCueStopped for TBC's or for the standby cue or for disabled cues, or for hotkeys
                    If (aSub(j)\bHotkey = #False) And (aSub(j)\bExtAct = #False) And (aSub(j)\bCallableCue = #False)
                      If gnFirstCueStopped = -1
                        gnFirstCueStopped = i
                        debugMsg(sProcName, "gnFirstCueStopped=" + getCueLabel(gnFirstCueStopped))
                      EndIf
                    EndIf
                  EndIf
                EndIf
                k = aAud(k)\nNextAudIndex
              Wend
              
            ElseIf (\bSubTypeA) And (\nSubState >= #SCS_CUE_COUNTDOWN_TO_START) And (\nSubState <= #SCS_CUE_FADING_OUT) And (getPLRepeatActive(j))
              ; Added 5Aug2024 11.10.3ba
              k = \nFirstAudIndex
              While k >= 0
                bWantThisAud = #False
                If bPlayingCuesOnly
                  If (nItemState >= #SCS_CUE_COUNTDOWN_TO_START) And (nItemState <= #SCS_CUE_FADING_OUT)
                    bWantThisAud = #True
                  EndIf
                Else
                  bWantThisAud = #True
                EndIf
                If bWantThisAud
                  If aAud(k)\bDoContinuous
                    aAud(k)\bDoContinuous = #False
                    debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\bDoContinuous=" + strB(aAud(k)\bDoContinuous))
                  EndIf
                EndIf
                k = aAud(k)\nNextAudIndex
              Wend
              ; End added 5Aug2024 11.10.3ba
              
            ElseIf ((\bSubTypeF) And (\nSubState = #SCS_CUE_READY)) Or
                   ((\bSubTypeP) And (\nSubState >= #SCS_CUE_COUNTDOWN_TO_START) And (\nSubState <= #SCS_CUE_FADING_OUT)) Or
                   ((\bSubTypeK) And (\nSubState >= #SCS_CUE_READY) And (\nSubState <= #SCS_CUE_FADING_OUT)) Or
                   ((\bSubTypeL) And (\nSubState >= #SCS_CUE_READY) And (\nSubState <= #SCS_CUE_FADING_OUT)) Or
                   ((\bSubTypeM) And (\nSubState >= #SCS_CUE_READY) And (\nSubState <= #SCS_CUE_FADING_OUT)) Or
                   ((\bSubTypeQ) And (\nSubState >= #SCS_CUE_READY) And (\nSubState <= #SCS_CUE_FADING_OUT)) Or
                   ((\bSubTypeS) And (\nSubState >= #SCS_CUE_READY) And (\nSubState <= #SCS_CUE_FADING_OUT))
              stopSub(j, pSubSubType, #False, bJustStop)
              bThisCueChanged = #True
              ; If (aCue(i)\nActivationMethod <> #SCS_ACMETH_TIME) And (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)
              If (aCue(i)\nActivationMethodReqd <> #SCS_ACMETH_TIME) And (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)  ; modified 25Aug2016 11.5.2
                ; don't set gnFirstCueStopped for TBC's or for the standby cue or for disabled cues, or for hotkeys
                If (aSub(j)\bHotkey = #False) And (aSub(j)\bExtAct = #False) And (aSub(j)\bCallableCue = #False)
                  If gnFirstCueStopped = -1
                    gnFirstCueStopped = i
                    debugMsg(sProcName, "gnFirstCueStopped=" + getCueLabel(gnFirstCueStopped))
                  EndIf
                EndIf
              EndIf
              
            ElseIf ((\bSubTypeF) Or (\bSubTypeP) Or (\bSubTypeA)) And (bStopNotLoadedCues)
              k = \nFirstAudIndex
              While k >= 0
                If aAud(k)\nAudState = #SCS_CUE_NOT_LOADED
                  debugMsg(sProcName, aAud(k)\sAudLabel + " setting \nAudState (" + decodeCueState(aAud(k)\nAudState) + ") to SCS_CUE_COMPLETED")
                  debugMsg(sProcName, "calling endOfAud(" + getAudLabel(k) + ", " + decodeCueState(#SCS_CUE_COMPLETED) + ")")
                  endOfAud(k, #SCS_CUE_COMPLETED)
                  bThisCueChanged = #True
                  ; If (aCue(i)\nActivationMethod <> #SCS_ACMETH_TIME) And (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)
                  If (aCue(i)\nActivationMethodReqd <> #SCS_ACMETH_TIME) And (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)  ; modified 25Aug2016 11.5.2
                    ; don't set gnFirstCueStopped for TBC's or for the standby cue or for disabled cues, or for hotkeys
                    If (aSub(j)\bHotkey = #False) And (aSub(j)\bExtAct = #False) And (aSub(j)\bCallableCue = #False)
                      If gnFirstCueStopped = -1
                        gnFirstCueStopped = i
                        debugMsg(sProcName, "gnFirstCueStopped=" + getCueLabel(gnFirstCueStopped))
                      EndIf
                    EndIf
                  EndIf
                EndIf
                k = aAud(k)\nNextAudIndex
              Wend
            EndIf
          EndIf
          j = \nNextSubIndex
        EndWith
      Wend
    EndIf
    If bThisCueChanged
      bAnyCueChanged = #True
      setCueState(i)
      debugMsg(sProcName, "calling updateGrid(" + i + ")")
      updateGrid(i)
    EndIf
  Next i

  If bAnyCueChanged
    gnCallOpenNextCues = 1
    debugMsg(sProcName, "gnCallOpenNextCues=" + gnCallOpenNextCues)
    debugMsg(sProcName, "(4) setting gbCallLoadDispPanels=#True")
    gbCallLoadDispPanels = #True
    debugMsg(sProcName, "calling setCueToGo()")
    setCueToGo()
    gbCallSetNavigateButtons = #True
  EndIf

EndProcedure

Procedure removeAudChannelLoopSyncs(pAudPtr, bSwapped=#False, nLoopInfoIndex=-1)
  PROCNAMECA(pAudPtr)
  Protected nBassResult.l, d, n
  Protected l2, s2.s, l2From, l2To
  Protected nChannel.l, nAltChannel.l
  Protected bSyncPointRemoved
  
  ; debugMsg(sProcName, #SCS_START + ", bSwapped=" + strB(bSwapped) + ", nLoopInfoIndex=" + nLoopInfoIndex)
  
  If (nLoopInfoIndex >= 0) And (nLoopInfoIndex <= aAud(pAudPtr)\nMaxLoopInfo)
    l2From = nLoopInfoIndex
    l2To = nLoopInfoIndex
  Else
    l2From = 0
    l2To = aAud(pAudPtr)\nMaxLoopInfo
  EndIf
  
  If gbUseBASS  ; BASS
    
    d = aAud(pAudPtr)\nFirstSoundingDev
    If d >= 0
      
      If aAud(pAudPtr)\bUsingSplitStream
        If bSwapped = #False
          nChannel = aAud(pAudPtr)\nBassChannel[d]
          nAltChannel = aAud(pAudPtr)\nBassAltChannel[d]
        Else
          nChannel = aAud(pAudPtr)\nBassAltChannel[d]
          nAltChannel = aAud(pAudPtr)\nBassChannel[d]
        EndIf
      Else
        If bSwapped = #False
          nChannel = aAud(pAudPtr)\nSourceChannel
          nAltChannel = aAud(pAudPtr)\nSourceAltChannel
        Else
          nChannel = aAud(pAudPtr)\nSourceAltChannel
          nAltChannel = aAud(pAudPtr)\nSourceChannel
        EndIf
      EndIf
      
      For l2 = l2From To l2To
        s2 = "l2=" + l2 + ", "
        With aAud(pAudPtr)\aLoopInfo(l2)
          If nChannel = 0
            \nBassLoopSyncStart = 0
            \nBassAltLoopSyncStart = 0
            \nBassLoopSyncMixTime = 0
            \nBassAltLoopSyncMixTime = 0
            \nBassLoopSyncHearXFade = 0
            \nBassAltLoopSyncHearXFade = 0
            \nBassLoopSyncHearLE = 0
            \nBassAltLoopSyncHearLE = 0
            \nBassLoopSyncHearBoth = 0
            \nBassAltLoopSyncHearBoth = 0
            
          Else ; nChannel <> 0
            If \nBassLoopSyncStart <> 0
              If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False)
                nBassResult = BASS_Mixer_ChannelRemoveSync(nChannel, \nBassLoopSyncStart)
                debugMsg2(sProcName, s2 + "(Start) BASS_Mixer_ChannelRemoveSync(" + decodeHandle(nChannel) + ", " + decodeHandle(\nBassLoopSyncStart) + ")", nBassResult)
              Else
                nBassResult = BASS_ChannelRemoveSync(nChannel, \nBassLoopSyncStart)
                debugMsg2(sProcName, s2 + "(Start) BASS_ChannelRemoveSync(" + decodeHandle(nChannel) + ", " + decodeHandle(\nBassLoopSyncStart) + ")", nBassResult)
              EndIf
              If nBassResult = 0
                debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
              EndIf
              \nBassLoopSyncStart = 0
            EndIf
            
            If \nBassAltLoopSyncStart <> 0
              If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False)
                nBassResult = BASS_Mixer_ChannelRemoveSync(nAltChannel, \nBassAltLoopSyncStart)
                debugMsg2(sProcName, s2 + "(Start) BASS_Mixer_ChannelRemoveSync(" + decodeHandle(nAltChannel) + ", " + decodeHandle(\nBassAltLoopSyncStart) + ")", nBassResult)
              Else
                nBassResult = BASS_ChannelRemoveSync(nAltChannel, \nBassAltLoopSyncStart)
                debugMsg2(sProcName, s2 + "(Start) BASS_ChannelRemoveSync(" + decodeHandle(nAltChannel) + ", " + decodeHandle(\nBassAltLoopSyncStart) + ")", nBassResult)
              EndIf
              If nBassResult = 0
                debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
              EndIf
              \nBassAltLoopSyncStart = 0
            EndIf
            
            If \nBassLoopSyncMixTime <> 0
              If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False)
                nBassResult = BASS_Mixer_ChannelRemoveSync(nChannel, \nBassLoopSyncMixTime)
                debugMsg2(sProcName, s2 + "(MixTime) BASS_Mixer_ChannelRemoveSync(" + decodeHandle(nChannel) + ", " + decodeHandle(\nBassLoopSyncMixTime) + ")", nBassResult)
              ElseIf \nBassLoopSyncMixTime
                nBassResult = BASS_ChannelRemoveSync(nChannel, \nBassLoopSyncMixTime)
                debugMsg2(sProcName, s2 + "(MixTime) BASS_ChannelRemoveSync(" + decodeHandle(nChannel) + ", " + decodeHandle(\nBassLoopSyncMixTime) + ")", nBassResult)
              EndIf
              If nBassResult = 0
                debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
              EndIf
              \nBassLoopSyncMixTime = 0
            EndIf
            
            If \nBassAltLoopSyncMixTime <> 0
              If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False)
                nBassResult = BASS_Mixer_ChannelRemoveSync(nAltChannel, \nBassAltLoopSyncMixTime)
                debugMsg2(sProcName, s2 + "(MixTime) BASS_Mixer_ChannelRemoveSync(" + decodeHandle(nAltChannel) + ", " + decodeHandle(\nBassAltLoopSyncMixTime) + ")", nBassResult)
              Else
                nBassResult = BASS_ChannelRemoveSync(nAltChannel, \nBassAltLoopSyncMixTime)
                debugMsg2(sProcName, s2 + "(MixTime) BASS_ChannelRemoveSync(" + decodeHandle(nAltChannel) + ", " + decodeHandle(\nBassAltLoopSyncMixTime) + ")", nBassResult)
              EndIf
              If nBassResult = 0
                debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
              EndIf
              \nBassAltLoopSyncMixTime = 0
            EndIf
            
            If \nBassLoopSyncHearXFade <> 0
              If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False)
                nBassResult = BASS_Mixer_ChannelRemoveSync(nChannel, \nBassLoopSyncHearXFade)
                If nBassResult = #BASSTRUE
                  debugMsg2(sProcName, s2 + "(XFade) BASS_Mixer_ChannelRemoveSync(" + decodeHandle(nChannel) + ", " + decodeHandle(\nBassLoopSyncHearXFade) + ")", nBassResult)
                Else
                  nBassResult = BASS_Mixer_ChannelRemoveSync(nAltChannel, \nBassLoopSyncHearXFade)
                  debugMsg2(sProcName, s2 + "(XFade) BASS_Mixer_ChannelRemoveSync(" + decodeHandle(nAltChannel) + ", " + decodeHandle(\nBassLoopSyncHearXFade) + ")", nBassResult)
                  If nBassResult = #BASSTRUE
                    ; swap nChannel and nAltChannel for subsequent removesyncs
                    nChannel = aAud(pAudPtr)\nBassAltChannel[d]
                    nAltChannel = aAud(pAudPtr)\nBassChannel[d]
                  EndIf
                EndIf
                If nBassResult = 0
                  debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                EndIf
              Else
                nBassResult = BASS_ChannelRemoveSync(nChannel, \nBassLoopSyncHearXFade)
                If nBassResult = #BASSTRUE
                  debugMsg2(sProcName, s2 + "(XFade) BASS_ChannelRemoveSync(" + decodeHandle(nChannel) + ", " + decodeHandle(\nBassLoopSyncHearXFade) + ")", nBassResult)
                Else
                  nBassResult = BASS_ChannelRemoveSync(nAltChannel, \nBassLoopSyncHearXFade)
                  debugMsg2(sProcName, s2 + "(XFade) BASS_ChannelRemoveSync(" + decodeHandle(nAltChannel) + ", " + decodeHandle(\nBassLoopSyncHearXFade) + ")", nBassResult)
                  If nBassResult = #BASSTRUE
                    ; swap nChannel and nAltChannel for subsequent removesyncs
                    nChannel = aAud(pAudPtr)\nBassAltChannel[d]
                    nAltChannel = aAud(pAudPtr)\nBassChannel[d]
                  EndIf
                EndIf
                If nBassResult = 0
                  debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                EndIf
              EndIf
              \nBassLoopSyncHearXFade = 0
            EndIf
            
            If \nBassAltLoopSyncHearXFade <> 0
              If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False)
                nBassResult = BASS_Mixer_ChannelRemoveSync(nAltChannel, \nBassAltLoopSyncHearXFade)
                debugMsg2(sProcName, s2 + "(Alt XFade) BASS_Mixer_ChannelRemoveSync(" + decodeHandle(nAltChannel) + ", " + decodeHandle(\nBassAltLoopSyncHearXFade) + ")", nBassResult)
              Else
                nBassResult = BASS_ChannelRemoveSync(nAltChannel, \nBassAltLoopSyncHearXFade)
                debugMsg2(sProcName, s2 + "(Alt XFade) BASS_ChannelRemoveSync(" + decodeHandle(nAltChannel) + ", " + decodeHandle(\nBassAltLoopSyncHearXFade) + ")", nBassResult)
              EndIf
              If nBassResult = 0
                debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
              EndIf
              \nBassAltLoopSyncHearXFade = 0
            EndIf
            
            If \nBassLoopSyncHearLE <> 0
              If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False)
                nBassResult = BASS_Mixer_ChannelRemoveSync(nChannel, \nBassLoopSyncHearLE)
                debugMsg2(sProcName, s2 + "(LE) BASS_Mixer_ChannelRemoveSync(" + decodeHandle(nChannel) + ", " + decodeHandle(\nBassLoopSyncHearLE) + ")", nBassResult)
              Else
                nBassResult = BASS_ChannelRemoveSync(nChannel, \nBassLoopSyncHearLE)
                debugMsg2(sProcName, s2 + "(LE) BASS_ChannelRemoveSync(" + decodeHandle(nChannel) + ", " + decodeHandle(\nBassLoopSyncHearLE) + ")", nBassResult)
              EndIf
              If nBassResult = 0
                debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
              EndIf
              \nBassLoopSyncHearLE = 0
            EndIf
            
            If \nBassAltLoopSyncHearLE <> 0
              If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False)
                nBassResult = BASS_Mixer_ChannelRemoveSync(nAltChannel, \nBassAltLoopSyncHearLE)
                debugMsg2(sProcName, s2 + "(Alt LE) BASS_Mixer_ChannelRemoveSync(" + decodeHandle(nAltChannel) + ", " + decodeHandle(\nBassAltLoopSyncHearLE) + ")", nBassResult)
              Else
                nBassResult = BASS_ChannelRemoveSync(nAltChannel, \nBassAltLoopSyncHearLE)
                debugMsg2(sProcName, s2 + "(Alt LE) BASS_ChannelRemoveSync(" + decodeHandle(nAltChannel) + ", " + decodeHandle(\nBassAltLoopSyncHearLE) + ")", nBassResult)
              EndIf
              If nBassResult = 0
                debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
              EndIf
              \nBassAltLoopSyncHearLE = 0
            EndIf
            
            If \nBassLoopSyncHearBoth <> 0
              If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False)
                nBassResult = BASS_Mixer_ChannelRemoveSync(nChannel, \nBassLoopSyncHearBoth)
                If nBassResult = #BASSTRUE
                  debugMsg2(sProcName, s2 + "(Both) BASS_Mixer_ChannelRemoveSync(" + decodeHandle(nChannel) + ", " + decodeHandle(\nBassLoopSyncHearBoth) + ")", nBassResult)
                Else
                  nBassResult = BASS_Mixer_ChannelRemoveSync(nAltChannel, \nBassLoopSyncHearBoth)
                  debugMsg2(sProcName, s2 + "(Both) BASS_Mixer_ChannelRemoveSync(" + decodeHandle(nAltChannel) + ", " + decodeHandle(\nBassLoopSyncHearBoth) + ")", nBassResult)
                  If nBassResult = #BASSTRUE
                    ; swap nChannel and nAltChannel for subsequent removesyncs
                    nChannel = aAud(pAudPtr)\nBassAltChannel[d]
                    nAltChannel = aAud(pAudPtr)\nBassChannel[d]
                  EndIf
                EndIf
                If nBassResult = 0
                  debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                EndIf
              Else
                nBassResult = BASS_ChannelRemoveSync(nChannel, \nBassLoopSyncHearBoth)
                If nBassResult = #BASSTRUE
                  debugMsg2(sProcName, s2 + "(Both) BASS_ChannelRemoveSync(" + decodeHandle(nChannel) + ", " + decodeHandle(\nBassLoopSyncHearBoth) + ")", nBassResult)
                Else
                  nBassResult = BASS_ChannelRemoveSync(nAltChannel, \nBassLoopSyncHearBoth)
                  debugMsg2(sProcName, s2 + "(Both) BASS_ChannelRemoveSync(" + decodeHandle(nAltChannel) + ", " + decodeHandle(\nBassLoopSyncHearBoth) + ")", nBassResult)
                  If nBassResult = #BASSTRUE
                    ; swap nChannel and nAltChannel for subsequent removesyncs
                    nChannel = aAud(pAudPtr)\nBassAltChannel[d]
                    nAltChannel = aAud(pAudPtr)\nBassChannel[d]
                  EndIf
                EndIf
                If nBassResult = 0
                  debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                EndIf
              EndIf
              \nBassLoopSyncHearBoth = 0
            EndIf
            
            If \nBassAltLoopSyncHearBoth <> 0
              If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False)
                nBassResult = BASS_Mixer_ChannelRemoveSync(nAltChannel, \nBassAltLoopSyncHearBoth)
                debugMsg2(sProcName, s2 + "(Alt Both) BASS_Mixer_ChannelRemoveSync(" + decodeHandle(nAltChannel) + ", " + decodeHandle(\nBassAltLoopSyncHearBoth) + ")", nBassResult)
              Else
                nBassResult = BASS_ChannelRemoveSync(nAltChannel, \nBassAltLoopSyncHearBoth)
                debugMsg2(sProcName, s2 + "(Alt Both) BASS_ChannelRemoveSync(" + decodeHandle(nAltChannel) + ", " + decodeHandle(\nBassAltLoopSyncHearBoth) + ")", nBassResult)
              EndIf
              If nBassResult = 0
                debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
              EndIf
              \nBassAltLoopSyncHearBoth = 0
            EndIf
            
          EndIf ; EndIf nChannel <> 0
          
        EndWith
      Next l2
      
    EndIf ; EndIf d >= 0
    
  Else  ; SM-S
    For l2 = l2From To l2To
      s2 = "l2=" + l2 + ", "
      If aAud(pAudPtr)\aLoopInfo(l2)\nSMSLoopSyncPointIndex1 >= 0
        removeSMSSyncPoint(pAudPtr, aAud(pAudPtr)\aLoopInfo(l2)\nSMSLoopSyncPointIndex1)
        bSyncPointRemoved = #True
      EndIf
    Next l2
    If bSyncPointRemoved
      debugMsg(sProcName, "calling listSMSSyncPoints()")
      listSMSSyncPoints()
    EndIf
    
  EndIf
  
  For l2 = l2From To l2To
    For n = 1 To gnLastLoopSync
      With gaLoopSync(n)
        If (\bActive) And (\nAudPtr = pAudPtr) And (\nLoopInfoIndex = l2)
          \bActive = #False
        EndIf
      EndWith
    Next n
  Next l2
  
EndProcedure

Procedure removeAChannelSync(pAudPtr, nChannel.l, nSync.l, bLogErrors=#True)
  PROCNAMECA(pAudPtr)
  Protected nBassResult.l
  Protected nBassErrorCode.l
  Protected bSyncRemoved
  
  ; debugMsg3(sProcName, #SCS_START + ", nChannel=" + decodeHandle(nChannel) + ", nSync=" + decodeHandle(nSync))
  
  ; debugMsg(sProcName, "gbUseBASSMixer=" + strB(gbUseBASSMixer) + ", #c_use_BassChannelSetSync_not_BassMixerChannelSetSync=" + strB(#c_use_BassChannelSetSync_not_BassMixerChannelSetSync))
  If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False)
    If nChannel <> 0
      nBassResult = BASS_Mixer_ChannelRemoveSync(nChannel, nSync) ; nb using 'mixer'
      If nBassResult = #BASSTRUE
        ; only log valid removals because for looped cues the procedure is called for both \nSourceChannel and \nSourceAltChannel, so one of them WILL fail
        debugMsg2(sProcName, "BASS_Mixer_ChannelRemoveSync(" + decodeHandle(nChannel) + ", " + decodeHandle(nSync) + ")", nBassResult)
        bSyncRemoved = #True
      Else
        nBassResult = BASS_ChannelRemoveSync(nChannel, nSync) ; nb NOT using 'mixer'
        If nBassResult = #BASSTRUE
          ; only log valid removals because for looped cues the procedure is called for both \nSourceChannel and \nSourceAltChannel, so one of them WILL fail
          debugMsg2(sProcName, "BASS_ChannelRemoveSync(" + decodeHandle(nChannel) + ", " + decodeHandle(nSync) + ")", nBassResult)
          bSyncRemoved = #True
        ElseIf bLogErrors
          debugMsg2(sProcName, "BASS_ChannelRemoveSync(" + decodeHandle(nChannel) + ", " + decodeHandle(nSync) + ")", nBassResult)
          debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
        EndIf
      EndIf
    EndIf
  Else
    If nChannel <> 0
      nBassResult = BASS_ChannelRemoveSync(nChannel, nSync)
      If nBassResult = #BASSTRUE
        ; only log valid removals because for looped cues the procedure is called for both \nSourceChannel and \nSourceAltChannel, so one of them WILL fail
        debugMsg2(sProcName, "BASS_ChannelRemoveSync(" + decodeHandle(nChannel) + ", " + decodeHandle(nSync) + ")", nBassResult)
        bSyncRemoved = #True
      ElseIf bLogErrors
        debugMsg2(sProcName, "BASS_ChannelRemoveSync(" + decodeHandle(nChannel) + ", " + decodeHandle(nSync) + ")", nBassResult)
        nBassErrorCode = BASS_ErrorGetCode()
        debugMsg3(sProcName, "error: " + getBassErrorDesc(nBassErrorCode))
      EndIf
    EndIf
  EndIf
  
  ; debugMsg(sProcName, #SCS_END + ", returning bSyncRemoved=" + strB(bSyncRemoved))
  ProcedureReturn bSyncRemoved
  
EndProcedure

Procedure removeAudChannelPlayEndSyncs(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected d
  Protected nChannel.l, nAltChannel.l
  Protected bSyncRemoved
  
  debugMsg(sProcName, #SCS_START)
  
  CheckSubInRange(pAudPtr, ArraySize(aAud()), "aAud()")
  With aAud(pAudPtr)
    d = \nFirstSoundingDev
    If d >= 0
      If \bUsingSplitStream
        ; debugMsg(sProcName, "\nBassChannel[" + d + "]=" + decodeHandle(\nBassChannel[d]) + ", \nBassPlayEndSync=" + decodeHandle(\nBassPlayEndSync) + ", \nBassChannelEndSync=" + decodeHandle(\nBassChannelEndSync))
        nChannel = \nBassChannel[d]
        nAltChannel = \nBassAltChannel[d]
      Else
        ; debugMsg(sProcName, "\nSourceChannel=" + decodeHandle(\nSourceChannel) + ", \nBassPlayEndSync=" + decodeHandle(\nBassPlayEndSync) + ", \nBassChannelEndSync=" + decodeHandle(\nBassChannelEndSync))
        nChannel = \nSourceChannel
        nAltChannel = \nSourceAltChannel
      EndIf
      
      If \nBassPlayEndSync <> 0
        bSyncRemoved = removeAChannelSync(pAudPtr, nChannel, \nBassPlayEndSync, #False)
        If bSyncRemoved = #False
          removeAChannelSync(pAudPtr, nAltChannel, \nBassPlayEndSync)
        EndIf
        ; clear anyway as both may have failed if the stream has been freed
        \nBassPlayEndSync = 0
      EndIf
      
      If \nBassAltPlayEndSync <> 0
        bSyncRemoved = removeAChannelSync(pAudPtr, nAltChannel, \nBassAltPlayEndSync, #False)
        If bSyncRemoved = #False
          removeAChannelSync(pAudPtr, nChannel, \nBassAltPlayEndSync)
        EndIf
        ; clear anyway as both may have failed if the stream has been freed
        \nBassAltPlayEndSync = 0
      EndIf
      
      If \nBassChannelEndSync <> 0
        bSyncRemoved = removeAChannelSync(pAudPtr, nChannel, \nBassChannelEndSync, #False)
        If bSyncRemoved = #False
          removeAChannelSync(pAudPtr, nAltChannel, \nBassChannelEndSync)
        EndIf
        ; clear anyway as both may have failed if the stream has been freed
        \nBassChannelEndSync = 0
      EndIf
      
      If \nBassAltChannelEndSync <> 0
        bSyncRemoved = removeAChannelSync(pAudPtr, nAltChannel, \nBassAltChannelEndSync, #False)
        If bSyncRemoved = #False
          removeAChannelSync(pAudPtr, nChannel, \nBassAltChannelEndSync)
        EndIf
        ; clear anyway as both may have failed if the stream has been freed
        \nBassAltChannelEndSync = 0
      EndIf
      
    EndIf ; EndIf d >= 0
    
  EndWith
EndProcedure

Procedure removeAudChannelMarkerSyncs(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nCueMarkerIndex
  
  debugMsg(sProcName, #SCS_START)
  
  CheckSubInRange(pAudPtr, ArraySize(aAud()), "aAud()")
  For nCueMarkerIndex = 0 To aAud(pAudPtr)\nMaxCueMarker
    With aAud(pAudPtr)\aCueMarker(nCueMarkerIndex)
      If \nBassMarkerSync <> 0
        removeAChannelSync(pAudPtr, \nBassMarkerSyncChannel, \nBassMarkerSync, #False)
        \nBassMarkerSync = 0
      EndIf
      If \nBassMarkerAltSync <> 0
        removeAChannelSync(pAudPtr, \nBassMarkerAltSyncChannel, \nBassMarkerAltSync, #False)
        \nBassMarkerAltSync = 0
      EndIf
    EndWith
  Next nCueMarkerIndex

EndProcedure

Procedure removeLinksOneAud(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected d, k, nBassResult.l
  Protected bCloseThisAud, bSubComplete

  debugMsg(sProcName, #SCS_START)
  
  With aAud(pAudPtr)
    ; added 14Dec2019 11.8.2af following bug report from Harriet Hardie
    If aSub(\nSubIndex)\nSubState = #SCS_CUE_COMPLETED
      bSubComplete = #True
    EndIf
    ; end added 14Dec2019 11.8.2af
    debugMsg(sProcName, "\nAudLinkCount=" + \nAudLinkCount + ", \nFirstAudLink=" + getAudLabel(\nFirstAudLink) + ", gnLastAud=" + getAudLabel(gnLastAud) +
                        ", aSub(" + getSubLabel(\nSubIndex) + ")\nSubState=" + decodeCueState(aSub(\nSubIndex)\nSubState))
    If \nAudLinkCount > 0
      For k = \nFirstAudLink To gnLastAud
        If aAud(k)\bExists
          If aAud(k)\nLinkedToAudPtr = pAudPtr
            bCloseThisAud = #False
            For d = aAud(k)\nFirstSoundingDev To aAud(k)\nLastSoundingDev
              If aAud(k)\nBassChannel[d] <> 0
                nBassResult = BASS_ChannelRemoveLink(\nBassChannel[\nFirstSoundingDev], aAud(k)\nBassChannel[d])
                debugMsg2(sProcName, "BASS_ChannelRemoveLink(" + decodeHandle(\nBassChannel[\nFirstSoundingDev]) + ", " + decodeHandle(aAud(k)\nBassChannel[d]) + ")", nBassResult)
                If nBassResult = #BASSFALSE
                  debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                EndIf                  
                debugMsg(sProcName, "RemoveLink d=" + d + ", nBassResult=" + nBassResult)
                bCloseThisAud = #True
              EndIf
            Next d
            ; 11/12/2013 (11.2.6f) commented out - see line added later in this procedure re bCallClearLinksForCue
            ; aAud(k)\nLinkedToAudPtr = grAudDef\nLinkedToAudPtr
            ; debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nLinkedToAudPtr=" + getAudLabel(aAud(k)\nLinkedToAudPtr))
            If bCloseThisAud
              debugMsg(sProcName, "calling closeAud(" + getAudLabel(k) + ", #False, " + strB(bSubComplete) + ")")
              closeAud(k, #False, bSubComplete) ; modified 14Dec2019 11.8.2af to include bSubComplete - see comments near start of this procedure
              debugMsg(sProcName, "calling setCueState(" + getCueLabel(aAud(k)\nCueIndex) + ")")
              setCueState(aAud(k)\nCueIndex)
            EndIf
          EndIf
        EndIf
      Next k
    EndIf
    ; 11/12/2013 (11.2.6f) added the following variable and line
    aCue(\nCueIndex)\bCallClearLinksForCue = #True
    debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\bCallClearLinksForCue=" + strB(aCue(\nCueIndex)\bCallClearLinksForCue))
  EndWith
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure reposAuds(pPrimaryAudPtr, pAbsReposAt, bManualChange=#False, bResyncOtherCues=#False, nVidPicTarget=#SCS_VID_PIC_TARGET_NONE, bTrace=#False)
  PROCNAMECA(pPrimaryAudPtr)
  Protected h, n, nTmpAudPtr, bChangedToReady
  Protected nPlayingPos, nChangeInPos, nBassChannel.l
  Protected nCuePtr
  Protected qTimeCueStarted.q, qTimeAudStarted.q
  Protected bTimeCueStartedSet
  Protected qTimeNow.q
  Protected i, j, k, nReqdPos
  Protected bWantThisCue, bWantThisAud
  Protected bProcessThisSub
  Protected nPrimarySubPtr
  Protected nReqdMTCPos
  Protected nFileFormat
  Protected bHoldIgnoreInStatusCheck
  Protected nBassResult.l, nErrorCode.l
  ; Protected bAsioLockedByThisProc

  If gbInReposAuds
    ProcedureReturn
  EndIf
  gbInReposAuds = #True
  
  debugMsgC(sProcName, #SCS_START + ", pAbsReposAt=" + pAbsReposAt + ", bManualChange=" + strB(bManualChange) + ", bResyncOtherCues=" + strB(bResyncOtherCues) + ", nVidPicTarget=" + decodeVidPicTarget(nVidPicTarget))
  gnLabelReposAuds = 1000
  
  If pPrimaryAudPtr < 0
    ; shouldn't happen
    gbInReposAuds = #False
    ProcedureReturn
  EndIf
  
  ; debugMsgC(sProcName, "calling listCueStates")
  ; listCueStates()
  
  bHoldIgnoreInStatusCheck = aAud(pPrimaryAudPtr)\bIgnoreInStatusCheck
  aAud(pPrimaryAudPtr)\bIgnoreInStatusCheck = #True
  ; debugMsg(sProcName, "aAud(" + getAudLabel(pPrimaryAudPtr) + ")\bIgnoreInStatusCheck=" + strB(aAud(pPrimaryAudPtr)\bIgnoreInStatusCheck))
  THR_waitForCueStatusChecksToEnd()
  
  With aAud(pPrimaryAudPtr)
    nPrimarySubPtr = \nSubIndex
    nFileFormat = \nFileFormat
    
    If bResyncOtherCues
      qTimeNow = ElapsedMilliseconds()
      
      qTimeAudStarted = \qTimeAudStarted
      If (\nAudState >= #SCS_CUE_FADING_IN) And (qTimeAudStarted <> 0)
        nPlayingPos = qTimeNow - qTimeAudStarted + \nManualOffset
      Else
        nPlayingPos = \nCuePos
      EndIf
      ; nChangeInPos = pAbsReposAt - nPlayingPos
      ; fix 27Dec2018 11.8.0cm following bug report from Vellema Monitor on 4Dec2018 "when cue 7 is playing and I click in the cue-panel on the waveform to skip some time, the next sub-cue is (7 <2>) is completed immediately"
      ; needed to include "- \nAbsMin" in the claculation of nChangeInPos
      nChangeInPos = pAbsReposAt - \nAbsMin - nPlayingPos
      debugMsgC(sProcName, "aAud(" + getAudLabel(pPrimaryAudPtr) + ")\nAudState=" + decodeCueState(\nAudState) +
                          ", qTimeAudStarted=" + traceTime(qTimeAudStarted) + ", \nAbsMin=" + \nAbsMin + ", nPlayingPos=" + nPlayingPos +
                          ", nChangeInPos=" + nChangeInPos + ", aAud(" + getAudLabel(pPrimaryAudPtr) + ")\nManualOffset=" + Str(\nManualOffset))
      
      nCuePtr = \nCueIndex
      qTimeCueStarted = aCue(nCuePtr)\qTimeCueStarted
      bTimeCueStartedSet = aCue(nCuePtr)\bTimeCueStartedSet
      If (aCue(nCuePtr)\nCueState >= #SCS_CUE_FADING_IN) And (bTimeCueStartedSet)
        nChangeInPos + (\qTimeAudStarted - qTimeCueStarted)
      EndIf
      \nManualOffset + nChangeInPos
      debugMsgC(sProcName, "aAud(" + getAudLabel(pPrimaryAudPtr) + ")\nManualOffset=" + \nManualOffset)
      ; If \nManualOffset < 0
        ; \nManualOffset = 0
      ; EndIf
      debugMsgC(sProcName, "aCue(" + getCueLabel(nCuePtr) + ")\nCueState=" + decodeCueState(aCue(nCuePtr)\nCueState) +
                          ", qTimeCueStarted=" + traceTime(qTimeCueStarted) + ", nChangeInPos=" + Str(nChangeInPos) +
                          ", aAud(" + getAudLabel(pPrimaryAudPtr) + ")\nManualOffset=" + \nManualOffset)
      
    EndIf
  EndWith
  
  If nFileFormat = #SCS_FILEFORMAT_AUDIO ; Or nFileFormat = #SCS_FILEFORMAT_VIDEO
    ; #SCS_FILEFORMAT_VIDEO removed 25Apr2024 11.10.2cf as cue markers in video cues are now handled exclusively by eventTVGOnFrameProgress2() and MarkerTVGSyncProc()
    If aAud(pPrimaryAudPtr)\nMaxCueMarker >= 0 ; Test added 13Jan2025 11.10.6-b03
      debugMsgC(sProcName, "calling setNextCueMarker(" + getAudLabel(pPrimaryAudPtr) + ", " + pAbsReposAt + ")")
      setNextCueMarker(pPrimaryAudPtr, pAbsReposAt)
      debugMsg(sProcName, "calling loadOCMCuesAfterAudPos(" + getAudLabel(pPrimaryAudPtr) + ", " + pAbsReposAt + ")") ; Added 13Jan2025 11.10.6-b03
      loadOCMCuesAfterAudPos(pPrimaryAudPtr, pAbsReposAt) ; Added 13Jan2025 11.10.6-b03
    EndIf
  EndIf
  
  ; added 14Feb2017 11.6.0
  ; added gqIgnoreCalcPosUntilTime because it was found there was some latency(?) delay in BASS after actually setting the new channel position
  ; and that new position being detected correctly by GetPlayingPos() and therefore also by calcCuePositionForAud().
  ; this new global variable (gqIgnoreCalcPosUntilTime) is used to bypass calcCuePositionForAud() until a reasonable time after reposAuds().
  ; don't know if there's a way to actually determine what that latency is, so currently have just set this delay to 500ms
  ; gqIgnoreCalcPosUntilTime = ElapsedMilliseconds() + 500
  ; 9Aug2021 11.8.5rc2a - changed from 500ms to 50ms, and then only if fade in time >= 100ms
  If aAud(pPrimaryAudPtr)\nFadeInTime >= 100
    gqIgnoreCalcPosUntilTime = ElapsedMilliseconds() + 50
  EndIf
  ; end changed 9Aug2021 11.8.5rc2a
  debugMsgC(sProcName, "gqIgnoreCalcPosUntilTime=" + traceTime(gqIgnoreCalcPosUntilTime))
  ; end added 14Feb2017 11.6.0
  
  debugMsgC(sProcName, "aAud(" + getAudLabel(pPrimaryAudPtr) + ")\nAudLinkCount=" + aAud(pPrimaryAudPtr)\nAudLinkCount)
  
  CompilerIf #c_enable_bass_asio_lock
    lockBassAsioIfReqd()
  CompilerEndIf
  
  For h = 0 To aAud(pPrimaryAudPtr)\nMaxAudSetPtr2
    gnLabelReposAuds = 2000 + h
    CheckSubInRange(pPrimaryAudPtr, ArraySize(gaAudSet(),1), "ArraySize(gaAudSet(),1)")
    CheckSubInRange(h, ArraySize(gaAudSet(),2), "ArraySize(gaAudSet(),2)")
    nTmpAudPtr = gaAudSet(pPrimaryAudPtr, h)
    If nTmpAudPtr > 0
      debugMsg(sProcName, "calling setAudChannelPositions(" + getAudLabel(nTmpAudPtr) + ", " + ttszt(pAbsReposAt) + ", " + strB(bManualChange) + ", -2, -2, " + decodeVidPicTarget(nVidPicTarget) + ")")
      setAudChannelPositions(nTmpAudPtr, pAbsReposAt, bManualChange, -2, -2, nVidPicTarget, bTrace)
    EndIf
  Next h
  
  CompilerIf #c_enable_bass_asio_lock
    unlockBassAsioIfReqd()
  CompilerEndIf
  
  For h = 0 To aAud(pPrimaryAudPtr)\nMaxAudSetPtr2
    gnLabelReposAuds = 3000 + h
    nTmpAudPtr = gaAudSet(pPrimaryAudPtr, h)
    If nTmpAudPtr > 0
      With aAud(nTmpAudPtr)
        \bMediaStarted = #False
        \bMediaEnded = #False
        \nRelFilePos = pAbsReposAt - \nAbsMin
        CompilerIf #cTraceRelFilePos
          debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nRelFilePos=" + ttszt(aAud(nTmpAudPtr)\nRelFilePos))
        CompilerEndIf
        \nCuePos = \nRelFilePos
        debugMsgC(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nRelFilePos=" + \nRelFilePos + ", \nRelPassStart=" + \nRelPassStart + ", \nCuePos=" + \nCuePos)
        sendRAICueSetPosIfReqd(nTmpAudPtr)
        FMP_sendCommandIfReqd(#SCS_OSCINP_CUE_SET_POS, \nCueIndex, nTmpAudPtr)
        loadLvlPtRun(nTmpAudPtr, \nCuePos, #False, bTrace)
        If (\nAudState < #SCS_CUE_FADING_IN) Or (\nAudState > #SCS_CUE_FADING_OUT)
          \bCheckProgSlider = #True
        Else
          \bCheckProgSlider = #False
          debugMsgC(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\bCheckProgSlider=" + strB(\bCheckProgSlider))
        EndIf
        \qTimeAudRestarted = gqTimeNow - (\nRelFilePos - \nRelPassStart)
        debugMsgC(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\qTimeAudRestarted=" + traceTime(aAud(nTmpAudPtr)\qTimeAudRestarted) + ", \bCheckProgSlider=" + strB(\bCheckProgSlider))
        \nTotalTimeOnPause = 0
        ; debugMsgC(sProcName, "nTmpAudPtr=" + Str(nTmpAudPtr) + ", \qTimeRestarted=" + traceTime(\qTimeRestarted))
        If \nAudState = #SCS_CUE_FADING_OUT
          If \nRelFilePos < (\nRelEndAt - \nFadeOutTime)
            \nAudState = #SCS_CUE_PLAYING
            setCueState(\nCueIndex)
            \nCurrFadeOutTime = \nFadeOutTime
            debugMsgC(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nCurrFadeOutTime=" + \nCurrFadeOutTime)
          EndIf
        EndIf
        If (\nAudState = #SCS_CUE_PLAYING) And (\nFadeInTime > 0)
          If \nRelFilePos < \nFadeInTime
            If \bAudTypeF
              \nAudState = #SCS_CUE_FADING_IN
            ElseIf (\bAudTypeAorP) And (\nPrevPlayIndex >= 0)
              \nAudState = #SCS_CUE_TRANS_FADING_IN
            EndIf
            setCueState(\nCueIndex)
          EndIf
        EndIf
        If \nAudState = #SCS_CUE_PAUSED
          \nPriorTimeOnPause = 0
          \qTimePauseStarted = gqTimeNow
          If (\nRelFilePos = \nRelStartAt) And (\nPrevPlayIndex = -1)
            audSetState(nTmpAudPtr, #SCS_CUE_READY, 7)
            setCueState(\nCueIndex)
            bChangedToReady = #True
          EndIf
        EndIf
        
        debugMsgC(sProcName, "calling resetAudStateForPos(" + getAudLabel(nTmpAudPtr) + ", " + \nCuePos + ")")
        resetAudStateForPos(nTmpAudPtr, \nCuePos, bTrace)
        
        debugMsgC(sProcName, "calling loadCurrLoopInfo(" + getAudLabel(nTmpAudPtr) + ", " + \nCuePos + ", #True)")
        loadCurrLoopInfo(nTmpAudPtr, \nCuePos, #True, bTrace)
        
        debugMsgC(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nMaxLoopInfo=" + \nMaxLoopInfo + ", \nCuePos=" + \nCuePos +
                            ", \nRelFilePos=" + \nRelFilePos + ", \rCurrLoopInfo\nRelLoopEnd=" + \rCurrLoopInfo\nRelLoopEnd + ", \nRelEndAt=" + \nRelEndAt + ", \bLoopReleased=" + strB(\rCurrLoopInfo\bLoopReleased))
        If \nMaxLoopInfo >= 0 ; \bContainsLoop
          If (\nRelFilePos >= \rCurrLoopInfo\nRelLoopEnd) And (\nRelFilePos < \nRelEndAt)
            \rCurrLoopInfo\bLoopReleased = #True
            \nRelPassEnd = \nRelEndAt
            debugMsgC(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\rCurrLoopInfo\bLoopReleased=" + strB(\rCurrLoopInfo\bLoopReleased) + ", \nRelPassEnd=" + \nRelPassEnd)
          EndIf
        EndIf
        
        If aSub(aAud(nTmpAudPtr)\nSubIndex)\bStartedInEditor
          If nTmpAudPtr = nEditAudPtr
            If \bAudTypeA
              If SLD_getValue(WQA\sldProgress[0]) <> \nRelFilePos
                SLD_setValue(WQA\sldProgress[0], \nRelFilePos)
                If IsGadget(WQA\cvsGraphQA)
                  drawPosSlice(@grMG5)
                EndIf
              EndIf
            ElseIf \bAudTypeF
              gnLabelReposAuds = 3100+h
              If SLD_getValue(WQF\sldProgress) <> \nRelFilePos
                gnLabelReposAuds = 3200+h
                ; debugMsgC(sProcName, "calling SLD_setValue(WQF\sldProgress, " + \nRelFilePos + ")")
                SLD_setValue(WQF\sldProgress, \nRelFilePos)
                gnLabelReposAuds = 3300+h
                drawPosSlice(@grMG2)
                gnLabelReposAuds = 3400+h
              EndIf
            EndIf
          EndIf
        Else
          gnLabelReposAuds = 4000+h
          For n = 0 To gnMaxDispPanel
            If gaDispPanel(n)\nDPAudPtr = nTmpAudPtr
              gnLabelReposAuds = 4300+h
              debugMsgC(sProcName, "calling PNL_setDisplayButtons()")
              PNL_setDisplayButtons(n, \nAudState, \nLinkedToAudPtr)
              gnLabelReposAuds = 4400+h
              If bChangedToReady
                debugMsgC(sProcName, "bChangedToReady=" + strB(bChangedToReady))
                If \bAudTypeAorF
                  If \nFadeOutTime > 0
                    gaDispPanel(n)\bEnableFadeOut = #True
                  EndIf
                  If (\bAudTypeF) And (\nMaxLoopInfo >= 0) And (\rCurrLoopInfo\bLoopReleased = #False Or \nCurrLoopInfoIndex < \nMaxLoopInfo) ; Added nCurrLoopInfoIndex test 6Jan2024 11.10.0
                    gaDispPanel(n)\bEnableRelease = #True
                    debugMsgC(sProcName, "gaDispPanel(" + n + ")\bEnableRelease=" + strB(gaDispPanel(n)\bEnableRelease))
                  EndIf
                ElseIf \bAudTypeP
                  If aSub(\nSubIndex)\nPLFadeOutTime > 0
                    gaDispPanel(n)\bEnableFadeOut = #True
                  EndIf
                EndIf
                gqMainThreadRequest | #SCS_MTH_SET_CUE_TO_GO
                debugMsgC(sProcName, "gnLabelOther=" + gnLabelOther + ", gqMainThreadRequest | #SCS_MTH_SET_CUE_TO_GO")

              ElseIf (\bAudTypeF) And (\nMaxLoopInfo >= 0) And (\rCurrLoopInfo\bLoopReleased = #False)
                debugMsgC(sProcName, "\rCurrLoopInfo\nAbsLoopEnd - \rCurrLoopInfo\nLoopXFadeTime=" + Str(\rCurrLoopInfo\nAbsLoopEnd - \rCurrLoopInfo\nLoopXFadeTime))
                If pAbsReposAt < (\rCurrLoopInfo\nAbsLoopEnd - \rCurrLoopInfo\nLoopXFadeTime)
                  \rCurrLoopInfo\bLoopReleased = #False
                  \nLoopPassNo = grAudDef\nLoopPassNo
                  If \rCurrLoopInfo\nLoopSyncIndex >= 0
                    gaLoopSync(\rCurrLoopInfo\nLoopSyncIndex)\nLoopSyncPassNo = 1
                  EndIf
                  debugMsgC(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex + ", \nLoopPassNo=" + \nLoopPassNo + ", \rCurrLoopInfo\bLoopReleased=" + strB(\rCurrLoopInfo\bLoopReleased))
                  gaDispPanel(n)\bEnableRelease = #True
                ElseIf \nCurrLoopInfoIndex < \nMaxLoopInfo ; Added 6Jan2024 11.10.0
                  gaDispPanel(n)\bEnableRelease = #True
                  debugMsgC(sProcName, "gaDispPanel(" + n + ")\bEnableRelease=" + strB(gaDispPanel(n)\bEnableRelease))
                EndIf
              EndIf
            EndIf
          Next n
        EndIf
        aCue(\nCueIndex)\nCuePanelUpdateFlags | #SCS_CUEPNL_PROGRESS | #SCS_CUEPNL_TRANSPORT
        debugMsgC(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\nCuePanelUpdateFlags=" + Str(aCue(\nCueIndex)\nCuePanelUpdateFlags))
      EndWith
    EndIf
  Next h
  
  If (bResyncOtherCues) And (nChangeInPos <> 0)
    ; debugMsgC(sProcName, "calling listCueStates")
    ; listCueStates()
    ; Added 31Jan2025 11.10.6
    j = aCue(nCuePtr)\nFirstSubIndex
    While j >= 0
      If aSub(j)\bSubTypeU
        ; debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\nMTCLinkedToAFSubPtr=" + getSubLabel(aSub(j)\nMTCLinkedToAFSubPtr) + ", nPrimarySubPtr=" + getSubLabel(nPrimarySubPtr))
        If aSub(j)\nMTCLinkedToAFSubPtr = nPrimarySubPtr
          ; debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\nSubState=" + decodeCueState(aSub(j)\nSubState))
          If aSub(j)\nSubState = #SCS_CUE_PLAYING
            debugMsg(sProcName, "calling reposTimeCode(" + getSubLabel(j) + ", " + pAbsReposAt + ")")
            reposTimeCode(j, pAbsReposAt)
          EndIf
        EndIf
      EndIf
      j = aSub(j)\nNextSubIndex
    Wend
    ; End added 31Jan2025 11.10.6
    
    gnLabelReposAuds = 7000
    debugMsgC(sProcName, "resyncing other cues")
    For i = 1 To gnLastCue
      bWantThisCue = #False
      If i = nCuePtr
        bWantThisCue = #True  ; want to look for non-linked aud's in this cue
        
      ElseIf aCue(i)\nActivationMethodReqd = #SCS_ACMETH_AUTO
        If aCue(i)\nAutoActCuePtr = nCuePtr
          If aCue(i)\nAutoActPosn = #SCS_ACPOSN_AS
            bWantThisCue = #True  ; an auto-start cue based on the primary cue, and which is currently playing
          EndIf
        EndIf
      EndIf
      
      If bWantThisCue
        debugMsgC(sProcName, "i=" + getCueLabel(i) + ", bWantThisCue=" + strB(bWantThisCue) + ", \nCueState=" + decodeCueState(aCue(i)\nCueState))
        ; Only commented out the following because it's not yet ready - need to do more design work.
        ; See SCS Feature Requests forum topic 'Enhance "After start of cue" behavior'
        If aCue(i)\nCueState = #SCS_CUE_COUNTDOWN_TO_START
          aCue(i)\qTimeToStartCue - nChangeInPos
          If (aCue(i)\qTimeToStartCue - qTimeNow) < 0
            ; skip this cue
            debugMsgC(sProcName, "aCue(" + getCueLabel(i) + ")\qTimeToStart=" + traceTime(aCue(i)\qTimeToStartCue) + ", so skipping this cue (ie closing cue)")
            If aCue(i)\bNonLinearCue
              If (aCue(i)\nActivationMethod = #SCS_ACMETH_AUTO) Or (aCue(i)\nActivationMethod = #SCS_ACMETH_AUTO_PLUS_CONF)
                If aCue(i)\bAutoStartLocked = #False
                  ; debugMsgC(sProcName, "setting aCue(" + getCueLabel(i) + ")\bAutoStartLocked = #True")
                  aCue(i)\bAutoStartLocked = #True
                  debugMsgC(sProcName, "aCue(" + getCueLabel(i) + ")\bAutoStartLocked=" + strB(aCue(i)\bAutoStartLocked))
                EndIf
              EndIf
              closeCue(i, #True, #False)
              ; debugMsgC(sProcName, "calling debugCuePtrs()")
              ; debugCuePtrs()
            Else
              closeCue(i, #False, #True)
            EndIf
          Else
            debugMsgC(sProcName, "aCue(" + getCueLabel(i) + ")\qTimeToStartCue=" + traceTime(aCue(i)\qTimeToStartCue) + ", qTimeNow=" + traceTime(qTimeNow))
          EndIf
        Else
          j = aCue(i)\nFirstSubIndex
          While j >= 0
            If aSub(j)\bSubEnabled
              bProcessThisSub = #True
              If (i = nCuePtr) And (aSub(j)\nSubState = #SCS_CUE_SUB_COUNTDOWN_TO_START)
                debugMsgC(sProcName, "aSub(" + getSubLabel(j) + ")\qTimeToStartSub=" + traceTime(aSub(j)\qTimeToStartSub) + ", nChangeInPos=" + nChangeInPos + ", qTimeNow=" + traceTime(qTimeNow))
                aSub(j)\qTimeToStartSub - nChangeInPos
                debugMsgC(sProcName, "aSub(" + getSubLabel(j) + ")\qTimeToStartSub=" + traceTime(aSub(j)\qTimeToStartSub))
                If (aSub(j)\qTimeToStartSub - qTimeNow) < 0
                  ; skip this sub
                  debugMsgC(sProcName, "calling closeSub(" + getSubLabel(j) + ", #False, #True)")
                  closeSub(j, #False, #True)
                  bProcessThisSub = #False
                EndIf
              EndIf
              If (i = nCuePtr) And (aSub(j)\nSubState <= #SCS_CUE_READY)
                If aSub(j)\nRelStartMode = #SCS_RELSTART_AE_PREV_SUB
                  bProcessThisSub = #False
                EndIf
              EndIf
              If bProcessThisSub
                If aSub(j)\bSubTypeHasAuds
                  k = aSub(j)\nFirstPlayIndex
                  While k >= 0
                    bWantThisAud = #True
                    If k = pPrimaryAudPtr
                      bWantThisAud = #False
                    ElseIf aSub(j)\bSubTypeAorP
                      If k <> aSub(j)\nCurrPlayIndex
                        bWantThisAud = #False
                      EndIf
                    ElseIf aAud(k)\nLinkedToAudPtr = pPrimaryAudPtr
                      bWantThisAud = #False
                    EndIf
                    If bWantThisAud
                      aAud(k)\nManualOffset + nChangeInPos
                      debugMsgC(sProcName, "(**) aAud(" + getAudLabel(k) + ")\nManualOffset=" + Str(aAud(k)\nManualOffset))
                      debugMsgC(sProcName, "aAud(" + getAudLabel(k) + ")\nAudState=" + decodeCueState(aAud(k)\nAudState) + ", \nManualOffset=" + Str(aAud(k)\nManualOffset))
                      If (aAud(k)\nAudState >= #SCS_CUE_FADING_IN) And (aAud(k)\nAudState <= #SCS_CUE_FADING_OUT) And (aAud(k)\qTimeAudStarted > 0)
                        ; debugMsgC(sProcName, "a")
                        nReqdPos = qTimeNow - aAud(k)\qTimeAudStarted + aAud(k)\nManualOffset + aAud(k)\nAbsStartAt
                        debugMsgC(sProcName, "qTimeNow=" + traceTime(qTimeNow) + ", aAud(" + getAudLabel(k) + ")\qTimeAudStarted=" + traceTime(aAud(k)\qTimeAudStarted) + ", diff=" + Str(qTimeNow - aAud(k)\qTimeAudRestarted))
                      Else
                        ; debugMsgC(sProcName, "b")
                        nReqdPos = aAud(k)\nManualOffset + aAud(k)\nAbsStartAt
                      EndIf
                      debugMsgC(sProcName, "calling reposAuds(" + getAudLabel(k) + ", " + nReqdPos + ", " + strB(bManualChange) + ", #False)")
                      reposAuds(k, nReqdPos, bManualChange, #False) ; do not recurse the bResyncCues as this can cause a loop
                    EndIf
                    k = aAud(k)\nNextPlayIndex
                  Wend
                ElseIf aSub(j)\bSubTypeU ; Added 1Feb2025 11.10.6
                  debugMsg(sProcName, "calling reposTimeCode(" + getSubLabel(j) + ", " + pAbsReposAt + ")")
                  reposTimeCode(j, pAbsReposAt)
                EndIf
              EndIf
            EndIf
            j = aSub(j)\nNextSubIndex
          Wend
        EndIf
      EndIf
    Next i
  EndIf
  
  debugMsgC(sProcName, "pPrimaryAudPtr=" + getAudLabel(pPrimaryAudPtr) + ", nEditAudPtr=" + getAudLabel(nEditAudPtr) +
                      ", aAud(" + getAudLabel(pPrimaryAudPtr) + ")\nPlayFromPos=" + aAud(pPrimaryAudPtr)\nPlayFromPos)
  If pPrimaryAudPtr = nEditAudPtr
    If aAud(nEditAudPtr)\nPlayFromPos > 0
      If aAud(nEditAudPtr)\bAudTypeF
        If IsGadget(WQF\btnEditRewind)  ; check any relevant gadget to make sure the controls do exist
          editSetDisplayButtonsF()
        EndIf
      ElseIf aAud(nEditAudPtr)\bAudTypeA
        If IsGadget(WQA\btnPlay)
          WQA_SetTransportButtons()
        EndIf
      EndIf
    EndIf
  EndIf
  
  gnLabelReposAuds = 9999
  aAud(pPrimaryAudPtr)\bIgnoreInStatusCheck = bHoldIgnoreInStatusCheck
  gbInReposAuds = #False
  
  debugMsgC(sProcName, #SCS_END)
  
EndProcedure

Procedure adjustMasterFader(nDirection)
  PROCNAMEC()
  Protected fCurrDBLevel.f, fDBIncrement.f, fNewDBLevel.f, fNewLevel.f
  
  fCurrDBLevel = convertBVLevelToDBLevel(SLD_getLevel(WMN\sldMasterFader))
  fDBIncrement = ValF(grProd\sDBLevelChangeIncrement)
  fNewDBLevel = fCurrDBLevel + (fDBIncrement * nDirection)
  fNewLevel = convertDBLevelToBVLevel(fNewDBLevel)
  If fNewLevel <= grLevels\fMinBVLevel
    fNewLevel = #SCS_MINVOLUME_SINGLE ; grLevels\fMinBVLevel ; Changed 15Nov2023 11.10.0-b02
  ElseIf fNewLevel > grLevels\fMaxBVLevel
    fNewLevel = grLevels\fMaxBVLevel
  EndIf
  SLD_setLevel(WMN\sldMasterFader, fNewLevel)
  setMasterFader(fNewLevel)

EndProcedure

Procedure muteMasterFader()
  PROCNAMEC()
  Protected fBVLevel.f

  ; debugMsg(sProcName, #SCS_START)
  
  With grMMedia
    ; debugMsg(sProcName, "SLD_getLevel(WMN\sldMasterFader)=" + convertBVLevelToDBString(SLD_getLevel(WMN\sldMasterFader)) + ", \bMastFaderMuted=" + strB(\bMastFaderMuted))
    If \bMastFaderMuted = #False
      debugMsg(sProcName, "mute master fader")
      \fMastFaderSliderLevelBeforeMute = SLD_getLevel(WMN\sldMasterFader)
      SLD_setLevel(WMN\sldMasterFader, #SCS_MINVOLUME_SINGLE)
      \bMastFaderMuted = #True
    Else
      debugMsg(sProcName, "reset master fader to " + formatLevel(\fMastFaderSliderLevelBeforeMute))
      SLD_setLevel(WMN\sldMasterFader, \fMastFaderSliderLevelBeforeMute)
      \bMastFaderMuted = #False
    EndIf
    fBVLevel = SLD_getLevel(WMN\sldMasterFader)
    setMasterFader(fBVLevel)
  EndWith
  
EndProcedure

Procedure resetMasterFader()
  PROCNAMEC()
  Protected fBVLevel.f

  fBVLevel = SLD_getBaseLevel(WMN\sldMasterFader)
  SLD_setLevel(WMN\sldMasterFader, fBVLevel)
  setMasterFader(fBVLevel)

EndProcedure

Procedure restartAud(pAudPtr, bCalledFromEditLvlChg=#False)
  PROCNAMECA(pAudPtr)

  debugMsg(sProcName, #SCS_START + ", nAudState=" + decodeCueState(aAud(pAudPtr)\nAudState))

  debugMsg(sProcName, "calling rewindAud(" + getAudLabel(pAudPtr) + ")")
  rewindAud(pAudPtr)
  
  With aAud(pAudPtr)
    If (\nAudState >= #SCS_CUE_FADING_IN) And (\nAudState <= #SCS_CUE_FADING_OUT) And (\nAudState <> #SCS_CUE_PAUSED)
      playAudChannels(pAudPtr, #False, -1, bCalledFromEditLvlChg)
    EndIf
  EndWith
  
  If gbUseBASSMixer = #False
    samAddRequest(#SCS_SAM_BUILD_DEV_CHANNEL_LIST)
  EndIf
EndProcedure

Procedure resumeAud(pAudPtr, bFadeIn=#False)
  PROCNAMECA(pAudPtr)
  Protected d, h, nTmpAudPtr, nTimeToGo, nFadeInPosition
  Protected nBassResult.l
  Protected bSyncResumeIssued
  Protected nTmpAudState
  Protected nTmpSubPtr, j, nMTCSubPtr, bCallResumeAudChannelsNow, bCallResumeAudChannelsLater
  Protected qTimeNow.q
  Protected bAddTmpAudPtrToFadeAudArray
  Protected sMsg.s
  Protected bCallResumeAudChannels
  
  debugMsg(sProcName, #SCS_START + ", bFadeIn=" + strB(bFadeIn))
  logKeyEvent("Resume Aud " + getAudLabel(pAudPtr))
  
  setGlobalTimeNow()
  
  If gbUseSMS
    With aAud(pAudPtr)
      Select \nFileFormat
        Case #SCS_FILEFORMAT_AUDIO
          If \bSyncPChanListPlaying
            If \sSyncPChanList
              sendSMSCommand("resume " + \sSyncPChanList)
              bSyncResumeIssued = #True
            EndIf
          EndIf
        Case #SCS_FILEFORMAT_LIVE_INPUT
          If \sSyncXChanList
            sendSMSCommand("set chan " + \sSyncXChanList + " mute off")
            bSyncResumeIssued = #True
          EndIf
      EndSelect
    EndWith
  EndIf
  
  bCallResumeAudChannelsLater = #True
  ; debugMsg0(sProcName, "bCallResumeAudChannelsNow=" + strB(bCallResumeAudChannelsNow) + ", bCallResumeAudChannelsLater=" + strB(bCallResumeAudChannelsLater))
  
  ; debugMsg0(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nAudLinkCount=" + aAud(pAudPtr)\nAudLinkCount)
  For h = 0 To aAud(pAudPtr)\nMaxAudSetPtr2
    nTmpAudPtr = gaAudSet(pAudPtr, h)
    ; debugMsg0(sProcName, "nTmpAudPtr=" + getAudLabel(nTmpAudPtr))
    If nTmpAudPtr > 0
      bCallResumeAudChannelsNow = #False
      bCallResumeAudChannelsLater = #True
      ; debugMsg0(sProcName, "bCallResumeAudChannelsNow=" + strB(bCallResumeAudChannelsNow) + ", bCallResumeAudChannelsLater=" + strB(bCallResumeAudChannelsLater))
      nTmpSubPtr = aAud(nTmpAudPtr)\nSubIndex
      bAddTmpAudPtrToFadeAudArray = #False
      With aAud(nTmpAudPtr)
        qTimeNow = ElapsedMilliseconds()
        debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nAudState=" + decodeCueState(\nAudState))
        nTmpAudState = \nAudState
        
        If (nTmpAudState >= #SCS_CUE_COMPLETED) Or (nTmpAudState < #SCS_CUE_READY)
          sMsg = LangPars("Errors", "CannotResume", getAudLabel(nTmpAudPtr), decodeCueStateL(nTmpAudState))
          WMN_displayWarningMsg(sMsg)
          Continue
        EndIf
        
        If nTmpAudState = #SCS_CUE_COUNTDOWN_TO_START
          If aCue(\nCueIndex)\bCueCountDownPaused
            resetCueTimeToStart(\nCueIndex)
            aCue(\nCueIndex)\bCueCountDownPaused = #False
          EndIf
          Continue  ; skip remainder of processing for this aAud()
          
        ElseIf nTmpAudState = #SCS_CUE_SUB_COUNTDOWN_TO_START
          If aSub(\nSubIndex)\bSubCountDownPaused
            resetSubTimeToStart(\nSubIndex)
            aSub(\nSubIndex)\bSubCountDownPaused = #False
          EndIf
          Continue  ; skip remainder of processing for this aAud()
          
        ElseIf (nTmpAudState = #SCS_CUE_FADING_IN) Or ((nTmpAudState = #SCS_CUE_PAUSED) And (\nPrepauseAudState = #SCS_CUE_FADING_IN))
          If \bTimeFadeInStartedSet
            nFadeInPosition = (qTimeNow - \qTimeFadeInStarted) - (\nTotalTimeOnPause - \nPreFadeInTimeOnPause)
          Else
            nFadeInPosition = (0) - (\nTotalTimeOnPause - \nPreFadeInTimeOnPause)
          EndIf
          nTimeToGo = \nCurrFadeInTime - nFadeInPosition
          
        ElseIf nTmpAudState = #SCS_CUE_HIBERNATING
          If \bAudTypeAorP
            debugMsg(sProcName, "aSub(" + getSubLabel(\nSubIndex) + ")\nPLCurrFadeInTime=" + aSub(\nSubIndex)\nPLCurrFadeInTime)
            If aSub(\nSubIndex)\nPLCurrFadeInTime > 0
              \nPrepauseAudState = #SCS_CUE_FADING_IN
              nTimeToGo = aSub(\nSubIndex)\nPLCurrFadeInTime
              \qTimeFadeInStarted = qTimeNow
              \nCuePosAtFadeStart = \nCuePos
              debugMsg(sProcName, "\qTimeFadeInStarted=" + traceTime(\qTimeFadeInStarted) + ", \nCuePosAtFadeStart=" + \nCuePosAtFadeStart)
              \bTimeFadeInStartedSet = #True
              \nPreFadeInTimeOnPause = \nTotalTimeOnPause
              CompilerIf #c_include_tvg
                If grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG
;                   debugMsg(sProcName, "calling addAudToTVGFadeAudArray(" + getAudLabel(nTmpAudPtr) + ")")
;                   addAudToTVGFadeAudArray(nTmpAudPtr)
                  bAddTmpAudPtrToFadeAudArray = #True
                EndIf
              CompilerEndIf
            Else
              \nPrepauseAudState = #SCS_CUE_PLAYING
            EndIf
          ElseIf \nCurrFadeInTime > 0
            \nPrepauseAudState = #SCS_CUE_FADING_IN
            nTimeToGo = \nCurrFadeInTime
            \qTimeFadeInStarted = qTimeNow
            \bTimeFadeInStartedSet = #True
            \nCuePosAtFadeStart = \nCuePos
            debugMsg(sProcName, "\qTimeFadeInStarted=" + traceTime(\qTimeFadeInStarted) + ", \nCuePosAtFadeStart=" + \nCuePosAtFadeStart)
            \nPreFadeInTimeOnPause = \nTotalTimeOnPause
            CompilerIf #c_include_tvg
              If grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG
;                 debugMsg(sProcName, "calling addAudToTVGFadeAudArray(" + getAudLabel(nTmpAudPtr) + ")")
;                 addAudToTVGFadeAudArray(nTmpAudPtr)
                bAddTmpAudPtrToFadeAudArray = #True
              EndIf
            CompilerEndIf
          Else
            \nPrepauseAudState = #SCS_CUE_PLAYING
          EndIf
          
          ; added 29Oct2015 11.4.1.2d following test of David Lambert's hibernate of video, followed by resume of haibernated video where the
          ; video was set to repeat. the 'repeat' failed because \nMovieAudPtr and \nMovieNo had not been reset by the resume
          If \bAudTypeA
            If aSub(\nSubIndex)\bStartedInEditor = #False
              Select \nAudVidPicTarget
                Case #SCS_VID_PIC_TARGET_F2 To #SCS_VID_PIC_TARGET_LAST
                  grVidPicTarget(\nAudVidPicTarget)\nMovieAudPtr = nTmpAudPtr
                  grVidPicTarget(\nAudVidPicTarget)\sMovieFileName = \sFileName
                  grVidPicTarget(\nAudVidPicTarget)\nMovieNo = \nMainVideoNo
                  debugMsg(sProcName, "grVidPicTarget(" + decodeVidPicTarget(\nAudVidPicTarget) + ")\nMovieAudPtr=" + getAudLabel(grVidPicTarget(\nAudVidPicTarget)\nMovieAudPtr) +
                                      ", \sMovieFileName=" + grVidPicTarget(\nAudVidPicTarget)\sMovieFileName +
                                      ", \nMovieNo=" + grVidPicTarget(\nAudVidPicTarget)\nMovieNo)
              EndSelect
            EndIf
          EndIf
          ; end of added 29Oct2015 11.4.1.2d
          
        EndIf
        
        If bFadeIn
          For d = aAud(nTmpAudPtr)\nFirstSoundingDev To aAud(nTmpAudPtr)\nLastSoundingDev
            If aAud(nTmpAudPtr)\sLogicalDev[d]
              setLevelsAny(nTmpAudPtr, d, #SCS_MINVOLUME_SINGLE, #SCS_NOPANCHANGE_SINGLE)
            EndIf
          Next d
        EndIf
        
        If bSyncResumeIssued = #False
          bCallResumeAudChannelsNow = #True
          ; debugMsg0(sProcName, "bCallResumeAudChannelsNow=" + strB(bCallResumeAudChannelsNow) + ", bCallResumeAudChannelsLater=" + strB(bCallResumeAudChannelsLater))
          If aSub(nTmpSubPtr)\bStartedInEditor = #False
            debugMsg(sProcName, "aSub(" + getSubLabel(nTmpSubPtr) + ")\nAFLinkedToMTCSubPtr=" + getSubLabel(aSub(nTmpSubPtr)\nAFLinkedToMTCSubPtr))
            nMTCSubPtr = aSub(nTmpSubPtr)\nAFLinkedToMTCSubPtr
            If nMTCSubPtr >= 0
              bCallResumeAudChannelsNow = #False
              bCallResumeAudChannelsLater = #False
              ; debugMsg0(sProcName, "bCallResumeAudChannelsNow=" + strB(bCallResumeAudChannelsNow) + ", bCallResumeAudChannelsLater=" + strB(bCallResumeAudChannelsLater))
              debugMsg(sProcName, "aSub(" + getSubLabel(nMTCSubPtr) + ")\nSubState=" + decodeCueState(aSub(nMTCSubPtr)\nSubState))
              If aSub(nMTCSubPtr)\nSubState > #SCS_CUE_READY ; And aSub(nMTCSubPtr)\nSubState <> #SCS_CUE_PAUSED ; commented out 'not paused' test 28Aug2021 11.8.6ae
                                                             ; linked MTC sub-cue is already marked as 'playing' (even though MTC will not yet have been started), so now we can activate both this audio and the MTC
                debugMsg(sProcName, "calling MTC_playOrResumeMTCAndLinkedAud(" + getSubLabel(nMTCSubPtr) + ", #False, #True)")
                MTC_playOrResumeMTCAndLinkedAud(nMTCSubPtr, #False, #True)
              EndIf
            EndIf
          EndIf
          If bCallResumeAudChannelsNow
            debugMsg(sProcName, "calling resumeAudChannels(" + getAudLabel(nTmpAudPtr) + ")")
            resumeAudChannels(nTmpAudPtr)
            bCallResumeAudChannelsLater = #False
            ; debugMsg0(sProcName, "bCallResumeAudChannelsNow=" + strB(bCallResumeAudChannelsNow) + ", bCallResumeAudChannelsLater=" + strB(bCallResumeAudChannelsLater))
          EndIf
        EndIf
        \nAudState = \nPrepauseAudState
        \nPlayingPos = \nRelFilePos
        
        If \nAudState = #SCS_CUE_FADING_IN
          debugMsg(sProcName, "Q=" + \sCue + ", IN nTimeToGo=" + nTimeToGo)
          For d = \nFirstSoundingDev To \nLastSoundingDev
            If \nBassChannel[d] <> 0
              If \bCueVolManual[d]
                \nAudState = #SCS_CUE_PLAYING
              EndIf
            EndIf
          Next d
          
        ElseIf \nAudState = #SCS_CUE_FADING_OUT
          If \bTimeFadeOutStartedSet
            nTimeToGo = \nFadeOutTime - ((qTimeNow - \qTimeFadeOutStarted) - (\nTotalTimeOnPause - \nPreFadeOutTimeOnPause))
          Else
            ; shouldn't get here
            nTimeToGo = \nFadeOutTime - ((0) - (\nTotalTimeOnPause - \nPreFadeOutTimeOnPause))
          EndIf
          debugMsg(sProcName, "Q=" + \sCue + ", OUT nTimeToGo=" + nTimeToGo)
          For d = 0 To grLicInfo\nMaxAudDevPerAud
            If \nBassChannel[d] <> 0
              If \bCueVolManual[d]
                \nAudState = #SCS_CUE_PLAYING
              EndIf
            EndIf
          Next d
          CompilerIf #c_include_tvg
            If grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG
              bAddTmpAudPtrToFadeAudArray = #True
            EndIf
          CompilerEndIf
          
        EndIf
        
        If bAddTmpAudPtrToFadeAudArray
          debugMsg(sProcName, "calling addAudToTVGFadeAudArray(" + getAudLabel(nTmpAudPtr) + ")")
          addAudToTVGFadeAudArray(nTmpAudPtr)
        EndIf
        
        debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nAudState=" + decodeCueState(\nAudState))
      EndWith
      
      If aSub(nTmpSubPtr)\bStartedInEditor = #False
        If aSub(nTmpSubPtr)\bSubTypeAorF
          If aSub(nTmpSubPtr)\nAFLinkedToMTCSubPtr >= 0
            j = aSub(nTmpSubPtr)\nAFLinkedToMTCSubPtr
            If aSub(j)\bSubTypeU
              If aSub(j)\nMTCLinkedToAFSubPtr = nTmpSubPtr And aSub(j)\bSubEnabled
                debugMsg(sProcName, "calling resumeSub(" + buildSubLabel(j) + ")")
                resumeSub(j)
              EndIf
            EndIf ; EndIf aSub(j)\bSubTypeU
          EndIf ; EndIf aSub(nTmpSubPtr)\nAFLinkedToMTCSubPtr >= 0
        EndIf ; EndIf aSub(nTmpSubPtr)\bSubTypeAorF
      EndIf ; EndIf aSub(nTmpSubPtr)\bStartedInEditor = #False
      
      ; debugMsg0(sProcName, "bCallResumeAudChannelsNow=" + strB(bCallResumeAudChannelsNow) + ", bCallResumeAudChannelsLater=" + strB(bCallResumeAudChannelsLater))
      If bCallResumeAudChannelsLater
        debugMsg(sProcName, "calling resumeAudChannels(" + getAudLabel(nTmpAudPtr) + ")")
        resumeAudChannels(nTmpAudPtr)
      EndIf
      
    EndIf ; EndIf nTmpAudPtr > 0
  Next h
  
  For h = 0 To aAud(pAudPtr)\nMaxAudSetPtr2
    nTmpAudPtr = gaAudSet(pAudPtr, h)
    If nTmpAudPtr > 0
      With aAud(nTmpAudPtr)
        setCueState(\nCueIndex)
        updateGrid(\nCueIndex)
        aCue(\nCueIndex)\nCuePanelUpdateFlags | #SCS_CUEPNL_PROGRESS | #SCS_CUEPNL_TRANSPORT
        debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\nCuePanelUpdateFlags=" + aCue(\nCueIndex)\nCuePanelUpdateFlags)
      EndWith
    EndIf
  Next h
  
  THR_resumeAThread(#SCS_THREAD_CONTROL)
  
  If gbUseBASSMixer = #False
    samAddRequest(#SCS_SAM_BUILD_DEV_CHANNEL_LIST)
  EndIf
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure resumeMidiFile(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nErrCode.l
  Protected sMciString.s
  Protected bDummyDev
  
  ; warning! all mciSendString calls must be from the same thread or mciSendString returns error 263 (not a registered device), so use main thread
  ASSERT_THREAD(#SCS_THREAD_MAIN)
  
  With aAud(pAudPtr)
    bDummyDev = gaMidiOutDevice(\nMidiPhysicalDevPtr)\bDummy
    debugMsg(sProcName, "gaMidiOutDevice(" + \nMidiPhysicalDevPtr + ")\bDummy=" + strB(gaMidiOutDevice(\nMidiPhysicalDevPtr)\bDummy) + ", bDummyDev=" + strB(bDummyDev))
    If bDummyDev = #False
      sMciString = "resume " + \sMidiAlias
      nErrCode = mciSendString_(sMciString, #Null, 0, #Null)
      debugMsg2(sProcName, "mciSendString_(" + sMciString + ", #Null, 0, #Null)", nErrCode)
      If nErrCode <> 0
        ; if "resume" failed it may be because "resume" is not supported so use "play" instead
        ; ("resume" is not supported by the MCISEQ driver)
        ; "play" without a position parameter plays from the current position
        sMciString = "play " + \sMidiAlias
        nErrCode = mciSendString_(sMciString, #Null, 0, #Null)
        debugMsg2(sProcName, "mciSendString_(" + sMciString + ", #Null, 0, #Null)", nErrCode)
        If nErrCode <> 0
          displayMidiError(nErrCode, sMciString, sProcName)
          ProcedureReturn
        EndIf
      EndIf
    EndIf
  EndWith

EndProcedure

Procedure rewindAud(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected h, nTmpAudPtr
  
  debugMsg(sProcName, #SCS_START)
  
  For h = 0 To aAud(pAudPtr)\nMaxAudSetPtr2
    CheckSubInRange(pAudPtr, ArraySize(gaAudSet(), 1), "gaAudSet(), 1 h=" + h)
    CheckSubInRange(h, ArraySize(gaAudSet(), 2), "gaAudSet(), 2 pAudPtr=" + getAudLabel(pAudPtr))
    nTmpAudPtr = gaAudSet(pAudPtr, h)
    If nTmpAudPtr > 0
      With aAud(nTmpAudPtr)
        If (\nAudState >= #SCS_CUE_READY) And (\nAudState <= #SCS_CUE_COMPLETED)
          Select \nFileFormat
            Case #SCS_FILEFORMAT_AUDIO, #SCS_FILEFORMAT_MIDI
              debugMsg(sProcName, "calling setAudChannelPositions(" + getAudLabel(nTmpAudPtr) + ", " + ttszt(\nAbsStartAt) + ", #False, " + \qStartAtBytePos + ")")
              setAudChannelPositions(nTmpAudPtr, \nAbsStartAt, #False, \qStartAtBytePos)
            Case #SCS_FILEFORMAT_VIDEO
              If grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_VMIX
                debugMsg(sProcName, "calling setAudChannelPositions(" + getAudLabel(nTmpAudPtr) + ", " + ttszt(\nAbsStartAt) + ", #False, " + \qStartAtBytePos + ")")
                setAudChannelPositions(nTmpAudPtr, \nAbsStartAt, #False, \qStartAtBytePos)
              EndIf
          EndSelect
        EndIf
        \nTotalTimeOnPause = 0
        \nRelFilePos = \nRelStartAt
        ; debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nRelFilePos=" + \nRelFilePos)
        \nPreFadeInTimeOnPause = 0
        \nPreFadeOutTimeOnPause = 0
        \nCuePos = 0
        \nCuePosAtLoopStart = 0
        ; \qChannelBytePosition = 0
        \bPLSkipDone = #False
        \nLoopPassNo = grAudDef\nLoopPassNo
        If \rCurrLoopInfo\nLoopSyncIndex >= 0
          gaLoopSync(\rCurrLoopInfo\nLoopSyncIndex)\nLoopSyncPassNo = 1
        EndIf
        loadCurrLoopInfo(nTmpAudPtr, 0, #True)
        If \nCurrLoopInfoIndex >= 0
          \aLoopInfo(\nCurrLoopInfoIndex)\bLoopReleased = #False
        EndIf
        \rCurrLoopInfo\bLoopReleased = #False
        ; debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex + ", \nLoopPassNo=" + \nLoopPassNo + ", \rCurrLoopInfo\bLoopReleased=" + strB(\rCurrLoopInfo\bLoopReleased))
        \bPlayEndSyncOccurred = #False
        aCue(\nCueIndex)\nCuePanelUpdateFlags | #SCS_CUEPNL_PROGRESS | #SCS_CUEPNL_TRANSPORT
        ; debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\nCuePanelUpdateFlags=" + Str(aCue(\nCueIndex)\nCuePanelUpdateFlags))
      EndWith
    EndIf
  Next h
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure rewindMidiFile(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nErrCode.l
  Protected sMciString.s
  Protected bDummyDev
  
  ; warning! all mciSendString calls must be from the same thread or mciSendString returns error 263 (not a registered device), so use main thread
  ASSERT_THREAD(#SCS_THREAD_MAIN)
  
  With aAud(pAudPtr)
    bDummyDev = gaMidiOutDevice(\nMidiPhysicalDevPtr)\bDummy
    debugMsg(sProcName, "gaMidiOutDevice(" + \nMidiPhysicalDevPtr + ")\bDummy=" + strB(gaMidiOutDevice(\nMidiPhysicalDevPtr)\bDummy) + ", bDummyDev=" + strB(bDummyDev))
    If bDummyDev = #False
      sMciString = "seek " + \sMidiAlias + " to start"
      nErrCode = mciSendString_(sMciString, #Null, 0, #Null)
      debugMsg2(sProcName, "mciSendString_(" + sMciString + ", #Null, 0, #Null)", nErrCode)
      If nErrCode <> 0
        displayMidiError(nErrCode, sMciString, sProcName)
        ProcedureReturn
      EndIf
    EndIf
  EndWith

EndProcedure

Procedure rewindVideo(pAudPtr, pVidPicTarget)
  PROCNAMECA(pAudPtr)

  debugMsg(sProcName, "calling setVideoPosition(" + getAudLabel(pAudPtr) + ", " + Str(aAud(pAudPtr)\nAbsStartAt) + ")")
  setVideoPosition(pAudPtr, pVidPicTarget, aAud(pAudPtr)\nAbsStartAt)

EndProcedure

Procedure setLevelsAny(pAudPtr, nOutputDev, fReqdBVLevel.f, fReqdPan.f, nInputDev=-1, nReqdFadeTime=0)
  PROCNAMECA(pAudPtr)
  Protected sLevelInfo.s, sDevPXChanListLeft.s, sDevPXChanListRight.s, sDevPXDownMix.s, sSetCommandItem.s
  Protected sStringField1.s, sStringField2.s
  Protected nSubIndex
  Protected nVidPicTarget
  Protected sAudSetGainCommandString.s
  Protected d, d2
  Protected nInputDevMapDevPtr, nOutputDevMapDevPtr
  Protected nLogicalDevPtr
  Protected sDevXChanListLeft.s, sDevXChanListRight.s
  Protected sField1.s, sField2.s
  Protected bSetLevelsNow
  Protected nFirstInputDev, nLastInputDev
  
  CompilerIf #cTraceSetLevels
    debugMsg(sProcName, "nOutputDev=" + nOutputDev + ", fReqdBVLevel=" + formatLevel(fReqdBVLevel) + ", fReqdPan=" + formatPan(fReqdPan) + ", nInputDev=" + nInputDev + ", nReqdFadeTime=" + nReqdFadeTime)
  CompilerEndIf
  
  With aAud(pAudPtr)
    
    Select aAud(pAudPtr)\nFileFormat
      Case #SCS_FILEFORMAT_AUDIO    ; SCS_FILEFORMAT_AUDIO
        If gbUseBASS  ; BASS
          setLevelsBASS(pAudPtr, nOutputDev, fReqdBVLevel, fReqdPan)
          
        Else  ; SM-S
          ; nb no facility to pass nFadeTime or sFadeType when using setLevelsAny
          sDevPXChanListLeft = \sDevPXChanListLeft[nOutputDev]
          sDevPXChanListRight = \sDevPXChanListRight[nOutputDev]
          sDevPXDownMix = \sDevPXDownMix[nOutputDev]
          If Len(sDevPXChanListLeft) > 0
            sLevelInfo = setLevelsForSMSOutputDev(pAudPtr, nOutputDev, fReqdBVLevel, fReqdPan, nReqdFadeTime)
            sStringField1 = StringField(sLevelInfo, 1, "|")
            sStringField2 = StringField(sLevelInfo, 2, "|")
            If sStringField1 = sStringField2
              sSetCommandItem = " chan " + sDevPXChanListLeft + " " + sDevPXChanListRight + " " + sStringField1
            Else
              sSetCommandItem = " chan " + sDevPXChanListLeft + " " + sStringField1
              If Len(sDevPXChanListRight) > 0
                sSetCommandItem + " chan " + sDevPXChanListRight + " " + sStringField2
              EndIf
            EndIf
            ; debugMsg0(sProcName, "sStringField1=" + sStringField1 + ", sStringField2=" + sStringField2 + ", sDevPXDownMix=" + sDevPXDownMix)
            ; debugMsg(sProcName, "sSetCommandItem=" + sSetCommandItem)
            sendSMSCommand("set " + Trim(sSetCommandItem), #cTraceSetLevels)
          EndIf
        EndIf
        
        If WCN\nPlayingSubTypeF = \nSubIndex
          WCN\bRefreshAudioChannelFaders = #True
          ; debugMsg(sProcName, "WCN\bRefreshAudioChannelFaders=" + strB(WCN\bRefreshAudioChannelFaders))
        EndIf
        
      Case #SCS_FILEFORMAT_LIVE_INPUT   ; #SCS_FILEFORMAT_LIVE_INPUT
        If nInputDev >= 0
          nFirstInputDev = nInputDev
          nLastInputDev = nInputDev
          sProcName + "[" + \sInputLogicalDev[nInputDev] + "]"
        Else
          nFirstInputDev = \nFirstInputDev
          nLastInputDev = \nLastInputDev
        EndIf
        d = nOutputDev
        ; debugMsg(sProcName, "\sLogicalDev[" + d + "]=" + \sLogicalDev[d] + ", \bIgnoreDev[" + d + "]=" + strB(\bIgnoreDev[d]))
        For d2 = nFirstInputDev To nLastInputDev
          nInputDevMapDevPtr = \nInputDevMapDevPtr[d2]
          If nInputDevMapDevPtr >= 0
            If (Len(\sLogicalDev[d]) > 0) And (\bIgnoreDev[d] = #False)
              nLogicalDevPtr = getProdLogicalDevPtrForLogicalDev(\sLogicalDev[d])
              ; debugMsg(sProcName, "\sLogicalDev(" + d + ")=" + \sLogicalDev[d] + ", nLogicalDevPtr=" + nLogicalDevPtr)
              If nLogicalDevPtr >= 0
                nOutputDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_AUDIO_OUTPUT, \sLogicalDev[d])
                If nOutputDevMapDevPtr < 0
                  ; shouldn't happen
                  Continue
                EndIf
                If (\nAudState >= #SCS_CUE_FADING_IN) And (\nAudState <= #SCS_CUE_FADING_OUT)
                  bSetLevelsNow = #True
                Else
                  \bSetLevelsWhenPlayAud = #True  ; ALWAYS set "\bSetLevelsWhenPlayAud = #True" for non-playing live inputs as that's how we 'turn on' the inputs
                EndIf
                ; sDevXChanListLeft = \sDevXChanListLeft[nOutputDev]
                ; sDevXChanListRight = \sDevXChanListRight[nOutputDev]
                If (grMaps\aDev(nOutputDevMapDevPtr)\nNrOfDevOutputChans = 2) And (fReqdPan <> #SCS_PANCENTRE_SINGLE)
                  sDevXChanListLeft = "x" + grMaps\aDev(nInputDevMapDevPtr)\s0BasedInputRangeAG + "." + Str(grMaps\aDev(nOutputDevMapDevPtr)\nFirst1BasedOutputChan - 1)
                  sDevXChanListRight = "x" + grMaps\aDev(nInputDevMapDevPtr)\s0BasedInputRangeAG + "." + Str(grMaps\aDev(nOutputDevMapDevPtr)\nFirst1BasedOutputChan)
                Else
                  sDevXChanListLeft = "x" + grMaps\aDev(nInputDevMapDevPtr)\s0BasedInputRangeAG + "." + grMaps\aDev(nOutputDevMapDevPtr)\s0BasedOutputRangeAG
                  sDevXChanListRight = ""
                EndIf
                sLevelInfo = setLevelsForSMSOutputDev(pAudPtr, d, fReqdBVLevel, fReqdPan, nReqdFadeTime, #SCS_FADE_STD, d2)
                sField1 = StringField(sLevelInfo, 1, "|")
                sField2 = StringField(sLevelInfo, 2, "|")
                If fReqdPan = #SCS_PANCENTRE_SINGLE
                  sSetCommandItem = " chan " + sDevXChanListLeft + " " + sDevXChanListRight + " " + sField1
                Else
                  sSetCommandItem = " chan " + sDevXChanListLeft + " " + sField1
                  If Len(sDevXChanListRight) > 0
                    sSetCommandItem + " chan " + sDevXChanListRight + " " + sField2
                  EndIf
                EndIf
                ; debugMsg(sProcName, "sSetCommandItem=" + sSetCommandItem)
                sAudSetGainCommandString + sSetCommandItem
                
              EndIf
            EndIf
          EndIf
        Next d2
        ; tidy up sAudSetGainCommandString, converting double-spaces to single-spaces, and trimming result
        sAudSetGainCommandString = Trim(ReplaceString(sAudSetGainCommandString, "  ", " "))
        If bSetLevelsNow
          If sAudSetGainCommandString
            sendSMSCommand("set " + sAudSetGainCommandString, #cTraceSetLevels)
          EndIf
        Else
          \sAudSetGainCommandString = sAudSetGainCommandString
          debugMsg(sProcName, "\sAudSetGainCommandString=" + \sAudSetGainCommandString)
          \sAudFinalSetGainCommandString = ""
          debugMsg(sProcName, "\sAudFinalSetGainCommandString=" + \sAudFinalSetGainCommandString)
        EndIf
        
      Case #SCS_FILEFORMAT_VIDEO  ; #SCS_FILEFORMAT_VIDEO
        nSubIndex = \nSubIndex
        If aSub(nSubIndex)\bStartedInEditor
          nVidPicTarget = #SCS_VID_PIC_TARGET_P
        Else
          nVidPicTarget = \nAudVidPicTarget
        EndIf
        CompilerIf #cTraceSetLevels
          debugMsg(sProcName, "call setLevelsVideo, fReqdBVLevel=" + formatLevel(fReqdBVLevel))
        CompilerEndIf
        setLevelsVideo(pAudPtr, nOutputDev, fReqdBVLevel, fReqdPan, nVidPicTarget)
        
      Default
        ; ignore other formats, eg picture
        
    EndSelect
    
  EndWith
  
EndProcedure

Procedure setLevelsBASS(pAudPtr, nDev, fBVLevel.f, fPan.f)
  PROCNAMEC()
  Protected fAdjBVLevel.f, nDevMapDevPtr
  Protected fOutputGain.f

  With aAud(pAudPtr)
    Select \nFileFormat
      Case #SCS_FILEFORMAT_AUDIO
        If \nBassChannel[nDev] <> 0
          
          fAdjBVLevel = fBVLevel
          If gbUseBASSMixer = #False
            nDevMapDevPtr = \nOutputDevMapDevPtr[nDev]
            If nDevMapDevPtr >= 0
              fOutputGain = grMaps\aDev(nDevMapDevPtr)\fDevOutputGain
              If fOutputGain <> 1.0
                fAdjBVLevel * fOutputGain
              EndIf
            EndIf
          EndIf
          CompilerIf #cTraceSetLevels
            debugMsg(sProcName, "pAudPtr=" + getAudLabel(pAudPtr) + ", nDev=" + nDev + ", fBVLevel=" + formatLevel(fBVLevel) + ", fAdjBVLevel=" + formatLevel(fAdjBVLevel) + ", fPan=" + fPan +
                                ", grMaps\aDev(" + nDevMapDevPtr + ")\fDevOutputGain=" + traceLevel(grMaps\aDev(nDevMapDevPtr)\fDevOutputGain))
          CompilerEndIf
          
          If BASS_ChannelIsSliding(\nBassChannel[nDev], 0) = #BASSFALSE
            ; no attributes of channel are sliding
            setAudChannelAttributes(pAudPtr, nDev, fAdjBVLevel, fPan)
          Else
            ; if channel sliding then need to issue another slide to cancel it
            If \bUseMatrix[nDev] = #False
              slideChannelAttributes(pAudPtr, nDev, fAdjBVLevel, fPan, 0, 220001)
            Else
              slideChannelAttributes(pAudPtr, nDev, fAdjBVLevel, #SCS_NOPANCHANGE_SINGLE, 0, 220002)
              setAudChannelAttributes(pAudPtr, nDev, #SCS_NOVOLCHANGE_SINGLE, fPan)
            EndIf
          EndIf
          
          If ((\nAudState >= #SCS_CUE_FADING_IN) And (\nAudState <= #SCS_CUE_FADING_OUT)) Or (\nAudState = #SCS_CUE_PL_READY)
            ; update \fCueVolNow and \fCuePanNow
            getChannelAttributes(pAudPtr)
          EndIf
          
        EndIf
        
    EndSelect
    
  EndWith
  
EndProcedure

Procedure setLinksOneAud(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected d, d2, nLinkMasterChannel.l, nLinkMasterCuePtr, bVideo
  Protected nLinkMasterAltChannel.l
  Protected nBassResult.l, nErrorCode.l
  
  debugMsg(sProcName, #SCS_START)
  
  If pAudPtr >= 0
    With aAud(pAudPtr)
      
      If \bCallSetLinksOneAud
        \bCallSetLinksOneAud = #False
        debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\bCallSetLinksOneAud=" + strB(\bCallSetLinksOneAud))
      EndIf
      
      If \nFileFormat <> #SCS_FILEFORMAT_AUDIO And \nFileFormat <> #SCS_FILEFORMAT_VIDEO
        debugMsg(sProcName, "exit because file format not audio or video")
        ProcedureReturn
      EndIf
      If \nFileFormat = #SCS_FILEFORMAT_VIDEO
        bVideo = #True
      EndIf
      
      If bVideo = #False
        debugMsg(sProcName, "\nFirstSoundingDev=" + \nFirstSoundingDev)
        d = \nFirstSoundingDev
        If d >= 0
          If gbUseBASS  ; BASS
            
            If aAud(pAudPtr)\nBassChannel[d] = 0
              debugMsg(sProcName, "exit because first sounding dev channel = 0")
              ProcedureReturn
            EndIf
            
            nLinkMasterChannel = \nBassChannel[d]
            nLinkMasterAltChannel = \nBassAltChannel[d] ; must only be set for current pAudPtr (alt channels only linked within one aud, not across aud's)
            nLinkMasterCuePtr = \nCueIndex
            
            debugMsg(sProcName, "d=" + d + ", nLinkMasterChannel=" + decodeHandle(nLinkMasterChannel) + ", nLinkMasterAltChannel=" + decodeHandle(nLinkMasterAltChannel) + ", \nLinkedToAudPtr=" + getAudLabel(\nLinkedToAudPtr))
            
            If (\nLinkedToAudPtr >= 0) And (aSub(\nSubIndex)\bStartedInEditor = #False)
              debugMsg(sProcName, "\nAbsStartAt=" + \nAbsStartAt + ", aAud(" + getAudLabel(\nLinkedToAudPtr) + ")\nAbsStartAt)=" + aAud(\nLinkedToAudPtr)\nAbsStartAt)
              If (\nCueDuration <> aAud(\nLinkedToAudPtr)\nCueDuration) Or (\nAbsStartAt <> aAud(\nLinkedToAudPtr)\nAbsStartAt)
                ; cancel link if files not exactly the same duration
                aAud(\nLinkedToAudPtr)\nAudLinkCount - 1
                debugMsg(sProcName, "aAud(" + getAudLabel(\nLinkedToAudPtr) + ")\nAudLinkCount=" + aAud(\nLinkedToAudPtr)\nAudLinkCount)
                \nLinkedToAudPtr = -1
                debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nLinkedToAudPtr=" + getAudLabel(\nLinkedToAudPtr))
                
              ElseIf aAud(\nLinkedToAudPtr)\nFirstSoundingDev < 0
                ; cancel link if linked to aud has no sounding device, ie all used devices are <no device>
                aAud(\nLinkedToAudPtr)\nAudLinkCount - 1
                debugMsg(sProcName, "aAud(" + getAudLabel(\nLinkedToAudPtr) + ")\nAudLinkCount=" + aAud(\nLinkedToAudPtr)\nAudLinkCount)
                \nLinkedToAudPtr = -1
                debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nLinkedToAudPtr=" + getAudLabel(\nLinkedToAudPtr))
                
              Else
                nLinkMasterChannel = aAud(\nLinkedToAudPtr)\nBassChannel[aAud(\nLinkedToAudPtr)\nFirstSoundingDev]
                nLinkMasterAltChannel = aAud(\nLinkedToAudPtr)\nBassAltChannel[aAud(\nLinkedToAudPtr)\nFirstSoundingDev]
                nLinkMasterCuePtr = aAud(\nLinkedToAudPtr)\nCueIndex
                
                If gbUseBASSMixer = #False ; nb cannot use BASS_ChannelSetLink() on decode channels, and channels fed to the BASSMixer are decode channels
                  If (nLinkMasterChannel <> 0) And (\nBassChannel[d] <> 0)
                    debugMsg(sProcName, "Linking " + \sAudLabel + "(" + d + ") to " + aAud(\nLinkedToAudPtr)\sAudLabel)
                    nBassResult = BASS_ChannelSetLink(nLinkMasterChannel, \nBassChannel[d])
                    debugMsg2(sProcName, "BASS_ChannelSetLink(" + decodeHandle(nLinkMasterChannel) + ", " + decodeHandle(\nBassChannel[d]) + ")", nBassResult)
                    If nBassResult = #BASSFALSE
                      nErrorCode = BASS_ErrorGetCode()
                      If nErrorCode = #BASS_ERROR_ALREADY
                        debugMsg(sProcName, "already linked")
                        ; no action
                      ElseIf nErrorCode = #BASS_ERROR_DECODE
                        debugMsg(sProcName, "one of them is a decode channel - probably a <no device> channel")
                        ; no action
                      Else
                        Error_(sProcName, "Set link for " + buildAudLabel(pAudPtr) + " to " + \sAudLabel + " failed")
                      EndIf
                    EndIf
                    
                    If (nLinkMasterAltChannel <> 0) And (\nBassAltChannel[d] <> 0)
                      debugMsg(sProcName, "(a alt) Linking " + \sAudLabel + "(" + d + ") to " + aAud(\nLinkedToAudPtr)\sAudLabel)
                      nBassResult = BASS_ChannelSetLink(nLinkMasterAltChannel, \nBassAltChannel[d])
                      debugMsg2(sProcName, "BASS_ChannelSetLink(" + decodeHandle(nLinkMasterAltChannel) + ", " + decodeHandle(\nBassAltChannel[d]) + ")", nBassResult)
                      If nBassResult = #BASSFALSE
                        nErrorCode = BASS_ErrorGetCode()
                        If nErrorCode = #BASS_ERROR_ALREADY
                          debugMsg(sProcName, "already linked")
                          ; no action
                        ElseIf nErrorCode = #BASS_ERROR_DECODE
                          debugMsg(sProcName, "one of them is a decode channel - probably a <no device> channel")
                          ; no action
                        Else
                          Error_(sProcName, "Set link for " + buildAudLabel(pAudPtr) + " to " + \sAudLabel + " failed")
                        EndIf
                      EndIf
                    EndIf
                    
                  EndIf
                EndIf
              EndIf
            EndIf
            
            If gbUseBASSMixer = #False ; nb cannot use BASS_ChannelSetLink() on decode channels, and channels fed to the BASSMixer are decode channels
              For d2 = \nFirstSoundingDev To \nLastSoundingDev
                debugMsg(sProcName, "\nBassChannel(" + d2 + ")=" + decodeHandle(\nBassChannel[d2]))
                If (d2 > \nFirstSoundingDev) And (nLinkMasterChannel <> 0) And (\nBassChannel[d2] <> 0) ; And (gbEditHasFocus = #False)
                  
                  ; link secondary outputs to first or master output
                  debugMsg(sProcName, "Linking " + \sAudLabel + "(" + d2 + ") to " + \sAudLabel + "(" + \nFirstSoundingDev + ")")
                  nBassResult = BASS_ChannelSetLink(nLinkMasterChannel, \nBassChannel[d2])
                  debugMsg2(sProcName, "BASS_ChannelSetLink(" + decodeHandle(nLinkMasterChannel) + ", " + decodeHandle(\nBassChannel[d2]) + ")", nBassResult)
                  If nBassResult = #BASSFALSE
                    nErrorCode = BASS_ErrorGetCode()
                    If nErrorCode = #BASS_ERROR_ALREADY
                      debugMsg(sProcName, "already linked")
                      ; no action
                    ElseIf nErrorCode = #BASS_ERROR_DECODE
                      debugMsg(sProcName, "one of them is a decode channel - probably a <no device> channel")
                      ; no action
                    Else
                      Error_(sProcName, "Set link for " + \sAudLabel + "(" + d2 + ") to " + buildAudLabel(pAudPtr) + "(" + d2 + ") failed")
                    EndIf
                  EndIf
                  
                  If (nLinkMasterAltChannel <> 0) And (\nBassAltChannel[d2] <> 0)
                    nBassResult = BASS_ChannelSetLink(nLinkMasterAltChannel, \nBassAltChannel[d2])
                    debugMsg2(sProcName, "BASS_ChannelSetLink(" + decodeHandle(nLinkMasterAltChannel) + ", " + decodeHandle(\nBassAltChannel[d2]) + ")", nBassResult)
                    If nBassResult = #BASSFALSE
                      nErrorCode = BASS_ErrorGetCode()
                      If nErrorCode = #BASS_ERROR_ALREADY
                        debugMsg(sProcName, "alt already linked")
                        ; no action
                      ElseIf nErrorCode = #BASS_ERROR_DECODE
                        debugMsg(sProcName, "alt: one of them is a decode channel - probably a <no device> channel")
                        ; no action
                      Else
                        Error_(sProcName, "Set alt link for " + \sAudLabel + "(" + d2 + ") to " + buildAudLabel(pAudPtr) + "(" + d2 + ") failed")
                      EndIf
                    EndIf
                  EndIf
                  
                EndIf
                
              Next d2
            EndIf
            
          Else  ; SM-S
            nLinkMasterCuePtr = \nCueIndex
            
            debugMsg(sProcName, "\nLinkedToAudPtr=" + getAudLabel(\nLinkedToAudPtr))
            
            If (\nLinkedToAudPtr >= 0) And (aSub(\nSubIndex)\bStartedInEditor = #False)
              If \nCueDuration <> aAud(\nLinkedToAudPtr)\nCueDuration
                ; cancel link if files not exactly the same duration
                aAud(\nLinkedToAudPtr)\nAudLinkCount - 1
                debugMsg(sProcName, "aAud(" + getAudLabel(\nLinkedToAudPtr) + ")\nAudLinkCount=" + aAud(\nLinkedToAudPtr)\nAudLinkCount)
                \nLinkedToAudPtr = -1
                debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nLinkedToAudPtr=" + getAudLabel(\nLinkedToAudPtr))
                
              ElseIf aAud(\nLinkedToAudPtr)\nFirstSoundingDev < 0
                ; cancel link if linked to aud has no sounding device, ie all used devices are <no device>
                aAud(\nLinkedToAudPtr)\nAudLinkCount - 1
                debugMsg(sProcName, "aAud(" + getAudLabel(\nLinkedToAudPtr) + ")\nAudLinkCount=" + aAud(\nLinkedToAudPtr)\nAudLinkCount)
                \nLinkedToAudPtr = -1
                debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nLinkedToAudPtr=" + getAudLabel(\nLinkedToAudPtr))
                
              Else
                nLinkMasterCuePtr = aAud(\nLinkedToAudPtr)\nCueIndex
                
              EndIf
            EndIf
            
          EndIf
        EndIf ; EndIf d >= 0
        
      Else ; bVideo = #True
        debugMsg(sProcName, "bVideo=" + strB(bVideo))
        nLinkMasterCuePtr = \nCueIndex
        debugMsg(sProcName, "\nLinkedToAudPtr=" + getAudLabel(\nLinkedToAudPtr))
        If (\nLinkedToAudPtr >= 0) And (aSub(\nSubIndex)\bStartedInEditor = #False)
          If \nCueDuration <> aAud(\nLinkedToAudPtr)\nCueDuration
            ; cancel link if files not exactly the same duration
            aAud(\nLinkedToAudPtr)\nAudLinkCount - 1
            debugMsg(sProcName, "aAud(" + getAudLabel(\nLinkedToAudPtr) + ")\nAudLinkCount=" + aAud(\nLinkedToAudPtr)\nAudLinkCount)
            \nLinkedToAudPtr = -1
            debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nLinkedToAudPtr=" + getAudLabel(\nLinkedToAudPtr))
          Else
            nLinkMasterCuePtr = aAud(\nLinkedToAudPtr)\nCueIndex
          EndIf
        EndIf
        
      EndIf
      
    EndWith
  EndIf
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure setLinksForAudsWhereRequested()
  PROCNAMEC()
  Protected i, j, k
  Protected bUpdateGrid
  
debugMsg(sProcName, #SCS_START)
  
  For i = 1 To gnLastCue
    If aCue(i)\bSubTypeF
      bUpdateGrid = #False
      j = aCue(i)\nFirstSubIndex
      While j >= 0
        If aSub(j)\bSubTypeF And aSub(j)\bSubEnabled
          k = aSub(j)\nFirstAudIndex
          If k >= 0
            If aAud(k)\bCallSetLinksOneAud
              debugMsg(sProcName, "calling setLinksOneAud(" + getAudLabel(k) + ")")
              setLinksOneAud(k)
              bUpdateGrid = #True
            EndIf
          EndIf
        EndIf
        j = aSub(j)\nNextSubIndex
      Wend
      If bUpdateGrid
        debugMsg(sProcName, "calling loadGridRow(" + getCueLabel(i) + ")")
        loadGridRow(i)
      EndIf
    EndIf
  Next i
  
  ; debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure setLogicalDevsDerivedFields()
  PROCNAMEC()
  Protected d
  Protected nDevMapPtr, nDevMapDevPtr
  
  debugMsg(sProcName, #SCS_START)
  
  nDevMapPtr = grProd\nSelectedDevMapPtr
  If nDevMapPtr < 0
    ProcedureReturn
  EndIf
  
  For d = 0 To grProd\nMaxAudioLogicalDev
    With grProd\aAudioLogicalDevs(d)
      If Trim(\sLogicalDev)
        nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_AUDIO_OUTPUT, \sLogicalDev)
        If nDevMapDevPtr >= 0
          ; debugMsg(sProcName, "d=" + d + ", \sLogicalDev=" + \sLogicalDev + ", nDevMapDevPtr=" + nDevMapDevPtr)
          \bNoDevice = grMaps\aDev(nDevMapDevPtr)\bNoDevice
          If \bNoDevice
            \nPhysicalDevPtr = gaAudioDev(\nPhysicalDevPtr)\nRealPhysDevPtr
            ; debugMsg(sProcName, "grProd\aAudioLogicalDevs(" + d + ")\nPhysicalDevPtr=" + \nPhysicalDevPtr)
          Else
            \nPhysicalDevPtr = grMaps\aDev(nDevMapDevPtr)\nPhysicalDevPtr
            ; debugMsg(sProcName, "grProd\aAudioLogicalDevs(" + d + ")\nPhysicalDevPtr=" + \nPhysicalDevPtr)
          EndIf
          debugMsg(sProcName, \sLogicalDev + ", grProd\aAudioLogicalDevs(" + d + ")\nNrOfOutputChans=" + \nNrOfOutputChans + ", \nPhysicalDevPtr=" + \nPhysicalDevPtr)
        EndIf
      EndIf
    EndWith
  Next d
  
  For d = 0 To grProd\nMaxVidAudLogicalDev
    With grProd\aVidAudLogicalDevs(d)
      If Trim(\sVidAudLogicalDev)
        nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_VIDEO_AUDIO, \sVidAudLogicalDev)
        If nDevMapDevPtr >= 0
          ; debugMsg(sProcName, "d=" + d + ", \sVidAudLogicalDev=" + \sVidAudLogicalDev + ", nDevMapDevPtr=" + nDevMapDevPtr)
          \nPhysicalDevPtr = grMaps\aDev(nDevMapDevPtr)\nPhysicalDevPtr
          ; debugMsg(sProcName, "grProd\aVidAudLogicalDevs(" + d + ")\nPhysicalDevPtr=" + \nPhysicalDevPtr)
          debugMsg(sProcName, \sVidAudLogicalDev + ", grProd\aVidAudLogicalDevs(" + d + ")\nPhysicalDevPtr=" + \nPhysicalDevPtr)
        EndIf
      EndIf
    EndWith
  Next d
  
  For d = 0 To grProd\nMaxVidCapLogicalDev
    With grProd\aVidCapLogicalDevs(d)
      If Trim(\sLogicalDev)
        nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_VIDEO_CAPTURE, \sLogicalDev)
        If nDevMapDevPtr >= 0
          ; debugMsg(sProcName, "d=" + d + ", \sLogicalDev=" + \sLogicalDev + ", nDevMapDevPtr=" + nDevMapDevPtr)
          \nPhysicalDevPtr = grMaps\aDev(nDevMapDevPtr)\nPhysicalDevPtr
          ; debugMsg(sProcName, "grProd\aCaptureLogicalDevs(" + d + ")\nPhysicalDevPtr=" + \nPhysicalDevPtr)
          debugMsg(sProcName, \sLogicalDev + ", grProd\aCaptureLogicalDevs(" + d + ")\nPhysicalDevPtr=" + \nPhysicalDevPtr)
        EndIf
      EndIf
    EndWith
  Next d
  
  For d = 0 To grProd\nMaxLiveInputLogicalDev
    With grProd\aLiveInputLogicalDevs(d)
      If Trim(\sLogicalDev)
        nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_LIVE_INPUT, \sLogicalDev)
        If nDevMapDevPtr >= 0
          ; debugMsg(sProcName, "d=" + d + ", \sLogicalDev=" + \sLogicalDev + ", nDevMapDevPtr=" + nDevMapDevPtr)
          \bNoDevice = grMaps\aDev(nDevMapDevPtr)\bNoDevice
          If \bNoDevice
            \nPhysicalDevPtr = gaAudioDev(\nPhysicalDevPtr)\nRealPhysDevPtr
            debugMsg(sProcName, "grProd\aLiveInputLogicalDevs(" + d + ")\nPhysicalDevPtr=" + \nPhysicalDevPtr)
          Else
            \nPhysicalDevPtr = grMaps\aDev(nDevMapDevPtr)\nPhysicalDevPtr
            debugMsg(sProcName, "grProd\aLiveInputLogicalDevs(" + d + ")\nPhysicalDevPtr=" + \nPhysicalDevPtr)
          EndIf
        EndIf
      EndIf
    EndWith
  Next d
  
EndProcedure

Procedure setDevChgsDerivedFieldsForLogicalDevs()
  PROCNAMEC()
  Protected d
  Protected nDevMapPtr, nDevMapDevPtr
  
  debugMsg(sProcName, #SCS_START)
  
  nDevMapPtr = grProdForDevChgs\nSelectedDevMapPtr
  If nDevMapPtr < 0
    ProcedureReturn
  EndIf
  
  For d = 0 To grProdForDevChgs\nMaxAudioLogicalDev
    With grProdForDevChgs\aAudioLogicalDevs(d)
      If Trim(\sLogicalDev)
        nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMapsForDevChgs, #SCS_DEVGRP_AUDIO_OUTPUT, \sLogicalDev)
        If nDevMapDevPtr >= 0
          ; debugMsg(sProcName, "d=" + d + ", \sLogicalDev=" + \sLogicalDev + ", nDevMapDevPtr=" + nDevMapDevPtr)
          \bNoDevice = grMapsForDevChgs\aDev(nDevMapDevPtr)\bNoDevice
          If \bNoDevice
            \nPhysicalDevPtr = gaAudioDev(\nPhysicalDevPtr)\nRealPhysDevPtr
            ; debugMsg(sProcName, "grProdForDevChgs\aAudioLogicalDevs(" + d + ")\nPhysicalDevPtr=" + \nPhysicalDevPtr)
          Else
            \nPhysicalDevPtr = grMapsForDevChgs\aDev(nDevMapDevPtr)\nPhysicalDevPtr
            ; debugMsg(sProcName, "grProdForDevChgs\aAudioLogicalDevs(" + d + ")\nPhysicalDevPtr=" + \nPhysicalDevPtr)
          EndIf
          ; debugMsg(sProcName, \sLogicalDev + ", \nNrOfOutputChans=" + \nNrOfOutputChans + ", \nPhysicalDevPtr=" + \nPhysicalDevPtr)
        EndIf
      EndIf
    EndWith
  Next d
  
  For d = 0 To grProdForDevChgs\nMaxVidAudLogicalDev
    With grProdForDevChgs\aVidAudLogicalDevs(d)
      If Trim(\sVidAudLogicalDev)
        nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMapsForDevChgs, #SCS_DEVGRP_VIDEO_AUDIO, \sVidAudLogicalDev)
        If nDevMapDevPtr >= 0
          ; debugMsg(sProcName, "d=" + d + ", \sVidAudLogicalDev=" + \sVidAudLogicalDev + ", nDevMapDevPtr=" + nDevMapDevPtr)
          \nPhysicalDevPtr = grMapsForDevChgs\aDev(nDevMapDevPtr)\nPhysicalDevPtr
          ; debugMsg(sProcName, "grProdForDevChgs\aAudioLogicalDevs(" + d + ")\nPhysicalDevPtr=" + \nPhysicalDevPtr)
          ; debugMsg(sProcName, \sVidAudLogicalDev + ", \nPhysicalDevPtr=" + \nPhysicalDevPtr)
        EndIf
      EndIf
    EndWith
  Next d
  
  For d = 0 To grProdForDevChgs\nMaxVidCapLogicalDev
    With grProdForDevChgs\aVidCapLogicalDevs(d)
      If Trim(\sLogicalDev)
        nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMapsForDevChgs, #SCS_DEVGRP_VIDEO_CAPTURE, \sLogicalDev)
        If nDevMapDevPtr >= 0
          ; debugMsg(sProcName, "d=" + d + ", \sLogicalDev=" + \sLogicalDev + ", nDevMapDevPtr=" + nDevMapDevPtr)
          \nPhysicalDevPtr = grMapsForDevChgs\aDev(nDevMapDevPtr)\nPhysicalDevPtr
          ; debugMsg(sProcName, "grProdForDevChgs\aCaptureLogicalDevs(" + d + ")\nPhysicalDevPtr=" + \nPhysicalDevPtr)
          ; debugMsg(sProcName, \sLogicalDev + ", \nPhysicalDevPtr=" + \nPhysicalDevPtr)
        EndIf
      EndIf
    EndWith
  Next d
  
  For d = 0 To grProdForDevChgs\nMaxLiveInputLogicalDev
    With grProdForDevChgs\aLiveInputLogicalDevs(d)
      If Trim(\sLogicalDev)
        nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMapsForDevChgs, #SCS_DEVGRP_LIVE_INPUT, \sLogicalDev)
        If nDevMapDevPtr >= 0
          ; debugMsg(sProcName, "d=" + d + ", \sLogicalDev=" + \sLogicalDev + ", nDevMapDevPtr=" + nDevMapDevPtr)
          \bNoDevice = grMapsForDevChgs\aDev(nDevMapDevPtr)\bNoDevice
          If \bNoDevice
            \nPhysicalDevPtr = gaAudioDev(\nPhysicalDevPtr)\nRealPhysDevPtr
            ; debugMsg(sProcName, "grProdForDevChgs\aLiveInputLogicalDevs(" + d + ")\nPhysicalDevPtr=" + \nPhysicalDevPtr)
          Else
            \nPhysicalDevPtr = grMapsForDevChgs\aDev(nDevMapDevPtr)\nPhysicalDevPtr
            ; debugMsg(sProcName, "grProdForDevChgs\aLiveInputLogicalDevs(" + d + ")\nPhysicalDevPtr=" + \nPhysicalDevPtr)
          EndIf
        EndIf
      EndIf
    EndWith
  Next d
  
EndProcedure

Procedure.f calcReqdGain(*rDev.tyDevMapDev, bMuteOutput=#False, bLogResults=#False)
  PROCNAMEC()
  Protected fReqdGain.f
  
  With *rDev
    ; debugMsg(sProcName, #SCS_START + "*rDev\bUseFaderOutputGain=" + strB(\bUseFaderOutputGain) + ", \sLogicalDev=" + \sLogicalDev)
    If \bOutputMuteOn Or \bOutputMuteTmpOn Or bMuteOutput
      fReqdGain = #SCS_MINVOLUME_SINGLE
      If bLogResults
        debugMsg3(sProcName, "*rDev\bOutputMuteOn=" + strB(\bOutputMuteOn) + ", \bOutputMuteTmpOn=" + strB(\bOutputMuteTmpOn) + ", bMuteOutput=" + strB(bMuteOutput))
      EndIf
    ElseIf \bUseFaderOutputGain
      fReqdGain = \fDevFaderOutputGain * grMasterLevel\fControllerFaderMasterBVLevel
      If bLogResults
        debugMsg3(sProcName, "*rDev\fDevFaderOutputGain=" + traceLevel(\fDevFaderOutputGain) +
                             ", grMasterLevel\fControllerFaderMasterBVLevel=" + traceLevel(grMasterLevel\fControllerFaderMasterBVLevel) +
                             ", fReqdGain=" + traceLevel(fReqdGain))
      EndIf
    Else
      fReqdGain = \fDevOutputGain * grMasterLevel\fProdMasterBVLevel
      If bLogResults
        debugMsg3(sProcName, "*rDev\fDevOutputGain=" + traceLevel(\fDevOutputGain) +
                             ", grMasterLevel\fProdMasterBVLevel=" + traceLevel(grMasterLevel\fProdMasterBVLevel) +
                             ", fReqdGain=" + traceLevel(fReqdGain))
      EndIf
    EndIf
  EndWith
  ProcedureReturn fReqdGain
EndProcedure

Procedure setAudioDevOutputGain(nDevNo, bInDevChgs=#False, bInitializingDev=#False, bMuteOutput=#False)
  PROCNAMEC()
  Protected nDevMapPtr, nDevMapDevPtr
  Protected sLogicalDev.s
  Protected fReqdGain.f, sReqdDBGain.s, fBVLevel.f
  Protected nBassResult.l, nChannelNo.l, nBassChannel.l
  Protected sCmdDetail.s
  Protected bLogResults
  Protected nFirstDev, nLastDev
  Protected d, nCtrlNo
  Static bBlockRecursiveCall ; added 23Apr2019 11.8.1ah

  ; debugMsg(sProcName, #SCS_START)
  
  If bBlockRecursiveCall
    ProcedureReturn
  EndIf
  bBlockRecursiveCall = #True
  
  CompilerIf #cTraceSetLevels
    debugMsg(sProcName, #SCS_START + ", nDevNo=" + nDevNo + ", bInDevChgs=" + strB(bInDevChgs) + ", bInitializingDev=" + strB(bInitializingDev) + ", bMuteOutput=" + strB(bMuteOutput))
    bLogResults = #True
  CompilerElse
    If bInitializingDev
      bLogResults = #True
    EndIf
  CompilerEndIf
  
  If nDevNo >= 0
    nFirstDev = nDevNo
    nLastDev = nDevNo
  Else
    nFirstDev = 0
    nLastDev = grProd\nMaxAudioLogicalDev
  EndIf
  
  ; SEE ALSO calcMeterBarOutputGain() where some of the following code is also used
  
  For d = nFirstDev To nLastDev
    If bInDevChgs = #False
      sLogicalDev = grProd\aAudioLogicalDevs(d)\sLogicalDev
      If sLogicalDev
        ; debugMsg(sProcName, "grProd\aAudioLogicalDevs(" + d + ")\sLogicalDev=" + grProd\aAudioLogicalDevs(d)\sLogicalDev)
        nDevMapPtr = grProd\nSelectedDevMapPtr
        ; debugMsg(sProcName, "grProd\nSelectedDevMapPtr=" + Str(grProd\nSelectedDevMapPtr))
        If nDevMapPtr >= 0
          nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_AUDIO_OUTPUT, sLogicalDev)
          ; debugMsg(sProcName, "nDevMapDevPtr=" + nDevMapDevPtr)
          If nDevMapDevPtr >= 0
            With grMaps\aDev(nDevMapDevPtr)
              fBVLevel = \fDevOutputGain
              ; debugMsg(sProcName, "calling calcReqdGain(@grMaps\aDev(" + nDevMapDevPtr + "), " + strB(bMuteOutput) + ", " + strB(bLogResults) + ")")
              fReqdGain = calcReqdGain(@grMaps\aDev(nDevMapDevPtr), bMuteOutput, bLogResults)
              If bLogResults
                debugMsg(sProcName, "calcReqdGain() returned " + traceLevel(fReqdGain) + " for " + sLogicalDev + ", grMaps\aDev(" + nDevMapDevPtr + ")\bUseFaderOutputGain=" + strB(grMaps\aDev(nDevMapDevPtr)\bUseFaderOutputGain))
              EndIf
              If gbUseBASS  ; BASS
                ; Added 28Sep2022 11.9.6
                If fReqdGain <= grLevels\fMinBVLevel
                  fReqdGain = 0.0
                EndIf
                ; End added 28Sep2022 11.9.6
                If \bBassASIO
                  ; debugMsg(sProcName, "gbAsioInitDone=" + strB(gbAsioInitDone) + ", \nFirstASIOChannel=" + Str(\nFirstASIOChannel) + ", \nLastASIOChannel=" + Str(\nLastASIOChannel))
                  If gbAsioInitDone
                    nBassResult = BASS_ASIO_SetDevice(\nBassASIODevice)
                    If bLogResults
                      debugMsg2(sProcName, "BASS_ASIO_SetDevice(" + \nBassASIODevice + ")", nBassResult)
                    EndIf
                    For nChannelNo = \nFirstASIOChannel To \nLastASIOChannel
                      nBassResult = BASS_ASIO_ChannelSetVolume(#BASSFALSE, nChannelNo, fReqdGain)
                      If bLogResults
                        debugMsg2(sProcName, "BASS_ASIO_ChannelSetVolume(#BASSFALSE, " + decodeHandle(nChannelNo) + ", " + formatLevel(fReqdGain) + ")", nBassResult)
                      EndIf
                    Next nChannelNo
                  EndIf
                ElseIf gbUseBASSMixer
                  ; debugMsg(sProcName, "\nMixerStreamPtr=" + \nMixerStreamPtr) 
                  If \nMixerStreamPtr >= 0
                    nBassChannel = gaMixerStreams(\nMixerStreamPtr)\nMixerStreamHandle
                    If nBassChannel <> 0
                      nBassResult = BASS_ChannelSetAttribute(nBassChannel, #BASS_ATTRIB_VOL, fReqdGain)
                      If bLogResults
                        debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nBassChannel) + ", #BASS_ATTRIB_VOL, " + formatLevel(fReqdGain) + ")", nBassResult)
                      EndIf
                    EndIf
                  EndIf
                EndIf
              Else  ; SM-S
                If grSMS\bInterfaceOpen
                  If Trim(\s0BasedOutputRangeAG)
                    sReqdDBGain = convertBVLevelToDBString(fReqdGain)
                    If sReqdDBGain = #SCS_INF_DBLEVEL
                      sCmdDetail + " chan o" + \s0BasedOutputRangeAG + " gain 0"
                    Else
                      sCmdDetail + " chan o" + \s0BasedOutputRangeAG + " gaindb " + sReqdDBGain
                    EndIf
                  EndIf
                EndIf
              EndIf
            EndWith
          EndIf
        EndIf
      EndIf
      
    Else  ; bInDevChgs = #True
      sLogicalDev = grProdForDevChgs\aAudioLogicalDevs(d)\sLogicalDev
      If sLogicalDev
        nDevMapPtr = grProdForDevChgs\nSelectedDevMapPtr
        If nDevMapPtr >= 0
          nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMapsForDevChgs, #SCS_DEVGRP_AUDIO_OUTPUT, sLogicalDev)
          If nDevMapDevPtr >= 0
            With grMapsForDevChgs\aDev(nDevMapDevPtr)
              If \bOutputMuteOn Or \bOutputMuteTmpOn
                fReqdGain = #SCS_MINVOLUME_SINGLE
              ElseIf \bUseFaderOutputGain
                fReqdGain = \fDevFaderOutputGain * grMasterLevel\fControllerFaderMasterBVLevel
              Else
                fReqdGain = \fDevOutputGain * grMasterLevel\fProdMasterBVLevel
              EndIf
              If gbUseBASS  ; BASS
                ; Added 28Sep2022 11.9.6
                If fReqdGain <= grLevels\fMinBVLevel
                  fReqdGain = 0.0
                EndIf
                ; End added 28Sep2022 11.9.6
                If \bBassASIO
                  If gbAsioInitDone
                    nBassResult = BASS_ASIO_SetDevice(\nBassASIODevice)
                    If bLogResults
                      debugMsg2(sProcName, "BASS_ASIO_SetDevice(" + \nBassASIODevice + ")", nBassResult)
                    EndIf
                    For nChannelNo = \nFirstASIOChannel To \nLastASIOChannel
                      nBassResult = BASS_ASIO_ChannelSetVolume(#BASSFALSE, nChannelNo, fReqdGain)
                      If bLogResults
                        debugMsg2(sProcName, "BASS_ASIO_ChannelSetVolume(#BASSFALSE, " + decodeHandle(nChannelNo) + ", " + formatLevel(fReqdGain) + ")", nBassResult)
                      EndIf
                    Next nChannelNo
                  EndIf
                ElseIf gbUseBASSMixer
                  If \nMixerStreamPtr >= 0
                    nBassChannel = gaMixerStreams(\nMixerStreamPtr)\nMixerStreamHandle
                    If nBassChannel <> 0
                      nBassResult = BASS_ChannelSetAttribute(nBassChannel, #BASS_ATTRIB_VOL, fReqdGain)
                      If bLogResults
                        debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nBassChannel) + ", #BASS_ATTRIB_VOL, " + formatLevel(fReqdGain) + ")", nBassResult)
                      EndIf
                    EndIf
                  EndIf
                EndIf
              Else  ; SM-S
                If grSMS\bInterfaceOpen
                  If Len(Trim(\s0BasedOutputRangeAG)) > 0
                    sReqdDBGain = convertBVLevelToDBString(fReqdGain)
                    If sReqdDBGain = #SCS_INF_DBLEVEL
                      sCmdDetail + " chan o" + \s0BasedOutputRangeAG + " gain 0"
                    Else
                      sCmdDetail + " chan o" + \s0BasedOutputRangeAG + " gaindb " + sReqdDBGain
                    EndIf
                  EndIf
                EndIf
              EndIf
            EndWith
          EndIf
        EndIf
      EndIf
      
    EndIf
    
  Next d
  
  If gbUseSMS
    If sCmdDetail
      sendSMSCommand("set " + Trim(sCmdDetail))
    EndIf
  EndIf
  
  bBlockRecursiveCall = #False
  
EndProcedure

Procedure setVidAudDevOutputGain(nDevNo, bInDevChgs=#False, bInitializingDev=#False)
  CompilerIf 1=2
    ; This procedure has been blocked out because TVG does not support adjusting the audio levels of a video file (or 'player'), it only supports
    ; adjusting the master level, via TVG_SetAudioVolume(), which is called when required
    PROCNAMEC()
    Protected nDevMapPtr, nDevMapDevPtr
    Protected sLogicalDev.s
    Protected fReqdGain.f
    Protected nBassResult.l, nChannelNo.l, nBassChannel.l
    Protected sCmdDetail.s
    Protected bLogResults
    Protected nFirstDev, nLastDev
    Protected d
    
    ; debugMsg(sProcName, #SCS_START + ", nDevNo=" + nDevNo + ", bInDevChgs=" + strB(bInDevChgs) + ", bInitializingDev=" + strB(bInitializingDev))
    
    CompilerIf #cTraceSetLevels
      bLogResults = #True
    CompilerElse
      If bInitializingDev
        bLogResults = #True
      EndIf
    CompilerEndIf
    
    If nDevNo >= 0
      nFirstDev = nDevNo
      nLastDev = nDevNo
    Else
      nFirstDev = 0
      nLastDev = grProd\nMaxVidAudLogicalDev
    EndIf
    
    For d = nFirstDev To nLastDev
      If bInDevChgs = #False
        sLogicalDev = grProd\aVidAudLogicalDevs(d)\sVidAudLogicalDev
        If sLogicalDev
          ; debugMsg(sProcName, "grProd\aAudioLogicalDevs(" + d + ")\sLogicalDev=" + grProd\aAudioLogicalDevs(d)\sLogicalDev)
          nDevMapPtr = grProd\nSelectedDevMapPtr
          ; debugMsg(sProcName, "grProd\nSelectedDevMapPtr=" + Str(grProd\nSelectedDevMapPtr))
          If nDevMapPtr >= 0
            nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_VIDEO_AUDIO, sLogicalDev)
            ; debugMsg(sProcName, "nDevMapDevPtr=" + nDevMapDevPtr)
            If nDevMapDevPtr >= 0
              With grMaps\aDev(nDevMapDevPtr)
                fReqdGain = \fDevOutputGain * grMasterLevel\fMasterBVLevel
                If bLogResults
                  debugMsg3(sProcName, "grMaps\aDev(" + nDevMapDevPtr + ")\fDevOutputGain=" + traceLevel(\fDevOutputGain) + ", grMasterLevel\fMasterBVLevel=" + traceLevel(grMasterLevel\fMasterBVLevel))
                EndIf
                ; no facility to apply a global level control on video audio outputs
              EndWith
            EndIf
          EndIf
        EndIf
        
      Else  ; bInDevChgs = #True
        sLogicalDev = grProdForDevChgs\aVidAudLogicalDevs(d)\sVidAudLogicalDev
        If sLogicalDev
          nDevMapPtr = grProdForDevChgs\nSelectedDevMapPtr
          If nDevMapPtr >= 0
            nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMapsForDevChgs, #SCS_DEVGRP_VIDEO_AUDIO, sLogicalDev)
            If nDevMapDevPtr >= 0
              With grMapsForDevChgs\aDev(nDevMapDevPtr)
                fReqdGain = \fDevOutputGain * grMasterLevel\fMasterBVLevel
                ; no facility to apply a global level control on video audio outputs
              EndWith
            EndIf
          EndIf
        EndIf
        
      EndIf
      
    Next d
  CompilerEndIf
  
EndProcedure

Procedure setInputGain(nDevNo, bInDevChgs=#False, bInitializingDev=#False)
  PROCNAMEC()
  Protected nDevMapPtr, nDevMapDevPtr
  Protected sLogicalDev.s
  Protected sCmdDetail.s
  Protected bLogResults
  Protected nFirstDev, nLastDev
  Protected d
  Protected sReqdInputGainDB.s
  
  ; debugMsg(sProcName, #SCS_START + ", nDevNo=" + nDevNo + ", bInDevChgs=" + strB(bInDevChgs) + ", bInitializingDev=" + strB(bInitializingDev))
  
  CompilerIf #cTraceSetLevels
    bLogResults = #True
  CompilerElse
    If bInitializingDev
      bLogResults = #True
    EndIf
  CompilerEndIf
  
  If nDevNo >= 0
    nFirstDev = nDevNo
    nLastDev = nDevNo
  Else
    nFirstDev = 0
    If bInDevChgs = #False
      nLastDev = grProd\nMaxLiveInputLogicalDevDisplay
    Else
      nLastDev = grProdForDevChgs\nMaxLiveInputLogicalDev
    EndIf
  EndIf
  
  For d = nFirstDev To nLastDev
    If bInDevChgs = #False
      sLogicalDev = grProd\aLiveInputLogicalDevs(d)\sLogicalDev
      If sLogicalDev
        nDevMapPtr = grProd\nSelectedDevMapPtr
        If nDevMapPtr >= 0
          nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_LIVE_INPUT, sLogicalDev)
          If nDevMapDevPtr >= 0
            With grMaps\aDev(nDevMapDevPtr)
              If gbUseSMS ; SM-S
                If grSMS\bInterfaceOpen
                  If Trim(\s0BasedInputRangeAG)
                    If \bInputMuteOn Or \bInputMuteTmpOn
                      sReqdInputGainDB = #SCS_INF_DBLEVEL
                    ElseIf \bUseFaderInputGain
                      sReqdInputGainDB = \sFaderInputGainDB
                      If bLogResults
                        debugMsg3(sProcName, "grMaps\aDev(" + nDevMapDevPtr + ")\sFaderInputGainDB=" + \sFaderInputGainDB)
                      EndIf
                    Else
                      sReqdInputGainDB = \sInputGainDB
                      If bLogResults
                        debugMsg3(sProcName, "grMaps\aDev(" + nDevMapDevPtr + ")\sInputGainDB=" + \sInputGainDB)
                      EndIf
                    EndIf
                    If sReqdInputGainDB = #SCS_INF_DBLEVEL
                      sCmdDetail + " chan i" + Trim(\s0BasedInputRangeAG) + " gain 0"
                    Else
                      sCmdDetail + " chan i" + Trim(\s0BasedInputRangeAG) + " gaindb " + sReqdInputGainDB
                    EndIf
                  EndIf
                EndIf
              EndIf
            EndWith
          EndIf
        EndIf
      EndIf
      
    Else  ; bInDevChgs = #True
      sLogicalDev = grProdForDevChgs\aLiveInputLogicalDevs(d)\sLogicalDev
      If sLogicalDev
        nDevMapPtr = grProdForDevChgs\nSelectedDevMapPtr
        If nDevMapPtr >= 0
          nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMapsForDevChgs, #SCS_DEVGRP_LIVE_INPUT, sLogicalDev)
          If nDevMapDevPtr >= 0
            With grMapsForDevChgs\aDev(nDevMapDevPtr)
              If gbUseSMS ; SM-S
                If grSMS\bInterfaceOpen
                  debugMsg(sProcName, "grMapsForDevChgs\aDev(" + nDevMapDevPtr + ")\s0BasedInputRangeAG=" + \s0BasedInputRangeAG + ", \nFirst0BasedInputChanAG=" + \nFirst0BasedInputChanAG)
                  If Trim(\s0BasedInputRangeAG)
                    If \bInputMuteOn Or \bInputMuteTmpOn
                      sReqdInputGainDB = #SCS_INF_DBLEVEL
                    ElseIf \bUseFaderInputGain
                      sReqdInputGainDB = \sFaderInputGainDB
                    Else
                      sReqdInputGainDB = \sInputGainDB
                    EndIf
                    If sReqdInputGainDB = #SCS_INF_DBLEVEL
                      sCmdDetail + " chan i" + Trim(\s0BasedInputRangeAG) + " gain 0"
                    Else
                      sCmdDetail + " chan i" + Trim(\s0BasedInputRangeAG) + " gaindb " + sReqdInputGainDB
                    EndIf
                  EndIf
                EndIf
              EndIf
            EndWith
          EndIf
        EndIf
      EndIf
      
    EndIf
  Next d
  
  If sCmdDetail
    sendSMSCommand("set " + Trim(sCmdDetail))
  EndIf
  
EndProcedure

Procedure setMasterFader(fMasterBVLevel.f, bInDevChgs=#False, bInitializingDev=#False)
  PROCNAMEC()
  Protected nBassResult.l
  Protected nBassMasterVol.l
  Protected nAudPtr, nDevNo, fBVLevelNow.f
  Protected i, j, k, n
  Protected sCmdString.s
  Protected bLogResults
  Static bBlockRecursiveCall ; added 23Apr2019 11.8.1ah

  ; debugMsg(sProcName, #SCS_START)
  
  ; added 23Apr2019 11.8.1ah
  If bBlockRecursiveCall
    ProcedureReturn
  EndIf
  bBlockRecursiveCall = #True
  ; end added 23Apr2019 11.8.1ah
  
  CompilerIf #cTraceSetLevels
    bLogResults = #True
  CompilerElse
    If bInitializingDev
      bLogResults = #True
    EndIf
  CompilerEndIf
  
  If fMasterBVLevel > #SCS_MINVOLUME_SINGLE
    grMMedia\bMastFaderMuted = #False
  EndIf
  
  With grMasterLevel
    If \bUseControllerFaderMasterBVLevel
      \fControllerFaderMasterBVLevel = fMasterBVLevel
      CompilerIf #cTraceSetLevels
        debugMsg(sProcName, "grMasterLevel\fControllerFaderMasterBVLevel=" + traceLevel(grMasterLevel\fControllerFaderMasterBVLevel))
      CompilerEndIf
    Else
      \fProdMasterBVLevel = fMasterBVLevel
      CompilerIf #cTraceSetLevels
        debugMsg(sProcName, "grMasterLevel\fProdMasterBVLevel=" + traceLevel(grMasterLevel\fProdMasterBVLevel))
      CompilerEndIf
    EndIf
    \fVideoVolumeFactor = fMasterBVLevel    ; factor used in video playback
  EndWith
  
  ; added 23Apr2019 11.8.1ah
  If WCN\nNrOfControllers > 0
    ; debugMsg0(sProcName, "calling WCN_setFader(#SCS_CTRLTYPE_MASTER, 1, ...)")
    WCN_setFader(#SCS_CTRLTYPE_MASTER, 1, SLD_BVLevelToSliderValue(fMasterBVLevel), #True)
  EndIf
  ; end added 23Apr2019 11.8.1ah
  
  ; debugMsg(sProcName, "gnCurrAudioDriver=" + decodeDriver(gnCurrAudioDriver) + ", gbUseBASS=" + strB(gbUseBASS) + ", gbUseBASSMixer=" + strB(gbUseBASSMixer))
  
  If gbUseBASS  ; BASS
    If gbUseBASSMixer = #False
      nBassMasterVol = fMasterBVLevel * 10000
      ;debugMsg(sProcName, "nMasterFader=" & formatLevel(fMasterBVLevel) & ", nBassMasterVol=" & nBassMasterVol)
      If nBassMasterVol < 0
        nBassMasterVol = 0
      ElseIf nBassMasterVol > 10000
        nBassMasterVol = 10000
      EndIf
      nBassResult = BASS_SetConfig(#BASS_CONFIG_GVOL_STREAM, nBassMasterVol)
      If bLogResults
        debugMsg2(sProcName, "BASS_SetConfig(BASS_CONFIG_GVOL_STREAM, " + nBassMasterVol + ")", nBassResult)
      EndIf
      
    Else  ; gbUseBASSMixer = #True
      setAllOutputGains(#False, bInitializingDev)
      
    EndIf
    
    ; debugMsg(sProcName, "calling setVolumeFactor()")
    setVolumeFactor()    ; sets factor used in VU displays
    
  Else ; SM-S
    setAllOutputGains(#False, bInitializingDev)
    
  EndIf
  
  nDevNo = 0
  Select grVideoDriver\nVideoPlaybackLibrary
    Case #SCS_VPL_TVG, #SCS_VPL_VMIX
      For n = 0 To ArraySize(grVidPicTarget())
        With grVidPicTarget(n)
          If \nMovieNo > 0
            ; debugMsg(sProcName, "grVidPicTarget(" + n + ")\nPrimaryAudPtr=" + getAudLabel(\nPrimaryAudPtr) + ", \nPrimaryAudPtr=" + getAudLabel(\nPrimaryAudPtr))
            k = \nPrimaryAudPtr
            If k >= 0
              fBVLevelNow = aAud(k)\fCueVolNow[nDevNo]
              ; debugMsg(sProcName, "calling setLevelsVideo(" + getAudLabel(k) + ", " + nDevNo + ", " + formatLevel(fBVLevelNow) + ", #SCS_NOPANCHANGE_SINGLE, " + n + ")")
              setLevelsVideo(k, nDevNo, fBVLevelNow, #SCS_NOPANCHANGE_SINGLE, n)
            EndIf
          EndIf
        EndWith
      Next n
  EndSelect
  
  If bInitializingDev = #False
    If gbMainFormLoaded
      ; debugMsg(sProcName, "calling setSaveSettings(#True)")
      setSaveSettings(#True)
    EndIf
  EndIf
  
  If gnVisMode = #SCS_VU_LEVELS
    ; need to call displayLabels() as this procedure also sets gaMeterBar(nOutputNr)\fVUOutputGain which is used in correctly displaying the VU levels and output gain markers
    displayLabels()
  EndIf
  
  grRAI\nStatus | #SCS_RAI_STATUS_MASTER
  
  bBlockRecursiveCall = #False ; added 23Apr2019 11.8.1ah
  
  ; debugMsg(sProcName, #SCS_END)
  
EndProcedure

; Procedure setDevFader(nCtrlNo, fDevBVLevel.f)
;   PROCNAMEC()
;   Protected nBassResult.l
;   Protected nBassMasterVol.l
;   
;   If WCN\nNrOfControllers > 0
;     debugMsg0(sProcName, "calling WCN_setFader(#SCS_CTRLTYPE_MASTER, 1, ...)")
;     WCN_setFader(#SCS_CTRLTYPE_OUTPUT, nCtrlNo, SLD_BVLevelToSliderValue(fDevBVLevel), #True)
;   EndIf
;   
; EndProcedure

Procedure setAllInputGains(bInDevChgs=#False, bInitializingDev=#False)
  ; PROCNAMEC()
  
  If gbUseSMS
    setInputGain(-1, bInDevChgs, bInitializingDev)
  EndIf
EndProcedure

Procedure setAllOutputGains(bInDevChgs=#False, bInitializingDev=#False)
  ; PROCNAMEC()
  
  setAudioDevOutputGain(-1, bInDevChgs, bInitializingDev)
  setVidAudDevOutputGain(-1, bInDevChgs, bInitializingDev)
  
EndProcedure

Procedure setMidiFilePosition(pAudPtr, pPosition)
  PROCNAMECA(pAudPtr)
  Protected nErrCode.l
  Protected sMidiAlias.s
  Protected sInitialMode.s
  Protected sCurrentMode.s
  Protected qTimeNow.q
  Protected sMciString.s
  Protected bDummyDev
  
  ; warning! all mciSendString calls must be from the same thread or mciSendString returns error 263 (not a registered device), so use main thread
  ASSERT_THREAD(#SCS_THREAD_MAIN)

  debugMsg(sProcName, #SCS_START)
  
  With aAud(pAudPtr)
    bDummyDev = gaMidiOutDevice(\nMidiPhysicalDevPtr)\bDummy
    debugMsg(sProcName, "gaMidiOutDevice(" + \nMidiPhysicalDevPtr + ")\bDummy=" + strB(gaMidiOutDevice(\nMidiPhysicalDevPtr)\bDummy) + ", bDummyDev=" + strB(bDummyDev))
    If bDummyDev = #False
      sMidiAlias = \sMidiAlias
      gnPositioningMidi + 1
      
      ; sInitialMode = getMidiMode(sMidiAlias)
      sInitialMode = getMidiMode(pAudPtr)
      debugMsg3(sProcName, sMidiAlias + " sInitialMode=" + sInitialMode)
      
      ; set the time format to milliseconds
      sMciString = "set " + sMidiAlias + " time format milliseconds"
      nErrCode = mciSendString_(sMciString, #Null, 0, #Null)
      debugMsg2(sProcName, "mciSendString_(" + sMciString + ", #Null, 0, #Null)", nErrCode)
      
      sMciString = "seek " + sMidiAlias + " to " + Str(pPosition)
      nErrCode = mciSendString_(sMciString, #Null, 0, #Null)
      debugMsg2(sProcName, "mciSendString_(" + sMciString + ", #Null, 0, #Null)", nErrCode)
      If nErrCode <> 0
        displayMidiError(nErrCode, sMciString, sProcName)
        ProcedureReturn
      EndIf
      
      sCurrentMode = "seeking"
      qTimeNow = ElapsedMilliseconds()
      While sCurrentMode = "seeking" And ElapsedMilliseconds() < (qTimeNow + 2000)
        sCurrentMode = getMidiMode(pAudPtr)
        Delay(2)
      Wend
      debugMsg3(sProcName, sMidiAlias + " sCurrentMode=" + sCurrentMode)
      
      If (sInitialMode = "playing") And (sCurrentMode = "paused")
        sMciString = "resume " + sMidiAlias
        nErrCode = mciSendString_(sMciString, #Null, 0, #Null)
        debugMsg2(sProcName, "mciSendString_(" + sMciString + ", #Null, 0, #Null)", nErrCode)
        If nErrCode <> 0
          ; resume failed so try play
          sMciString = "play " + sMidiAlias
          nErrCode = mciSendString_(sMciString, #Null, 0, #Null)
          debugMsg2(sProcName, "mciSendString_(" + sMciString + ", #Null, 0, #Null)", nErrCode)
        EndIf
      EndIf
      
      ; delay clearing this gnPositioningMidi to ensure we don't clear this before StatusCheck is ready (around label 1050)
      samAddRequest(#SCS_SAM_CLEAR_POSITIONING_MIDI, 0, 0, 0, "", ElapsedMilliseconds()+500)
    EndIf
  EndWith
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure startAsioDevices()
  PROCNAMEC()
  Protected d, nBassResult.l
  Protected nErrorCode.l
  Protected dMyAsioSampleRate.d, nLatency.l
  Protected nBufLen.l
  Protected nPrevDevice, bPrevDevStarted

  debugMsg(sProcName, #SCS_START)
  
  nPrevDevice = -1
  
  If (gbAsioInitDone) And (gbAsioStarted = #False)
    
    For d = 0 To ArraySize(gaMixerStreams())
      With gaMixerStreams(d)
        If \bASIO
          If (\nBassASIODevice = nPrevDevice) And (bPrevDevStarted)
            Continue
          EndIf
          nBassResult = BASS_ASIO_SetDevice(\nBassASIODevice) ; set the ASIO device to work with
          debugMsg2(sProcName, "BASS_ASIO_SetDevice(" + \nBassASIODevice + ")", nBassResult)
          
          nBassResult = BASS_ASIO_IsStarted()
          debugMsg2(sProcName, "BASS_ASIO_IsStarted", nBassResult)
          nPrevDevice = \nBassASIODevice
          If nBassResult = #BASSTRUE
            bPrevDevStarted = #True
          Else
            CompilerIf #c_omit_bass_asio_setrate = #False
              dMyAsioSampleRate = \nSampleRate  ; convert to double
              nBassResult = BASS_ASIO_SetRate(dMyAsioSampleRate) ; try to set the device rate too (saves resampling)
              debugMsg2(sProcName, "BASS_ASIO_SetRate(" + StrD(dMyAsioSampleRate,0) + ")", nBassResult)
              If nBassResult = #BASSFALSE
                nErrorCode = BASS_ASIO_ErrorGetCode()
                debugMsg3(sProcName, "BASS_ASIO_ErrorGetCode=" + nErrorCode + " (" + getBassErrorDesc(nErrorCode) + ")")
              EndIf
            CompilerEndIf
            
            CompilerIf #cEnableASIOBufLen
              nBufLen = gaAudioDev(\nPhysicalDevPtr)\nAsioBufLen
            CompilerElse
              nBufLen = 0
            CompilerEndIf
            nBassResult = BASS_ASIO_Start(nBufLen, 0)
            debugMsg2(sProcName, "BASS_ASIO_Start(" + nBufLen + ", 0) for ASIO device " + \nBassASIODevice, nBassResult)
            If nBassResult = #BASSTRUE
              bPrevDevStarted = #True
            Else
              ; ASIO_Error_(sProcName, "Can't start ASIO output")
              debugMsg(sProcName, "exiting because BASS_ASIO_Start() returned #False")
              ProcedureReturn
            EndIf
            CompilerIf #c_omit_bass_asio_setrate = #False
              dMyAsioSampleRate = BASS_ASIO_GetRate()
              If dMyAsioSampleRate > 0
                nLatency = BASS_ASIO_GetLatency(#BASSFALSE)
                debugMsg2(sProcName, "BASS_ASIO_GetLatency(BASSFALSE)", nLatency)
                debugMsg3(sProcName, "output latency = " + StrD(nLatency * 1000.0 / dMyAsioSampleRate, 3))
              EndIf
            CompilerEndIf
            
          EndIf
          
        EndIf
      EndWith
    Next d
    
    gbAsioStarted = #True
    
  EndIf
  
  debugMsg(sProcName, "calling setMasterFader(" + formatLevel(grProd\fMasterBVLevel) + ")")
  setMasterFader(grProd\fMasterBVLevel)
  debugMsg(sProcName, "calling setAllInputGains()")
  setAllInputGains()
  debugMsg(sProcName, "calling setAllLiveEQ()")
  setAllLiveEQ()
  
  debugMsg(sProcName, #SCS_END)

EndProcedure

Procedure startAsioMixerStreams()
  PROCNAMEC()
  Protected d, n
  Protected nBassResult.l, nErrorCode.l, sErrorMsg.s
  Protected nFirstASIOChannel.l
  Protected rChanInfo.BASS_CHANNELINFO
  
  debugMsg(sProcName, #SCS_START)
  
  For d = 0 To ArraySize(gaMixerStreams())
    With gaMixerStreams(d)
      If \bASIO
        debugMsg(sProcName, "gaMixerStreams(" + d + ")\nFirstOutputChannel=" + \nFirstOutputChannel)
        nBassResult = BASS_ASIO_SetDevice(\nBassASIODevice) ; set the ASIO device to work with
        debugMsg2(sProcName, "BASS_ASIO_SetDevice(" + \nBassASIODevice + ")", nBassResult)
        
        ; get channel info to get number of channels to be joined, and frequency (sample rate)
        nBassResult = BASS_ChannelGetInfo(\nMixerStreamHandle, @rChanInfo)
        debugMsg2(sProcName, "BASS_ChannelGetInfo(" + decodeHandle(\nMixerStreamHandle) + ", rChanInfo)", nBassResult)
        \nSampleRate = rChanInfo\freq
        
        nFirstASIOChannel = \nFirstOutputChannel
        nBassResult = BASS_ASIO_ChannelEnableBASS(#BASSFALSE, nFirstASIOChannel, \nMixerStreamHandle, #True)
        debugMsg2(sProcName, "BASS_ASIO_ChannelEnableBASS(BASSFALSE, " + nFirstASIOChannel + ", " + decodeHandle(\nMixerStreamHandle) + ", #True)", nBassResult)
        If nBassResult = #BASSFALSE
          nErrorCode = BASS_ASIO_ErrorGetCode()
          If nErrorCode = #BASS_ERROR_ILLPARAM
            sErrorMsg = LangPars("Errors", "CannotEnableASIOChan", Str(nFirstASIOChannel))
            debugMsg3(sProcName, sErrorMsg)
            ensureSplashNotOnTop()
            scsMessageRequester("SCS Device Initialization", sErrorMsg, #PB_MessageRequester_Error)
            \bRecreateMixerStream = #True
          Else
            debugMsg3(sProcName, "BASS_ASIO_ErrorGetCode=" + nErrorCode + " (" + getBassErrorDesc(nErrorCode) + ")")
            ASIO_Error_(sProcName, "Can't enable ASIO channel")
            ProcedureReturn
          EndIf
        EndIf ; EndIf nBassResult = #BASSFALSE
      EndIf ; EndIf \bASIO
    EndWith
  Next d
  
  ; after all channel-enables and channel-joins have been done, start the ASIO devices used
  startAsioDevices()
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure stopAll(bCompleteCues, bJustStop, bIncludeHibernatedCues=#False)
  PROCNAMEC()
  Protected i, j
  
  debugMsg(sProcName, #SCS_START + ", bCompleteCues=" + strB(bCompleteCues) + ", bJustStop=" + strB(bJustStop) + ", bIncludeHibernatedCues=" + strB(bIncludeHibernatedCues))
  
  stopAllEarlierCues(gnLastCue + 1, #True, "ALL", bJustStop, #False, #False, #SCS_SFR_CUE_ALL_ANY, -99, -99, #False, #False, #False, bIncludeHibernatedCues)

  For i = 1 To gnLastCue
    
    If bCompleteCues
      If aCue(i)\bNonLinearCue = #False
        If (aCue(i)\bCueCurrentlyEnabled) And (aCue(i)\nCueState <> #SCS_CUE_IGNORED)
          j = aCue(i)\nFirstSubIndex
          While j >= 0
            If aSub(j)\bSubEnabled
              If (aSub(j)\nSubState <> #SCS_CUE_HIBERNATING) Or (bIncludeHibernatedCues)
                If grProd\nRunMode = #SCS_RUN_MODE_LINEAR
                  endOfSub(j, #SCS_CUE_COMPLETED)
                Else
                  endOfSub(j, #SCS_CUE_NOT_LOADED)
                EndIf
                debugMsg(sProcName, "calling closeSub(" + getSubLabel(j) + ")")
                closeSub(j)
              EndIf
            EndIf
            j = aSub(j)\nNextSubIndex
          Wend
          setCueState(i)
          If bJustStop = #False
            updateGrid(i)
          EndIf
        EndIf
      EndIf
    EndIf
    
    If aCue(i)\bStopOpenNextCuesHere
      debugMsg(sProcName, "clearing aCue(" + getCueLabel(i) + ")\bStopOpenNextCuesHere")
      aCue(i)\bStopOpenNextCuesHere = #False
    EndIf
    
  Next i
  
  hideMonitorsNotInUse()

  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure stopAtTrackEndAllEarlierCues(pCuePtr, nSFRCueType=#SCS_SFR_CUE_ALL_ANY, nExcludeCuePtr=-1, bExcludeSFRCueList=#False, bSFRCompleteAssocAutoStartCues=#False)
  PROCNAMECQ(pCuePtr)
  Protected i, j, k, n
  Protected nItemState, bWantThisCue, bWantThisSub
  Protected bThisCueChanged, bAnyCueChanged
  Protected bAnyCues, bPlayingCuesOnly, bAudioOnly, bVideoOnly, bLiveOnly
  
  debugMsg(sProcName, #SCS_START + ", pCuePtr=" + pCuePtr + ", nSFRCueType=" + decodeSFRCueType(nSFRCueType))
  
  setProcSFRFlags(nSFRCueType)  ; macro sets bPlayingCuesOnly, bAudioOnly and bVideoOnly, based on nSRCueType
  debugMsg(sProcName, "bPlayingCuesOnly=" + strB(bPlayingCuesOnly) + ", bAudioOnly=" + strB(bAudioOnly) + ", bVideoOnly=" + strB(bVideoOnly) + ", bLiveOnly=" + strB(bLiveOnly))
  
  For i = 1 To (pCuePtr - 1)
    bThisCueChanged = #False
    nItemState = aCue(i)\nCueState
    setWantThisCue(i)
    If bWantThisCue
      If aCue(i)\nActivationMethod = #SCS_ACMETH_AUTO
        If aCue(i)\nAutoActCuePtr = nExcludeCuePtr
          bWantThisCue = #False
        EndIf
      EndIf
    EndIf
    If bExcludeSFRCueList
      For n = 0 To grMMedia\nSFRCueMax
        If grMMedia\anSFRCuePtr[n] = i
          bWantThisCue = #False
          Break
        EndIf
      Next n
    EndIf
    If bWantThisCue
      j = aCue(i)\nFirstSubIndex
      While j >= 0
        With aSub(j)
          nItemState = \nSubState
          setWantThisSub(j)
          If (bWantThisSub) And (\nSubState <> #SCS_CUE_HIBERNATING)
            If aSub(j)\bSubTypeAorP
              If (aSub(j)\nSubState >= #SCS_CUE_COUNTDOWN_TO_START) And (aSub(j)\nSubState <= #SCS_CUE_FADING_OUT)
                aSub(j)\bPLTerminating = #True
                debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\bPLTerminating=" + strB(aSub(j)\bPLTerminating))
                bThisCueChanged = #True
              EndIf
            EndIf
          EndIf
          j = \nNextSubIndex
        EndWith
      Wend
      
      If bThisCueChanged
        bAnyCueChanged = #True
        setCueState(i)
        debugMsg(sProcName, "calling updateGrid(" + i + ")")
        updateGrid(i)
      EndIf
    EndIf
  Next i
  
  If bAnyCueChanged
    gnCallOpenNextCues = 1
    debugMsg(sProcName, "gnCallOpenNextCues=" + gnCallOpenNextCues)
    debugMsg(sProcName, "(5) setting gbCallLoadDispPanels=#True")
    gbCallLoadDispPanels = #True
    debugMsg(sProcName, "calling setCueToGo()")
    setCueToGo()
    gbCallSetNavigateButtons = #True
    hideMonitorsNotInUse()
  EndIf

EndProcedure

Procedure stopChannelSlides(pAudPtr)
  PROCNAMEC()
  Protected d
  
  getChannelAttributes(pAudPtr)
  With aAud(pAudPtr)
    For d = \nFirstSoundingDev To \nLastSoundingDev
      If \nBassChannel[d] <> 0
        slideChannelAttributes(pAudPtr, d, \fCueVolNow[d], \fCuePanNow[d], 0, 240001)
      EndIf
    Next d
  EndWith
EndProcedure

Procedure stopCue(pCuePtr, pTypesToStop.s, bOpenNextCues, bUseCas = #False)
  PROCNAMECQ(pCuePtr)
  Protected j
  
  logKeyEvent("Stop Cue " + getCueLabel(pCuePtr))
  
  debugMsg(sProcName, "pTypesToStop=" + pTypesToStop)

  j = aCue(pCuePtr)\nFirstSubIndex
  While j >= 0
    If aSub(j)\bSubEnabled
      stopSub(j, pTypesToStop, #False, #False, bUseCas)
    EndIf
    j = aSub(j)\nNextSubIndex
  Wend
  Select aCue(pCuePtr)\nActivationMethod
    Case #SCS_ACMETH_EXT_TOGGLE
      aCue(pCuePtr)\nExtActToggleState = 0
  EndSelect
  ; added 29Jan2019 11.8.0.2ad to help sort out issue with Auto-Start after Load not starting in Marco's "SPACE JOURNEY DEMO - Low Q.scs11"
  aCue(pCuePtr)\bTimeToStartCueSet = #False
  ; end added 29Jan2019 11.8.0.2ad

  If bOpenNextCues
    If aCue(pCuePtr)\nCueState = #SCS_CUE_COMPLETED
      gnCallOpenNextCues = 1
      debugMsg(sProcName, "gnCallOpenNextCues=" + gnCallOpenNextCues)
      If aCue(pCuePtr)\nHideCueOpt = #SCS_HIDE_NO
        If (aCue(pCuePtr)\bHotkey) Or (aCue(pCuePtr)\bExtAct) Or (aCue(pCuePtr)\bCallableCue)
          If (grOperModeOptions(gnOperMode)\bShowHotkeyCuesInPanels)
            debugMsg(sProcName, "setting gbCallLoadDispPanels=#True")
            gbCallLoadDispPanels = #True
          EndIf
        Else
          debugMsg(sProcName, "setting gbCallLoadDispPanels=#True")
          gbCallLoadDispPanels = #True
        EndIf
      EndIf
      debugMsg(sProcName, "calling setCueToGo()")
      setCueToGo()
      gbCallSetNavigateButtons = #True
    EndIf
  EndIf

EndProcedure

Procedure stopOneSub(pSubPtr, pTypesToStop.s, bJustStop, bUseCas=#False, bTypeUStopsMTC=#True)
  PROCNAMECS(pSubPtr)
  Protected d, k, nAudPtr, nStartingAudPtr
  Protected bDoCloseSub, bCheckStandby, bKeepOpen, nReqdNewState
  Protected nBassResult.l
  Protected nMyVidPicTarget
  Protected bHotkey, bExtAct, bCallableCue
  Protected nChannel.l, nAltChannel.l, nSplitterStream.l
  Protected fBVLevel.f
  Protected nDisplayPos
  Protected qBytePos.q
  Protected bHoldIgnoreInStatusCheck
  Protected bStopAllTypes
  Protected bCompleteCue
  Protected nVidPicTarget
  Protected nThisSubsCuePtr ; this Sub's CuePtr
  
  With aSub(pSubPtr)
    debugMsg(sProcName, #SCS_START + ", \sSubType=" + \sSubType + ", pTypesToStop=" + pTypesToStop + ", bJustStop=" + strB(bJustStop) + ", bUseCas=" + strB(bUseCas) + ", bTypeUStopsMTC=" + strB(bTypeUStopsMTC))
    bHotkey = \bHotkey
    bExtAct = \bExtAct
    bCallableCue = \bCallableCue
    bHoldIgnoreInStatusCheck = \bIgnoreInStatusCheck
    If gbFadingEverything = #False ; Test added 4Jun2021 11.8.5
      \bIgnoreInStatusCheck = #True
      ; debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\bIgnoreInStatusCheck=" + strB(aSub(pSubPtr)\bIgnoreInStatusCheck))
    EndIf
    nThisSubsCuePtr = \nCueIndex ; This Sub's CuePtr
  EndWith
  
  With aCue(nThisSubsCuePtr)
    ; NB nReqdNewState is not used for subcues that have associated files, ie not for subtypes A, F, M or the LTC mode of U,
    ; because these may need to be set to 'not loaded' rather than 'ready'.
    ; It is used for other subtypes.
    If \nActivationMethod = #SCS_ACMETH_HK_STEP
      nReqdNewState = #SCS_CUE_COMPLETED
    ElseIf \bNonLinearCue Or \bHotkey Or \bExtAct Or \bCallableCue
      nReqdNewState = #SCS_CUE_READY
    Else
      nReqdNewState = #SCS_CUE_COMPLETED
    EndIf
  EndWith

  ; debugMsg(sProcName, "aCue(" + getCueLabel(nThisSubsCuePtr) + ")\nCueState=" + decodeCueState(aCue(nThisSubsCuePtr)\nCueState))
  
  If pTypesToStop = "ALL"
    bStopAllTypes = #True
  EndIf
  
  ; debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\bSubTypeHasAuds=" + strB(aSub(pSubPtr)\bSubTypeHasAuds) + ", \nFirstAudIndex=" + aSub(pSubPtr)\nFirstAudIndex)
  If (aSub(pSubPtr)\bSubTypeHasAuds) And (aSub(pSubPtr)\nFirstAudIndex >= 0)
    If (bStopAllTypes) Or
       (FindString(pTypesToStop, "F") > 0) Or
       (FindString(pTypesToStop, "A") > 0) Or
       (FindString(pTypesToStop, "I") > 0) Or
       (FindString(pTypesToStop, "M") > 0) Or
       (FindString(pTypesToStop, "P") > 0)
      
      If gbFadingEverything = #False ; Test added 4Jun2021 11.8.5
        k = aSub(pSubPtr)\nFirstAudIndex
        While k >= 0
          aAud(k)\bIgnoreInStatusCheck = #True
          ; debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\bIgnoreInStatusCheck=" + strB(aAud(k)\bIgnoreInStatusCheck))
          k = aAud(k)\nNextAudIndex
        Wend
      EndIf
      
      With aSub(pSubPtr)
        If aCue(nThisSubsCuePtr)\nActivationMethod <> #SCS_ACMETH_TIME And aCue(nThisSubsCuePtr)\nActivationMethod <> #SCS_ACMETH_HK_STEP ; Added #SCS_ACMETH_TIME test 3Dec2021 11.8.6cq, #SCS_ACMETH_HK_STEP test 1Mar2022 11.9.1ad
          If (\bHotkey Or \bExtAct Or \bCallableCue) And (\bSubTypeA = #False)
            ; nb video hotkey cues are not kept open
            bKeepOpen = #True
            ; debugMsg(sProcName, "bKeepOpen=" + strB(bKeepOpen))
            
          ; ElseIf ((\bSubTypeAorP) And (\bPLRepeat) And (\nAudCount <= 2) And (\bPLTerminating = #False)) Or (aCue(\nCueIndex)\nStandby = #SCS_STANDBY_SET) Or (\bStartedInEditor)
          ElseIf ((\bSubTypeAorP) And (getPLRepeatActive(pSubPtr)) And (\nAudCount <= 2) And (\bPLTerminating = #False)) Or (aCue(\nCueIndex)\nStandby = #SCS_STANDBY_SET) Or (\bStartedInEditor)
            bKeepOpen = #True
            ; debugMsg(sProcName, "bKeepOpen=" + strB(bKeepOpen))
            
            ; Commented out 20Dec2021 11.8.6cx following bug report from Jason (LONGJOIN) where an auto-start cue didn't auto-start after the end of the specified cue.
            ; The following (now commented out) code to set bKeepOpen #True is not required, as the original cue's state MUST be set to Comnpleted for the auto-start to work,
            ; and 'Open Next Cues' will then re-open the cue anyway (after the auto-start was successfully actioned).
;           ElseIf ((grProd\nRunMode = #SCS_RUN_MODE_NON_LINEAR_PREOPEN_ALL) Or ((grProd\nRunMode = #SCS_RUN_MODE_BOTH_PREOPEN_ALL) And (aCue(\nCueIndex)\bNonLinearCue))) And (\bSubTypeA = #False)
;             ; non-linear mode (pre-load all cues)
;             If aCue(\nCueIndex)\bUnloadWhenEnded = #False
;               bKeepOpen = #True
;               ; debugMsg(sProcName, "bKeepOpen=" + strB(bKeepOpen))
;             EndIf
            ; End of commented out 20Dec2021 11.8.6cx
          EndIf
        EndIf
        
        If \bSubTypeAorP
          debugMsg(sProcName, "\nCurrPlayIndex=" + getAudLabel(\nCurrPlayIndex))
          nAudPtr = \nCurrPlayIndex
          If nAudPtr >= 0
            If aAud(nAudPtr)\nSubIndex <> pSubPtr
              debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\nSubIndex=" + getSubLabel(aAud(nAudPtr)\nSubIndex) + " so setting nAudPtr=" + getAudLabel(\nFirstPlayIndex))
              nAudPtr = \nFirstPlayIndex
            EndIf
          Else
            nAudPtr = \nFirstPlayIndex
          EndIf
        Else
          nAudPtr = \nFirstPlayIndex
        EndIf
        nStartingAudPtr = nAudPtr
        
      EndWith
      
      debugMsg(sProcName, "nAudPtr=" + getAudLabel(nAudPtr) + ", bKeepOpen=" + strB(bKeepOpen) + ", nStartingAudPtr=" + getAudLabel(nStartingAudPtr))
      While nAudPtr >= 0
        With aAud(nAudPtr)
          ; debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\nAudState=" + decodeCueState(\nAudState))
          If \nAudState <= #SCS_CUE_COMPLETED
            If bKeepOpen = #False
              debugMsg(sProcName, "calling StopOrFadeOutAudChannels(" + getAudLabel(nAudPtr) + ", #False, #True, " + strB(bUseCas) + ", " + decodeVidPicTarget(\nAudVidPicTarget) + ")")
              StopOrFadeOutAudChannels(nAudPtr, #False, #True, bUseCas, \nAudVidPicTarget)
              If aCue(\nCueIndex)\nActivationMethod = #SCS_ACMETH_HK_STEP
                ; 'step' hotkey completed
                debugMsg(sProcName, "calling endOfAud(" + getAudLabel(nAudPtr) + ", " + decodeCueState(#SCS_CUE_COMPLETED) + ")")
                endOfAud(nAudPtr, #SCS_CUE_COMPLETED)
                bDoCloseSub = #True
                \nCuePos = \nCueDuration - 1
                \nRelFilePos = \nCueDuration - 1
                
              ElseIf (grProd\nRunMode = #SCS_RUN_MODE_NON_LINEAR_OPEN_ON_DEMAND) Or ((grProd\nRunMode = #SCS_RUN_MODE_BOTH_OPEN_ON_DEMAND) And (aCue(\nCueIndex)\bNonLinearCue))
                ; non-linear mode (load_on_demand)
                \nAudState = #SCS_CUE_NOT_LOADED
                bDoCloseSub = #True
                \nCuePos = grAudDef\nCuePos
                \nRelFilePos = grAudDef\nRelFilePos
                
              ElseIf (\bAudTypeA) And
                     (aSub(\nSubIndex)\bHotkey Or aSub(\nSubIndex)\bExtAct Or aSub(\nSubIndex)\bCallableCue) And 
                     \nAudState = #SCS_CUE_NOT_LOADED
                ; video hotkey cues are not kept open
                bDoCloseSub = #True
                \nCuePos = grAudDef\nCuePos
                \nRelFilePos = grAudDef\nRelFilePos
                ; ONC_openNextCues is to be called because playing this video hotkey cue may have caused another video cue to be unloaded, and that cue may now be reloaded
                ;gbCallOpenNextCues = True
                debugMsg(sProcName, "calling samAddRequest(#SCS_SAM_OPEN_NEXT_CUES,...+3000")
                samAddRequest(#SCS_SAM_OPEN_NEXT_CUES, 0, 0, -1, "", ElapsedMilliseconds()+3000)
                
              Else
                debugMsg(sProcName, "calling endOfAud(" + getAudLabel(nAudPtr) + ", " + decodeCueState(#SCS_CUE_COMPLETED) + ")")
                endOfAud(nAudPtr, #SCS_CUE_COMPLETED)
                bDoCloseSub = #True
                \nCuePos = \nCueDuration - 1
                \nRelFilePos = \nCueDuration - 1
              EndIf
              
            Else
              ; bKeepOpen = #True, so reset sub
              
              ; Commented out because this delay affects other playing cues - reported by Christian Peters. 
              ; Delay coding now added to stopEverything() - 20Jun2018 11.7.1RC4
              ; If gbFadingEverything
              ;   If gbFadingEverythingDelayCompleted = #False
              ;     ; set this delay following bug reported by email from Jens Aage Jrgensen 13Apr2018.
              ;     ; a 'fade all' ignored the 'fade all time' set in Options if the cue is a hotkey cue.
              ;     Delay(gnFadeEverythingTime + 150)
              ;     gbFadingEverythingDelayCompleted = #True
              ;   EndIf
              ; EndIf
              
              debugMsg(sProcName, "nAudPtr=" + getAudLabel(nAudPtr) + ", nEditAudPtr=" + getAudLabel(nEditAudPtr) + ", gbEditing=" + strB(gbEditing) + ", \nFileFormat=" + decodeFileFormat(\nFileFormat))
              If (\nFileFormat = #SCS_FILEFORMAT_VIDEO) Or (\nFileFormat = #SCS_FILEFORMAT_PICTURE)
                debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\nAudState=" + decodeCueState(\nAudState))
                If (\nAudState <> #SCS_CUE_READY) And (\nAudState <> #SCS_CUE_PL_READY)
                  If gbEditing
                    If nEditAudPtr = nAudPtr
                      If grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_VMIX
                        debugMsg(sProcName, "calling stopAud(" + getAudLabel(nAudPtr) + ", #True, #False, #True)")
                        stopAud(nAudPtr, #True, #False, #True)
                      ElseIf (\nFileFormat = #SCS_FILEFORMAT_VIDEO) Or
                         ((\nFileFormat = #SCS_FILEFORMAT_PICTURE) And (grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG) And (checkUse2DDrawing(pSubPtr) = #False))
                        debugMsg(sProcName, "calling stopAud(" + getAudLabel(nAudPtr) + ", #True, #False, #True)")
                        stopAud(nAudPtr, #True, #False, #True)
                        nDisplayPos = \nAbsStartAt
                        samAddRequest(#SCS_SAM_SHOW_VIDEO_FRAME, nAudPtr, 0, nDisplayPos)
                      EndIf
                      nMyVidPicTarget = \nAudVidPicTarget
                      If grVidPicTarget(nMyVidPicTarget)\nPrimaryAudPtr = nAudPtr
                        grVidPicTarget(nMyVidPicTarget)\nPrimaryAudPtr = -1
                        debugMsg(sProcName, "grVidPicTarget(" + decodeVidPicTarget(nMyVidPicTarget) + ")\nPrimaryAudPtr=" + getAudLabel(grVidPicTarget(nMyVidPicTarget)\nPrimaryAudPtr))
                      EndIf
                    EndIf
                  Else
                    debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\nAudState=" + decodeCueState(\nAudState) + ", \nAudVidPicTarget=" + decodeVidPicTarget(\nAudVidPicTarget))
                    nMyVidPicTarget = \nAudVidPicTarget
                    debugMsg(sProcName, "calling closeAud(" + getAudLabel(nAudPtr) + ")")
                    closeAud(nAudPtr)
                    If (nMyVidPicTarget <> #SCS_VID_PIC_TARGET_P) And (nMyVidPicTarget <> #SCS_VID_PIC_TARGET_NONE)
                      debugMsg(sProcName, "calling openMediaFile(" + getAudLabel(nAudPtr) + ", #False, " + decodeVidPicTarget(nMyVidPicTarget) + ")")
                      openMediaFile(nAudPtr, #False, nMyVidPicTarget)
                    EndIf
                  EndIf
                EndIf
              ElseIf \nAudState >= #SCS_CUE_READY
                If bHotkey Or bExtAct Or bCallableCue
                  debugMsg(sProcName, "calling stopAud(" + GetAudLabel(nAudPtr) + ", " + strB(bKeepOpen) + ", " + strB(bUseCas) + ")")
                  stopAud(nAudPtr, bKeepOpen, bUseCas)
                  fBVLevel = 0.0
                  If gbUseBASS  ; BASS
                    For d = \nFirstSoundingDev To \nLastSoundingDev
                      nChannel = \nBassChannel[d]
                      If d = \nFirstSoundingDev
                        nSplitterStream = nChannel
                      EndIf
                      nAltChannel = \nBassAltChannel[d]
                      nBassResult = BASS_ChannelSetAttribute(nChannel, #BASS_ATTRIB_VOL, fBVLevel)
                      If nAltChannel <> 0
                        nBassResult = BASS_ChannelSetAttribute(nAltChannel, #BASS_ATTRIB_VOL, fBVLevel)
                      EndIf
                      \bCueVolManual[d] = #False
                      \bCuePanManual[d] = #False
                    Next d
                  Else ; SM-S
                    \bSetLevelsWhenPlayAud = #False
                    For d = \nFirstSoundingDev To \nLastSoundingDev
                      If \nFadeInTime > 0
                        setLevelsAny(nAudPtr, d, #SCS_MINVOLUME_SINGLE, \fPan[d])
                        \bCueVolManual[d] = #False
                        \bCuePanManual[d] = #False
                        \bSetLevelsWhenPlayAud = #True
                      ElseIf (\fCueVolNow[d] <> \fBVLevel[d]) Or (\fCuePanNow[d] <> \fPan[d])
                        setLevelsAny(nAudPtr, d, \fBVLevel[d], \fPan[d])
                        \bCueVolManual[d] = #False
                        \bCuePanManual[d] = #False
                        \bSetLevelsWhenPlayAud = #True
                      EndIf
                    Next d
                    debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\bSetLevelsWhenPlayAud=" + strB(\bSetLevelsWhenPlayAud))
                  EndIf
                  If \bAudTypeI = #False
                    debugMsg(sProcName, "calling setAudChannelPositions(" + getAudLabel(nAudPtr) + ", " + ttszt(\nAbsStartAt) + ", #False ," + \qStartAtBytePos + ")")
                    setAudChannelPositions(nAudPtr, \nAbsStartAt, #False, \qStartAtBytePos)
                    If \bUsingSplitStream
                      nBassResult = BASS_Split_StreamReset(nSplitterStream)
                      debugMsg2(sProcName, "BASS_Split_StreamReset(" + decodeHandle(nSplitterStream) + ")", nBassResult)
                      qBytePos = BASS_ChannelGetPosition(nSplitterStream, #BASS_POS_BYTE)
                      debugMsg3(sProcName, "BASS_ChannelGetPosition(" + decodeHandle(nSplitterStream) + ", BASS_POS_BYTE) returned " + qBytePos)
                      ; Added 25Nov2022 11.9.7am
                      If qBytePos = -1
                        debugMsg(sProcName, "Error " + BASS_ErrorGetCode() + ": " + getBassErrorDesc(BASS_ErrorGetCode()))
                        qBytePos = 0
                      EndIf
                      ; End added 25Nov2022 11.9.7am
                    EndIf
                  EndIf
                  If gbUseBASSMixer
                    ; debugMsg(sProcName, "calling pauseAud(" + getAudLabel(nAudPtr) + ")")
                    ; pauseAud(nAudPtr)
                  Else
                    If gbUseBASS
                      d = \nFirstSoundingDev
                      If d >= 0
                        nBassResult = BASS_ChannelIsActive(\nBassChannel[d])
                        debugMsg2(sProcName, "BASS_ChannelIsActive(" + decodeHandle(\nBassChannel[d]) + ")", nBassResult)
                        If nBassResult = #BASS_ACTIVE_PLAYING
                          stopAud(nAudPtr, bKeepOpen, bUseCas)
                        EndIf
                      EndIf
                    Else ; SM-S
                      stopAud(nAudPtr, bKeepOpen)
                    EndIf
                  EndIf
                  \bAffectedByLevelChange = #False
                  \nLevelChangeSubPtr = -1
                  \bIncDecLevelSet = #False
                Else
                  debugMsg(sProcName, "calling stopAud(" + GetAudLabel(nAudPtr) + ", " + strB(bKeepOpen) + ", " + strB(bUseCas) + ")")
                  stopAud(nAudPtr, bKeepOpen, bUseCas)
                EndIf
              EndIf
              \nLoopPassNo = 0
              debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex + ", \nLoopPassNo=" + \nLoopPassNo)
              If (aCue(\nCueIndex)\nStandby = #SCS_STANDBY_SET) And (aSub(\nSubIndex)\bStartedInEditor = #False) And (gbStoppingEverything = #False)
                If gnStandbyCuePtr > 0 And gnStandbyCuePtr > \nCueIndex
                  closeCue(gnStandbyCuePtr)
                  setCueState(gnStandbyCuePtr)
                  updateGrid(gnStandbyCuePtr)
                EndIf
                \nAudState = #SCS_CUE_STANDBY
                gnStandbyCuePtr = \nCueIndex
                debugMsg(sProcName, "calling PostEvent(#SCS_Event_SetStandbyToolbarBtn, #WMN, 0, 0, #True)")
                PostEvent(#SCS_Event_SetStandbyToolbarBtn, #WMN, 0, 0, #True)
                
              ; ElseIf (\bAudTypeP) And (aSub(\nSubIndex)\bPLRepeat) And (aSub(\nSubIndex)\nAudCount <= 2)
              ElseIf (\bAudTypeP) And (getPLRepeatActive(\nSubIndex)) And (aSub(\nSubIndex)\nAudCount <= 2)
                audSetState(nAudPtr, #SCS_CUE_PL_READY, 57)
                
              Else
                audSetState(nAudPtr, #SCS_CUE_READY, 8)
                
              EndIf
              \bUpdateDisplay = #True
              debugMsg(sProcName, \sAudLabel + ", \nAudState=" + decodeCueState(\nAudState))
            EndIf
            \nCuePos = \nRelStartAt
            \nRelFilePos = 0
          EndIf
          
          sendRAICueSetPosIfReqd(nAudPtr)
          
          If \bAudTypeAorP
            If \nNextPlayIndex >= 0
              debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\nNextPlayIndex=" + getAudLabel(\nNextPlayIndex))
              nAudPtr = \nNextPlayIndex
            Else
              debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\nFirstPlayIndex=" + getAudLabel(aSub(pSubPtr)\nFirstPlayIndex))
              nAudPtr = aSub(pSubPtr)\nFirstPlayIndex
            EndIf
          Else
            ; debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\nNextAudIndex=" + getAudLabel(\nNextAudIndex))
            nAudPtr = \nNextAudIndex
          EndIf
        EndWith
        debugMsg(sProcName, "aCue(" + getCueLabel(nThisSubsCuePtr) + ")\nCueState=" + decodeCueState(aCue(nThisSubsCuePtr)\nCueState) + ", nAudPtr=" + getAudLabel(nAudPtr) + ", nStartingAudPtr=" + getAudLabel(nStartingAudPtr))
        
        If nAudPtr = nStartingAudPtr
          ; back to where we started, so we've processed all the Aud's for this Sub
          Break
        EndIf
      Wend
      
      With aSub(pSubPtr)
        nThisSubsCuePtr = \nCueIndex
        If \bSubTypeAorP
          ; reset playlists to start
          \nCurrPlayIndex = \nFirstPlayIndex
          ; debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\nCurrPlayIndex=" + getAudLabel(\nCurrPlayIndex))
          \nPLAudPlayCount = 0
        EndIf
        \nSubState = #SCS_CUE_READY   ; may be overriden by setCueState() if an Aud has error status, but need to set \nSubState for non-Aud sub types
        ; debugMsg(sProcName, "aCue(" + getCueLabel(nThisSubsCuePtr) + ")\nCueState=" + decodeCueState(aCue(nThisSubsCuePtr)\nCueState))
        setCueState(nThisSubsCuePtr)
        ; debugMsg(sProcName, "\nSubState=" + decodeCueState(\nSubState) + ", aCue(" + getCueLabel(nThisSubsCuePtr) + ")\nCueState=" + decodeCueState(aCue(nThisSubsCuePtr)\nCueState))
        If aCue(nThisSubsCuePtr)\nCueState = #SCS_CUE_COMPLETED
          bCompleteCue = #True
        EndIf
        If bJustStop = #False
          samAddRequest(#SCS_SAM_LOAD_GRID_ROW, \nCueIndex)
        EndIf
        If bDoCloseSub
          If \bStartedInEditor
            k = \nFirstPlayIndex
            While k >= 0
              debugMsg(sProcName, "calling rewindAud(" + getAudLabel(k) + ")")
              rewindAud(k)
              k = aAud(k)\nNextPlayIndex
            Wend
          Else
            debugMsg(sProcName, "calling closeSub(" + getSubLabel(pSubPtr) + ", #False, " + strB(bCompleteCue) + ")")
            closeSub(pSubPtr, #False, bCompleteCue)
            debugMsg(sProcName, "returned from closeSub(" + getSubLabel(pSubPtr) + ")")
          EndIf
        EndIf
        If (\bHotkey Or \bExtAct Or \bCallableCue) And (grOperModeOptions(gnOperMode)\bShowHotkeyCuesInPanels = #False)
          ; stopping hotkey but hotkeys not displayed in cue panels
        Else
          If aCue(\nCueIndex)\nHideCueOpt = #SCS_HIDE_NO
            If (\bHotkey Or \bExtAct Or \bCallableCue) Or (grOperModeOptions(gnOperMode)\bShowSubCues)
              debugMsg(sProcName, "setting gbCallLoadDispPanels=#True")
              gbCallLoadDispPanels = #True
            Else
              gnRefreshCuePtr = \nCueIndex
              gnRefreshSubPtr = pSubPtr
              gnRefreshAudPtr = -1
              gbCallRefreshDispPanel = #True
              debugMsg(sProcName, "gbCallRefreshDispPanel=" + strB(gbCallRefreshDispPanel) + ", gnRefreshCuePtr=" + getCueLabel(gnRefreshCuePtr) + ", gnRefreshSubPtr=" + getSubLabel(gnRefreshSubPtr) + ", gnRefreshAudPtr=" + getAudLabel(gnRefreshAudPtr))
            EndIf
          EndIf
        EndIf
        
        If \bSubTypeA
          nVidPicTarget = #SCS_VID_PIC_TARGET_F2 + \nOutputScreen - 2
          hideMonitorsNotInUse()
          If gbVideosOnMainWindow
            ; debugMsg(sProcName, "calling hideVideoWindowIfNotInUse(" + decodeVidPicTarget(nVidPicTarget) + ")")
            ; hideVideoWindowIfNotInUse(nVidPicTarget)
            samAddRequest(#SCS_SAM_HIDE_VIDEO_WINDOW_IF_NOT_IN_USE, nVidPicTarget)
          Else
            samAddRequest(#SCS_SAM_CLEAR_VIDEO_CANVAS_IF_NOT_IN_USE, nVidPicTarget)
          EndIf
        EndIf
        
      EndWith
      
      k = aSub(pSubPtr)\nFirstAudIndex
      While k >= 0
        aAud(k)\bIgnoreInStatusCheck = #False
        ; debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\bIgnoreInStatusCheck=" + strB(aAud(k)\bIgnoreInStatusCheck))
        k = aAud(k)\nNextAudIndex
      Wend
      
    EndIf
    
  ElseIf FindString("GJMNQRST", aSub(pSubPtr)\sSubType) > 0
    With aSub(pSubPtr)
      If (bStopAllTypes) Or (FindString(pTypesToStop, \sSubType) > 0)
        bCheckStandby = #True
        endOfSub(pSubPtr, nReqdNewState)
        setCueState(\nCueIndex)
        If bJustStop = #False
          updateGrid(\nCueIndex)
        EndIf
      EndIf
    EndWith
    
  ElseIf aSub(pSubPtr)\bSubTypeE  ; bSubTypeE
    With aSub(pSubPtr)
      If (bStopAllTypes) Or (FindString(pTypesToStop, "E", 1) > 0)
        bCheckStandby = #True
        endOfSub(pSubPtr, nReqdNewState)
        setCueState(\nCueIndex)
        If bJustStop = #False
          updateGrid(\nCueIndex)
        EndIf
        If \bStartedInEditor = #False
          If grWEN\nMainSubPtr = pSubPtr
            WEN_Form_Unload(#WE1)
          ElseIf grMain\nMainMemoSubPtr = pSubPtr
            WMN_clearMainMemoIfReqd(pSubPtr)
          EndIf
          If \nMemoScreen >= 2
            nVidPicTarget = #SCS_VID_PIC_TARGET_F2 + \nMemoScreen - 2
            If grVidPicTarget(nVidPicTarget)\nPlayingSubPtr = pSubPtr
              debugMsg(sProcName, "calling WEN_hideMemoOnSecondaryScreen(" + decodeVidPicTarget(nVidPicTarget) + ")")
              WEN_hideMemoOnSecondaryScreen(nVidPicTarget)
            EndIf
            hideMonitorsNotInUse()
          EndIf
        EndIf
      EndIf
    EndWith
    
  ElseIf aSub(pSubPtr)\bSubTypeK  ; bSubTypeK
    With aSub(pSubPtr)
      If (bStopAllTypes) Or (FindString(pTypesToStop, "K", 1) > 0)
        If \bChase
          If (grDMXChaseItems\nChaseSubPtr = pSubPtr) And (grDMXChaseItems\bChaseRunning)
            grDMXChaseItems\bStopChase = #True
            ; prepareDMXChaseStepForSend()
          EndIf
        EndIf
        bCheckStandby = #True
        endOfSub(pSubPtr, nReqdNewState)
        setCueState(\nCueIndex)
        If bJustStop = #False
          updateGrid(\nCueIndex)
        EndIf
        If gbDMXAvailable
          If grDMXFadeItems\nMaxFadeItem >= 0
            If gbStoppingEverything
              DMX_stopDMXFadesForSub(pSubPtr)
            Else
              ; if not stopping everything then delay processing by 0.1 second as the fade may not have completed (test showed DMX value of 1 instead of 0)
              samAddRequest(#SCS_SAM_STOP_DMX_FADES_FOR_SUB, pSubPtr, 0, 0, "", ElapsedMilliseconds()+100)
            EndIf
          EndIf
        EndIf
      EndIf
    EndWith
    
  ElseIf aSub(pSubPtr)\bSubTypeL  ; bSubTypeL
    With aSub(pSubPtr)
      If (bStopAllTypes) Or (FindString(pTypesToStop, "L", 1) > 0)
        bCheckStandby = #True
        endOfSub(pSubPtr, nReqdNewState)
        setCueState(\nCueIndex)
        updateGrid(\nCueIndex)
        \nLCPositionMax = 0
        For d = 0 To grLicInfo\nMaxAudDevPerAud
          If \nLCTime[d] < 0
            \nLCPosition[d] = 0
          Else
            \nLCPosition[d] = \nLCTime[d]
          EndIf
          If \nLCPosition[d] > \nLCPositionMax
            \nLCPositionMax = \nLCPosition[d]
          EndIf
          ; debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\nLCTime[" + d + "]=" + \nLCTime[d] + ", \nLCPosition[" + d + "]=" + \nLCPosition[d] + ", \nLCPositionMax=" + \nLCPositionMax)
        Next d
      EndIf
    EndWith
    
  ElseIf aSub(pSubPtr)\bSubTypeU  ; bSubTypeU
    With aSub(pSubPtr)
      If (bStopAllTypes) Or (FindString(pTypesToStop, "U", 1) > 0)
        debugMsg(sProcName, "grMTCSendControl\nMTCSubPtr=" + getSubLabel(grMTCSendControl\nMTCSubPtr) + ", pSubPtr=" + getSubLabel(pSubPtr))
        If bTypeUStopsMTC
          If grMTCSendControl\nMTCSubPtr = pSubPtr
            If \nMTCType = #SCS_MTC_TYPE_LTC
              stopTimeCode(pSubPtr)
            Else
              ; Added 11Nov2024 11.10.6bi following emails from Jan van Triest whereby the next MTC cue, which was already being started, had incorrect MTC quarter-frames being sent.
              ; So the solution is to ensure the MTC Cues thread is stopped before the next cue re-activates the thread and starts sending MTC.
              debugMsg(sProcName, "Calling THR_waitForAThreadToStop(#SCS_THREAD_MTC_CUES, 1000, #True)")
              THR_waitForAThreadToStop(#SCS_THREAD_MTC_CUES, 1000, #True)
              debugMsg(sProcName, "Returned from THR_waitForAThreadToStop(#SCS_THREAD_MTC_CUES, 1000, #True)")
              ; End added 11Nov2024 11.10.6bi
              ; grMTCSendControl\nMTCThreadRequest | #SCS_MTC_THR_STOP_MTC ; deleted 11Nov2024 11.10.6bi as made redundant by the above
              ; debugMsg(sProcName, "grMTCSendControl\nMTCThreadRequest=" + grMTCSendControl\nMTCThreadRequest)
            EndIf
          EndIf
        EndIf
        bCheckStandby = #True
        If \nMTCType = #SCS_MTC_TYPE_LTC
          If aCue(\nCueIndex)\nActivationMethod = #SCS_ACMETH_EXT_STEP
            endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
          ElseIf aCue(\nCueIndex)\bNonLinearCue Or aCue(\nCueIndex)\bHotkey Or aCue(\nCueIndex)\bExtAct Or aCue(\nCueIndex)\bCallableCue
            endOfSub(pSubPtr, #SCS_CUE_NOT_LOADED)
          Else
            endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
          EndIf
        Else
          endOfSub(pSubPtr, nReqdNewState)
        EndIf
        ; debugMsg0(sProcName, "grMTCSendControl\nMTCSubPtr=" + getSubLabel(grMTCSendControl\nMTCSubPtr) + ", pSubPtr=" + getSubLabel(pSubPtr))
        If grMTCSendControl\nMTCSubPtr = pSubPtr Or 1=1 ; Test added 14Mar2025 11.10.8ak
          \nMTCMSAtLinkedAudStart = grSubDef\nMTCMSAtLinkedAudStart ; added 2Sep2019 11.8.2aj following emails from Christopher Dean (christopher@uponstage.com)
          grMTCSendControl\bMTCSendControlActive = #False ; Added 30Jan2025 11.10.6
          debugMsg(sProcName, "grMTCSendControl\bMTCSendControlActive=" + strB(grMTCSendControl\bMTCSendControlActive))
        EndIf
        setCueState(\nCueIndex)
        If bJustStop = #False
          updateGrid(\nCueIndex)
        EndIf
      EndIf
    EndWith
    
  EndIf
  
  With aSub(pSubPtr)
    \bIgnoreInStatusCheck = bHoldIgnoreInStatusCheck
    If (bCheckStandby) And (\bStartedInEditor = #False) And (gbStoppingEverything = #False)
      If aCue(\nCueIndex)\nStandby = #SCS_STANDBY_SET
        If gnStandbyCuePtr > 0 And gnStandbyCuePtr > \nCueIndex
          closeCue(gnStandbyCuePtr)
          setCueState(gnStandbyCuePtr)
          updateGrid(gnStandbyCuePtr)
        EndIf
        \nSubState = #SCS_CUE_STANDBY
        gnStandbyCuePtr = \nCueIndex
        debugMsg(sProcName, "calling PostEvent(#SCS_Event_SetStandbyToolbarBtn, #WMN, 0, 0, #True)")
        PostEvent(#SCS_Event_SetStandbyToolbarBtn, #WMN, 0, 0, #True)
      EndIf
    EndIf
    
    ; commented out 19Mar2019 11.8.0.2cf following bug report from Dave Korman 'Pre-viewing sub-cue in editor triggers the cue in the main window'
    ; (now only in endOfSub())
    ;  \bStartedInEditor = #False
    ;  debugMsg(sProcName, "\bStartedInEditor=" + strB(\bStartedInEditor))
    ; end commented out 19Mar2019 11.8.0.2cf
    
    If \bSubTypeI
      If gbStoppingEverything = #False
        WCN_setLiveOnInds()
      EndIf
    EndIf
    
  EndWith
  
  If gbUseSMS
    ; rebuild getSMSCurrInfo() command strings
    If gbStoppingEverything = #False
      debugMsg(sProcName, "calling buildGetSMSCurrInfoCommandStrings")
      buildGetSMSCurrInfoCommandStrings()
    EndIf
  EndIf
  
  debugMsg(sProcName, #SCS_END + ", aCue(" + getCueLabel(aSub(pSubPtr)\nCueIndex) + ")\nCueState=" + decodeCueState(aCue(aSub(pSubPtr)\nCueIndex)\nCueState))
  
EndProcedure

Procedure stopSub(pSubPtr, pTypesToStop.s, bOpenNextCues, bJustStop, bUseCas=#False, bTypeUStopsMTC=#True)
  PROCNAMECS(pSubPtr)
  Protected bStopNow, k, k2
  Protected nMyAudLinkCount, bExitFor
  Protected nCuePtr
  Protected j
  Protected nVideoAudioDevPtr
  
  debugMsg(sProcName, #SCS_START + ", pTypesToStop=" + pTypesToStop + ", bOpenNextCues=" + strB(bOpenNextCues) + ", bJustStop=" + strB(bJustStop) + ", bUseCas=" + strB(bUseCas) + ", bTypeUStopsMTC=" + strB(bTypeUStopsMTC))
  
  bStopNow = #True
  
  ; modified 22Oct2019 11.8.2bc - added "And (aSub(pSubPtr)\bStartedInEditor = #False)" following email from Eric Snodgrass 15Oct2019 that reported
  ; testing playlist files sometimes set a file position to the end (due to 'completed' status).
  ; On testing, this did only seem to occur when testing the 'highlighted file only'
  If (aSub(pSubPtr)\bSubTypeAorP) And (aSub(pSubPtr)\bStartedInEditor = #False)
    debugMsg(sProcName, "setting \bPLTerminating = #True")
    aSub(pSubPtr)\bPLTerminating = #True ; prevents other aud's in the playlist starting
    debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\bPLTerminating=" + strB(aSub(pSubPtr)\bPLTerminating))
  EndIf
  
  ; If (aSub(pSubPtr)\bSubTypeM) Or (aSub(pSubPtr)\bSubTypeA)
  ; changed 5Nov2017 11.7.0av to force ALL Aud stops to be handled by the main thread, mainly following examination of log that showed mixer locking occurring in the control thread
  If aSub(pSubPtr)\bSubTypeHasAuds
    If aSub(pSubPtr)\nFirstAudIndex >= 0
      ; warning! all mciSendString calls must be from the same thread or mciSendString returns error 263 (not a registered device), so use main thread
      ; also, DirectShow calls need to be from the main thread
      If gnThreadNo > #SCS_THREAD_MAIN
        samAddRequest(#SCS_SAM_STOP_SUB, pSubPtr, 0, bOpenNextCues, pTypesToStop, 0, bJustStop)
        debugMsg(sProcName, "grMain\nSamRequestsWaiting=" + grMain\nSamRequestsWaiting + ", grMain\bControlThreadWaiting=" + strB(grMain\bControlThreadWaiting))
        gbLogInfoForSam = #True
        ; ; defer action 100ms to allow next cue to start if called from statusCheck()
        ; samAddRequest(#SCS_SAM_STOP_SUB, pSubPtr, 0, bOpenNextCues, pTypesToStop, ElapsedMilliseconds()+100, bJustStop)
        ProcedureReturn
      EndIf
    EndIf
  EndIf
  
  ; added 16May2019 11.8.1rc3 following emails from CPeters dated 15May2019
  If aSub(pSubPtr)\bSubTypeE
    If gnThreadNo > #SCS_THREAD_MAIN
      samAddRequest(#SCS_SAM_STOP_SUB, pSubPtr, 0, bOpenNextCues, pTypesToStop, 0, bJustStop)
      debugMsg(sProcName, "grMain\nSamRequestsWaiting=" + grMain\nSamRequestsWaiting + ", grMain\bControlThreadWaiting=" + strB(grMain\bControlThreadWaiting))
      gbLogInfoForSam = #True
      ProcedureReturn
    EndIf
  EndIf
  ; end added 16May2019 11.8.1rc3
  
  gbLogInfoForSam = #False

  debugMsg(sProcName, "calling stopOneSub(" + getSubLabel(pSubPtr) + ", '" + pTypesToStop + "', " + strB(bJustStop) + ", " + strB(bUseCas) + ", " + strB(bTypeUStopsMTC) + ")") ; mod 7Jan2017
  stopOneSub(pSubPtr, pTypesToStop, bJustStop, bUseCas, bTypeUStopsMTC)
  debugMsg(sProcName, "returned from stopOneSub()")
  
  If aSub(pSubPtr)\bSubTypeHasAuds
    k = aSub(pSubPtr)\nFirstAudIndex
    While k >= 0
      With aAud(k)
        ; debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nAudLinkCount=" + \nAudLinkCount + ", \nFirstAudLink=" + \nFirstAudLink + ", gnLastSub=" + gnLastSub)
        If \nAudLinkCount > 0
          nMyAudLinkCount = \nAudLinkCount
          bExitFor = #False
          For k2 = \nFirstAudLink To gnLastAud
            ; debugMsg(sProcName, "k2=" + getAudLabel(k2) + ", bExitFor=" + strB(bExitFor))
            If bExitFor
              Break
            EndIf
            ; debugMsg(sProcName, "aAud(" + getAudLabel(k2) + ")\bExists=" + strB(aAud(k2)\bExists))
            If aAud(k2)\bExists
              ; debugMsg(sProcName, "aAud(" + getAudLabel(k2) + ")\nLinkedToAudPtr=" + getAudLabel(aAud(k2)\nLinkedToAudPtr) + ", k=" + getAudLabel(k))
              If aAud(k2)\nLinkedToAudPtr = k
                debugMsg(sProcName, "calling stopOneSub for linked cue " + aAud(k2)\sCue + " " + aAud(k2)\nSubNo)
                stopOneSub(aAud(k2)\nSubIndex, pTypesToStop, bJustStop, bUseCas)
                nMyAudLinkCount - 1
                If nMyAudLinkCount = 0
                  bExitFor = #True
                EndIf
              EndIf
            EndIf
          Next k2
        EndIf
        k = \nNextAudIndex
      EndWith
    Wend
  EndIf
  
  If aSub(pSubPtr)\bStartedInEditor = #False
    If aSub(pSubPtr)\bSubTypeF
      If aSub(pSubPtr)\nAFLinkedToMTCSubPtr >= 0
        j = aSub(pSubPtr)\nAFLinkedToMTCSubPtr
        If aSub(j)\bSubTypeU
          If aSub(j)\nMTCLinkedToAFSubPtr = pSubPtr And aSub(j)\bSubEnabled
            debugMsg(sProcName, "calling stopOneSub(" + buildSubLabel(pSubPtr) + ", 'U', " + strB(bJustStop) + ", " + strB(bUseCas) + ", " + strB(bTypeUStopsMTC) + ")")  ; mod 7Jan2017
            stopOneSub(j, "U", bJustStop, bUseCas, bTypeUStopsMTC)                                                                                                        ; mod 7Jan2017
          EndIf
        EndIf ; EndIf aSub(j)\bSubTypeU
      EndIf ; EndIf aSub(pSubPtr)\nAFLinkedToMTCSubPtr >= 0
    EndIf ; EndIf aSub(pSubPtr)\bSubTypeF
  EndIf ; EndIf aSub(pSubPtr)\bStartedInEditor = #False
  
  nCuePtr = aSub(pSubPtr)\nCueIndex
  With aCue(nCuePtr)
    If bOpenNextCues
      debugMsg(sProcName, "aCue(" + getCueLabel(nCuePtr) + ")\nCueState=" + decodeCueState(\nCueState))
      If \nCueState = #SCS_CUE_COMPLETED
        gnCallOpenNextCues = 1
        debugMsg(sProcName, "gnCallOpenNextCues=" + gnCallOpenNextCues)
        If \nHideCueOpt = #SCS_HIDE_NO
          If (\bHotkey = #False) And (\bExtAct = #False) And (\bCallableCue = #False)
            debugMsg(sProcName, "setting gbCallLoadDispPanels=#True")
            gbCallLoadDispPanels = #True
          ElseIf grOperModeOptions(gnOperMode)\bShowHotkeyCuesInPanels
            debugMsg(sProcName, "setting gbCallLoadDispPanels=#True")
            gbCallLoadDispPanels = #True
          EndIf
        EndIf
        gqMainThreadRequest | #SCS_MTH_SET_CUE_TO_GO
        debugMsg(sProcName, "gnLabelOther=" + gnLabelOther + ", gqMainThreadRequest | #SCS_MTH_SET_CUE_TO_GO")
        gbCallSetNavigateButtons = #True
        
      ElseIf grOperModeOptions(gnOperMode)\bShowSubCues
        If \nHideCueOpt = #SCS_HIDE_NO
          If (\bHotkey = #False) And (\bExtAct = #False) And (\bCallableCue = #False)
            debugMsg(sProcName, "setting gbCallLoadDispPanels=#True")
            gbCallLoadDispPanels = #True
          ElseIf grOperModeOptions(gnOperMode)\bShowHotkeyCuesInPanels
            debugMsg(sProcName, "setting gbCallLoadDispPanels=#True")
            gbCallLoadDispPanels = #True
          EndIf
        EndIf
      EndIf
    EndIf
    
    ; moved to endOfSub() 19Mar2019 11.8.0.2cf following bug report from Dave Korman 'Pre-viewing sub-cue in editor triggers the cue in the main window'
    ;   aSub(pSubPtr)\bStartedInEditor = #False
    ;   debugMsg(sProcName, "\bStartedInEditor=" + strB(aSub(pSubPtr)\bStartedInEditor))
    ; end moved to endOfSub() 19Mar2019 11.8.0.2cf
    
    If (\nCueState <= #SCS_CUE_READY) Or ((\nCueState >= #SCS_CUE_PL_READY) And (\nCueState <> #SCS_CUE_COMPLETED))
      resetRelatedCueActivationMethodReqd(nCuePtr)
    EndIf
  EndWith
  
  ; Added 26Feb2025 11.10.7-b06 to ensure VU meter for video is cleared (email from Llus Vilarrasa)
  If aSub(pSubPtr)\bSubTypeA
    nVideoAudioDevPtr = aSub(pSubPtr)\nVideoAudioDevPtr
    If nVideoAudioDevPtr >= 0
      If aSub(pSubPtr)\bMuteVideoAudio = #False
        With grMaps\aDev(nVideoAudioDevPtr)
          \dAudioPeakLeftPercent = 0.0
          \dAudioPeakRightPercent = 0.0
        EndWith
      EndIf ; EndIf aSub(pSubPtr)\bMuteVideoAudio = #False
    EndIf ; EndIf nVideoAudioDevPtr >= 0
  EndIf
  ; End added 26Feb2025 11.10.7-b06
  
  If IsWindow(#WCN)
    WCN_setPlayingControlsIfReqd()
  EndIf
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure stopAllEarlierCues(pCuePtr, bStopImmediately, pSubSubType.s, bJustStop, bStopNotLoadedCues, bUseCas=#False, nSFRCueType=#SCS_SFR_CUE_ALL_ANY, nExcludeCuePtr=-99, nExcludeSubPtr=-99, bExcludeSFRCueList=#False, bSFRCompleteAssocAutoStartCues=#False, bSFRHoldAssocAutoStartCues=#False, bIncludeHibernatedCues=#False)
  PROCNAMECQ(pCuePtr)
  Protected i, j, k, n
  Protected nCueState, bWantThisCue, nSubState, bWantThisSub, nAudState, bWantThisAud, bStopThis
  Protected bThisCueChanged, bAnyCueChanged
  Protected bAnyCues, bPlayingCuesOnly, bAudioOnly, bVideoOnly, bLiveOnly
  Protected nExcludeSubCueIndex
  Protected bHoldPLTerminating
  
  debugMsg(sProcName, #SCS_START + ", bStopImmediately=" + strB(bStopImmediately) + ", pSubSubType=" + pSubSubType + ", bJustStop=" + strB(bJustStop) +
                      ", bStopNotLoadedCues=" + strB(bStopNotLoadedCues) + ", bUseCas=" + strB(bUseCas) + ", nSFRCueType=" + decodeSFRCueType(nSFRCueType))
  debugMsg(sProcName, "nExcludeCuePtr=" + getCueLabel(nExcludeCuePtr) + ", nExcludeSubPtr=" + getSubLabel(nExcludeSubPtr) + ", bExcludeSFRCueList=" + strB(bExcludeSFRCueList) +
                      ", bSFRCompleteAssocAutoStartCues=" + strB(bSFRCompleteAssocAutoStartCues) + ", bSFRHoldAssocAutoStartCues=" + strB(bSFRHoldAssocAutoStartCues) +
                      ", bIncludeHibernatedCues=" + strB(bIncludeHibernatedCues))
  
  setProcSFRFlags(nSFRCueType)  ; macro sets bPlayingCuesOnly, bAudioOnly and bVideoOnly, based on nSRCueType
  debugMsg(sProcName, "bPlayingCuesOnly=" + strB(bPlayingCuesOnly) + ", bAudioOnly=" + strB(bAudioOnly) + ", bVideoOnly=" + strB(bVideoOnly) + ", bLiveOnly=" + strB(bLiveOnly))

  If gbStoppingEverything = #False
    ; Test added 4Jan2020 11.8.2.1ax as this is now set at the start of StopEverythingPart1() and must NOT be reset to -1 as some cues may already have been stopped
    gnFirstCueStopped = -1
    debugMsg(sProcName, "gnFirstCueStopped=" + getCueLabel(gnFirstCueStopped))
  EndIf
  
  ; Added 30Aug2024 11.10.3bp
  If nExcludeSubPtr >= 0
    nExcludeSubCueIndex = aSub(nExcludeSubPtr)\nCueIndex
  Else
    nExcludeSubCueIndex = -1
  EndIf
  ; End added 30Aug2024 11.10.3bp
  
  For i = 1 To (pCuePtr - 1)
    bThisCueChanged = #False
    nCueState = aCue(i)\nCueState
    
    bWantThisCue = #False
    If i <> nExcludeCuePtr
      ; setWantThisCue(i)
      bWantThisCue = #True ; Changed from setWantThisCue(i) 24Jan2025 as we DO need to include cues that may be currently disabled.
                           ; Issue found after investigating error reported by Marius Krausse 8Jan2025 under the email subject 'Cues aren't disabled properly'.
                           ; Martin had a cue file that included several dynamic 'Enable/Disable Cue' cues and it was possible that ESC would
                           ; be applied after a running cue had been disabled by another cue. The now-disabled cue was still running (correctly)
                           ; when ESC was pressed but needed to be included here to stop the cue.
                           ; So bWantThisCue needs to be set #True whether or not the cue is enabled.
    EndIf
    ; debugMsg(sProcName, "i=" + getCueLabel(i) + ", bWantThisCue=" + strB(bWantThisCue) + ", \nCueState=" + decodeCueState(aCue(i)\nCueState))

    If bWantThisCue
      If aCue(i)\nActivationMethod = #SCS_ACMETH_AUTO
        If aCue(i)\nAutoActPosn <> #SCS_ACPOSN_LOAD
          ; nb default value for parameter nExcludeCuePtr was previously -1 but aCue(i)\nAutoActCuePtr could be -1 if aCue(i)\nAutoActCuePtr is disabled
          ; so changed default value for parameter nExcludeCuePtr to a different negative value (viz -99)
          If aCue(i)\nAutoActCuePtr = nExcludeCuePtr
            bWantThisCue = #False
          EndIf
        EndIf
      EndIf
    EndIf
    If bExcludeSFRCueList
      For n = 0 To grMMedia\nSFRCueMax
        If grMMedia\anSFRCuePtr[n] = i
          bWantThisCue = #False
          Break
        EndIf
      Next n
    EndIf
    If bWantThisCue
      ; debugMsg(sProcName, "i=" + getCueLabel(i) + ", bWantThisCue=" + strB(bWantThisCue) + ", nCueState=" + decodeCueState(nCueState))
      j = aCue(i)\nFirstSubIndex
      While j >= 0
        With aSub(j)
          nSubState = \nSubState
          bWantThisSub = #False
          bHoldPLTerminating = \bPLTerminating ; Added 28Sep2024 11.10.6ac (only relevant for type A (video/image) and type P (playlist) sub-cues, but save this for all sub types)
          ; Changed 30Aug2024 11.10.3bp following email from Jason Mai 28Aug2024
          If nExcludeSubPtr >= 0
            If j <> nExcludeSubPtr
              If \nCueIndex = nExcludeSubCueIndex
                ; We're in the same cue as 'nExcludeSubPtr'
                ; debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\nRelStartMode=" + decodeRelStartMode(\nRelStartMode) + ", \nRelStartTime=" + \nRelStartTime)
                ; debugMsg(sProcName, "aSub(" + getSubLabel(nExcludeSubPtr) + ")\nRelStartMode=" + decodeRelStartMode(aSub(nExcludeSubPtr)\nRelStartMode) + ", \nRelStartTime=" + aSub(nExcludeSubPtr)\nRelStartTime)
                If \nRelStartMode <= #SCS_RELSTART_AS_CUE And aSub(nExcludeSubPtr)\nRelStartMode <= #SCS_RELSTART_AS_CUE And \nRelStartTime >= aSub(nExcludeSubPtr)\nRelStartTime
                  ; Relstart at or later than nExcludeSubptr so DO NOT stop this sub as it is the same cue as 'nExcludeSubPtr'
                  ; (See comment at the start of the enumeration for #SCS_RELSTART_... in Constants.pbi)
                Else
                  setWantThisSub(j)
                EndIf
              ElseIf j <> nExcludeSubPtr
                setWantThisSub(j)
              EndIf
            EndIf
          Else
            setWantThisSub(j)
          EndIf
          ; End changed 30Aug2024 11.10.3bp
          debugMsg(sProcName, "j=" + getSubLabel(j) + ", bWantThisSub=" + strB(bWantThisSub) + ", nSubState=" + decodeCueState(nSubState))
          If (bWantThisSub) And ((nSubState <> #SCS_CUE_HIBERNATING) Or (bIncludeHibernatedCues))
            ; debugMsg(sProcName, "j=" + getSubLabel(j) + ", bWantThisSub=" + strB(bWantThisSub) + ", nSubState=" + decodeCueState(nSubState))
            If \bSubTypeAorP
              \bPLTerminating = #True
              debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\bPLTerminating=" + strB(aSub(j)\bPLTerminating) + ", nSubState=" + decodeCueState(nSubState))
            EndIf
            ; debugMsg(sProcName, "j=" + j + ", " + \sSubLabel + ", \nSubState=" + decodeCueState(\nSubState))
            bStopThis = #False
            If (nSubState > #SCS_CUE_READY) And (nSubState <= #SCS_CUE_FADING_OUT)
              bStopThis = #True
            ElseIf (nSubState = #SCS_CUE_READY) And ((nCueState > #SCS_CUE_READY) And (nCueState <= #SCS_CUE_FADING_OUT))
              bStopThis = #True
            EndIf
            If bStopThis
              debugMsg(sProcName, "calling stopSub(" + getSubLabel(j) + ", " + pSubSubType + ", #False, " + strB(bJustStop) + ", " + strB(bUseCas) + ", #True)")
              stopSub(j, pSubSubType, #False, bJustStop, bUseCas, #True)
              bThisCueChanged = #True
              debugMsg(sProcName, "returned from stopSub(" + getSubLabel(j) + ")")
              debugMsg(sProcName, "aCue(" + getCueLabel(i) + ")\nActivationMethod=" + decodeActivationMethod(aCue(i)\nActivationMethod) +
                                  ", \nActivationMethodReqd=" + decodeActivationMethod(aCue(i)\nActivationMethodReqd))
;               If (aCue(i)\nActivationMethodReqd <> #SCS_ACMETH_TIME) And (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)
;                 ; don't set gnFirstCueStopped for TBC's or for the standby cue or for disabled cues, or for hotkeys or for callable cues
;                 If (\bHotkey = #False) And (\bExtAct = #False) And (\bCallableCue = #False)
;                   If gnFirstCueStopped = -1
;                     gnFirstCueStopped = i
;                     debugMsg(sProcName, "gnFirstCueStopped=" + getCueLabel(gnFirstCueStopped))
;                   EndIf
;                 EndIf
;               EndIf
              If (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)
                If (aCue(i)\nActivationMethodReqd <> #SCS_ACMETH_TIME) Or (gbStoppingEverything) Or (gbSamRequestUnderStoppingEverything)
                  ; don't set gnFirstCueStopped for TBC's or for the standby cue or for disabled cues, or for hotkeys or for callable cues
                  If (\bHotkey = #False) And (\bExtAct = #False) And (\bCallableCue = #False)
                    If gnFirstCueStopped = -1
                      gnFirstCueStopped = i
                      debugMsg(sProcName, "gnFirstCueStopped=" + getCueLabel(gnFirstCueStopped))
                    EndIf
                  EndIf
                EndIf
              EndIf
              
            ElseIf (\bSubTypeHasAuds) And (bStopNotLoadedCues) And (aCue(\nCueIndex)\bNonLinearCue = #False)
              k = \nFirstAudIndex
              While k >= 0
                nAudState = aAud(k)\nAudState
                bWantThisAud = #False
                If bPlayingCuesOnly
                  If (nAudState >= #SCS_CUE_COUNTDOWN_TO_START) And (nAudState <= #SCS_CUE_FADING_OUT)
                    bWantThisAud = #True
                  EndIf
                Else
                  bWantThisAud = #True
                EndIf
                If (bWantThisAud)
                  If nAudState = #SCS_CUE_NOT_LOADED
                    debugMsg(sProcName, aAud(k)\sAudLabel + " setting \nAudState (" + decodeCueState(nAudState) + ") to SCS_CUE_COMPLETED")
                    debugMsg(sProcName, "calling endOfAud(" + getAudLabel(k) + ", " + decodeCueState(#SCS_CUE_COMPLETED) + ")")
                    endOfAud(k, #SCS_CUE_COMPLETED)
                    bThisCueChanged = #True
                    If (aCue(i)\nActivationMethodReqd <> #SCS_ACMETH_TIME) And (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)
                      ; don't set gnFirstCueStopped for TBC's or for the standby cue or for disabled cues, or for hotkeys or for callable cues
                      If (aSub(j)\bHotkey = #False) And (aSub(j)\bExtAct = #False) And (aSub(j)\bCallableCue = #False)
                        If gnFirstCueStopped = -1
                          gnFirstCueStopped = i
                          debugMsg(sProcName, "gnFirstCueStopped=" + getCueLabel(gnFirstCueStopped))
                        EndIf
                      EndIf
                    EndIf
                  EndIf
                EndIf
                k = aAud(k)\nNextAudIndex
              Wend
            EndIf
          EndIf
          ; Added 28Sep2024 11.10.6ac following bug reported by Patrick McCarthy 24Sep2024
          ; Only relevant for type A (video/image) and type P (playlist) sub-cues, but no problem in applying this code for all sub types
          If \bPLTerminating <> bHoldPLTerminating
            \bPLTerminating = bHoldPLTerminating
            debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\bPLTerminating=" + strB(aSub(j)\bPLTerminating) + ", nSubState=" + decodeCueState(nSubState))
          EndIf
          ; End added 28Sep2024 11.10.6ac
          j = \nNextSubIndex
        EndWith
      Wend
    EndIf
    If bThisCueChanged
      bAnyCueChanged = #True
      clearCurrHotkeyToggleState(i)
      setCueState(i, #True)
      updateGrid(i)
      If bSFRCompleteAssocAutoStartCues
        debugMsg(sProcName, "calling completeAssocAutoStartCues(" + getCueLabel(i) + ")")
        completeAssocAutoStartCues(i)
      ElseIf bSFRHoldAssocAutoStartCues
        debugMsg(sProcName, "calling holdAssocAutoStartCues(" + getCueLabel(i) + ")")
        holdAssocAutoStartCues(i)
      EndIf
    EndIf
  Next i
  
  CompilerIf #c_vMix_in_video_cues
    If grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_VMIX
      If grvMixInfo\nMaxInputKeyToRemoveWhenvMixIdle >= 0
        vMix_RemoveRequestedInputs(#False)
      EndIf
    EndIf
  CompilerEndIf
  
  If (bAnyCueChanged) And (gbStoppingEverything = #False)
    gnCallOpenNextCues = 1
    gbCallLoadDispPanels = #True
    debugMsg(sProcName, "gnCallOpenNextCues=" + gnCallOpenNextCues + ", gbCallLoadDispPanels=" + strB(gbCallLoadDispPanels))
    debugMsg(sProcName, "calling setCueToGo()")
    setCueToGo()
    gbCallSetNavigateButtons = #True
  EndIf
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure Error_(pProcName.s, message.s)
  ensureSplashNotOnTop()
  Error_2(pProcName, BASS_ErrorGetCode(), message)
EndProcedure

Procedure ASIO_Error_(pProcName.s, message.s)
  ensureSplashNotOnTop()
  Error_2(pProcName, BASS_ASIO_ErrorGetCode(), message)
EndProcedure

Procedure Error_2(pProcName.s, pErrorCode, pMessage.s)
  Protected sMessage.s
  
  debugMsg3(pProcName, "pErrorCode=" + pErrorCode + " (" + getBassErrorDesc(pErrorCode) + "), pMessage=" + pMessage)
  sMessage = pMessage + Chr(10)
  ErrorHandler(pProcName, getBassErrorDesc(pErrorCode), pMessage, #False)

EndProcedure

Procedure fadeInOneAud(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nBassResult.l, nTimeToGo, d, nChannel.l, fPan.f
  Protected fReqdBVLevel.f ; Added 28Sep2022 11.9.6
  Protected sDevPXChanListLeft.s, sDevPXChanListRight.s
  Protected sLevelInfo.s, sSetCommandItem.s, sFinalSetCommandItem.s
  Protected sAudSetGainCommandString.s
  Protected sField1.s, sField2.s, sField3.s, sField4.s
  Protected bPrevInFadeImage

  debugMsg(sProcName, #SCS_START)
  
  bPrevInFadeImage = gbInFadeImage
  
  With aAud(pAudPtr)
    
    ; Added 10Aug2021 11.8.5rc2b
    If \bAudTypeA And \nFileFormat = #SCS_FILEFORMAT_PICTURE
      gbInFadeImage = #True
    EndIf
    ; End added 10Aug2021 11.8.5rc2b
    
    If (\bAudTypeAorP) And (\nAudState = #SCS_CUE_FADING_IN)
      nTimeToGo = aSub(\nSubIndex)\nPLCurrFadeInTime - (\nCuePos - \nCuePosAtFadeStart) ; Added \nCuePosAtFadeStart 1Feb2022 11.9.0rc7
    ElseIf (\bAudTypeA) And (\nAudState = #SCS_CUE_HIBERNATING)
      nTimeToGo = \nCurrFadeInTime
    ElseIf (\bAudTypeF) And (\nAudState = #SCS_CUE_HIBERNATING) ; Added 30Nov2021 11.8.6ck following email from Dave Cornish (bug related to using linear fade in type)
      nTimeToGo = \nCurrFadeInTime                              ; Added 30Nov2021 11.8.6ck following email from Dave Cornish (bug related to using linear fade in type)
    Else
      nTimeToGo = \nCurrFadeInTime - (\nCuePos - \nCuePosAtFadeStart) ; Added \nCuePosAtFadeStart 1Feb2022 11.9.0rc7
    EndIf
    debugMsg(sProcName, "nTimeToGo=" + nTimeToGo + ", \nCuePos=" + \nCuePos + ", \nCuePosAtFadeStart=" + \nCuePosAtFadeStart + ", \nAudState=" + decodeCueState(\nAudState) + ", \nCurrFadeInTime=" + \nCurrFadeInTime)
    
    If nTimeToGo < 0
      nTimeToGo = 0
    EndIf
    
    If nTimeToGo = 0
      If \nAudState = #SCS_CUE_FADING_IN
        \nAudState = #SCS_CUE_PLAYING
      EndIf
      If gbUseBASS
        For d = \nFirstSoundingDev To \nLastSoundingDev
          If \nBassChannel[d] <> 0
            If \bAudTypeF
              setLevelsBASS(pAudPtr, d, \fBVLevel[d], \fPan[d])
            EndIf
          EndIf
        Next d
      EndIf
    EndIf
    \qTimeFadeInStarted = gqTimeNow + (nTimeToGo - \nCurrFadeInTime)
    \bTimeFadeInStartedSet = #True
    \nPreFadeInTimeOnPause = \nTotalTimeOnPause
    \nCuePosAtFadeStart = \nCuePos
    debugMsg(sProcName, "\bTimeFadeInStartedSet=" + strB(\bTimeFadeInStartedSet) + ", \qTimeFadeInStarted=" + traceTime(\qTimeFadeInStarted) +
                        ", \nPreFadeInTimeOnPause=" + \nPreFadeInTimeOnPause + ", \nCuePosAtFadeStart=" + \nCuePosAtFadeStart + ", \nAudState=" + decodeCueState(\nAudState))
    CompilerIf #c_include_tvg
      If grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG
        If (\nFileFormat = #SCS_FILEFORMAT_VIDEO) Or (\nFileFormat = #SCS_FILEFORMAT_PICTURE And checkUse2DDrawing(\nSubIndex) = #False)
          debugMsg(sProcName, "calling addAudToTVGFadeAudArray(" + getAudLabel(pAudPtr) + ")")
          addAudToTVGFadeAudArray(pAudPtr)
        EndIf
      EndIf
    CompilerEndIf
    
    If gbUseBASS  ; BASS
      For d = \nFirstSoundingDev To \nLastSoundingDev
        nChannel = \nBassChannel[d]
        If nChannel <> 0
          If \bAudTypeF
            If \nFadeInType = #SCS_FADE_LIN Or nTimeToGo < 500 ; Added nTimeToGo test 26Sep2023 11.10.0ce to force fade in time of less than 0.5 second to be linear
              ; Added 28Sep2022 11.9.6
              fReqdBVLevel = \fBVLevel[d]
              If fReqdBVLevel <= grLevels\fMinBVLevel
                fReqdBVLevel = 0.0
              EndIf
              ; End added 28Sep2022 11.9.6
              \bFadeInOneAudIssuedSlideChannelAttributes = #True ; Added 4Feb2025 11.10.6 (preferably set this BEFORE calling BASS_ChannelSlideAttribute())
              ; Changed 28Sep2022 11.9.6
              debugMsg(sProcName, "issuing slide for " + \sAudLabel + ", channel=" + decodeHandle(nChannel) + ", level=" + traceLevel(fReqdBVLevel) + ", time=" + nTimeToGo)
              nBassResult = BASS_ChannelSlideAttribute(nChannel, #BASS_ATTRIB_VOL, fReqdBVLevel, nTimeToGo)
              debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nChannel) + ", BASS_ATTRIB_VOL, " + traceLevel(fReqdBVLevel) + ", " + nTimeToGo + ")", nBassResult)
              ; End changed 28Sep2022 11.9.6
              fPan = \fPan[d]
              If fPan <> #SCS_NOPANCHANGE_SINGLE
                nBassResult = BASS_ChannelSlideAttribute(nChannel, #BASS_ATTRIB_PAN, fPan, 50)
                CompilerIf #cTraceSetLevels
                  debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nChannel) + ", #BASS_ATTRIB_PAN, " + formatPan(fPan) + ", 50)", nBassResult)
                CompilerEndIf
              EndIf
            EndIf
          EndIf
        EndIf
      Next d
      
    Else  ; SM-S
      sFinalSetCommandItem = ""
      For d = \nFirstSoundingDev To \nLastSoundingDev
        sDevPXChanListLeft = \sDevPXChanListLeft[d]
        sDevPXChanListRight = \sDevPXChanListRight[d]
        If Len(sDevPXChanListLeft) > 0
          sLevelInfo = setLevelsForSMSOutputDev(pAudPtr, d, \fBVLevel[d], \fPan[d], nTimeToGo, \nFadeInType)
          debugMsg(sProcName, "d=" + d + ", sLevelInfo=" + sLevelInfo)
          sField1 = StringField(sLevelInfo, 1, "|")
          sField2 = StringField(sLevelInfo, 2, "|")
          sField3 = StringField(sLevelInfo, 3, "|")
          sField4 = StringField(sLevelInfo, 4, "|")
          If \fPan[d] = #SCS_PANCENTRE_SINGLE
            sSetCommandItem = " chan " + sDevPXChanListLeft + " " + sDevPXChanListRight + " " + sField1
            If Len(sField3) > 0
              sFinalSetCommandItem + " chan " + sDevPXChanListLeft + " " + sDevPXChanListRight + " " + sField3
            EndIf
          Else
            sSetCommandItem = " chan " + sDevPXChanListLeft + " " + sField1
            If Len(sDevPXChanListRight) > 0
              sSetCommandItem + " chan " + sDevPXChanListRight + " " + sField2
            EndIf
            If Len(sField3) > 0
              sFinalSetCommandItem + " chan " + sDevPXChanListLeft + " " + sField3
              If Len(sDevPXChanListRight) > 0
                sFinalSetCommandItem + " chan " + sDevPXChanListRight + " " + sField4
              EndIf
            EndIf
          EndIf
          debugMsg(sProcName, "sSetCommandItem=" + sSetCommandItem)
          If Len(sFinalSetCommandItem) > 0
            debugMsg(sProcName, "sFinalSetCommandItem=" + sFinalSetCommandItem)
          EndIf
          sAudSetGainCommandString + sSetCommandItem
        EndIf
      Next d
      \sAudFinalSetGainCommandString = sFinalSetCommandItem   ; nb may be blank
      debugMsg(sProcName, "\sAudFinalSetGainCommandString=" + \sAudFinalSetGainCommandString)
      If Len(sAudSetGainCommandString) > 0
        sendSMSCommand("set " + Trim(sAudSetGainCommandString), #cTraceSetLevels)
      EndIf
      
    EndIf
    
  EndWith
  
  gbInFadeImage = bPrevInFadeImage ; Added 10Aug2021 11.8.5rc2b

EndProcedure

Procedure fadeOutCue(pCuePtr, bOpenNextCues=#False, bStopCountingDownSubs=#False, bHibernate=#False)
  PROCNAMECQ(pCuePtr)
  Protected j

  debugMsg(sProcName, #SCS_START + ", bOpenNextCues=" + strB(bOpenNextCues) + ", bStopCountingDownSubs=" + strB(bStopCountingDownSubs) + ", bHibernate=" + strB(bHibernate))
  
  j = aCue(pCuePtr)\nFirstSubIndex
  While j >= 0
    If aSub(j)\bSubEnabled
      fadeOutSub(j, #False, bStopCountingDownSubs, bHibernate)
    EndIf
    j = aSub(j)\nNextSubIndex
  Wend

  If bOpenNextCues
    gnCallOpenNextCues = 1
    debugMsg(sProcName, "gnCallOpenNextCues=" + gnCallOpenNextCues)
  EndIf
  
;   debugMsg(sProcName, "calling listCueStates()")
;   listCueStates()
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure fadeOutAllEarlierCues(pCuePtr, bStopImmediately, pSubSubType.s, bJustStop, bStopNotLoadedCues, bUseCas=#False, nSFRCueType=#SCS_SFR_CUE_ALL_ANY, nExcludeCuePtr=-1, nExcludeSubPtr=-99, bExcludeSFRCueList=#False, bSFRCompleteAssocAutoStartCues=#False, bSFRHoldAssocAutoStartCues=#False)
  PROCNAMECQ(pCuePtr)
  Protected i, j, k, n
  Protected nItemState, bWantThisCue, bWantThisSub, bWantThisAud
  Protected bThisCueChanged, bAnyCueChanged
  Protected bAnyCues, bPlayingCuesOnly, bAudioOnly, bVideoOnly, bLiveOnly
  
  debugMsg(sProcName, #SCS_START + ", bStopImmediately=" + strB(bStopImmediately) + ", pSubSubType=" + pSubSubType + ", bJustStop=" + strB(bJustStop) +
                      ", bStopNotLoadedCues=" + strB(bStopNotLoadedCues) + ", bUseCas=" + strB(bUseCas) + ", nSFRCueType=" + decodeSFRCueType(nSFRCueType))
  debugMsg(sProcName, "nExcludeCuePtr=" + getCueLabel(nExcludeCuePtr) + ", nExcludeSubPtr=" + getSubLabel(nExcludeSubPtr) + ", bExcludeSFRCueList=" + strB(bExcludeSFRCueList) +
                      ", bSFRCompleteAssocAutoStartCues=" + strB(bSFRCompleteAssocAutoStartCues) + ", bSFRHoldAssocAutoStartCues=" + strB(bSFRHoldAssocAutoStartCues))
  
  setProcSFRFlags(nSFRCueType)  ; macro sets bPlayingCuesOnly, bAudioOnly and bVideoOnly, based on nSRCueType
  debugMsg(sProcName, "bPlayingCuesOnly=" + strB(bPlayingCuesOnly) + ", bAudioOnly=" + strB(bAudioOnly) + ", bVideoOnly=" + strB(bVideoOnly) + ", bLiveOnly=" + strB(bLiveOnly))
  
  If gbStoppingEverything = #False
    ; Test added 4Jan2020 11.8.2.1ax as this is now set at the start of StopEverythingPart1() and must NOT be reset to -1 as some cues may already have been stopped
    gnFirstCueStopped = -1
    debugMsg(sProcName, "gnFirstCueStopped=" + getCueLabel(gnFirstCueStopped))
  EndIf
  
  For i = 1 To pCuePtr - 1
    bThisCueChanged = #False
    nItemState = aCue(i)\nCueState
    
    bWantThisCue = #False
    If i <> nExcludeCuePtr
      setWantThisCue(i)
    EndIf
    ; debugMsg(sProcName, "i=" + getCueLabel(i) + ", bWantThisCue=" + strB(bWantThisCue) + ", \nCueState=" + decodeCueState(aCue(i)\nCueState))
    
    If bWantThisCue And bPlayingCuesOnly
      If aCue(i)\nActivationMethod = #SCS_ACMETH_AUTO
        If aCue(i)\nAutoActPosn <> #SCS_ACPOSN_LOAD
          If aCue(i)\nAutoActCuePtr = nExcludeCuePtr
            If nItemState < #SCS_CUE_FADING_IN Or nItemState > #SCS_CUE_FADING_OUT
              bWantThisCue = #False
            EndIf
          EndIf
        EndIf
      EndIf
    EndIf
    
    If bExcludeSFRCueList
      For n = 0 To grMMedia\nSFRCueMax
        If grMMedia\anSFRCuePtr[n] = i
          bWantThisCue = #False
          Break
        EndIf
      Next n
    EndIf
    
    If bWantThisCue
      j = aCue(i)\nFirstSubIndex
      While j >= 0
        With aSub(j)
          nItemState = \nSubState
          bWantThisSub = #False
          If j <> nExcludeSubPtr
            setWantThisSub(j)
          EndIf
          ; debugMsg(sProcName, "j=" + getSubLabel(j) + ", bWantThisSub=" + strB(bWantThisSub))
          If (bWantThisSub) And (\nSubState <> #SCS_CUE_HIBERNATING)
            If \bSubTypeAorP
              \bPLTerminating = #True
              debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\bPLTerminating=" + strB(aSub(j)\bPLTerminating))
            EndIf
            ; debugMsg(sProcName, \sSubLabel + ", \bSubTypeF=" + strB(\bSubTypeF) + ", \nSubState=" + decodeCueState(\nSubState))
            If ((\bSubTypeF) And (nItemState >= #SCS_CUE_COUNTDOWN_TO_START) And (nItemState <= #SCS_CUE_FADING_OUT)) Or
               ((\bSubTypeAorP) And (nItemState >= #SCS_CUE_COUNTDOWN_TO_START) And (nItemState <= #SCS_CUE_FADING_OUT)) Or
               ((\bSubTypeI) And (nItemState >= #SCS_CUE_COUNTDOWN_TO_START) And (nItemState <= #SCS_CUE_FADING_OUT))
              debugMsg(sProcName, "calling fadeOutOneSub(" + getSubLabel(j) + ", #True)")
              fadeOutOneSub(j, #True)
              bThisCueChanged = #True
              ; If (aCue(i)\nActivationMethod <> #SCS_ACMETH_TIME) And (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)
              If (aCue(i)\nActivationMethodReqd <> #SCS_ACMETH_TIME) And (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)  ; modified 25Aug2016 11.5.2
                ; don't set gnFirstCueStopped for TBC's or for the standby cue or for disabled cues, or for hotkeys or for callable cues
                If (aSub(j)\bHotkey = #False) And (aSub(j)\bExtAct = #False) And (aSub(j)\bCallableCue = #False)
                  If gnFirstCueStopped = -1
                    gnFirstCueStopped = i
                    debugMsg(sProcName, "gnFirstCueStopped=" + getCueLabel(gnFirstCueStopped))
                  EndIf
                EndIf
              EndIf
              
            ElseIf ((\bSubTypeF) And (nItemState >= #SCS_CUE_READY) And (nItemState < #SCS_CUE_FADING_OUT)) Or
                   ((\bSubTypeA) And (nItemState >= #SCS_CUE_READY) And (nItemState < #SCS_CUE_FADING_OUT)) Or
                   ((\bSubTypeI) And (nItemState >= #SCS_CUE_READY) And (nItemState < #SCS_CUE_FADING_OUT)) Or
                   ((\bSubTypeK) And (nItemState >= #SCS_CUE_READY) And (nItemState < #SCS_CUE_FADING_OUT)) Or
                   ((\bSubTypeP) And (((nItemState >= #SCS_CUE_READY) And (nItemState < #SCS_CUE_FADING_OUT)) Or (nItemState = #SCS_CUE_PL_READY))) Or
                   ((\bSubTypeL) And (nItemState >= #SCS_CUE_READY) And (nItemState <= #SCS_CUE_FADING_OUT)) Or
                   ((\bSubTypeM) And (nItemState >= #SCS_CUE_READY) And (nItemState <= #SCS_CUE_FADING_OUT)) Or
                   ((\bSubTypeN) And (nItemState >= #SCS_CUE_READY) And (nItemState <= #SCS_CUE_FADING_OUT)) Or
                   ((\bSubTypeS) And (nItemState >= #SCS_CUE_READY) And (nItemState <= #SCS_CUE_FADING_OUT))
              If (aCue(i)\bHotkey Or aCue(i)\bCallableCue) And (nItemState = #SCS_CUE_READY)
                ; test added 6Mar2020 11.8.2.2bc following log and reports from Declan Brennan
                ; no action
              Else
                debugMsg(sProcName, "calling stopSub(" + getSubLabel(j) + ", " + pSubSubType + ", #False, " + strB(bJustStop) + ", " + strB(bUseCas) + ")")
                stopSub(j, pSubSubType, #False, bJustStop, bUseCas)
                bThisCueChanged = #True
                ; If (aCue(i)\nActivationMethod <> #SCS_ACMETH_TIME) And (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)
                If (aCue(i)\nActivationMethodReqd <> #SCS_ACMETH_TIME) And (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)  ; modified 25Aug2016 11.5.2
                  ; don't set gnFirstCueStopped for TBC's or for the standby cue or for disabled cues, or for hotkeys or for callable cues
                  If (aSub(j)\bHotkey = #False) And (aSub(j)\bExtAct = #False) And (aSub(j)\bCallableCue = #False)
                    If gnFirstCueStopped = -1
                      gnFirstCueStopped = i
                      debugMsg(sProcName, "gnFirstCueStopped=" + getCueLabel(gnFirstCueStopped))
                    EndIf
                  EndIf
                EndIf
              EndIf
              
            ElseIf (\bSubTypeF Or \bSubTypeP Or \bSubTypeA Or \bSubTypeI) And (bStopNotLoadedCues)
              k = \nFirstAudIndex
              While k >= 0
                nItemState = aAud(k)\nAudState
                bWantThisAud = #False
                If bPlayingCuesOnly
                  If (nItemState >= #SCS_CUE_COUNTDOWN_TO_START) And (nItemState <= #SCS_CUE_FADING_OUT)
                    bWantThisAud = #True
                  EndIf
                Else
                  bWantThisAud = #True
                EndIf
                If (bWantThisAud)
                  If (nItemState = #SCS_CUE_NOT_LOADED) Or (nItemState = #SCS_CUE_COUNTDOWN_TO_START) Or (nItemState = #SCS_CUE_SUB_COUNTDOWN_TO_START) Or (nItemState = #SCS_CUE_PL_COUNTDOWN_TO_START)
                    debugMsg(sProcName, aAud(k)\sAudLabel + " setting \nAudState (" + decodeCueState(nItemState) + ") to SCS_CUE_COMPLETED")
                    debugMsg(sProcName, "calling endOfAud(" + getAudLabel(k) + ", " + decodeCueState(#SCS_CUE_COMPLETED) + ")")
                    endOfAud(k, #SCS_CUE_COMPLETED)
                    bThisCueChanged = #True
                    ; If (aCue(i)\nActivationMethod <> #SCS_ACMETH_TIME) And (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)
                    If (aCue(i)\nActivationMethodReqd <> #SCS_ACMETH_TIME) And (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)  ; modified 25Aug2016 11.5.2
                      ; don't set gnFirstCueStopped for TBC's or for the standby cue or for disabled cues, or for hotkeys or for callable cues
                      If (aSub(j)\bHotkey = #False) And (aSub(j)\bExtAct = #False) And (aSub(j)\bCallableCue = #False)
                        If gnFirstCueStopped = -1
                          gnFirstCueStopped = i
                          debugMsg(sProcName, "gnFirstCueStopped=" + getCueLabel(gnFirstCueStopped))
                        EndIf
                      EndIf
                    EndIf
                  EndIf
                EndIf
                k = aAud(k)\nNextAudIndex
              Wend
              
            ElseIf (\bSubTypeE Or \bSubTypeG Or \bSubTypeK Or \bSubTypeL Or \bSubTypeM Or \bSubTypeN Or \bSubTypeQ Or \bSubTypeR Or \bSubTypeT Or \bSubTypeU) And
                   (nItemState >= #SCS_CUE_READY) And (nItemState < #SCS_CUE_COMPLETED)
              debugMsg(sProcName, "calling stopSub(" + getSubLabel(j) + ", " + pSubSubType + ", #False, " + strB(bJustStop) + ", " + strB(bUseCas) + ")")
              stopSub(j, pSubSubType, #False, bJustStop, bUseCas)
              bThisCueChanged = #True
              ; If (aCue(i)\nActivationMethod <> #SCS_ACMETH_TIME) And (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)
              If (aCue(i)\nActivationMethodReqd <> #SCS_ACMETH_TIME) And (i <> gnStandbyCuePtr) And (aCue(i)\bCueCurrentlyEnabled)  ; modified 25Aug2016 11.5.2
                ; don't set gnFirstCueStopped for TBC's or for the standby cue or for disabled cues, or for hotkeys or for callable cues
                If (aSub(j)\bHotkey = #False) And (aSub(j)\bExtAct = #False) And (aSub(j)\bCallableCue = #False)
                  If gnFirstCueStopped = -1
                    gnFirstCueStopped = i
                    debugMsg(sProcName, "gnFirstCueStopped=" + getCueLabel(gnFirstCueStopped))
                  EndIf
                EndIf
              EndIf
              
            EndIf
          EndIf
          j = \nNextSubIndex
        EndWith
      Wend
      If bThisCueChanged
        bAnyCueChanged = #True
        clearCurrHotkeyToggleState(i)
        setCueState(i, #True)
        updateGrid(i)
        If bSFRCompleteAssocAutoStartCues
          debugMsg(sProcName, "calling completeAssocAutoStartCues(" + getCueLabel(i) + ")")
          completeAssocAutoStartCues(i)
        ElseIf bSFRHoldAssocAutoStartCues
          debugMsg(sProcName, "calling holdAssocAutoStartCues(" + getCueLabel(i) + ")")
          holdAssocAutoStartCues(i)
        EndIf
      EndIf
    EndIf
  Next i

  If bAnyCueChanged
    gnCallOpenNextCues = 1
    debugMsg(sProcName, "gnCallOpenNextCues=" + gnCallOpenNextCues)
    debugMsg(sProcName, "(11) setting gbCallLoadDispPanels=#True")
    gbCallLoadDispPanels = #True
    debugMsg(sProcName, "calling setCueToGo()")
    setCueToGo()
    gbCallSetNavigateButtons = #True
  EndIf
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure fadeOutOneAud(pAudPtr, nRequestedBySubPtr=-1)
  PROCNAMECA(pAudPtr)
  Protected nBassResult.l, nTimeToGo, d, d2, n, nFadeOutType
  Protected nNewAudState
  Protected bMyPicture, nPictureTarget
  Protected sDevPXChanListLeft.s, sDevPXChanListRight.s
  Protected sDevXChanListLeft.s, sDevXChanListRight.s
  Protected sLevelInfo.s, sSetCommandItem.s
  Protected sAudSetGainCommandString.s
  Protected sCmdDetail.s
  Protected nInputDevMapDevPtr, nOutputDevMapDevPtr
  Protected nReqdFadeOutTime, bPrevInFadeImage
  
  debugMsg(sProcName, #SCS_START + ", nRequestedBySubPtr=" + getSubLabel(nRequestedBySubPtr))
  
  bPrevInFadeImage = gbInFadeImage ; Added 10Aug2021 11.8.5rc2b
  
  With aAud(pAudPtr)
    
    nNewAudState = #SCS_CUE_FADING_OUT
    
    If gbFadingEverything And gnFadeEverythingTime > 0
      nReqdFadeOutTime = gnFadeEverythingTime
    Else
      nReqdFadeOutTime = \nCurrFadeOutTime
    EndIf
    
    If \bAudTypeA   ; \bAudTypeA
      If \nFileFormat = #SCS_FILEFORMAT_PICTURE
        gbInFadeImage = #True ; Added 10Aug2021 11.8.5rc2b
        bMyPicture = #True
        \nFinalFadeOutTime = 0
      EndIf
      nFadeOutType = #SCS_FADE_STD
      If gbFadingEverything
        nTimeToGo = gnFadeEverythingTime
      Else
        ; added 20Mar2020 11.8.2.3ad for vMix
        ; If \nNextPlayIndex = -1 And aSub(\nSubIndex)\bPLRepeat = #False ; Added "And aSub(\nSubIndex)\bPLRepeat = #False" 7Oct2020 11.8.3.2bj following forum bug report from 'Gaiden'
        If \nNextPlayIndex = -1 And getPLRepeatActive(\nSubIndex) = #False
          If aSub(\nSubIndex)\bPLTerminating = #False
            aSub(\nSubIndex)\bPLTerminating = #True
            debugMsg(sProcName, "aSub(" + getSubLabel(\nSubIndex) + ")\bPLTerminating=#True")
          EndIf
        EndIf
        ; end added 20Mar2020 11.8.2.3ad
        debugMsg(sProcName, "aSub(" + getSubLabel(\nSubIndex) + ")\bPLTerminating=" + strB(aSub(\nSubIndex)\bPLTerminating) + ", \nPLCurrFadeOutTime=" + aSub(\nSubIndex)\nPLCurrFadeOutTime +
                            ", aAud(" + getAudLabel(pAudPtr) + ")\nPLTransTime=" + \nPLTransTime)
        If aSub(\nSubIndex)\bPLTerminating
          nTimeToGo = aSub(\nSubIndex)\nPLCurrFadeOutTime
        Else
          nTimeToGo = \nPLTransTime
          nNewAudState = #SCS_CUE_TRANS_FADING_OUT
        EndIf
      EndIf
      debugMsg(sProcName, "bMyPicture=" + strB(bMyPicture) + ", nTimeToGo=" + nTimeToGo)
      
    ElseIf \bAudTypeF   ; \bAudTypeF
      If \nSourceAltChannel <> 0
        \bFadeInProgress = #False  ; temporarily prevent another thread from processing a related fade on this Aud
        \nRequestedBySubPtr = nRequestedBySubPtr
        ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nRequestedBySubPtr=" + getSubLabel(\nRequestedBySubPtr))
        \nFadeType = #SCS_FADE_STD
        If nRequestedBySubPtr >= 0
          If aSub(nRequestedBySubPtr)\bSubTypeS
            \nFadeType = \nFadeOutType
          ElseIf aSub(nRequestedBySubPtr)\bSubTypeL
            \nFadeType = aSub(nRequestedBySubPtr)\nLCType
          EndIf
        EndIf
        \qTimeFadeStarted = gqTimeNow
        For d = 0 To grLicInfo\nMaxAudDevPerAud
          If \sLogicalDev[d]
            \fPreFadeBVLevel[d] = \fCueTotalVolNow[d]
            \fPreFadePan[d] = \fCuePanNow[d]
            \fTargetBVLevel[d] = #SCS_MINVOLUME_SINGLE
            \fTargetPan[d] = \fPreFadePan[d]
            \nReqdFadeTime[d] = nReqdFadeOutTime
            \bFadeCompleted[d] = #False
            ; added 10Aug2016 11.5.2 following bug report that resuming a fade-out hibernated cue did not fade-in the cue
            \fBVLevelWhenFadeOutStarted[d] = \fCueTotalVolNow[d]
            debugMsg(sProcName, "\fBVLevelWhenFadeOutStarted[" + d + "]=" + traceLevel(\fBVLevelWhenFadeOutStarted[d]))
            ; end added 10Aug2016 11.5.2
          Else
            \bFadeCompleted[d] = #True
          EndIf
        Next d
        \qTimeForNextFadeCheck = gqTimeNow
        \bFadeRequested = #True
        \bFadeInProgress = #True   ; now turn on this fading
      EndIf
      If gbUseBASS  ; BASS
        nFadeOutType = \nFadeOutType
        If (nFadeOutType = #SCS_FADE_LIN_SE) Or (nFadeOutType = #SCS_FADE_LOG_SE)
          \nMainFadeOutTime = nReqdFadeOutTime * 0.8     ; set fade out at a rate to end 80% thru the requested time
          \nFinalFadeOutTime = nReqdFadeOutTime * 0.3    ; the remaining 12.5% will fade out over 30% of the requested time
          nTimeToGo = \nMainFadeOutTime
        Else
          ; \nMainFadeOutTime not used for non-se fadeouts
          ; \nFinalFadeOutTime = 500 ; 0.5 second
          ; \nFinalFadeOutTime = 125 ; 1/8 second (changed from 0.5 second 30Jun2020 11.8.3.2aj)
          \nFinalFadeOutTime = 5 ; 5 milliseconds (changed from 0.5 second 30Jun2020 11.8.3.2aj)
          ; added 12Oct2016 11.5.2.3
          ; Following issue reported by Sebastian Franke whereby an audio file cue with a cross-fade loop set to fade out (by an SFR cue) over a period of 0.06 second actually
          ; took about a second. See files etc sent 11Oct2016
          If \nFinalFadeOutTime > nReqdFadeOutTime
            If (\nMaxLoopInfo >= 0) And (\rCurrLoopInfo\nLoopXFadeTime > 0) ; added this test 22Nov2016 11.5.2.4 following bug report from BritGeek (Tim Addison): "Problem with short fades in 11.5.2.3"
                                                                            ; (the test should not be applied if the cue does not contain a cross-fade loop)
              \nFinalFadeOutTime = nReqdFadeOutTime * 0.3
            EndIf
          EndIf
          ; end added 12Oct2016 11.5.2.3
          nTimeToGo = nReqdFadeOutTime
          debugMsg(sProcName, "\nFinalFadeOutTime=" + \nFinalFadeOutTime + ", \nCurrFadeOutTime=" + \nCurrFadeOutTime + ", nReqdFadeOutTime=" + nReqdFadeOutTime + ", nTimeToGo=" + nTimeToGo)
        EndIf
        
      Else  ; SM-S
        nFadeOutType = \nFadeOutType
        nTimeToGo = nReqdFadeOutTime
        
      EndIf
      
    ElseIf \bAudTypeI   ; \bAudTypeI
      If gbUseSMS
        nFadeOutType = \nFadeOutType
        nTimeToGo = nReqdFadeOutTime
      EndIf
      
    ElseIf \bAudTypeP   ; \bAudTypeP
      nFadeOutType = #SCS_FADE_STD
      If aSub(\nSubIndex)\bPLTerminating
        nTimeToGo = aSub(\nSubIndex)\nPLCurrFadeOutTime
      Else
        nTimeToGo = \nPLTransTime
        nNewAudState = #SCS_CUE_TRANS_FADING_OUT
      EndIf
      
    EndIf
    
    If \bAudTypeI = #False
      If bMyPicture = #False
        If \nRelFilePos > (\nRelEndAt - nTimeToGo) And (\nMaxLoopInfo < 0)
          nTimeToGo = \nRelEndAt - \nRelFilePos
        EndIf
      EndIf
    EndIf
    
    \nCuePosAtFadeStart = \nCuePos
    debugMsg(sProcName, "\nCuePosAtFadeStart=" + \nCuePosAtFadeStart)
    
    If gbFadingEverything
      nTimeToGo = gnFadeEverythingTime
    EndIf
   
    If nTimeToGo < 0
      nTimeToGo = 0
    EndIf
    If nTimeToGo <= 500
      \bFinalFadeOut = #True
    EndIf
    
    If bMyPicture = #False
      If \bAudTypeA   ; \bAudTypeA
        d = 0
        \fBVLevelWhenFadeOutStarted[d] = \fCueTotalVolNow[d]
        
      ElseIf \bAudTypeI   ; \bAudTypeI
        If gbUseSMS
          For d2 = \nFirstInputDev To \nLastInputDev
            nInputDevMapDevPtr = \nInputDevMapDevPtr[d2]
            If nInputDevMapDevPtr >= 0
              For d = \nFirstDev To \nLastDev
                nOutputDevMapDevPtr = \nOutputDevMapDevPtr[d]
                If nOutputDevMapDevPtr >= 0
                  For n = 0 To (grMaps\aDev(nOutputDevMapDevPtr)\nNrOfDevOutputChans - 1)
                    sCmdDetail + " x" + Str(grMaps\aDev(nInputDevMapDevPtr)\nFirst1BasedInputChan - 1) + "." + Str(grMaps\aDev(nOutputDevMapDevPtr)\nFirst1BasedOutputChan - 1 + n)
                  Next n
                  If d2 = \nFirstInputDev
                    ; only need to set fBVLevelWhenFadeOutStarted[d] once per output device, so set it on the first input device
                    \fBVLevelWhenFadeOutStarted[d] = \fCueTotalVolNow[d]
                  EndIf
                EndIf
              Next d
            EndIf
          Next d2
          If Len(sCmdDetail) > 0
            sCmdDetail + " gain 0"
            If nTimeToGo > 0
              sCmdDetail + " fadetime " + makeSMSTimeString(nTimeToGo)
            EndIf
            sendSMSCommand("set chan " + Trim(sCmdDetail), #cTraceSetLevels)
          EndIf
        EndIf
        
      Else  ; \bAudTypeF, \bAudTypeP
        If gbUseBASS  ; BASS
          debugMsg(sProcName, "\bFadeInProgress=" + strB(\bFadeInProgress))
          ; If \bFadeInProgress = #False ; commented out 14Dec2018 11.8.0rc3 - not sure why this test is here - it delays sliding the channel which may be why Detlef had problems with short delay times
            For d = \nFirstSoundingDev To \nLastSoundingDev
              If \nBassChannel[d] <> 0
                \fBVLevelWhenFadeOutStarted[d] = \fCueTotalVolNow[d]
                debugMsg(sProcName, "\fBVLevelWhenFadeOutStarted[" + d + "]=" + traceLevel(\fBVLevelWhenFadeOutStarted[d]))
                If \bAudTypeF
                  Select nFadeOutType
                    Case #SCS_FADE_STD, #SCS_FADE_LIN, #SCS_FADE_LIN_SE
                      debugMsg(sProcName, "calling slideChannelAttributes(" + getAudLabel(pAudPtr) + ", " + d + ", #SCS_MINVOLUME_SINGLE, #SCS_NOPANCHANGE_SINGLE, " + nTimeToGo + ", 250001)")
                      slideChannelAttributes(pAudPtr, d, #SCS_MINVOLUME_SINGLE, #SCS_NOPANCHANGE_SINGLE, nTimeToGo, 250001)
                  EndSelect
                EndIf
              EndIf
            Next d
          ; EndIf
        Else  ; SM-S
          For d = \nFirstSoundingDev To \nLastSoundingDev
            sDevPXChanListLeft = \sDevPXChanListLeft[d]
            sDevPXChanListRight = \sDevPXChanListRight[d]
            If Len(sDevPXChanListLeft) > 0
              sLevelInfo = setLevelsForSMSOutputDev(pAudPtr, d, #SCS_MINVOLUME_SINGLE, #SCS_NOPANCHANGE_SINGLE, nTimeToGo, \nFadeOutType)
              debugMsg(sProcName, "d=" + d + ", sLevelInfo=" + sLevelInfo)
              sSetCommandItem = " chan " + sDevPXChanListLeft + " " + sDevPXChanListRight + " " + StringField(sLevelInfo, 1, "|")
              debugMsg(sProcName, "sSetCommandItem=" + sSetCommandItem)
              sAudSetGainCommandString + sSetCommandItem
            EndIf
          Next d
          If Len(sAudSetGainCommandString) > 0
            sendSMSCommand("set " + Trim(sAudSetGainCommandString), #cTraceSetLevels)
          EndIf
        EndIf
      EndIf
    EndIf
    
    If \nAudState <> #SCS_CUE_FADING_OUT
      \qEndAtTime = gqTimeNow + nTimeToGo
    EndIf
    \nAudState = nNewAudState
    \qTimeFadeOutStarted = gqTimeNow
    \bTimeFadeOutStartedSet = #True
    \nPreFadeOutTimeOnPause = \nTotalTimeOnPause
    debugMsg(sProcName, "\nAudState=" + decodeCueState(\nAudState) + ", \bTimeFadeOutStartedSet=" + strB(\bTimeFadeOutStartedSet) + ", \qTimeFadeOutStarted=" + traceTime(\qTimeFadeOutStarted) +
                        ", \nPreFadeOutTimeOnPause=" + \nPreFadeOutTimeOnPause + ", \qEndAtTime=" + traceTime(\qEndAtTime))
    
    CompilerIf #c_include_tvg
      If \bAudTypeA
        If grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_VMIX
          CompilerIf #c_vMix_in_video_cues
            vMix_FadeOutInput(pAudPtr, nTimeToGo)
          CompilerEndIf
        ElseIf grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG
          If (\nFileFormat = #SCS_FILEFORMAT_PICTURE) And ((grVideoDriver\nVideoPlaybackLibrary <> #SCS_VPL_TVG) Or (checkUse2DDrawing(\nSubIndex)))
            If aSub(\nSubIndex)\bStartedInEditor
              nPictureTarget = #SCS_VID_PIC_TARGET_P
            Else
              nPictureTarget = getVidPicTargetForOutputScreen(aSub(\nSubIndex)\nOutputScreen)
            EndIf
            debugMsg(sProcName, "calling beginFadeOutPrimary(" + getAudLabel(pAudPtr) + ", " + decodeVidPicTarget(nPictureTarget) + ", " + nTimeToGo + ")")
            beginFadeOutPrimary(pAudPtr, nPictureTarget, nTimeToGo)
          Else
            debugMsg(sProcName, "calling addAudToTVGFadeAudArray(" + getAudLabel(pAudPtr) + ")")
            addAudToTVGFadeAudArray(pAudPtr)
          EndIf
        Else
          If bMyPicture
            If aSub(\nSubIndex)\bStartedInEditor
              nPictureTarget = #SCS_VID_PIC_TARGET_P
            Else
              nPictureTarget = getVidPicTargetForOutputScreen(aSub(\nSubIndex)\nOutputScreen)
            EndIf
            debugMsg(sProcName, "calling beginFadeOutPrimary(" + getAudLabel(pAudPtr) + ", " + decodeVidPicTarget(nPictureTarget) + ", " + nTimeToGo + ")")
            beginFadeOutPrimary(pAudPtr, nPictureTarget, nTimeToGo)
          EndIf
        EndIf
      EndIf ; EndIf \bAudTypeA
    CompilerElse
      If bMyPicture
        If aSub(\nSubIndex)\bStartedInEditor
          nPictureTarget = #SCS_VID_PIC_TARGET_P
        Else
          nPictureTarget = getVidPicTargetForOutputScreen(aSub(\nSubIndex)\nOutputScreen)
        EndIf
        debugMsg(sProcName, "calling beginFadeOutPrimary(" + getAudLabel(pAudPtr) + ", " + decodeVidPicTarget(nPictureTarget) + ", " + nTimeToGo + ")")
        beginFadeOutPrimary(pAudPtr, nPictureTarget, nTimeToGo)
      EndIf
    CompilerEndIf
    
  EndWith
  
  gbInFadeImage = bPrevInFadeImage ; Added 10Aug2021 11.8.5rc2b
  
EndProcedure

Procedure fadeOutOneSub(pSubPtr, bStopCountingDownSubs=#False, nRequestedBySubPtr=-1)
  PROCNAMECS(pSubPtr)
  Protected k
  Protected bHibernating
  Protected bHotkey, bExtAct, bCallableCue

  debugMsg(sProcName, #SCS_START + ", pSubPtr=" + pSubPtr + ", bStopCountingDownSubs=" + strB(bStopCountingDownSubs) + ", nRequestedBySubPtr=" + getSubLabel(nRequestedBySubPtr))
  
  bHibernating = aSub(pSubPtr)\bHibernating
  bHotkey = aSub(pSubPtr)\bHotkey
  bExtAct = aSub(pSubPtr)\bExtAct
  bCallableCue = aSub(pSubPtr)\bCallableCue
  
  If (aSub(pSubPtr)\bSubTypeA) Or (aSub(pSubPtr)\bSubTypeP)  ; \bSubTypeA or \bSubTypeP
    k = aSub(pSubPtr)\nFirstPlayIndex
    While k >= 0
      With aAud(k)
        debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nAudNo=" + \nAudNo + ", \nAudState=" + decodeCueState(\nAudState) +
                            ", \fCueVolNow(" + \nFirstDev + ")=" + formatLevel(\fCueVolNow[\nFirstDev]) + ", aSub(" + getSubLabel(pSubPtr) + ")\nPLCurrFadeOutTime=" + aSub(pSubPtr)\nPLCurrFadeOutTime)
        If (\nAudState >= #SCS_CUE_FADING_IN) And (\nAudState < #SCS_CUE_FADING_OUT)
          ; added 26May2017 11.6.2ai following email from Luis Vilarrasa regarding the effect of an SFR cue to fade out a slideshow when a cross-fade is happening
          If (\nAudState <> #SCS_CUE_TRANS_FADING_OUT) And (\nAudState <> #SCS_CUE_TRANS_MIXING_OUT)
            If \bBlending
              debugMsg(sProcName, "setting aAud(" + getAudLabel(k) + ")\bBlending=#False")
              \bBlending = #False
            EndIf
            ; end added 26May2017 11.6.2ai
            If (aSub(pSubPtr)\nPLCurrFadeOutTime > 0) Or (gbFadingEverything)
              debugMsg(sProcName, "calling fadeOutOneAud(" + getAudLabel(k) + ", " + getSubLabel(nRequestedBySubPtr) + ")")
              fadeOutOneAud(k, nRequestedBySubPtr)
            Else
              debugMsg(sProcName, "calling stopAud(" + getAudLabel(k) + ")")
              stopAud(k)
            EndIf
          EndIf
        ElseIf \nAudState >= #SCS_CUE_COUNTDOWN_TO_START And \nAudState <= #SCS_CUE_PL_COUNTDOWN_TO_START
          debugMsg(sProcName, "calling stopAud(" + getAudLabel(k) + ")")
          stopAud(k)
        ElseIf (\nAudState = #SCS_CUE_NOT_LOADED Or \nAudState = #SCS_CUE_READY Or \nAudState = #SCS_CUE_PL_READY) And
               (bHibernating = #False) And
               (bHotkey = #False) And (bExtAct = #False) And (bCallableCue = #False)
          If \nAudState <> #SCS_CUE_NOT_LOADED
            debugMsg(sProcName, "calling closeAud(" + getAudLabel(k) + ", #True)")
            closeAud(k, #True)
          EndIf
          \nAudState = #SCS_CUE_COMPLETED
          ; debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nAudState=" + decodeCueState(aAud(k)\nAudState))
        EndIf
        ; debugMsg(sProcName, \sAudLabel + ", \nAudState=" + decodeCueState(\nAudState))
        k = \nNextPlayIndex
      EndWith
    Wend
    
  ElseIf (aSub(pSubPtr)\bSubTypeF) Or (aSub(pSubPtr)\bSubTypeI)  ; \bSubTypeF or \bSubTypeI
    k = aSub(pSubPtr)\nFirstAudIndex
    If k >= 0
      With aAud(k)
        debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nAudNo=" + \nAudNo + ", \nAudState=" + decodeCueState(\nAudState) + ", \fCueVolNow(" + \nFirstDev + ")=" + formatLevel(\fCueVolNow[\nFirstDev]) + ", \nCurrFadeOutTime=" + \nCurrFadeOutTime)
        If (\nAudState = #SCS_CUE_PLAYING) Or (\nAudState = #SCS_CUE_FADING_IN)
          If \nCurrFadeOutTime > 0
            debugMsg(sProcName, "calling fadeOutOneAud(" + getAudLabel(k) + ", " + getSubLabel(nRequestedBySubPtr) + ")")
            fadeOutOneAud(k, nRequestedBySubPtr)
          Else
            debugMsg(sProcName, "calling stopAud(" + getAudLabel(k) + ")")
            stopAud(k)
          EndIf
        ElseIf (\nAudState = #SCS_CUE_NOT_LOADED Or \nAudState = #SCS_CUE_READY) And (bHibernating = #False) And (bHotkey = #False And bExtAct = #False)
          If \nAudState <> #SCS_CUE_NOT_LOADED
            debugMsg(sProcName, "calling closeAud(" + getAudLabel(k) + ", #True)")
            closeAud(k, #True)
          EndIf
          debugMsg(sProcName, "calling endOfAud(" + getAudLabel(k) + ", " + decodeCueState(#SCS_CUE_COMPLETED) + ")")
          endOfAud(k, #SCS_CUE_COMPLETED)
        EndIf
        If bStopCountingDownSubs
          If (\nAudState >= #SCS_CUE_COUNTDOWN_TO_START) And (\nAudState <= #SCS_CUE_PL_COUNTDOWN_TO_START)
            debugMsg(sProcName, "calling closeAud(" + getAudLabel(k) + ")")
            closeAud(k)
            debugMsg(sProcName, "calling endOfAud(" + getAudLabel(k) + ", " + decodeCueState(#SCS_CUE_COMPLETED) + ")")
            endOfAud(k, #SCS_CUE_COMPLETED)
          EndIf
        EndIf
      EndWith
    EndIf
    
  ElseIf aSub(pSubPtr)\bSubTypeU  ; added 11Mar2017 11.6.0 following test of Harold Fernades cues where a toggle hotket cue didn't stop MTC on toggle off
    stopSub(pSubPtr, "U", #True, #False)
    
  ElseIf aSub(pSubPtr)\bSubTypeE  ; added 23Mar2020 11.8.2.3af following report from Tim Hornett where he used an SFR cue to 'fade out and stop' a Memo cue, and the Memo cue didn't close
    stopSub(pSubPtr, "E", #True, #False)
    
  Else
    ; 15/08/2014 11.3.3 added to allow \bSubTypeG to be completed, following email from John Hutchinson re escaping from a cue loop
    endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
    
  EndIf
  
  With aSub(pSubPtr)
    setCueState(\nCueIndex)
    debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\nSubState=" + decodeCueState(\nSubState) + ", aCue(" + getCueLabel(\nCueIndex) + ")\nCueState=" + decodeCueState(aCue(\nCueIndex)\nCueState))
    
    ; Added 4Jan2020 11.8.2.1ax
    If gbStoppingEverything
      If aCue(\nCueIndex)\nCueState = #SCS_CUE_COMPLETED
        gnFirstCueStopped = \nCueIndex
        debugMsg(sProcName, "gnFirstCueStopped=" + getCueLabel(gnFirstCueStopped))
      EndIf
    EndIf
    ; End added 4Jan2020 11.8.2.1ax
    
    listCueStates(\nCueIndex)
    updateGrid(\nCueIndex)
  EndWith
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure fadeOutSub(pSubPtr, bOpenNextCues, bStopCountingDownSubs=#False, bHibernate=#False, bFadeOutLinked=#False, nRequestedBySubPtr=-1)
  PROCNAMECS(pSubPtr)
  Protected k2, k, j
  Protected nMyAudLinkCount
  Protected nCuePtr, nCallCuePtr
  
  debugMsg(sProcName, #SCS_START + ", bStopCountingDownSubs=" + strB(bStopCountingDownSubs) + ", bHibernate=" + strB(bHibernate) +
                      ", bFadeOutLinked=" + strB(bFadeOutLinked) + ", nRequestedBySubPtr=" + getSubLabel(nRequestedBySubPtr))
  
  With aSub(pSubPtr)
    If \bSubTypeAorP
      debugMsg(sProcName, "setting \bPLTerminating = #True")
      \bPLTerminating = #True ; prevents other aud's in the playlist starting
      debugMsg(sProcName, "aSub(" + getSubLabel(pSubPtr) + ")\bPLTerminating=" + strB(\bPLTerminating))
    EndIf
    
    If \bSubTypeQ
      nCallCuePtr = \nCallCuePtr
      If nCallCuePtr >= 0
        If aCue(nCallCuePtr)\bSubTypeK
          j = aCue(nCallCuePtr)\nFirstSubIndex
          While j >= 0
            If aSub(j)\bSubTypeK And aSub(j)\bSubEnabled
              If aSub(j)\nSubState = #SCS_CUE_PLAYING
                Select aCue(nCallCuePtr)\nActivationMethod
                  Case #SCS_ACMETH_HK_NOTE, #SCS_ACMETH_HK_TOGGLE, #SCS_ACMETH_EXT_NOTE, #SCS_ACMETH_EXT_TOGGLE
                    debugMsg(sProcName, "calling resetHotkeyDMXValues(" + getSubLabel(j) + ")")
                    resetHotkeyDMXValues(j)
                  Default
                    debugMsg(sProcName, "calling blackOutSubTypeK(" + getSubLabel(j) + ")")
                    blackOutSubTypeK(j)
                EndSelect
              EndIf
            EndIf
            j = aSub(j)\nNextSubIndex
          Wend
        EndIf
      EndIf
    EndIf
    
    If \bSubTypeK
      nCuePtr = \nCueIndex
      Select aCue(nCuePtr)\nActivationMethod
        Case #SCS_ACMETH_HK_NOTE, #SCS_ACMETH_HK_TOGGLE, #SCS_ACMETH_EXT_NOTE, #SCS_ACMETH_EXT_TOGGLE
          debugMsg(sProcName, "calling resetHotkeyDMXValues(" + getSubLabel(pSubPtr) + ")")
          resetHotkeyDMXValues(pSubPtr)
        Default
          debugMsg(sProcName, "calling blackOutSubTypeK(" + getSubLabel(pSubPtr) + ")")
          blackOutSubTypeK(pSubPtr)
      EndSelect
    Else
      \bHibernating = bHibernate
      If bHibernate
        \bFadingPreHibernating = #True
      Else
        \bFadingPreHibernating = #False
      EndIf
      
      debugMsg(sProcName, "calling fadeOutOneSub for " + buildSubLabel(pSubPtr))
      fadeOutOneSub(pSubPtr, bStopCountingDownSubs, nRequestedBySubPtr)
      
      If bFadeOutLinked
        If \bSubTypeHasAuds
          k = \nFirstPlayIndex
          While k >= 0
            debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nAudLinkCount=" + Str(aAud(k)\nAudLinkCount) + ", \nFirstLink=" + Str(aAud(k)\nFirstAudLink) + ", gnLastAud=" + Str(gnLastAud))
            If aAud(k)\nAudLinkCount > 0
              nMyAudLinkCount = aAud(k)\nAudLinkCount
              For k2 = aAud(k)\nFirstAudLink To gnLastAud
                If aAud(k2)\bExists
                  If aAud(k2)\nLinkedToAudPtr = k
                    debugMsg(sProcName, "calling fadeOutOneSub for linked cue " + buildSubLabel(aAud(k2)\nSubIndex))
                    fadeOutOneSub(aAud(k2)\nSubIndex, bStopCountingDownSubs, nRequestedBySubPtr)
                    nMyAudLinkCount - 1
                    If nMyAudLinkCount = 0
                      Break   ; Break k2 loop
                    EndIf
                  EndIf
                EndIf
              Next k2
            EndIf
            k = aAud(k)\nNextPlayIndex
          Wend
        EndIf
      EndIf
    EndIf
    
    If bOpenNextCues
      If aCue(\nCueIndex)\nCueState = #SCS_CUE_COMPLETED
        gnCallOpenNextCues = 1
        debugMsg(sProcName, "gnCallOpenNextCues=" + gnCallOpenNextCues)
        debugMsg(sProcName, "calling setCueToGo()")
        setCueToGo()
        gbCallSetNavigateButtons = #True
      EndIf
    EndIf
    
  EndWith
  
EndProcedure

Procedure playAud(pAudPtr, bUseCas=#False, bStartingOrResumingPlaylist=#False, nCasGroupId=-1, bTopLevelCall=#False, bCheckProgSlider=#True, nCtrlSendIndex=-1)
  PROCNAMECA(pAudPtr)
  Protected d, d2, bFadeIn, l2
  Protected h, nTmpAudPtr
  Protected rCasInfo.tyCasItem
  Protected nVidPicTarget, nVidPicTargetAll
  Protected nMidiAudPtr
  Protected sAudSetGainCommandString.s, sSetCommandItem.s, sLevelInfo.s
  Protected nPrimSubIndex ; \nSubIndex of aAud(pAudPtr), to distinguish it more clearly from \nSubIndex values used in the loop of linked Aud's (modified 3Feb2020 11.8.2.2af)
  Protected nTmpSubIndex  ; \nSubIndex of aAud(nTmpAudPtr), which is used in the loop of linked Aud's (added 3Feb2020 11.8.2.2af)
  Protected bMyUseCas
  Protected nMasterBassLinkPosSync
  Protected nPrevCueIndex
  Protected nInputDevMapDevPtr
  Protected fInputLevel.f, fBVLevel.f, fReqdXLevel.f
  Protected bPlayAudChannelsCalledForPrimaryAud
  Protected bSubStartedInEditor
  Protected nMyAudLinkCount
  Protected nTraceMutexLockingValue = 0  ; set to 1 to turn on tracing of mutex locking during this procedure
  Protected bOpenMediaResult
  Protected nVideoCanvasNo
  Protected nPlayFromPos, nLoopToGo
  Protected nIndex
  Protected nScreenIndex, nScreenVidPicTarget
  Protected nMonitorWindowNo, nOutputWindowNo
  Protected bFadeInActioned
  Protected b2DDrawingImage
  Protected nPhysicalDevPtr
  Protected bCallResetAudState
  Protected bCallPlayAudChannelsNow, nMTCSubPtr

;   debugMsg(sProcName, #SCS_START)
  
  If pAudPtr < 0
    ; shouldn't get here
    ProcedureReturn
  EndIf
  
  With aAud(pAudPtr)
    If gbUseSMS
      bMyUseCas = #False
    Else
      bMyUseCas = bUseCas
    EndIf
    debugMsg(sProcName, #SCS_START +
                        ", bMyUseCas=" + strB(bMyUseCas) +
                        ", bStartingOrResumingPlaylist=" + strB(bStartingOrResumingPlaylist) +
                        ", nCasGroupId=" + nCasGroupId +
                        ", bTopLevelCall=" + strB(bTopLevelCall) +
                        ", bCheckProgSlider=" + strB(bCheckProgSlider) +
                        ", nCtrlSendIndex=" + nCtrlSendIndex)
    
    debugMsg(sProcName, "\nSubIndex=" + getSubLabel(\nSubIndex) +
                        ", \nAudState=" + decodeCueState(\nAudState) + ", \nFileState=" + decodeFileState(\nFileState) + ", \nAudVidPicTarget=" + decodeVidPicTarget(\nAudVidPicTarget) + ", \nCurrFadeInTime=" + \nCurrFadeInTime)
    
    gbInPlayAud = #True
    nPrimSubIndex = \nSubIndex ; added 3Feb2020 11.8.2.2af
    gnTraceMutexLocking + nTraceMutexLockingValue
    logKeyEvent("Play Aud " + getAudLabel(pAudPtr))
    
    setGlobalTimeNow()
    
    If \nFileFormat = #SCS_FILEFORMAT_PICTURE And \nImageFrameCount > 1
      ; Animated image
      b2DDrawingImage = #True
    EndIf
      
    If grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG
      If (\nFileFormat = #SCS_FILEFORMAT_PICTURE) And (checkUse2DDrawing(nPrimSubIndex))
        b2DDrawingImage = #True
      EndIf
    EndIf

    If nPrimSubIndex >= 0
      bSubStartedInEditor = aSub(nPrimSubIndex)\bStartedInEditor
    EndIf
    
    If bSubStartedInEditor
      debugMsg(sProcName, "bSubStartedInEditor=" + strB(bSubStartedInEditor))
      If \bAudTypeP
        rWQP\bCallSetOrigDBLevels = #True
      EndIf
    EndIf
  
    nMasterBassLinkPosSync = \nBassLinkPosSync
    
    ; debugMsg(sProcName, "gbAsioInitDone=" + strB(gbAsioInitDone) + ", gbAsioStarted=" + strB(gbAsioStarted))
    If gbUseBASS
      If gbAsioInitDone
        If gbAsioStarted = #False
          startAsioDevices()
        EndIf
      EndIf
    EndIf
    
    rCasInfo\nCasGroupId = nCasGroupId
    
    \bIgnoreInStatusCheck = #False
    \bPlayNextAudRequested = #False
    \bFadingInFromHibernate = #False
    \sAudPrevSetGainCommandString = ""
    
    If (\bAudTypeA) And (\nVideoSource = #SCS_VID_SRC_CAPTURE)
      ; no action here
    ElseIf \bAudTypeI
      debugMsg(sProcName, "calling setGainCommandStringsForInputs(" + getAudLabel(pAudPtr) + ")")
      setGainCommandStringsForInputs(pAudPtr)
    ElseIf \nFileState <> #SCS_FILESTATE_OPEN
      debugMsg(sProcName, "calling openMediaFile(" + getAudLabel(pAudPtr) + ")")
      openMediaFile(pAudPtr)
      ; debugMsg(sProcName, "returned from openMediaFile(" + getAudLabel(pAudPtr) + ")")
    EndIf
    
    If bSubStartedInEditor
      nMyAudLinkCount = 0
    Else
      nMyAudLinkCount = \nAudLinkCount
    EndIf
    
    CompilerIf #c_include_tvg
      If bSubStartedInEditor
        If (\bAudTypeA) And (grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG)
          nIndex = getTVGIndexForAud(pAudPtr, #SCS_VID_PIC_TARGET_P)
          If nIndex < 0
            Select \nVideoSource
              Case #SCS_VID_SRC_CAPTURE
                debugMsg(sProcName, "calling openVideoCaptureDevForTVG(" + getAudLabel(pAudPtr) + ", " + decodeVidPicTarget(#SCS_VID_PIC_TARGET_P) + ")")
                nPhysicalDevPtr = openVideoCaptureDevForTVG(pAudPtr, #SCS_VID_PIC_TARGET_P)
                debugMsg(sProcName, "openVideoCaptureDevForTVG(" + getAudLabel(nEditAudPtr) + ", " + decodeVidPicTarget(nVidPicTarget) + ") returned nPhysicalDevPtr=" + nPhysicalDevPtr)
              Case #SCS_VID_SRC_FILE
                If (\bLogo = #False) And (b2DDrawingImage = #False)
                  \nPreviewVideoNo = openVideoFileForTVG(pAudPtr, #SCS_VID_PIC_TARGET_P)
                  debugMsg(sProcName, "openVideoFileForTVG(" + getAudLabel(pAudPtr) + ", #SCS_VID_PIC_TARGET_P) returned \nPreviewVideoNo=" + \nPreviewVideoNo)
                EndIf
            EndSelect
          Else
            setTVGDisplayLocation(nIndex)
          EndIf
        EndIf
      EndIf
    CompilerEndIf
    
  EndWith
  
  debugMsg(sProcName, "\nFileFormat=" + decodeFileFormat(aAud(pAudPtr)\nFileFormat) + ", nMyAudLinkCount=" + Str(nMyAudLinkCount))
  Select aAud(pAudPtr)\nFileFormat
    Case  #SCS_FILEFORMAT_MIDI  ; MIDI FILE
      ;{
      With aAud(pAudPtr)
        If playMidiFile(pAudPtr, bMyUseCas, nCasGroupId, nCtrlSendIndex) = #False
          ; MIDI file cannot be played
          ;casReadyGroup(nCasGroupId)
          gbInPlayAud = #False
          gnTraceMutexLocking - nTraceMutexLockingValue ; mutex2
          ProcedureReturn
        Else
          If \nAudState = #SCS_CUE_NOT_LOADED
            If \bAudTypeForP
              ; debugMsg(sProcName, "calling openMediaFile(" + getAudLabel(pAudPtr) + ")")
              openMediaFile(pAudPtr)
              ; debugMsg(sProcName, "returned from openMediaFile(" + getAudLabel(pAudPtr) + ")")
            EndIf
          EndIf
          \qEndAtTime = grAudDef\qEndAtTime
          \bMediaStarted = #False
          \bMediaEnded = #False
          \qTimeAudStarted = gqTimeNow
          setMTCAtAudStartIfReqd(pAudPtr)
          ; \nTimeAudEnded = 0
          \bTimeAudEndedSet = #False
          \bStopCompleted = #False
          If \bCheckProgSlider
            \qTimeAudRestarted = gqTimeNow - \nRelFilePos + \nRelPassStart
            \bCheckProgSlider = #False
            ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\bCheckProgSlider=" + strB(\bCheckProgSlider))
          Else
            \qTimeAudRestarted = gqTimeNow
          EndIf
          \nTotalTimeOnPause = 0
          \nPriorTimeOnPause = 0
          \nPreFadeInTimeOnPause = 0
          \nPreFadeOutTimeOnPause = 0
          \nCuePosAtLoopStart = 0
          \bFinalFadeOut = #False
          \bFinalSlide = #False
          \nRelEndAt = \nAbsEndAt - \nAbsMin
          \nRelFilePos = \nRelStartAt
          \bInLoopXFade = #False
          \nCurrLoopInfoIndex = grAudDef\nCurrLoopInfoIndex
          \nAudState = #SCS_CUE_PLAYING
          setCueState(\nCueIndex)
          If \nCueIndex <> nPrevCueIndex
            samAddRequest(#SCS_SAM_LOAD_GRID_ROW, \nCueIndex)
            nPrevCueIndex = \nCueIndex
          EndIf
          debugMsg(sProcName, "\qTimeAudRestarted=" + traceTime(aAud(pAudPtr)\qTimeAudRestarted) + ", \nRelFilePos=" + \nRelFilePos)
        EndIf
      EndWith
      ;}
    Default ; AUDIO, VIDEO, PICTURE, LIVEINPUT
      For h = 0 To nMyAudLinkCount
        ; debugMsg(sProcName, "h=" + h)
        CheckSubInRange(pAudPtr, ArraySize(gaAudSet(),1), "gaAudSet(),1 h=" + h)
        CheckSubInRange(h, ArraySize(gaAudSet(),2), "gaAudSet(),2 pAudPtr=" + pAudPtr)
        nTmpAudPtr = gaAudSet(pAudPtr, h)
        ; debugMsg(sProcName, "h=" + h + ", nTmpAudPtr=" + getAudLabel(nTmpAudPtr))
        If nTmpAudPtr > 0
          With aAud(nTmpAudPtr)
            nTmpSubIndex = \nSubIndex ; added 3Feb2020 11.8.2.2af
            ; debugMsg(sProcName, "h=" + h + ", aAud(" + getAudLabel(nTmpAudPtr) + ")\nLinkedToAudPtr=" + getAudLabel(\nLinkedToAudPtr))
            If (nTmpAudPtr = pAudPtr) Or (gbUseBASSMixer = #False)
              
              If \bAudTypeI ; \bAudTypeI
                ;{
                debugMsg(sProcName, "\bAudTypeI")
                setInputOnOffCounts(nTmpAudPtr)
                If \nInputOffCount > 0
                  processInputsOff(nTmpAudPtr)
                EndIf
                If \nInputOnCount = 0
                  debugMsg(sProcName, "calling closeAud(" + getAudLabel(nTmpAudPtr) + ", #True, #True)")
                  closeAud(nTmpAudPtr, #False, #True)
                  ProcedureReturn
                Else
                  If \nFileState <> #SCS_FILESTATE_OPEN
                    debugMsg(sProcName, "calling openInputChannels(" + getAudLabel(nTmpAudPtr) + ")")
                    openInputChannels(nTmpAudPtr)
                  EndIf
                  
                  If gbUseSMS
                    setSyncPChanListForAud(nTmpAudPtr)
                    debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\sSyncSetGainList=" + \sSyncSetGainList)
                    If bTopLevelCall = #False
                      aSub(nTmpSubIndex)\sSubSetGainCommandString + " " + Trim(\sSyncSetGainList)
                      debugMsg(sProcName, "aSub(" + getSubLabel(nTmpSubIndex) + ")\sSubSetGainCommandString=" + aSub(nTmpSubIndex)\sSubSetGainCommandString)
                      debugMsg(sProcName, "\bSetLevelsWhenPlayAud=" + strB(\bSetLevelsWhenPlayAud))
                      If \bSetLevelsWhenPlayAud
                        aSub(nTmpSubIndex)\bSetLevelsWhenPlaySub = #True
                      EndIf
                      debugMsg(sProcName, "aSub(" + getSubLabel(nTmpSubIndex) + ")\bSetLevelsWhenPlaySub=" + strB(aSub(nTmpSubIndex)\bSetLevelsWhenPlaySub))
                    Else
                      debugMsg(sProcName, "\bSetLevelsWhenPlayAud=" + strB(\bSetLevelsWhenPlayAud) + ", \sSyncSetGainList=" + \sSyncSetGainList)
                      If (\bSetLevelsWhenPlayAud) And Len(Trim(\sSyncSetGainList)) > 0
                        sendSMSCommand("set " + Trim(\sSyncSetGainList))
                      EndIf
                    EndIf
                    If \nCurrFadeInTime > 0
                      \nAudState = #SCS_CUE_FADING_IN
                      \qTimeFadeInStarted = gqTimeNow
                      \nCuePosAtFadeStart = \nCuePos
                      debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\qTimeFadeInStarted=" + traceTime(\qTimeFadeInStarted) + ", \nCuePosAtFadeStart=" + \nCuePosAtFadeStart)
                      \bTimeFadeInStartedSet = #True
                    Else
                      \nAudState = #SCS_CUE_PLAYING
                    EndIf
                    If bTopLevelCall
                      buildGetSMSCurrInfoCommandStrings()
                    EndIf
                    debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nAudState=" + decodeCueState(\nAudState) + ", \sPPrimaryChan=" + \sPPrimaryChan + ", \sAudPChanList=" + \sAudPChanList + ", \sSyncPChanList=" + \sSyncPChanList)
                  EndIf
                  WCN_setLiveOnInds()
                EndIf
                ;}
              Else ; not \bAudTypeI
                If (\nVideoSource = #SCS_VID_SRC_FILE) And (\nFileState <> #SCS_FILESTATE_OPEN)
                  debugMsg(sProcName, "calling openMediaFile(" + getAudLabel(nTmpAudPtr) + ")")
                  openMediaFile(nTmpAudPtr)
                EndIf
                debugMsg(sProcName, "starting " + getAudLabel(nTmpAudPtr) + " at " + \nRelStartAt)
                \bMediaStarted = #False
                \bMediaEnded = #False
                \qEndAtTime = grAudDef\qEndAtTime
                \nRelEndAt = \nAbsEndAt - \nAbsMin
                debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nAbsEndAt=" + \nAbsEndAt + ", \nAbsMin=" + \nAbsMin + ", \nRelEndAt=" + \nRelEndAt)
                setRelCheckForEnd(pAudPtr)
                If \nFileFormat = #SCS_FILEFORMAT_MIDI   ; nb even though main aAud format is not MIDI, a 'linked' aAud may be MIDI
                  nMidiAudPtr = nTmpAudPtr
                ElseIf \nFileFormat = #SCS_FILEFORMAT_AUDIO
                  ; nb calling setBassPlayEnd() is essential to ensure \bPlayEndSyncOccurred is set #True
                  debugMsg(sProcName, "calling setBassPlayEnd(" + getAudLabel(nTmpAudPtr) + ")")
                  setBassPlayEnd(nTmpAudPtr)
                EndIf
                For l2 = 0 To \nMaxLoopInfo
                  \aLoopInfo(l2)\bLoopReleased = #False
                Next l2
                If \bAudTypeA = #False
                  debugMsg(sProcName, "calling loadCurrLoopInfo(" + getAudLabel(nTmpAudPtr) + ", " + \nCuePos + ")")
                  loadCurrLoopInfo(nTmpAudPtr, \nCuePos)
                  If \rCurrLoopInfo\bLoopReleased
                    debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\rCurrLoopInfo\bLoopReleased=" + strB(\rCurrLoopInfo\bLoopReleased))
                  EndIf
                EndIf
                \bBetweenMixAndHearSyncPoints = #False
                \bPlayEndSyncOccurred = #False
                \nRelPassStart = \nRelStartAt
                \nLoopPassNo = grAudDef\nLoopPassNo
                If \rCurrLoopInfo\nLoopSyncIndex >= 0
                  gaLoopSync(\rCurrLoopInfo\nLoopSyncIndex)\nLoopSyncPassNo = 1
                EndIf
                \bFinalFadeOut = #False
                \bFinalSlide = #False
                \bInLoopXFade = #False
                ; debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\bInLoopXFade=" + strB(\bInLoopXFade) + ", \nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex + ", \nLoopPassNo=" + \nLoopPassNo)
                If \nMaxLoopInfo >= 0 ; \bContainsLoop
                  If gbUseBASS
                    If usingLoopXFade(nTmpAudPtr)
                      If \nFirstSoundingDev >= 0
                        If \nBassAltChannel[\nFirstSoundingDev] = 0
                          ; contains loop but the Alt channel hasn't been opened yet, so close and re-open the file
                          debugMsg(sProcName, "calling closeAud(" + getAudLabel(nTmpAudPtr) + ")")
                          closeAud(nTmpAudPtr)
                          debugMsg(sProcName, "calling openMediaFile(" + getAudLabel(nTmpAudPtr) + ")")
                          openMediaFile(nTmpAudPtr)
                        EndIf
                      EndIf
                    EndIf
                    \nRelPassEnd = \rCurrLoopInfo\nRelLoopEnd
                    debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nRelPassEnd=" + \nRelPassEnd)
                    debugMsg(sProcName, "calling setBassLoopStart(" + getAudLabel(nTmpAudPtr) + ")")
                    setBassLoopStart(nTmpAudPtr)
                    debugMsg(sProcName, "calling setBassLoopEnd(" + getAudLabel(nTmpAudPtr) + ")")
                    setBassLoopEnd(nTmpAudPtr)
                  Else ; gbUseSMS
                    ; If usingLoopXFade(nTmpAudPtr)
                      debugMsg(sProcName, "calling setSMSLoopStart(" + getAudLabel(nTmpAudPtr) + ")")
                      setSMSLoopStart(nTmpAudPtr)
                      debugMsg(sProcName, "calling setSMSLoopEnd(" + getAudLabel(nTmpAudPtr) + ")")
                      setSMSLoopEnd(nTmpAudPtr)
                    ; EndIf
                    \nRelPassEnd = \rCurrLoopInfo\nRelLoopEnd
                    debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nRelPassEnd=" + \nRelPassEnd)
                  EndIf
                  ; debugMsg(sProcName, "calling listLoopInfoArray(" + getAudLabel(nTmpAudPtr) + ")")
                  ; listLoopInfoArray(nTmpAudPtr)
                Else
                  \nRelPassEnd = \nRelEndAt
                  debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nRelPassEnd=" + \nRelPassEnd)
                EndIf
                
                If \bAudTypeF   ; \bAudTypeF
                  ;{
                  If \nFileFormat = #SCS_FILEFORMAT_AUDIO
                    If bCheckProgSlider
                      If (\nMaxLoopInfo >= 0) And (\rCurrLoopInfo\nLoopXFadeTime > 0)
                        debugMsg(sProcName, "\rCurrLoopInfo\nAbsLoopStart=" + \rCurrLoopInfo\nAbsLoopStart + ", \rCurrLoopInfo\nAbsLoopEnd=" + \rCurrLoopInfo\nAbsLoopEnd)
                        If (\nCuePos >= (\rCurrLoopInfo\nAbsLoopEnd - \rCurrLoopInfo\nLoopXFadeTime)) And (\nCuePos <= \rCurrLoopInfo\nAbsLoopEnd)
                          nLoopToGo = \rCurrLoopInfo\nAbsLoopEnd - \nCuePos
                          nPlayFromPos = \rCurrLoopInfo\nAbsLoopStart + nLoopToGo
                          debugMsg(sProcName, "nLoopToGo=" + nLoopToGo + ", nPlayFromPos=" + nPlayFromPos)
                          debugMsg(sProcName, "calling reposAuds(" + getAudLabel(nTmpAudPtr) + ", " + nPlayFromPos + ")")
                          reposAuds(nTmpAudPtr, nPlayFromPos, #False, #True)
                        EndIf
                      EndIf
                    EndIf
                    
                    debugMsg(sProcName, "\nMaxLoopInfo=" + \nMaxLoopInfo + ", \nCuePos=" + \nCuePos + ", \rCurrLoopInfo\nLoopEnd=" + \rCurrLoopInfo\nLoopEnd + ", \nAbsMin=" + \nAbsMin)
                    If \nMaxLoopInfo >= 0
                      ; If \nCuePos >= (\nLoopEnd - \nAbsMin)   ; del 29Jun2017 11.6.3ab
                      If \nCuePos >= (\rCurrLoopInfo\nAbsLoopEnd - \nAbsMin)  ; add 29Jun2017 11.6.3ab
                        debugMsg(sProcName, "calling releaseAudLoop(" + getAudLabel(nTmpAudPtr) + ")")
                        releaseAudLoop(nTmpAudPtr)
                      EndIf
                    EndIf
                    
                    debugMsg(sProcName, "calling loadLvlPtRun(" + getAudLabel(nTmpAudPtr) + ", " + \nCuePos + ", #True, " + strB(#cTraceSetLevels) + ")")
                    loadLvlPtRun(nTmpAudPtr, \nCuePos, #True, #cTraceSetLevels)
                    If gbUseBASS  ; BASS
                      debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nFirstSoundingDev=" + \nFirstSoundingDev + ", \nLastSoundingDev=" + \nLastSoundingDev)
                      For d = \nFirstSoundingDev To \nLastSoundingDev
                        If \nBassChannel[d] <> 0
                          ; debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nBassChannel[" + d + "]=" + decodeHandle(\nBassChannel[d]))
                          If \bCueVolManual[d] = #False
                            \fCueVolNow[d] = \aLvlPtRun[d]\fFromLevel
                            \fCueAltVolNow[d] = #SCS_MINVOLUME_SINGLE
                            \fCueTotalVolNow[d] = \fCueVolNow[d]
                            CompilerIf #cTraceCueTotalVolNow
                              debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\fCueTotalVolNow[" + d + "]=" + traceLevel(aAud(nTmpAudPtr)\fCueTotalVolNow[d]))
                            CompilerEndIf
                          EndIf
                          If \bCuePanManual[d] = #False
                            \fCuePanNow[d] = \aLvlPtRun[d]\fFromPan
                          EndIf
                          ; debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\fBVLevel[" + d + "]=" + formatLevel(\fBVLevel[d]) + ", \fCueVolNow[" + d + "]=" + formatLevel(\fCueVolNow[d]))
                          If nMasterBassLinkPosSync = 0
                            ; debugMsg(sProcName, "calling setLevels(" + getAudLabel(nTmpAudPtr) + ", " + d + ", " + formatLevel(\fCueVolNow[d]) + ", " + formatPan(\fCuePanNow[d]) + ")")
                            setLevelsBASS(nTmpAudPtr, d, \fCueVolNow[d], \fCuePanNow[d])
                          Else
                            ; debugMsg(sProcName, "calling setLevels(" + getAudLabel(nTmpAudPtr) + ", " + d + ", " + formatLevel(#SCS_MINVOLUME_SINGLE) + ", " + formatPan(\fCuePanNow[d]) + ")")
                            setLevelsBASS(nTmpAudPtr, d, #SCS_MINVOLUME_SINGLE, \fCuePanNow[d])
                          EndIf
                          ; debugMsg(sProcName, "returned from setLevels()")
                        EndIf
                      Next d
                      ; Added 1Feb2022 11.9.0rc7
                      \nCuePos = \nRelFilePos
                      If \nCurrFadeInTime > 0
                        \nAudState = #SCS_CUE_FADING_IN
                        \qTimeFadeInStarted = gqTimeNow
                        \nCuePosAtFadeStart = \nCuePos
                        debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\qTimeFadeInStarted=" + traceTime(\qTimeFadeInStarted) + ", \nCuePosAtFadeStart=" + \nCuePosAtFadeStart)
                        \bTimeFadeInStartedSet = #True
                      Else
                        \nAudState = #SCS_CUE_PLAYING
                      EndIf
                      ; End added 1Feb2022 11.9.0rc7
                      
                    Else  ; SM-S
                      If bTopLevelCall = #False
                        aSub(nTmpSubIndex)\sSubSetGainCommandString + " " + Trim(\sSyncSetGainList)
                        aSub(nTmpSubIndex)\sSubPlayCommandString + " " + Trim(\sSyncPChanList)
                        debugMsg(sProcName, "aSub(" + getSubLabel(nTmpSubIndex) + ")\sSubSetGainCommandString=" + aSub(nTmpSubIndex)\sSubSetGainCommandString)
                        debugMsg(sProcName, "aSub(" + getSubLabel(nTmpSubIndex) + ")\sSubPlayCommandString=" + aSub(nTmpSubIndex)\sSubPlayCommandString)
                        debugMsg(sProcName, "\bSetLevelsWhenPlayAud=" + strB(\bSetLevelsWhenPlayAud))
                        If \bSetLevelsWhenPlayAud
                          aSub(nTmpSubIndex)\bSetLevelsWhenPlaySub = #True
                        EndIf
                        debugMsg(sProcName, "aSub(" + getSubLabel(nTmpSubIndex) + ")\bSetLevelsWhenPlaySub=" + strB(aSub(nTmpSubIndex)\bSetLevelsWhenPlaySub))
                      Else
                        debugMsg(sProcName, "\bSetLevelsWhenPlayAud=" + strB(\bSetLevelsWhenPlayAud) + ", \sSyncSetGainList=" + \sSyncSetGainList)
                        If (\bSetLevelsWhenPlayAud) And Trim(\sSyncSetGainList)
                          sendSMSCommand("set " + Trim(\sSyncSetGainList))
                        EndIf
                        If aCue(\nCueIndex)\nActivationMethod <> #SCS_ACMETH_LTC
                          If Trim(\sSyncPChanList)
                            sendSMSCommand("play " + Trim(\sSyncPChanList))
                          EndIf
                        EndIf
                      EndIf
                      If \nCurrFadeInTime > 0
                        \nAudState = #SCS_CUE_FADING_IN
                        \qTimeFadeInStarted = gqTimeNow
                        \nCuePosAtFadeStart = \nCuePos
                        debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\qTimeFadeInStarted=" + traceTime(\qTimeFadeInStarted) + ", \nCuePosAtFadeStart=" + \nCuePosAtFadeStart)
                        \bTimeFadeInStartedSet = #True
                      Else
                        \nAudState = #SCS_CUE_PLAYING
                      EndIf
                      If bTopLevelCall
                        buildGetSMSCurrInfoCommandStrings()
                      EndIf
                      debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nAudState=" + decodeCueState(\nAudState) + ", \sPPrimaryChan=" + \sPPrimaryChan + ", \sAudPChanList=" + \sAudPChanList + ", \sSyncPChanList=" + \sSyncPChanList)
                    EndIf
                  EndIf
                  ;}
                  
                ElseIf \bAudTypeA   ; \bAudTypeA
                  ;{
                  debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\bLogo=" + strB(\bLogo) + ", \nImageFrameCount=" + \nImageFrameCount)
                  \bCancelAudAnimation = #False
                   ; Added 15Mar2025 11.10.8al
                  If \bLogo And aSub(nTmpSubIndex)\bStartedInEditor = #False
                    gnLogoAudPtr = nTmpAudPtr
                  EndIf
                   ; End added 15Mar2025 11.10.8al
                  debugMsg(sProcName, "gnLogoAudPtr=" + getAudLabel(gnLogoAudPtr))
                  If \bLogo And aSub(\nSubIndex)\bUseNew2DDrawing ; Added bUseNew2DDrawing test 9Jan2025 11.10.6-b02 as part of the fix for logos not to be displayed using 2D Drawing if the sub's bUseNew2DDrawing=#False
                    If (aSub(nTmpSubIndex)\bStartedInEditor) And (gbPreviewOnOutputScreen = #False Or grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG) ; mod 19Jan2020 11.8.2.2ae nSubIndex -> nTmpSubIndex
                      nVidPicTarget = #SCS_VID_PIC_TARGET_P
                    Else
                      nVidPicTarget = getVidPicTargetForOutputScreen(aSub(nTmpSubIndex)\nOutputScreen) ; mod 19Jan2020 11.8.2.2ae nSubIndex -> nTmpSubIndex
                    EndIf
                    \nAudVidPicTarget = nVidPicTarget
                    debugMsg(sProcName, "\nAudVidPicTarget=" + decodeVidPicTarget(\nAudVidPicTarget))
                    ; Added 24Feb2024 11.10.2av to enable a replacement logo to be displayed
                    grVidPicTarget(nVidPicTarget)\bLogoCurrentlyDisplayed = #False
                    debugMsg(sProcName, "grVidPicTarget(" + decodeVidPicTarget(nVidPicTarget) + ")\bLogoCurrentlyDisplayed=" + strB(grVidPicTarget(nVidPicTarget)\bLogoCurrentlyDisplayed))
                    ; End added 24Feb2024 11.10.2av
                    Select grVideoDriver\nVideoPlaybackLibrary
                      Case #SCS_VPL_VMIX
                        CompilerIf #c_vMix_in_video_cues
                          debugMsg(sProcName, "calling vMix_ReplaceBlackWithLogo(" + getAudLabel(nTmpAudPtr) + ")")
                          vMix_ReplaceBlackWithLogo(nTmpAudPtr)
                        CompilerEndIf
                      Default
                        If nVidPicTarget >= #SCS_VID_PIC_TARGET_F2
                          For nScreenIndex = 0 To \nMaxScreenInfo
                            nScreenVidPicTarget = \aScreenInfo(nScreenIndex)\nAudVidPicTarget
                            ; grVidPicTarget(nScreenVidPicTarget)\nLogoImageNo = nLogoImageNo
                            grVidPicTarget(nScreenVidPicTarget)\nLogoImageNo = \nVidPicTargetImageNo(nScreenVidPicTarget)
                            grVidPicTarget(nScreenVidPicTarget)\nLogoFadeInTime = aSub(nTmpSubIndex)\nPLFadeInTime
                            grVidPicTarget(nScreenVidPicTarget)\nLogoAudId = \nAudId
                            debugMsg(sProcName, "grVidPicTarget(" + decodeVidPicTarget(nScreenVidPicTarget) + ")\nLogoImageNo=" + decodeHandle(grVidPicTarget(nScreenVidPicTarget)\nLogoImageNo) + ", \nLogoAudId=" + grVidPicTarget(nScreenVidPicTarget)\nLogoAudId)
                            clearVideoCanvasIfNotInUse(nScreenVidPicTarget)
                          Next nScreenIndex
                        ElseIf nVidPicTarget = #SCS_VID_PIC_TARGET_P
                          ; grVidPicTarget(nVidPicTarget)\nLogoImageNo = nLogoImageNo
                          grVidPicTarget(nScreenVidPicTarget)\nLogoImageNo = \nVidPicTargetImageNo(nVidPicTarget)
                          grVidPicTarget(nVidPicTarget)\nLogoFadeInTime = aSub(nTmpSubIndex)\nPLFadeInTime
                          grVidPicTarget(nVidPicTarget)\nLogoAudId = \nAudId
                          debugMsg(sProcName, "grVidPicTarget(" + decodeVidPicTarget(nVidPicTarget) + ")\nLogoImageNo=" + decodeHandle(grVidPicTarget(nVidPicTarget)\nLogoImageNo) + ", \nLogoAudId=" + grVidPicTarget(nVidPicTarget)\nLogoAudId)
                          clearVideoCanvasIfNotInUse(nVidPicTarget)
                        EndIf
                    EndSelect
                    
                  Else ; \bLogo = #False
                    CompilerIf #c_include_tvg
                      If (grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG) And (b2DDrawingImage = #False)
                        If bSubStartedInEditor
                          nIndex = getTVGIndexForAud(nTmpAudPtr, #SCS_VID_PIC_TARGET_P)
                          If nIndex < 0
                            debugMsg(sProcName, "calling openVideoFileForTVG(" + getAudLabel(nTmpAudPtr) + ", #SCS_VID_PIC_TARGET_P)")
                            \nPreviewVideoNo = openVideoFileForTVG(nTmpAudPtr, #SCS_VID_PIC_TARGET_P)
                          EndIf
                        EndIf
                      EndIf
                    CompilerEndIf
                    
                    If \nNextPlayIndex = -1
                      ; if about to play last track then re-call setPLFades so that if playlist is continuous then the first track will have it's fadein time set if applicable
                      ; debugMsg(sProcName, "calling setPLFades(" + getSubLabel(nTmpSubIndex) + ")")
                      ; debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nCurrFadeInTime=" + \nCurrFadeInTime)
                      setPLFades(nTmpSubIndex)
                      ; debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nCurrFadeInTime=" + \nCurrFadeInTime)
                    EndIf
                    aSub(nTmpSubIndex)\bPLTerminating = #False ; mod 19Jan2020 11.8.2.2ae nSubIndex -> nTmpSubIndex
                    ; debugMsg(sProcName, "aSub(" + getSubLabel(nTmpSubIndex) + ")\bPLTerminating=" + strB(aSub(\nSubIndex)\bPLTerminating)) ; mod 19Jan2020 11.8.2.2ae nSubIndex -> nTmpSubIndex
                    aSub(nTmpSubIndex)\nPLAudPlayCount + 1 ; mod 19Jan2020 11.8.2.2ae nSubIndex -> nTmpSubIndex
                    \bPLSkipDone = #False
                    aSub(nTmpSubIndex)\nCurrPlayIndex = nTmpAudPtr ; mod 19Jan2020 11.8.2.2ae nSubIndex -> nTmpSubIndex
                    ; debugMsg(sProcName, "aSub(" + getSubLabel(nTmpSubIndex) + ")\nCurrPlayIndex=" + getAudLabel(aSub(nTmpSubIndex)\nCurrPlayIndex))
                    bFadeInActioned = #False
                    If bStartingOrResumingPlaylist
                      ; If aSub(nTmpSubIndex)\nPLFadeInTime > 0 ; mod 19Jan2020 11.8.2.2ae nSubIndex -> nTmpSubIndex
                      If aSub(nTmpSubIndex)\nPLCurrFadeInTime > 0 ; mod 19Jan2020 11.8.2.2ae nSubIndex -> nTmpSubIndex ; mod 13May2020 11.8.3rc4 \nPLFadeInTime -> \nPLCurrFadeInTime
                        aSub(nTmpSubIndex)\bPLFadingIn = #True    ; mod 19Jan2020 11.8.2.2ae nSubIndex -> nTmpSubIndex
                        If (grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG) And (b2DDrawingImage = #False)
                          \bTimeFadeInStartedSet = #False
                        Else
                          \qTimeFadeInStarted = gqTimeNow
                          \nCuePosAtFadeStart = \nCuePos
                          ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\qTimeFadeInStarted=" + traceTime(\qTimeFadeInStarted) + ", \nCuePosAtFadeStart=" + \nCuePosAtFadeStart)
                          \bTimeFadeInStartedSet = #True
                        EndIf
                        \nPreFadeInTimeOnPause = \nTotalTimeOnPause
                        CompilerIf #c_include_tvg
                          If (grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG) And (b2DDrawingImage = #False)
                            ; debugMsg(sProcName, "calling addAudToTVGFadeAudArray(" + getAudLabel(nTmpAudPtr) + ")")
                            addAudToTVGFadeAudArray(nTmpAudPtr)
                          EndIf
                        CompilerEndIf
                        bFadeInActioned = #True
                      EndIf
                    EndIf
                    ; debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nCurrFadeInTime=" + \nCurrFadeInTime)
                    If \nCurrFadeInTime > 0
                      \nAudState = #SCS_CUE_FADING_IN
                      If bFadeInActioned = #False
                        If (grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG) And (b2DDrawingImage = #False)
                          \bTimeFadeInStartedSet = #False
                        Else
                          \qTimeFadeInStarted = gqTimeNow
                          ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\qTimeFadeInStarted=" + traceTime(\qTimeFadeInStarted))
                          \bTimeFadeInStartedSet = #True
                        EndIf
                        \nPreFadeInTimeOnPause = \nTotalTimeOnPause
                        \nCuePosAtFadeStart = \nCuePos
                        ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nCuePosAtFadeStart=" + \nCuePosAtFadeStart)
                        CompilerIf #c_include_tvg
                          If (grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG) And (b2DDrawingImage = #False)
                            ; debugMsg(sProcName, "calling addAudToTVGFadeAudArray(" + getAudLabel(nTmpAudPtr) + ")")
                            addAudToTVGFadeAudArray(nTmpAudPtr)
                          EndIf
                        CompilerEndIf
                        bFadeInActioned = #True
                      EndIf
                    Else
                      \nAudState = #SCS_CUE_PLAYING
                    EndIf
                    debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nAudState=" + decodeCueState(\nAudState) + ", aSub(" + getSubLabel(nTmpSubIndex) + ")\nPLCurrFadeInTime=" + aSub(nTmpSubIndex)\nPLCurrFadeInTime +
                                        ", \nCurrFadeInTime=" + \nCurrFadeInTime + ", \bTimeFadeInStartedSet=" + strB(\bTimeFadeInStartedSet) +
                                        ", \nFadeInTime=" + \nFadeInTime + ", \qTimeFadeInStarted=" + traceTime(\qTimeFadeInStarted))
                    If aCue(\nCueIndex)\nHideCueOpt = #SCS_HIDE_NO
                      ; debugMsg(sProcName, "setting gbCallLoadDispPanels=#True")
                      gbCallLoadDispPanels = #True
                    EndIf
                    
                    ; debugMsg(sProcName, "aSub(" + getSubLabel(nTmpSubIndex) + ")\bStartedInEditor=" + strB(aSub(nTmpSubIndex)\bStartedInEditor))
                    If (aSub(nTmpSubIndex)\bStartedInEditor) And (gbPreviewOnOutputScreen = #False Or b2DDrawingImage = #False)
                      nVidPicTarget = #SCS_VID_PIC_TARGET_P
                    Else
                      nVidPicTarget = getVidPicTargetForOutputScreen(aSub(nTmpSubIndex)\nOutputScreen)
                    EndIf
                    \nAudVidPicTarget = nVidPicTarget
                    ; debugMsg(sProcName, "\nAudVidPicTarget=" + decodeVidPicTarget(\nAudVidPicTarget))
                    
                    If aSub(nTmpSubIndex)\bStartedInEditor = #False
                      nVideoCanvasNo = \nAudVideoCanvasNo(nVidPicTarget)
                    Else
                      If gbPreviewOnOutputScreen And grVideoDriver\nVideoPlaybackLibrary <> #SCS_VPL_VMIX
                        nVideoCanvasNo = \nAudVideoCanvasNo(nVidPicTarget)
                      Else
                        nVideoCanvasNo = WQA\cvsPreview
                      EndIf
                    EndIf
                    If IsGadget(nVideoCanvasNo)
                      grVidPicTarget(nVidPicTarget)\nTargetCanvasNo = nVideoCanvasNo
                      ; debugMsg(sProcName, "grVidPicTarget(" + decodeVidPicTarget(nVidPicTarget) + ")\nTargetCanvasNo=" + getGadgetName(grVidPicTarget(nVidPicTarget)\nTargetCanvasNo))
                    EndIf
                    
                    ; added 22Apr2022 11.9.1bc following email from Willi Hartel about fade ins for a linked image file not fading in
                    If aSub(nTmpSubIndex)\bStartedInEditor = #False
                      For nVidPicTargetAll = #SCS_VID_PIC_TARGET_F2 To #SCS_VID_PIC_TARGET_LAST
                        If aSub(nTmpSubIndex)\bOutputScreenReqd(nVidPicTargetAll)
                          grVidPicTarget(nVidPicTargetAll)\nCurrentSubPtr = nTmpSubIndex
                          ; debugMsg(sProcName, "grVidPicTarget(" + decodeVidPicTarget(nVidPicTargetAll) + ")\nCurrentSubPtr=" + getSubLabel(grVidPicTarget(nVidPicTargetAll)\nCurrentSubPtr))
                        EndIf
                      Next nVidPicTargetAll
                      \bCallSetWindowVisible = aCue(\nCueIndex)\bCallSetWindowVisible
                      ; debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\bCallSetWindowVisible=" + strB(\bCallSetWindowVisible))
                    EndIf
                    ; end added 22Apr2022 11.9.1bc
                    
                    If \nFileFormat = #SCS_FILEFORMAT_VIDEO
                      ; debugMsg(sProcName, "calling setPLLevels(" + getAudLabel(nTmpAudPtr) + ")")
                      setPLLevels(nTmpAudPtr, #False, #True)  ; setPLLevels() with fadein
                    EndIf
                    
                    ; debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nFileFormat=" + decodeFileFormat(aAud(nTmpAudPtr)\nFileFormat) + ", checkUse2DDrawing(" + getSubLabel(nPrimSubIndex) + ")=" + strB(checkUse2DDrawing(nPrimSubIndex)))
                    If (aAud(nTmpAudPtr)\nFileFormat = #SCS_FILEFORMAT_PICTURE) And
                       (grVideoDriver\nVideoPlaybackLibrary <> #SCS_VPL_VMIX) And
                       (grVideoDriver\nVideoPlaybackLibrary <> #SCS_VPL_TVG Or checkUse2DDrawing(nPrimSubIndex))
                      ; debugMsg(sProcName, "calling displayPicture(" + getAudLabel(nTmpAudPtr) + ", " + decodeVidPicTarget(nVidPicTarget) + ")")
                      If displayPicture(nTmpAudPtr, nVidPicTarget) = #False
                        ; picture cannot be displayed
                        gbInPlayAud = #False
                        gnTraceMutexLocking - nTraceMutexLockingValue
                        ProcedureReturn
                      EndIf
                   
                    ElseIf (aAud(nTmpAudPtr)\nFileFormat = #SCS_FILEFORMAT_CAPTURE) And (\nVideoSource = #SCS_VID_SRC_CAPTURE)
                      Select grVideoDriver\nVideoPlaybackLibrary
                        Case #SCS_VPL_VMIX
                          debugMsg(sProcName, "calling playVideo(" + getAudLabel(nTmpAudPtr) + ", " + decodeVidPicTarget(nVidPicTarget) + ", " + strB(bMyUseCas) + ", " + nCasGroupId + ", " + strB(bCheckProgSlider) + ")")
                          If playVideo(nTmpAudPtr, nVidPicTarget, bMyUseCas, nCasGroupId, bCheckProgSlider) = #False
                            ; video capture cannot be played
                            gbInPlayAud = #False
                            gnTraceMutexLocking - nTraceMutexLockingValue
                            ProcedureReturn
                          EndIf
                        Case #SCS_VPL_TVG
                          If playTVGCapture(nTmpAudPtr, nVidPicTarget) = #False
                            ; capture video cannot be displayed
                            gbInPlayAud = #False
                            gnTraceMutexLocking - nTraceMutexLockingValue
                            ProcedureReturn
                          EndIf
                      EndSelect
                        
                    Else
                      debugMsg(sProcName, "calling playVideo(" + getAudLabel(nTmpAudPtr) + ", " + decodeVidPicTarget(nVidPicTarget) + ", " + strB(bMyUseCas) + ", " + nCasGroupId + ", " + strB(bCheckProgSlider) + ")")
                      If playVideo(nTmpAudPtr, nVidPicTarget, bMyUseCas, nCasGroupId, bCheckProgSlider) = #False
                        ; video cannot be played
                        gbInPlayAud = #False
                        gnTraceMutexLocking - nTraceMutexLockingValue
                        ProcedureReturn
                      EndIf
                    EndIf
                  EndIf
                  ;}
                  
                ElseIf \bAudTypeP   ; \bAudTypeP
                  ;{
                  If \nNextPlayIndex = -1
                    ; if about to play last track then re-call setPLFades so that if playlist is continuous then the first track will have it's fadein time set if applicable
                    setPLFades(nTmpSubIndex)
                  EndIf
                  aSub(nTmpSubIndex)\bPLTerminating = #False
                  aSub(nTmpSubIndex)\nPLAudPlayCount + 1
                  If aSub(nTmpSubIndex)\bPLSavePos
                    debugMsg(sProcName, "aSub(" + getSubLabel(nTmpSubIndex) + ")\nPlayOrderAudNo=" + aSub(nTmpSubIndex)\nPlayOrderAudNo + ", \nAudNo=" + \nAudNo)
                    If aSub(nTmpSubIndex)\nPlayOrderAudNo <> \nAudNo
                      aSub(nTmpSubIndex)\nPlayOrderAudNo = \nAudNo
                      gbUnsavedPlaylistOrderInfo = #True
                      debugMsg(sProcName, "gbUnsavedPlaylistOrderInfo=" + strB(gbUnsavedPlaylistOrderInfo))
                    EndIf
                  EndIf
                  \bPLSkipDone = #False
                  aSub(nTmpSubIndex)\nCurrPlayIndex = nTmpAudPtr
                  debugMsg(sProcName, "aSub(" + getSubLabel(nTmpSubIndex) + ")\nCurrPlayIndex=" + getAudLabel(aSub(nTmpSubIndex)\nCurrPlayIndex))
                  If bStartingOrResumingPlaylist
                    If aSub(nTmpSubIndex)\nPLFadeInTime > 0
                      aSub(nTmpSubIndex)\bPLFadingIn = #True
                      \qTimeFadeInStarted = gqTimeNow
                      debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\qTimeFadeInStarted=" + traceTime(\qTimeFadeInStarted))
                      \bTimeFadeInStartedSet = #True
                      \nPreFadeInTimeOnPause = \nTotalTimeOnPause
                      \nCuePosAtFadeStart = \nCuePos
                    EndIf
                  EndIf
                  If \nFadeInTime > 0
                    \qTimeFadeInStarted = gqTimeNow
                    debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\qTimeFadeInStarted=" + traceTime(\qTimeFadeInStarted))
                    \bTimeFadeInStartedSet = #True
                    \nPreFadeInTimeOnPause = \nTotalTimeOnPause
                    \nCuePosAtFadeStart = \nCuePos
                  EndIf
                  debugMsg(sProcName, "\nAudState=" + decodeCueState(\nAudState) + ", aSub(" + getSubLabel(nTmpSubIndex) + ")\nPLFadeInTime=" + aSub(nTmpSubIndex)\nPLFadeInTime + ", \nFadeInTime=" + \nFadeInTime + ", \qTimeFadeInStarted=" + traceTime(\qTimeFadeInStarted))
                  
                  If gbUseBASS  ; BASS
                    ; modified 15Mar2019 11.8.0.2cd following report from Rob Taylor about "On action of the second sub cue to resume the playback the audio momentarily (milliseconds) Ramps up before proceeding to fade in from minus infinity"
;                     debugMsg(sProcName, "calling setPLLevels(" + getAudLabel(nTmpAudPtr) + ")")
;                     setPLLevels(nTmpAudPtr)
                    debugMsg(sProcName, "calling setPLLevels(" + getAudLabel(nTmpAudPtr) + ", #True, #True)")
                    setPLLevels(nTmpAudPtr, #True, #True)
                    ; end modified 15Mar2019 11.8.0.2cd
                    
                  Else  ; SM-S
                    debugMsg(sProcName, "calling setPLLevels(" + getAudLabel(nTmpAudPtr) + ", #False, #True)")
                    setPLLevels(nTmpAudPtr, #False, #True)  ; setPLLevels() with fadein
                    setSyncPChanListForAud(nTmpAudPtr)
                    debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\sSyncSetGainList=" + \sSyncSetGainList)
                    debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\sSyncPChanList=" + \sSyncPChanList)
                    If bTopLevelCall = #False
                      aSub(nTmpSubIndex)\sSubSetGainCommandString + " " + Trim(\sSyncSetGainList)
                      debugMsg(sProcName, "aSub(" + getSubLabel(nTmpSubIndex) + ")\sSubSetGainCommandString=" + aSub(nTmpSubIndex)\sSubSetGainCommandString)
                      aSub(nTmpSubIndex)\sSubPlayCommandString + " " + Trim(\sSyncPChanList)
                      debugMsg(sProcName, "aSub(" + getSubLabel(nTmpSubIndex) + ")\sSubPlayCommandString=" + aSub(nTmpSubIndex)\sSubPlayCommandString)
                      If \bSetLevelsWhenPlayAud
                        aSub(nTmpSubIndex)\bSetLevelsWhenPlaySub = #True
                      EndIf
                      debugMsg(sProcName, "aSub(" + getSubLabel(nTmpSubIndex) + ")\bSetLevelsWhenPlayAud=" + strB(aSub(nTmpSubIndex)\bSetLevelsWhenPlaySub))
                    Else
                      If Len(Trim(\sSyncSetGainList)) > 0
                        sendSMSCommand("set " + Trim(\sSyncSetGainList))
                      EndIf
                      If Len(Trim(\sSyncPChanList)) > 0
                        sendSMSCommand("play " + Trim(\sSyncPChanList))
                        buildGetSMSCurrInfoCommandStrings()
                      EndIf
                    EndIf
                    
                  EndIf ; EndIf gbUseBASS / Else
                  ;}
                  
                EndIf ; EndIf \bAudTypeF, \bAudTypeA, etc
                
              EndIf ; EndIf \bAudTypeI/Else
              
              \qTimePlayOrReposIssued = ElapsedMilliseconds()
              
            EndIf ; EndIf (nTmpAudPtr = pAudPtr) Or (gbUseBASSMixer = #False)
          EndWith
        EndIf ; EndIf nTmpAudPtr > 0
      Next h
      
      If aAud(pAudPtr)\nLinkedToAudPtr >= 0
        debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nLinkedToAudPtr=" + getAudLabel(aAud(pAudPtr)\nLinkedToAudPtr))
      EndIf
      If (aAud(pAudPtr)\nLinkedToAudPtr = -1) Or (bSubStartedInEditor) Or (gbUseBASSMixer) ; 1Mar2020 11.8.2.2ay added "Or (gbUseBASSMixer)" because BASS_ChannelSetLink() cannot be used on decode channels
        If aAud(pAudPtr)\bLogo = #False
          aAud(pAudPtr)\bIgnoreLevelEnvelope = #False
          bCallPlayAudChannelsNow = #True
          If bSubStartedInEditor = #False
            nMTCSubPtr = aSub(nPrimSubIndex)\nAFLinkedToMTCSubPtr
            If nMTCSubPtr >= 0
              If aSub(nMTCSubPtr)\nMTCType = #SCS_MTC_TYPE_LTC And gnCurrAudioDriver <> #SCS_DRV_SMS_ASIO ; Test added 20Dec2024
                bCallPlayAudChannelsNow = #True
              Else
                bCallPlayAudChannelsNow = #False
                If aSub(nMTCSubPtr)\nSubState > #SCS_CUE_READY
                  ; linked MTC sub-cue is already marked as 'playing' (even though MTC will not yet have been started), so now we can activate both this audio and the MTC
                  debugMsg(sProcName, "calling MTC_playOrResumeMTCAndLinkedAud(" + getSubLabel(nMTCSubPtr) + ")")
                  MTC_playOrResumeMTCAndLinkedAud(nMTCSubPtr)
                EndIf
              EndIf
            EndIf
          EndIf
          If bCallPlayAudChannelsNow
            debugMsg(sProcName, "calling playAudChannels(" + getAudLabel(pAudPtr) + ", " + strB(bMyUseCas) + ", " + nCasGroupId + ", #False, " + nCtrlSendIndex + ")")
            playAudChannels(pAudPtr, bMyUseCas, nCasGroupId, #False, nCtrlSendIndex)
          EndIf
          bPlayAudChannelsCalledForPrimaryAud = #True
          aAud(pAudPtr)\bSyncPChanListPlaying = #True
          debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\bSyncPChanListPlaying=" + strB(aAud(pAudPtr)\bSyncPChanListPlaying))
        EndIf
      EndIf
      If nMidiAudPtr > 0
        playMidiFile(nMidiAudPtr, bMyUseCas, nCasGroupId, nCtrlSendIndex)
      EndIf
      
      For h = 0 To nMyAudLinkCount
        ; debugMsg(sProcName, "gaAudSet(" + getAudLabel(pAudPtr) + ", " + h + ")=" + getAudLabel(gaAudSet(pAudPtr, h)))
        nTmpAudPtr = gaAudSet(pAudPtr, h)
        ; debugMsg(sProcName, "h=" + h + ", nTmpAudPtr=" + getAudLabel(nTmpAudPtr))
        If nTmpAudPtr > 0
          With aAud(nTmpAudPtr)
            nTmpSubIndex = \nSubIndex ; added 3Feb2020 11.8.2.2af
            If (nTmpAudPtr <> pAudPtr) And (gbUseBASSMixer)
              aAud(nTmpAudPtr)\bIgnoreLevelEnvelope = #False
              debugMsg(sProcName, "calling loadLvlPtRun(" + getAudLabel(nTmpAudPtr) + ", " + \nCuePos + ", #True)")
              loadLvlPtRun(nTmpAudPtr, \nCuePos, #True)
              debugMsg(sProcName, "calling playAud(" + getAudLabel(nTmpAudPtr) + ", #False, " + strB(bMyUseCas) + ", " + nCasGroupId + ", #False, #True, " + nCtrlSendIndex + ")")
              playAud(nTmpAudPtr, bMyUseCas, #False, nCasGroupId, #False, #True, nCtrlSendIndex)
              aAud(nTmpAudPtr)\bSyncPChanListPlaying = #True
              debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\bSyncPChanListPlaying=" + strB(aAud(nTmpAudPtr)\bSyncPChanListPlaying))
            EndIf
            bFadeIn = #False
            If \bLogo = #False Or aSub(\nSubIndex)\bUseNew2DDrawing = #False ; Added bUseNew2DDrawing test 9Jan2025 11.10.6-b02 as part of the fix for logos not to be displayed using 2D Drawing if the sub's bUseNew2DDrawing=#False
              If \bAudTypeAorP
                If (bStartingOrResumingPlaylist) And (aSub(nTmpSubIndex)\nPLFadeInTime > 0)
                  bFadeIn = #True
                EndIf
              EndIf
              If (\nCurrFadeInTime > 0) And ((\nCuePos - \nCuePosAtFadeStart) < \nCurrFadeInTime) ; Added \nCuePosAtFadeStart 1Feb2022 11.9.0rc7
                bFadeIn = #True
              EndIf
            EndIf
            
            \qTimeAudStarted = gqTimeNow
            setMTCAtAudStartIfReqd(nTmpAudPtr)
            ; \qTimeAudEnded = 0
            \bTimeAudEndedSet = #False
            \bStopCompleted = #False
            ; debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\bCheckProgSlider=" + strB(\bCheckProgSlider))
            If \bCheckProgSlider
              debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nRelFilePos=" + \nRelFilePos + ", \nRelPassStart=" + Str(\nRelPassStart))
              \qTimeAudRestarted = gqTimeNow - \nRelFilePos + \nRelPassStart
            Else
              \qTimeAudRestarted = gqTimeNow
            EndIf
            ; debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\qTimeAudRestarted=" + traceTime(aAud(nTmpAudPtr)\qTimeAudRestarted) + ", bFadeIn=" + strB(bFadeIn))
            \nTotalTimeOnPause = 0
            \nPriorTimeOnPause = 0
            \nPreFadeInTimeOnPause = 0
            \nPreFadeOutTimeOnPause = 0
            \nCuePosAtLoopStart = 0
            \bFinalFadeOut = #False
            \bFinalSlide = #False
            \bInLoopXFade = #False
            ; debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\bInLoopXFade=" + strB(\bInLoopXFade))
            
            If gbUseBASS  ; BASS
debugMsg(sProcName, "bFadeIn=" + strB(bFadeIn) + ", bFadeInActioned=" + strB(bFadeInActioned) + ", \nFadeInType=" + decodeFadeType(\nFadeInType))
              If (bFadeIn) And (\bAudTypeAorF) And ((\nFadeInType = #SCS_FADE_STD) Or (\nFadeInType = #SCS_FADE_LIN))
                If bFadeInActioned = #False
                  debugMsg(sProcName, "calling fadeInOneAud(" + getAudLabel(nTmpAudPtr) + ")")
                  fadeInOneAud(nTmpAudPtr)
                  bFadeInActioned = #True
                  If \nCuePos > 0
                    bCallResetAudState = #True
                  EndIf
                EndIf
              EndIf
            EndIf
            If bFadeIn
              If bFadeInActioned = #False
                \qTimeFadeInStarted = gqTimeNow
                \bTimeFadeInStartedSet = #True
                \nCuePosAtFadeStart = \nCuePos
                debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\bTimeFadeInStartedSet=" + strB(\bTimeFadeInStartedSet) + ", \qTimeFadeInStarted=" + traceTime(\qTimeFadeInStarted) + " \nCuePosAtFadeStart=" + \nCuePosAtFadeStart)
              EndIf
              If \bAudTypeAorP And ((aSub(nTmpSubIndex)\nPLAudPlayCount > 1) Or (\nPrevPlayIndex >= 0))
                \nAudState = #SCS_CUE_TRANS_FADING_IN
              Else
                \nAudState = #SCS_CUE_FADING_IN
                If \nCuePos > 0
                  \qTimeFadeInStarted = gqTimeNow - (\nCuePos - \nCuePosAtFadeStart) ; Added \nCuePosAtFadeStart 1Feb2022 11.9.0rc7
                Else
                  \qTimeFadeInStarted = gqTimeNow
                EndIf
                \bTimeFadeInStartedSet = #True
                \nCuePosAtFadeStart = \nCuePos
                debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\qTimeFadeInStarted=" + traceTime(\qTimeFadeInStarted) + ", \nCuePos=" + \nCuePos + ", \nCuePosAtFadeStart=" + \nCuePosAtFadeStart)
              EndIf
              CompilerIf #c_include_tvg
                If (grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG) And (b2DDrawingImage = #False)
                  If bFadeInActioned = #False
                    debugMsg(sProcName, "calling addAudToTVGFadeAudArray(" + getAudLabel(nTmpAudPtr) + ")")
                    addAudToTVGFadeAudArray(nTmpAudPtr)
                  EndIf
                EndIf
              CompilerEndIf
              For d2 = \nFirstSoundingDev To \nLastSoundingDev
                If \nBassChannel[d2] <> 0
                  If \bCueVolManual[d2]
                    \nAudState = #SCS_CUE_PLAYING
                    Break ; exit D2 loop
                  EndIf
                EndIf
              Next d2
            Else
              If \bLogo
                \nAudState = #SCS_CUE_COMPLETED
                debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nAudState=" + decodeCueState(\nAudState))
              Else
                \nAudState = #SCS_CUE_PLAYING
              EndIf
            EndIf
            
            If bCallResetAudState
              If \nCuePos > 0
                debugMsg(sProcName, "calling resetAudStateForPos(" + getAudLabel(nTmpAudPtr) + ", " + \nCuePos + ", #True)")
                resetAudStateForPos(nTmpAudPtr, \nCuePos, #True)
              EndIf
            EndIf
            ; debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nAudState=" + decodeCueState(\nAudState))
            
            If gbUseSMS
              If bTopLevelCall
                buildGetSMSCurrInfoCommandStrings()
              EndIf
            EndIf
            
            If \bAudTypeI
              If bTopLevelCall
                WCN_setLiveOnInds()
              EndIf
            EndIf
            
            ; debugMsg(sProcName, "nTmpAudPtr=" + getAudLabel(nTmpAudPtr) + ", pAudPtr=" + getAudLabel(pAudPtr) + ", bMyUseCas=" + strB(bMyUseCas))
            If nTmpAudPtr <> pAudPtr
              If (\nFileFormat = #SCS_FILEFORMAT_VIDEO) Or (\nFileFormat = #SCS_FILEFORMAT_PICTURE)
                If bMyUseCas
                  rCasInfo\nCasCueAction = #SCS_CAS_PLAY_VIDEO
                  rCasInfo\nCasAudPtr = nTmpAudPtr
                  rCasInfo\nCasVidPicTarget = aAud(nTmpAudPtr)\nAudVidPicTarget
                  rCasInfo\sCasOriginProcName = sProcName
                  grCasItem = rCasInfo
                  casAddRequest()
                EndIf
              Else
                CompilerIf 1=2
                  ; 'Deleted' 17Mar2023 11.10.0am
                  If (gbUseBASS) And (gbUseBASSMixer)
                    For d2 = \nFirstSoundingDev To \nLastSoundingDev
                      If \nBassChannel[d2] <> 0
                        If bMyUseCas
                          rCasInfo\nCasCueAction = #SCS_CAS_MIXER_UNPAUSE
                          rCasInfo\nCasChannel = \nBassChannel[d2]
                          rCasInfo\nCasMixerStream = gaMixerStreams(\nMixerStreamPtr[d2])\nMixerStreamHandle
                          rCasInfo\sCasOriginProcName = sProcName
                          grCasItem = rCasInfo
                          debugMsg(sProcName, "calling casAddRequest() with \nCasCueAction=#SCS_CAS_MIXER_UNPAUSE, \nCasChannel=" + decodeHandle(rCasInfo\nCasChannel) + ", \nCasMixerStream=" + decodeHandle(rCasInfo\nCasMixerStream))
                          casAddRequest()
                        EndIf
                      EndIf
                    Next d2
                  EndIf
                CompilerEndIf
              EndIf
            EndIf
            
            ; debugMsg(sProcName, "calling setCueState(" + getCueLabel(\nCueIndex) + ")")
            setCueState(\nCueIndex)
            If \nCueIndex <> nPrevCueIndex
              samAddRequest(#SCS_SAM_LOAD_GRID_ROW, \nCueIndex)
              nPrevCueIndex = \nCueIndex
            EndIf
            
            \qTimePlayOrReposIssued = ElapsedMilliseconds()
            aCue(\nCueIndex)\nCuePanelUpdateFlags | #SCS_CUEPNL_PROGRESS | #SCS_CUEPNL_TRANSPORT
            ; debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\nCuePanelUpdateFlags=" + Str(aCue(\nCueIndex)\nCuePanelUpdateFlags))
            
          EndWith
        EndIf
        
      Next h
      
  EndSelect
  
  If aAud(pAudPtr)\bAudTypeF
    If grMTCSendControl\nMTCLinkedToAudPtr = pAudPtr
      MTC_checkMTCLinkedToAudPtrValid()
    EndIf
  EndIf
  
  If aAud(pAudPtr)\bAudTypeAorP
    ; debugMsg(sProcName, "calling calcPLUnplayedFilesTime(" + getSubLabel(nPrimSubIndex) + ")")
    calcPLUnplayedFilesTime(nPrimSubIndex)
    ; gnLastPlayingAudioCue = aAud(pAudPtr)\nCueIndex ; Deleted 13Jun2020 11.8.23ab (see 'Added 13Jun2020' below)
  EndIf
  
  If aAud(pAudPtr)\bAudTypeForP
    gnLastPlayingAudioCue = aAud(pAudPtr)\nCueIndex
  EndIf
  
  If aSub(nPrimSubIndex)\bSubTypeA
    grMMedia\nVideoImageCurrFadeOutTime = aSub(nPrimSubIndex)\nPLCurrFadeOutTime
    grMMedia\nVideoImageCurrFadeOutSubPtr = nPrimSubIndex
  EndIf
  
  THR_resumeAThread(#SCS_THREAD_CONTROL)
  
  If (aAud(pAudPtr)\bAudTypeForP) Or (aAud(pAudPtr)\bAudTypeI)
    startVUDisplayIfReqd()
  EndIf
  
  If gbUseBASSMixer = #False
    samAddRequest(#SCS_SAM_BUILD_DEV_CHANNEL_LIST)
  EndIf
  
  If IsWindow(#WCN)
    WCN_setPlayingControlsIfReqd()
  EndIf
  
  gbInPlayAud = #False
  gnTraceMutexLocking - nTraceMutexLockingValue ; mutex2
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure playAudChannels(pAudPtr, bUseCas=#False, nCasGroupId=-1, bCalledFromEditLvlChg=#False, nCtrlSendIndex=-1)
  PROCNAMECA(pAudPtr)
  Protected nBassResult.l, d, d2
  Protected bMixerStreamsOK, bMixerPaused, bChannelPlaying, bDecodeStream
  Protected rCasInfo.tyCasItem
  Protected nPlayingPos
  Protected bChannelPlayIssued
  Protected bForceResetPos
  Protected nMixerStream.l, nChannelFlags.l
  Protected nChannel.l, nAltChannel.l
  Protected fReqdBVLevel.f, fReqdPan.f
  Protected nGaplessSeqPtr, nGaplessStream.l
  Protected nSplitterChannel.l
  Protected nMyBassChannel.l
  Protected nMyMixerStreamPtr
  Protected fBassPan.f
  
  debugMsg(sProcName, #SCS_START + ", bUseCas=" + strB(bUseCas) + ", nCasGroupId=" + nCasGroupId + ", bCalledFromEditLvlChg=" + strB(bCalledFromEditLvlChg) + ", nCtrlSendIndex=" + nCtrlSendIndex)

  rCasInfo\nCasGroupId = nCasGroupId

  If gdResetPosForLinked > 0
    ; seem to need to force 'reset pos' if 'link sync point' is set, or SyncProcLinkPos() may not get called.
    ; don't know why, unless it's a buffering issue.
    ; reported by Martin Norris and tested with "Dream2.scs11"
    bForceResetPos = #True
  EndIf
  
  With aAud(pAudPtr)
    \bFinalFadeOut = #False
    \bFinalSlide = #False
    \bPlayEndSyncOccurred = #False
    \bIgnoreInStatusCheck = #False
    ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\bIgnoreInStatusCheck=" + strB(aAud(pAudPtr)\bIgnoreInStatusCheck))
    
    If \nFileFormat = #SCS_FILEFORMAT_MIDI
      playMidiFile(pAudPtr, bUseCas, nCasGroupId, nCtrlSendIndex)
      
    ElseIf \nFileFormat = #SCS_FILEFORMAT_AUDIO Or \nFileFormat = #SCS_FILEFORMAT_VIDEO ; INFO 29Dec2020 added "Or \nFileFormat = #SCS_FILEFORMAT_VIDEO"
      If gbUseBASS  ; BASS
        bMixerStreamsOK = #True
        If gbUseBASSMixer
          For d2 = \nFirstSoundingDev To \nLastSoundingDev
            If \nBassChannel[d2] <> 0
              debugMsg(sProcName, "\nBassChannel[" + d2 + "]=" + decodeHandle(\nBassChannel[d2]) + ", \nMixerStreamPtr[" + d2 + "]=" + \nMixerStreamPtr[d2])
              nMyMixerStreamPtr = \nMixerStreamPtr[d2]
              If nMyMixerStreamPtr < 0
                debugMsg(sProcName, "calling createMixerStreams()")
                createMixerStreams()
                \nMixerStreamPtr[d2] = getMixerStreamPtrForLogicalDev(\sLogicalDev[d2])
              Else
                CheckSubInRange(nMyMixerStreamPtr, ArraySize(gaMixerStreams()), "gaMixerStreams()")
                If gaMixerStreams(nMyMixerStreamPtr)\bRecreateMixerStream
                  createOneMixerStream(\nMixerStreamPtr[d2], d2)
                  debugMsg(sProcName, "calling createMixerStreams()")
                  createMixerStreams() ; calling createMixerStreams forces any ASIO streams to be re-built
                  \nMixerStreamPtr[d2] = getMixerStreamPtrForLogicalDev(\sLogicalDev[d2])
                EndIf
              EndIf
            EndIf
          Next d2
        EndIf
        
        d = \nFirstSoundingDev
        debugMsg(sProcName, "\bAutoFollowStarted=" + strB(\bAutoFollowStarted) + ", \bUsingSplitStream=" + strB(\bUsingSplitStream) + ", \bAudUseGaplessStream=" + strB(\bAudUseGaplessStream))
        If (d >= 0) And (\bAutoFollowStarted = #False)
          If \bAudUseGaplessStream
            nChannel = \nSourceChannel
            nAltChannel = \nSourceAltChannel  ; nb should be 0 if \bAudUseGaplessStream = #True
          Else
            nChannel = \nBassChannel[d]
            nAltChannel = \nBassAltChannel[d]
          EndIf
          ; debugMsg(sProcName, "nChannel=" + decodeHandle(nChannel) + ", nAltChannel=" + decodeHandle(nAltChannel))
          If (gbUseBASSMixer) And (\bUsingSplitStream)
            If \bAudUseGaplessStream  ; \bAudUseGaplessStream = #True
              nGaplessSeqPtr = \nAudGaplessSeqPtr
              If nGaplessSeqPtr >= 0
                nGaplessStream = gaGaplessSeqs(nGaplessSeqPtr)\nGaplessStream
                debugMsg(sProcName, "\bAudUseGaplessStream=" + strB(\bAudUseGaplessStream) + ", nChannel=" + decodeHandle(nChannel) + ", nGaplessStream=" + decodeHandle(nGaplessStream))
                ; listStreamStatuses()
                nBassResult = BASS_Mixer_StreamAddChannel(nGaplessStream, nChannel, 0)
                debugMsg2(sProcName, "BASS_Mixer_StreamAddChannel(" + decodeHandle(nGaplessStream) + ", " + decodeHandle(nChannel) + ", 0)", nBassResult)
                If nBassResult = #BASSFALSE
                  debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                Else
                  nBassResult = BASS_ChannelSetAttribute(nChannel, #BASS_ATTRIB_VOL, 1.0) ; in case channel 'volume' had been faded out by StopOrFadeOutAudChannels()
                  debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nChannel) + ", #BASS_ATTRIB_VOL, 1.0)", nBassResult)
                  nBassResult = BASS_ChannelIsActive(nChannel)
                  debugMsg2(sProcName, "BASS_ChannelIsActive(" + decodeHandle(nChannel) + ")", nBassResult)
                  If nBassResult = #BASS_ACTIVE_STOPPED
                    ; nBassResult = BASS_ChannelSetAttribute(nChannel, #BASS_ATTRIB_VOL, 1.0)
                    ; debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nChannel) + ", #BASS_ATTRIB_VOL, 1.0)", nBassResult)
                    nBassResult = BASS_ChannelSetPosition(nChannel, 0, #BASS_POS_BYTE); // reset the source channel
                    debugMsg2(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nChannel) + ", 0, #BASS_POS_BYTE)", nBassResult)
                    If nBassResult = #BASSFALSE
                      debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                    EndIf
                  EndIf
                EndIf
                ; listStreamStatuses()
                If bCalledFromEditLvlChg = #False
                  If \bCheckProgSlider = #False Or 1=1  ; 05/12/2013 (11.2.6d) made unconditional as manually repositioning progress slider for playlist after ESC was not playing cue
                    nBassResult = BASS_ChannelSetPosition(nGaplessStream, 0, #BASS_POS_BYTE); // reset the mixer
                    debugMsg2(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nGaplessStream) + ", 0, #BASS_POS_BYTE)", nBassResult)
                    If nBassResult = #BASSFALSE
                      debugMsg3(sProcName, "Error " + BASS_ErrorGetCode() + ": " + getBassErrorDesc(BASS_ErrorGetCode()))
                    EndIf
                    For d2 = \nFirstSoundingDev To \nLastSoundingDev
                      nSplitterChannel = gaGaplessSeqs(nGaplessSeqPtr)\nSplitterChannel[d2]
                      If nSplitterChannel <> 0
                        ; listStreamStatuses()
                        If BASS_ChannelIsActive(nSplitterChannel) = #BASS_ACTIVE_STOPPED
                          nBassResult = BASS_ChannelSetPosition(nSplitterChannel, 0, #BASS_POS_BYTE); // reset the mixer
                          debugMsg2(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nSplitterChannel) + ", 0, #BASS_POS_BYTE)", nBassResult)
                          If nBassResult = #BASSFALSE
                            debugMsg3(sProcName, "Error " + BASS_ErrorGetCode() + ": " + getBassErrorDesc(BASS_ErrorGetCode()))
                          EndIf
                        EndIf
                      EndIf
                    Next d2
                  EndIf
                EndIf
                ; listStreamStatuses()
                debugMsg(sProcName, "calling setBassPlayEnd(" + getAudLabel(pAudPtr) + ")")
                setBassPlayEnd(pAudPtr)
                debugMsg(sProcName, "calling setBassMarkerPositions(" + getAudLabel(pAudPtr) + ")")
                setBassMarkerPositions(pAudPtr)
                gaGaplessSeqs(nGaplessSeqPtr)\nCurrGaplessAudPtr = pAudPtr
                For d2 = \nFirstSoundingDev To \nLastSoundingDev
                  If \nBassChannel[d2] <> 0
                    nBassResult = BASS_Mixer_ChannelFlags(\nBassChannel[d2], 0, #BASS_MIXER_CHAN_PAUSE)
                    debugMsg3(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(\nBassChannel[d2]) + ", 0, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
                  EndIf
                Next d2
                listGaplessArray()
                ; listStreamStatuses()
              EndIf
              
            Else  ; \bAudUseGaplessStream = #False
              nBassResult = BASS_Mixer_ChannelFlags(\nBassChannel[d], 0, 0)
              debugMsg3(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(\nBassChannel[d]) + ", 0, 0) returned " + decodeMixerChannelFlags(nBassResult))
              If nBassResult & #BASS_MIXER_CHAN_PAUSE
                bMixerPaused = #True
              EndIf
              nBassResult = BASS_ChannelIsActive(\nBassChannel[d])
              debugMsg2(sProcName, "BASS_ChannelIsActive(" + decodeHandle(\nBassChannel[d]) + ")", nBassResult)
              If nBassResult = #BASS_ACTIVE_PLAYING
                bChannelPlaying = #True
              EndIf
              debugMsg3(sProcName, "bMixerPaused=" + strB(bMixerPaused) + ", bChannelPlaying=" + strB(bChannelPlaying) + ", \bAudChannelsStopped=" + strB(\bAudChannelsStopped))
              If (bMixerPaused) And (bChannelPlaying)
                ; first time - just need to unpause mixer channels after possibly setting position
                If ((gbUseBASSMixer) And (\bAudUseGaplessStream = #False)) Or (\bUsingSplitStream)
                  nMyBassChannel = \nBassChannel[d]
                Else
                  nMyBassChannel = \nSourceChannel
                EndIf
                If bCalledFromEditLvlChg = #False
                  nPlayingPos = GetPlayingPos(pAudPtr, nMyBassChannel, 2)
                  debugMsg3(sProcName, "GetPlayingPos(" + getAudLabel(pAudPtr) + ", " + decodeHandle(nMyBassChannel) + ", 2) returned " + nPlayingPos + ", \nAbsStartAt=" + \nAbsStartAt)
                  If (nPlayingPos <> \nAbsStartAt) And (\bCheckProgSlider = #False)
                    debugMsg(sProcName, "calling SetPlayingPos(" + getAudLabel(pAudPtr) + ", " + d + ", #SCS_CHAN_MAIN, " + \nAbsStartAt + ", " + \qStartAtBytePos + ", " + strB(bForceResetPos) + ")")
                    SetPlayingPos(pAudPtr, d, #SCS_CHAN_MAIN, \nAbsStartAt, \qStartAtBytePos, bForceResetPos)
                    nBassResult = BASS_Split_StreamReset(\nSourceChannel)
                    debugMsg2(sProcName, "BASS_Split_StreamReset(" + decodeHandle(\nSourceChannel) + ")", nBassResult)
                  EndIf
                EndIf
                For d2 = \nFirstSoundingDev To \nLastSoundingDev
                  If \nBassChannel[d2] <> 0
                    nBassResult = BASS_Mixer_ChannelFlags(\nBassChannel[d2], 0, #BASS_MIXER_CHAN_PAUSE)
                    debugMsg3(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(\nBassChannel[d2]) + ", 0, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
                  EndIf
                Next d2
              Else
                If \nBassChannel[d] <> 0
                  If bChannelPlaying = #False Or \bAudChannelsStopped = #True
                    ; not first time and aud is not currently playing or paused: pause mixer channels, set source position, reset the splitter streams, and unpause mixer channels
                    For d2 = \nFirstSoundingDev To \nLastSoundingDev
                      If \nBassChannel[d2] <> 0
                        nBassResult = BASS_Mixer_ChannelFlags(\nBassChannel[d2], #BASS_MIXER_CHAN_PAUSE, #BASS_MIXER_CHAN_PAUSE)
                        debugMsg3(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(\nBassChannel[d2]) + ", BASS_MIXER_CHAN_PAUSE, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
                      EndIf
                    Next d2
                    If bCalledFromEditLvlChg = #False
                      If \bCheckProgSlider = #False
                        debugMsg(sProcName, "calling SetPlayingPos(" + getAudLabel(pAudPtr) + ", " + d + ", #SCS_CHAN_MAIN, " + \nAbsStartAt + ", " + \qStartAtBytePos + ", " + strB(bForceResetPos) + ")")
                        SetPlayingPos(pAudPtr, d, #SCS_CHAN_MAIN, \nAbsStartAt, \qStartAtBytePos, bForceResetPos)
                        nBassResult = BASS_Split_StreamReset(\nBassChannel[d])
                        debugMsg2(sProcName, "BASS_Split_StreamReset(" + decodeHandle(\nBassChannel[d]) + ")", nBassResult)
                      EndIf
                    EndIf
                    For d2 = \nFirstSoundingDev To \nLastSoundingDev
                      If \nBassChannel[d2] <> 0
                        nBassResult = BASS_Mixer_ChannelFlags(\nBassChannel[d2], 0, #BASS_MIXER_CHAN_PAUSE)
                        debugMsg3(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(\nBassChannel[d2]) + ", 0, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
                        If nBassResult = -1
                          debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                        EndIf
                      EndIf
                    Next d2
                  Else
                    If bCalledFromEditLvlChg = #False
                      If \bCheckProgSlider = #False
                        ; not first time but aud is currently playing, so just reset the source position
                        SetPlayingPos(pAudPtr, d, #SCS_CHAN_MAIN, \nAbsStartAt, \qStartAtBytePos, bForceResetPos)
                      EndIf
                    EndIf
                  EndIf
                EndIf
              EndIf
            EndIf
            
          ElseIf \bAudUseGaplessStream ; \bAudUseGaplessStream = #True but not using split stream
            nGaplessSeqPtr = \nAudGaplessSeqPtr
            If nGaplessSeqPtr >= 0
              nGaplessStream = gaGaplessSeqs(nGaplessSeqPtr)\nGaplessStream
              nMixerStream = gaGaplessSeqs(nGaplessSeqPtr)\nMixerStream
              debugMsg(sProcName, "\bAudUseGaplessStream=" + strB(\bAudUseGaplessStream) + ", nChannel=" + decodeHandle(nChannel) + ", nGaplessStream=" + decodeHandle(nGaplessStream) + ", nMixerStream=" + decodeHandle(nMixerStream))
              nBassResult = BASS_Mixer_StreamAddChannel(nGaplessStream, nChannel, 0)
              debugMsg2(sProcName, "BASS_Mixer_StreamAddChannel(" + decodeHandle(nGaplessStream) + ", " + decodeHandle(nChannel) + ", 0)", nBassResult)
              If nBassResult = #BASSFALSE
                debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
              Else
                nBassResult = BASS_ChannelIsActive(nChannel)
                debugMsg2(sProcName, "BASS_ChannelIsActive(" + decodeHandle(nChannel) + ")", nBassResult)
                If bCalledFromEditLvlChg = #False
                  If nBassResult = #BASS_ACTIVE_STOPPED
                    nBassResult = BASS_ChannelSetPosition(nChannel, 0, #BASS_POS_BYTE); // reset the source channel
                    debugMsg2(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nChannel) + ", 0, #BASS_POS_BYTE)", nBassResult)
                    If nBassResult = #BASSFALSE
                      debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                    EndIf
                  EndIf
                EndIf
              EndIf
              If bCalledFromEditLvlChg = #False
                nBassResult = BASS_ChannelSetPosition(nGaplessStream, 0, #BASS_POS_BYTE); // reset the mixer
                debugMsg2(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nGaplessStream) + ", 0, #BASS_POS_BYTE)", nBassResult)
                If nBassResult = #BASSFALSE
                  debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                EndIf
              EndIf
              gaGaplessSeqs(nGaplessSeqPtr)\nCurrGaplessAudPtr = pAudPtr
              If gbUseBASSMixer
                If nGaplessStream <> 0
                  nBassResult = BASS_Mixer_ChannelFlags(nGaplessStream, 0, #BASS_MIXER_CHAN_PAUSE)
                  debugMsg3(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(nGaplessStream) + ", 0, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
                  If nBassResult = -1
                    debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                  EndIf
                EndIf
              Else
                nBassResult = BASS_ChannelPlay(nGaplessStream, #BASSFALSE)
                debugMsg2(sProcName, "BASS_ChannelPlay(" + decodeHandle(nGaplessStream) + ", #BASSFALSE)", nBassResult)
                If nBassResult = #BASSFALSE
                  debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                EndIf
              EndIf
              nBassResult = BASS_ChannelIsActive(\nSourceChannel)
              debugMsg2(sProcName, "BASS_ChannelIsActive(" + decodeHandle(\nSourceChannel) + ")", nBassResult)
              nBassResult = BASS_ChannelIsActive(\nAudGaplessStream)
              debugMsg2(sProcName, "BASS_ChannelIsActive(" + decodeHandle(\nAudGaplessStream) + ")", nBassResult)
              listGaplessArray()
            EndIf
            
          ElseIf \nBassChannel[d] <> 0
            nBassResult = BASS_ChannelIsActive(\nBassChannel[d])
            debugMsg2(sProcName, "BASS_ChannelIsActive(" + decodeHandle(\nBassChannel[d]) + ")", nBassResult)
            If nBassResult = #BASS_ACTIVE_PAUSED_DEVICE
              nBassResult = BASS_Start()
              debugMsg2(sProcName, "BASS_Start()", nBassResult)
              nBassResult = BASS_ChannelIsActive(\nBassChannel[d])
              debugMsg2(sProcName, "BASS_ChannelIsActive(" + decodeHandle(\nBassChannel[d]) + ")", nBassResult)
            EndIf
            If (nBassResult <> #BASS_ACTIVE_PLAYING) Or (\nBassDevice[d] = 0) Or (gbUseBASSMixer) Or (\bUsingSplitStream)
              If ((nBassResult = #BASS_ACTIVE_STOPPED) And (\bCheckProgSlider = #False)) Or (\bUsingSplitStream) Or (grBCI\qChannelBytePosition <> \qInitialGetPosition)
                If bCalledFromEditLvlChg = #False
                  If gbUseBASSMixer
                    For d2 = \nLastSoundingDev To \nFirstSoundingDev Step -1
                      If \nBassChannel[d2] <> 0 And \bCheckProgSlider = #False
                        debugMsg(sProcName, "calling SetPlayingPos(" + getAudLabel(pAudPtr) + ", " + d2 + ", #SCS_CHAN_MAIN, " + \nAbsStartAt + ", " + \qStartAtBytePos + ", " + strB(bForceResetPos) + ")")
                        SetPlayingPos(pAudPtr, d2, #SCS_CHAN_MAIN, \nAbsStartAt, \qStartAtBytePos, bForceResetPos)
                      EndIf
                    Next d2
                  Else
                    If \bCheckProgSlider = #False
                      debugMsg(sProcName, "calling SetPlayingPos(" + getAudLabel(pAudPtr) + ", " + d + ", #SCS_CHAN_MAIN, " + \nAbsStartAt + ", " + \qStartAtBytePos + ", " + strB(bForceResetPos) + ")")
                      SetPlayingPos(pAudPtr, d, #SCS_CHAN_MAIN, \nAbsStartAt, \qStartAtBytePos, bForceResetPos)
                    EndIf
                  EndIf
                EndIf
                If \nBassAltChannel[d] <> 0
                  If gbUseBASSMixer
                    For d2 = \nLastSoundingDev To \nFirstSoundingDev Step -1
                      If (\nBassAltChannel[d2] <> 0) And (\bCheckProgSlider = #False)
                        debugMsg(sProcName, "calling SetPlayingPos(" + getAudLabel(pAudPtr) + ", " + d2 + ", #SCS_CHAN_ALT, " + \nAbsStartAt + ", " + \qStartAtBytePos + ", " + strB(bForceResetPos) + ")")
                        SetPlayingPos(pAudPtr, d2, #SCS_CHAN_ALT, \rCurrLoopInfo\nAbsLoopStart, \rCurrLoopInfo\qLoopStartBytePos, bForceResetPos)
                      EndIf
                    Next d2
                  Else
                    If \bCheckProgSlider = #False
                      debugMsg(sProcName, "calling SetPlayingPos(" + getAudLabel(pAudPtr) + ", " + d + ", #SCS_CHAN_ALT, " + \nAbsStartAt + ", " + \qStartAtBytePos + ", " + strB(bForceResetPos) + ")")
                      SetPlayingPos(pAudPtr, d, #SCS_CHAN_ALT, \rCurrLoopInfo\nAbsLoopStart, \rCurrLoopInfo\qLoopStartBytePos, bForceResetPos)
                    EndIf
                  EndIf
                EndIf
              EndIf
              
              If \bUsingSplitStream
                nBassResult = BASS_ChannelIsActive(\nBassChannel[d])
                debugMsg2(sProcName, "BASS_ChannelIsActive(" + decodeHandle(\nBassChannel[d]) + ")", nBassResult)
                If nBassResult <> #BASS_ACTIVE_PLAYING
                  nBassResult = BASS_ChannelPlay(\nBassChannel[d], #BASSFALSE)
                  debugMsg2(sProcName, "BASS_ChannelPlay(" + decodeHandle(\nBassChannel[d]) + ", BASSFALSE)", nBassResult)
                  If nBassResult = #BASSFALSE
                    debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                  EndIf
                  bChannelPlayIssued = #True
                EndIf
              Else
                nBassResult = BASS_ChannelIsActive(\nSourceChannel)
                debugMsg2(sProcName, "BASS_ChannelIsActive(" + decodeHandle(\nSourceChannel) + ")", nBassResult)
                If nBassResult <> #BASS_ACTIVE_PLAYING
                  nBassResult = BASS_ChannelPlay(\nSourceChannel, #BASSFALSE)
                  debugMsg2(sProcName, "BASS_ChannelPlay(" + decodeHandle(\nSourceChannel) + ", BASSFALSE)", nBassResult)
                  If nBassResult = #BASSFALSE
                    debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                  EndIf
                  bChannelPlayIssued = #True
                EndIf
              EndIf
              
              If gbUseBASSMixer
                If \bAudUseGaplessStream  ; \bAudUseGaplessStream = #True
                  nGaplessSeqPtr = \nAudGaplessSeqPtr
                  If nGaplessSeqPtr >= 0
                    nGaplessStream = gaGaplessSeqs(nGaplessSeqPtr)\nGaplessStream
                    debugMsg(sProcName, "\bAudUseGaplessStream=" + strB(\bAudUseGaplessStream) + ", nChannel=" + decodeHandle(nChannel) + ", nGaplessStream=" + decodeHandle(nGaplessStream))
                    ; nBassResult = BASS_Mixer_StreamAddChannel(nGaplessStream, nChannel, #BASS_STREAM_AUTOFREE)
                    ; debugMsg2(sProcName, "BASS_Mixer_StreamAddChannel(" + decodeHandle(nGaplessStream) + ", " + decodeHandle(nChannel) + ", #BASS_STREAM_AUTOFREE)", nBassResult)
                    nBassResult = BASS_Mixer_StreamAddChannel(nGaplessStream, nChannel, 0)
                    debugMsg2(sProcName, "BASS_Mixer_StreamAddChannel(" + decodeHandle(nGaplessStream) + ", " + decodeHandle(nChannel) + ", 0)", nBassResult)
                    If nBassResult = #BASSFALSE
                      debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                    Else
                      If bCalledFromEditLvlChg = #False
                        nBassResult = BASS_ChannelIsActive(nChannel)
                        debugMsg2(sProcName, "BASS_ChannelIsActive(" + decodeHandle(nChannel) + ")", nBassResult)
                        If nBassResult = #BASS_ACTIVE_STOPPED
                          nBassResult = BASS_ChannelSetPosition(nChannel, 0, #BASS_POS_BYTE); // reset the source channel
                          debugMsg2(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nChannel) + ", 0, #BASS_POS_BYTE)", nBassResult)
                          If nBassResult = #BASSFALSE
                            debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                          EndIf
                        EndIf
                      EndIf
                      nBassResult = BASS_ChannelSetPosition(nGaplessStream, 0, #BASS_POS_BYTE); // reset the mixer
                      debugMsg2(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nGaplessStream) + ", 0, #BASS_POS_BYTE)", nBassResult)
                      If nBassResult = #BASSFALSE
                        debugMsg3(sProcName, "Error " + BASS_ErrorGetCode() + ": " + getBassErrorDesc(BASS_ErrorGetCode()))
                      EndIf
                    EndIf
                    debugMsg(sProcName, "calling setBassPlayEnd(" + getAudLabel(pAudPtr) + ")")
                    setBassPlayEnd(pAudPtr)
                    debugMsg(sProcName, "calling setBassMarkerPositions(" + getAudLabel(pAudPtr) + ")")
                    setBassMarkerPositions(pAudPtr)
                    gaGaplessSeqs(nGaplessSeqPtr)\nCurrGaplessAudPtr = pAudPtr
                    listGaplessArray()
                  EndIf
                  
                Else  ; \bAudUseGaplessStream = #False
                  For d2 = \nLastSoundingDev To \nFirstSoundingDev Step -1
                    If \nBassChannel[d2] <> 0
                      ; debugMsg(sProcName, "d2=" + d2 + ", \nBassChannel[" + d2 + "]=" + decodeHandle(\nBassChannel[d2]) + ", \nMixerStreamPtr[" + d2 + "]=" + \nMixerStreamPtr[d2])
                      If bUseCas
                        CompilerIf 1=2
                          ; 'deleted' 17Mar2023 11.10.0am
                          nBassResult = BASS_Mixer_ChannelFlags(\nBassChannel[d2], 0, #BASS_MIXER_CHAN_PAUSE)                  ; clear the pause flag
                          debugMsg3(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(\nBassChannel[d2]) + ", 0, BASS_MIXER_CHAN_PAUSE)" + " returned " + decodeMixerChannelFlags(nBassResult))
                        CompilerElse
                          ; Added 17Mar2023 11.10.0am
                          rCasInfo\nCasCueAction = #SCS_CAS_MIXER_UNPAUSE
                          rCasInfo\nCasChannel = \nBassChannel[d2]
                          rCasInfo\nCasMixerStream = gaMixerStreams(\nMixerStreamPtr[d2])\nMixerStreamHandle
                          rCasInfo\sCasOriginProcName = sProcName
                          grCasItem = rCasInfo
                          debugMsg(sProcName, "calling casAddRequest() with \nCasCueAction=#SCS_CAS_MIXER_UNPAUSE, \nCasChannel=" + decodeHandle(rCasInfo\nCasChannel) + ", \nCasMixerStream=" + decodeHandle(rCasInfo\nCasMixerStream))
                          casAddRequest()
                          ; End added 17Mar2023 11.10.0am
                        CompilerEndIf
                      Else
                        nMyMixerStreamPtr = \nMixerStreamPtr[d2]
                        CheckSubInRange(nMyMixerStreamPtr, ArraySize(gaMixerStreams()), "gaMixerStreams()")
                        bDecodeStream = gaMixerStreams(nMyMixerStreamPtr)\bDecodeStream
                        If bDecodeStream = #False
                          nBassResult = BASS_ChannelPause(gaMixerStreams(nMyMixerStreamPtr)\nMixerStreamHandle)
                          debugMsg2(sProcName, "BASS_ChannelPause(" + decodeHandle(gaMixerStreams(nMyMixerStreamPtr)\nMixerStreamHandle) + ")", nBassResult)
                          If nBassResult = #BASSFALSE
                            debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                          EndIf
                        EndIf
                        nBassResult = BASS_Mixer_ChannelFlags(\nBassChannel[d2], 0, #BASS_MIXER_CHAN_PAUSE) ; remove the pause flag
                        debugMsg3(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(\nBassChannel[d2]) + ", 0, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
                        If bDecodeStream = #False
                          nBassResult = BASS_ChannelPlay(gaMixerStreams(\nMixerStreamPtr[d2])\nMixerStreamHandle, #BASSFALSE)
                          debugMsg2(sProcName, "BASS_ChannelPlay(" + decodeHandle(gaMixerStreams(\nMixerStreamPtr[d2])\nMixerStreamHandle) + ", BASSFALSE)", nBassResult)
                          If nBassResult = #BASSFALSE
                            debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                          EndIf
                          bChannelPlayIssued = #True
                        EndIf
                      EndIf
                    EndIf
                  Next d2
                EndIf
                
              Else
                If bUseCas
                  rCasInfo\nCasCueAction = #SCS_CAS_PLAY_AUD
                  rCasInfo\nCasChannel = \nBassChannel[d]
                  rCasInfo\sCasOriginProcName = sProcName
                  grCasItem = rCasInfo
                  casAddRequest()
                ElseIf bChannelPlayIssued = #False
                  If \bUsingSplitStream
                    nBassResult = BASS_ChannelPlay(\nBassChannel[d], #BASSFALSE)
                    debugMsg2(sProcName, "BASS_ChannelPlay(" + decodeHandle(\nBassChannel[d]) + ", BASSFALSE)", nBassResult)
                    If nBassResult = #BASSFALSE
                      debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                    EndIf
                  Else
                    nBassResult = BASS_ChannelPlay(\nSourceChannel, #BASSFALSE)
                    debugMsg2(sProcName, "BASS_ChannelPlay(" + decodeHandle(\nSourceChannel) + ", BASSFALSE)", nBassResult)
                    If nBassResult = #BASSFALSE
                      debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                    EndIf
                  EndIf
                EndIf
              EndIf
            EndIf
          EndIf
        EndIf ; EndIf d >= 0
        
      Else ; SM-S
        If bCalledFromEditLvlChg
          debugMsg(sProcName, "\sSyncSetGainList=" + \sSyncSetGainList)
          If Len(Trim(\sSyncSetGainList)) > 0
            If aCue(\nCueIndex)\nActivationMethod <> #SCS_ACMETH_LTC
              sendSMSCommand("set " + Trim(\sSyncSetGainList))
            EndIf
          EndIf
          If Len(Trim(\sSyncPChanList)) > 0
            If aCue(\nCueIndex)\nActivationMethod <> #SCS_ACMETH_LTC
              sendSMSCommand("play " + Trim(\sSyncPChanList))
            EndIf
            \bSyncPChanListPlaying = #True
          EndIf
        Else
          ; do nothing
        EndIf
        
      EndIf
      
      For d = \nFirstSoundingDev To \nLastSoundingDev
        \bStopping[d] = #False
        \bAltStopping[d] = #False
      Next d
      
    EndIf
    
    \bCheckProgSlider = #False
    ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\bCheckProgSlider=" + strB(\bCheckProgSlider))
    \bAudChannelsStopped = #False
    ; \nSMSManualStartPos = grAudDef\nSMSManualStartPos
    
  EndWith

  gnActiveAudPtr = pAudPtr
  If pAudPtr >= 0
    If aAud(pAudPtr)\bAudTypeForP ; changed 31Mar2020 11.8.2.3ah - was \bAudTypeF
      gnPlayingAudTypeForPPtr = pAudPtr
      ; debugMsg(sProcName, "gnPlayingAudTypeForPPtr=" + getAudLabel(gnPlayingAudTypeForPPtr))
    EndIf
  EndIf
  
  debugMsg(sProcName, #SCS_END)

EndProcedure

Procedure resumeAudChannels(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nBassResult.l, d, d2
  Protected nPLCurrFadeInTime
  Protected qCurrBytePos.q, dCurrTimePos.d
  
  debugMsg(sProcName, #SCS_START)
  
  With aAud(pAudPtr)
    debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nFileFormat=" + decodeFileFormat(\nFileFormat) + ", \nAudState=" + decodeCueState(\nAudState) + ", \nFadeInTime=" + \nFadeInTime + ", \nCurrFadeInTime=" + \nCurrFadeInTime)
    Select \nFileFormat
      Case #SCS_FILEFORMAT_MIDI
        resumeMidiFile(pAudPtr)
        
      Case #SCS_FILEFORMAT_VIDEO, #SCS_FILEFORMAT_PICTURE
        nPLCurrFadeInTime = aSub(\nSubIndex)\nPLCurrFadeInTime
        If (\nAudState = #SCS_CUE_HIBERNATING) And (nPLCurrFadeInTime > 0)
          \nCurrFadeInTime = nPLCurrFadeInTime
          debugMsg(sProcName, "calling fadeInOneAud(" + getAudLabel(pAudPtr) + ")")
          fadeInOneAud(pAudPtr)
          If \nFileFormat = #SCS_FILEFORMAT_VIDEO
            debugMsg(sProcName, "calling resumeVideo(" + getAudLabel(pAudPtr) + ")")
            resumeVideo(pAudPtr)
          EndIf
        Else
          debugMsg(sProcName, "calling resumeVideo(" + getAudLabel(pAudPtr) + ")")
          resumeVideo(pAudPtr)
        EndIf
        
      Case #SCS_FILEFORMAT_AUDIO
        ; Added 30Nov2021 11.8.6ck following email from Dave Cornish (bug related to using linear fade in type)
        If \nAudState = #SCS_CUE_HIBERNATING And \nFadeInType = #SCS_FADE_LIN
          debugMsg(sProcName, "calling fadeInOneAud(" + getAudLabel(pAudPtr) + ")")
          fadeInOneAud(pAudPtr)
        EndIf
        ; End added 30Nov2021 11.8.6ck
        If \bPlayEndSyncOccurred = #False
          d = \nFirstSoundingDev
          If d >= 0
            If \nBassChannel[d] <> 0
              If gbUseBASSMixer
                For d2 = \nLastSoundingDev To \nFirstSoundingDev Step -1
                  If \nBassChannel[d2] <> 0
                    nBassResult = BASS_Mixer_ChannelFlags(\nBassChannel[d2], 0, #BASS_MIXER_CHAN_PAUSE) ; remove the pause flag
                    debugMsg3(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(\nBassChannel[d2]) + ", 0, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
                  EndIf
                Next d2
              Else
                nBassResult = BASS_ChannelPlay(\nBassChannel[d], #BASSFALSE)
                debugMsg2(sProcName, "BASS_ChannelPlay(" + decodeHandle(\nBassChannel[d]) + ", BASSFALSE)", nBassResult)
                If nBassResult = #BASSFALSE
                  debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                EndIf
              EndIf
              qCurrBytePos = BASS_ChannelGetPosition(\nBassChannel[d], #BASS_POS_BYTE)
              ; Added 25Nov2022 11.9.7am
              If qCurrBytePos = -1
                debugMsg(sProcName, "BASS_ChannelGetPosition(" + decodeHandle(\nBassChannel[d]) + ", BASS_POS_BYTE) returned " + qCurrBytePos)
                debugMsg(sProcName, "Error " + BASS_ErrorGetCode() + ": " + getBassErrorDesc(BASS_ErrorGetCode()))
                qCurrBytePos = 0
              EndIf
              ; End added 25Nov2022 11.9.7am
              dCurrTimePos = BASS_ChannelBytes2Seconds(\nBassChannel[d], qCurrBytePos)
              debugMsg(sProcName, "BASS_ChannelBytes2Seconds(" + decodeHandle(\nBassChannel[d]) + ", " + qCurrBytePos + ") returned " + StrD(dCurrTimePos,4))
            EndIf
          EndIf
          
          For d = \nFirstSoundingDev To \nLastSoundingDev
            \bStopping[d] = #False
            \bAltStopping[d] = #False
          Next d
          
        EndIf
        
    EndSelect
  EndWith
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure resyncLinkedAuds()
  PROCNAMEC()
  Protected k
  
  ; debugMsg(sProcName, #SCS_START)
  
  For k = 1 To gnLastAud
    With aAud(k)
      If \bExists
        If \bResyncLinksReqd
          debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\bResyncLinksReqd=" + strB(\bResyncLinksReqd))
          ; nb this should only be set in the master aud
          resyncOneLinkedAud(k)
          \bResyncLinksReqd = #False
        EndIf
      EndIf
    EndWith
  Next k

EndProcedure

Procedure resyncOneLinkedAud(pPrimaryAudPtr)
  PROCNAMEC()
  Protected bInSync, k2, nLabel
  Protected nCurrentAudState, nCurrentAbsPos

  bInSync = #True

  With aAud(pPrimaryAudPtr)
    nLabel = 1000
    debugMsg(sProcName, Str(nLabel) + " " + \sAudLabel)
    
    nLabel = 1100
    nCurrentAudState = \nAudState
    
    ; calcCuePositionForAud must be called BEFORE pauseAud as
    ; calcCuePositionForAud does not calc position of a paused aud
    calcCuePositionForAud(pPrimaryAudPtr)
    debugMsg(sProcName, "calling pauseAud(" + getAudLabel(pPrimaryAudPtr) + ")")
    pauseAud(pPrimaryAudPtr)
    nCurrentAbsPos = \nCuePos + \nAbsMin
    
    debugMsg(sProcName, Str(nLabel) + " calling stopAud(" + Str(pPrimaryAudPtr) + ")")
    stopAud(pPrimaryAudPtr, #True)
    
    debugMsg3(sProcName, Str(nLabel) + " calling removeLinksOneAud(" + Str(pPrimaryAudPtr) + ")")
    removeLinksOneAud(pPrimaryAudPtr)
    
    ; set prepaudAudStates of secondary auds to prepauseAudState of the primary
    nLabel = 1200
    For k2 = 1 To gnLastAud
      If aAud(k2)\bExists
        If aAud(k2)\nLinkedToAudPtr = pPrimaryAudPtr
          debugMsg(sProcName, Str(nLabel) + " calling stopAud(" + Str(k2) + ")")
          stopAud(k2, #True)
          aAud(k2)\nPrepauseAudState = \nPrepauseAudState
          debugMsg3(sProcName, Str(nLabel) + " calling setLinksOneAud(" + Str(k2) + ")")
          setLinksOneAud(k2)
        EndIf
      EndIf
    Next k2
    nLabel = 1300
    
    debugMsg(sProcName, Str(nLabel) + " calling reposAuds(" + Str(pPrimaryAudPtr) + ", " + Str(nCurrentAbsPos) + ")")
    reposAuds(pPrimaryAudPtr, nCurrentAbsPos)
    If (nCurrentAudState >= #SCS_CUE_FADING_IN) And (nCurrentAudState <= #SCS_CUE_FADING_OUT) And (nCurrentAudState <> #SCS_CUE_PAUSED)
      debugMsg3(sProcName, Str(nLabel) + " calling playAud(" + Str(pPrimaryAudPtr) + ")")
      playAud(pPrimaryAudPtr)
    EndIf
    
    nLabel = 9000
    debugMsg3(sProcName, Str(nLabel) + " end")
  EndWith

EndProcedure

Procedure freeAudStreams(pAudPtr)
  PROCNAMEC()
  Protected d, l2
  Protected nMyFirstDev, nMyLastDev
  
  debugMsg(sProcName, #SCS_START)
  
  ; debugMsg(sProcName, "calling removeAudChannelLoopSyncs(" + getAudLabel(pAudPtr) + ")")
  removeAudChannelLoopSyncs(pAudPtr)
  
  ; debugMsg(sProcName, "calling removeAudChannelPlayEndSyncs(" + getAudLabel(pAudPtr) + ")")
  removeAudChannelPlayEndSyncs(pAudPtr)
  
  With aAud(pAudPtr)
    Select \nFileFormat
      Case #SCS_FILEFORMAT_AUDIO
        nMyFirstDev = \nFirstSoundingDev
        nMyLastDev = \nLastSoundingDev
      Default
        nMyFirstDev = 0
        nMyLastDev = 0
    EndSelect
    For d = nMyFirstDev To nMyLastDev
      ; debugMsg(sProcName, "calling freeOneAudStream(" + getAudLabel(pAudPtr) + ", " + d + ")")
      freeOneAudStream(pAudPtr, d)
    Next d
  EndWith
  
  ; now clear BASS sync handles
  For l2 = 0 To aAud(pAudPtr)\nMaxLoopInfo
    With aAud(pAudPtr)\aLoopInfo(l2)
      \nBassLoopSyncHearXFade = 0
      \nBassLoopSyncHearLE = 0
      \nBassLoopSyncHearBoth = 0
      \nBassLoopSyncMixTime = 0
      \nBassAltLoopSyncHearXFade = 0
      \nBassAltLoopSyncHearLE = 0
      \nBassAltLoopSyncHearBoth = 0
    EndWith
  Next l2
  
  loadCurrLoopInfo(pAudPtr, 0)
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure freeOneAudStream(pAudPtr, pDev)
  PROCNAME(buildAudProcName(#PB_Compiler_Procedure, pAudPtr) + "(" + pDev + ")]")
  Protected nBassResult.l, bDecodeStream, nBassDevice.l, nMixerStreamPtr, bFreeStreamNow
  
  debugMsg(sProcName, #SCS_START)
  
  If pAudPtr < 0
    ProcedureReturn
  EndIf
  
  With aAud(pAudPtr)
    Select \nFileFormat
      Case #SCS_FILEFORMAT_MIDI
        closeMidiFile(pAudPtr)
        
      Case #SCS_FILEFORMAT_VIDEO
        debugMsg(sProcName, "calling closeVideo(" + getAudLabel(pAudPtr) + ")")
        closeVideo(pAudPtr)
        
      Case #SCS_FILEFORMAT_PICTURE
        If \bLogo = #False Or aSub(\nSubIndex)\bUseNew2DDrawing ; Added test 9Jan2025 11.10.6-b02 as part of the fix for logos not to be displayed using 2D Drawing if the sub's bUseNew2DDrawing=#False
          If (grVideoDriver\nVideoPlaybackLibrary = #SCS_VPL_TVG) And (checkUse2DDrawing(\nSubIndex) = #False)
            debugMsg(sProcName, "calling closeVideo(" + getAudLabel(pAudPtr) + ")")
            closeVideo(pAudPtr)
          Else
            debugMsg(sProcName, "calling closePicture(" + getAudLabel(pAudPtr) + ")")
            closePicture(pAudPtr)
          EndIf
        EndIf
        
      Case #SCS_FILEFORMAT_AUDIO
        If gbUseBASS  ; BASS
          If \nVSTHandle
            BASS_VST_ChannelRemoveDSP(\nSourceChannel, \nVSTHandle)
            debugMsg(sProcName, "BASS_VST_ChannelRemoveDSP(" + decodeHandle(\nSourceChannel) + ", " + decodeHandle(\nVSTHandle) + ")")
            \nVSTHandle = 0
            bFreeStreamNow = #True
          EndIf
          If \nVSTAltHandle
            BASS_VST_ChannelRemoveDSP(\nSourceAltChannel, \nVSTAltHandle)
            debugMsg(sProcName, "BASS_VST_ChannelRemoveDSP(" + decodeHandle(\nSourceAltChannel) + ", " + decodeHandle(\nVSTAltHandle) + ")")
            \nVSTAltHandle = 0
            bFreeStreamNow = #True
          EndIf
          nBassDevice = \nBassDevice[pDev]
          nMixerStreamPtr = \nMixerStreamPtr[pDev]
          If \bUsingSplitStream
            debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nBassChannel[" + pDev + "]=" + decodeHandle(\nBassChannel[pDev]) +
                                ", \nBassAltChannel[" + pDev + "]=" + decodeHandle(\nBassAltChannel[pDev]) +
                                ", \nSourceChannel=" + decodeHandle(\nSourceChannel) +
                                ", \nSourceAltChannel=" + decodeHandle(\nSourceAltChannel))
            If \bAudUseGaplessStream
              nMixerStreamPtr = -1
            EndIf
            If \nSourceChannel <> 0
              debugMsg(sProcName, "\nSourceChannel=" + decodeHandle(\nSourceChannel))
              freeStreamRequest(\nSourceChannel, nBassDevice, pAudPtr, pDev, #True, nMixerStreamPtr, \bUsingSplitStream, bFreeStreamNow)
              \nSourceChannel = 0
            EndIf
            If \nSourceAltChannel <> 0
              debugMsg(sProcName, "\nSourceAltChannel=" + decodeHandle(\nSourceAltChannel))
              freeStreamRequest(\nSourceAltChannel, nBassDevice, pAudPtr, pDev, #True, nMixerStreamPtr, \bUsingSplitStream, bFreeStreamNow)
              \nSourceAltChannel = 0
            EndIf
            \nBassChannel[pDev] = 0
            \nBassAltChannel[pDev] = 0
          Else
            If nMixerStreamPtr >= 0
              bDecodeStream = #True
            EndIf
            If \nBassChannel[pDev] <> 0
              debugMsg(sProcName, "\nBassChannel(" + pDev + ")=" + decodeHandle(\nBassChannel[pDev]))
              freeStreamRequest(\nBassChannel[pDev], nBassDevice, pAudPtr, pDev, bDecodeStream, nMixerStreamPtr, \bUsingSplitStream, bFreeStreamNow)
              \nBassChannel[pDev] = 0
            EndIf
            If \nBassAltChannel[pDev] <> 0
              debugMsg(sProcName, "\nBassAltChannel(" + pDev + ")=" + decodeHandle(\nBassAltChannel[pDev]))
              freeStreamRequest(\nBassAltChannel[pDev], nBassDevice, pAudPtr, pDev, bDecodeStream, nMixerStreamPtr, \bUsingSplitStream, bFreeStreamNow)
              \nBassAltChannel[pDev] = 0
            EndIf
            \nSourceChannel = 0
            \nSourceAltChannel = 0
          EndIf
          ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nBassChannel[" + pDev + "]=" + Str(\nBassChannel[pDev]) + ", \nBassAltChannel[" + pDev + "]=" + Str(\nBassAltChannel[pDev]))
          
        Else  ; SM-S
          If \nPrimaryChan >= 0
            freeFilePlaybacks(\nPrimaryChan)
            \nPrimaryChan = -1
          EndIf
          If \nAltPrimaryChan >= 0
            freeFilePlaybacks(\nAltPrimaryChan)
            \nAltPrimaryChan = -1
          EndIf
          If \nGraphChan <> 0
            nBassResult = BASS_StreamFree(\nGraphChan)
            debugMsg2(sProcName, "BASS_StreamFree(" + Str(\nGraphChan) + ")", nBassResult)
            freeHandle(\nGraphChan)
            \nGraphChan = 0
          EndIf
        EndIf
        
    EndSelect
  EndWith
EndProcedure

Procedure setAudChannelPositions(pAudPtr, pAbsPosition, bManualChange=#False, pBytePosition.q=-2, pSamplePos.q=-2, nVidPicTarget=#SCS_VID_PIC_TARGET_NONE, bTrace=#False)
  PROCNAMECA(pAudPtr)
  Protected nBassResult.l, d, nAbsPosition, nAltPosition, qBytePosition.q, qAltBytePosition.q=-2.0
  Protected n, nMixerStream.l, nChannel.l, nAltChannel.l, bMixerStreamsLocked
  Protected bPlaying, nFadeTime, fCurrLevel.f
  Protected dTmpDouble.d, qTmpQuad.q
  Protected sSMSCommandString.s
  Protected sTrackStatus.s
  Protected sTrackRepeatTime.s
  Protected bResetLoopInfo
  Protected nMyFirstDev, nMyLastDev
  Protected qSamplePos.q
  Protected bListSMSSyncPoints
  Protected nCurrAudState, nMTCSubPtr, bCallResumeAudChannels
  
  debugMsgC(sProcName, #SCS_START + ", pAbsPosition=" + pAbsPosition + ", bManualChange=" + strB(bManualChange) + ", pBytePosition=" + pBytePosition + ", pSamplePos=" + pSamplePos +
                       ", nVidPicTarget=" + decodeVidPicTarget(nVidPicTarget))
  
  With aAud(pAudPtr)
    
    Select \nFileFormat
      Case #SCS_FILEFORMAT_MIDI
        ;{
        setMidiFilePosition(pAudPtr, pAbsPosition)
        \qChannelBytePosition = pAbsPosition
        ;}
      Case #SCS_FILEFORMAT_PICTURE
        ;{
        ;}
      Case #SCS_FILEFORMAT_VIDEO
        ;{
        nMTCSubPtr = aSub(\nSubIndex)\nAFLinkedToMTCSubPtr
        If nMTCSubPtr >= 0
          nCurrAudState = \nAudState
          If nCurrAudState >= #SCS_CUE_FADING_IN And nCurrAudState <= #SCS_CUE_FADING_OUT And nCurrAudState <> #SCS_CUE_PAUSED And nCurrAudState <> #SCS_CUE_HIBERNATING
            debugMsg(sProcName, "calling pauseAudChannels(" + getAudLabel(pAudPtr) + ")")
            pauseAudChannels(pAudPtr)
            bCallResumeAudChannels = #True
          EndIf
        EndIf
        If nVidPicTarget = #SCS_VID_PIC_TARGET_NONE
          setVideoPosition(pAudPtr, \nAudVidPicTarget, pAbsPosition)
        Else
          setVideoPosition(pAudPtr, nVidPicTarget, pAbsPosition)
        EndIf
        If nMTCSubPtr >= 0
          debugMsg(sProcName, "calling MTC_setSyncTimeCode(" + getSubLabel(nMTCSubPtr) + ")")
          MTC_setSyncTimeCode(nMTCSubPtr)
        EndIf
        If bCallResumeAudChannels And gbStoppingEverything = #False And gbInStopAud = #False ; Added "And gbStoppingEverything = #False And gbInStopAud = #False" 17Jan2023 11.9.8ad
          debugMsg(sProcName, "calling resumeAudChannels(" + getAudLabel(pAudPtr) + ")")
          resumeAudChannels(pAudPtr)
        EndIf
        ;}
      Case #SCS_FILEFORMAT_AUDIO
        If gbUseSMS
          If (\nAudState >= #SCS_CUE_FADING_IN) And (\nAudState <= #SCS_CUE_FADING_OUT)
            \qTimePlayOrReposIssued = ElapsedMilliseconds() + 60000   ; force calcCuePositionForAud() to leave \relFilePos unchanged (set correctly at end of procedure)
          EndIf
        EndIf
        nAbsPosition = pAbsPosition
        qSamplePos = pSamplePos
        If nAbsPosition < 0
          nAbsPosition = 0
          qSamplePos = -2 ; force qSamplePos to be ignored
        ElseIf nAbsPosition >= \nAbsMax
          nAbsPosition = \nAbsMax - 1
          qSamplePos = -2 ; force qSamplePos to be ignored
        EndIf
        nAltPosition = -1
        \nCuePos = pAbsPosition - \nAbsMin
        If \nMaxLoopInfo >= 0
          debugMsgC(sProcName, "calling loadCurrLoopInfo(" + getAudLabel(pAudPtr) + ", " + \nCuePos + ", #True)")
          loadCurrLoopInfo(pAudPtr, \nCuePos, #True)
          If bTrace
            listLoopInfoArray(pAudPtr)
          EndIf
          debugMsgC(sProcName, "nAbsPosition=" + nAbsPosition + ", \nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex +
                              ", \rCurrLoopInfo\nAbsLoopEnd=" + \rCurrLoopInfo\nAbsLoopEnd + ", \rCurrLoopInfo\bLoopReleased=" + strB(\rCurrLoopInfo\bLoopReleased))
          If nAbsPosition < \rCurrLoopInfo\nAbsLoopEnd
            If \rCurrLoopInfo\bLoopReleased
              debugMsgC(sProcName, "calling setBassLoopEnd(" + getAudLabel(pAudPtr) + ")")
              setBassLoopEnd(pAudPtr)
              \rCurrLoopInfo\bLoopReleased = #False
              debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\rCurrLoopInfo\bLoopReleased=" + strB(\rCurrLoopInfo\bLoopReleased))
              \nLoopPassNo = grAudDef\nLoopPassNo
              If \rCurrLoopInfo\nLoopSyncIndex >= 0
                gaLoopSync(\rCurrLoopInfo\nLoopSyncIndex)\nLoopSyncPassNo = 1
              EndIf
              debugMsgC(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex + ", \nLoopPassNo=" + \nLoopPassNo)
            EndIf
            bResetLoopInfo = #True
            If nAbsPosition > (\rCurrLoopInfo\nAbsLoopEnd - \rCurrLoopInfo\nLoopXFadeTime)
              nAltPosition = \rCurrLoopInfo\nAbsLoopStart + (nAbsPosition - (\rCurrLoopInfo\nAbsLoopEnd - \rCurrLoopInfo\nLoopXFadeTime))
            Else
              nAltPosition = \rCurrLoopInfo\nAbsLoopStart
              qAltBytePosition = \rCurrLoopInfo\qLoopStartBytePos
            EndIf
          Else
            \rCurrLoopInfo\bLoopReleased = #True
            \nRelPassEnd = \nRelEndAt
            debugMsgC(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\rCurrLoopInfo\bLoopReleased=" + strB(aAud(pAudPtr)\rCurrLoopInfo\bLoopReleased) + ", \nRelPassEnd=" + \nRelPassEnd)
          EndIf
        EndIf
        ; debugMsgC(sProcName, "\nMaxLoopInfo=" + \nMaxLoopInfo + ", nAbsPosition=" + nAbsPosition +
        ;                     ", \rCurrLoopInfo\nAbsLoopEnd=" + \rCurrLoopInfo\nAbsLoopEnd + ", \rCurrLoopInfo\bLoopReleased=" + strB(\rCurrLoopInfo\bLoopReleased))
        
        If gbUseBASS  ; BASS
          nMTCSubPtr = aSub(\nSubIndex)\nAFLinkedToMTCSubPtr
          If nMTCSubPtr >= 0
            nCurrAudState = \nAudState
            If nCurrAudState >= #SCS_CUE_FADING_IN And nCurrAudState <= #SCS_CUE_FADING_OUT And nCurrAudState <> #SCS_CUE_PAUSED And nCurrAudState <> #SCS_CUE_HIBERNATING
              debugMsg(sProcName, "calling pauseAudChannels(" + getAudLabel(pAudPtr) + ")")
              pauseAudChannels(pAudPtr)
              bCallResumeAudChannels = #True
            EndIf
          EndIf

          If gbUseBASSMixer
            If (\nAudState >= #SCS_CUE_FADING_IN) And (\nAudState <= #SCS_CUE_FADING_OUT)
              lockAllMixerStreams(#True, #False, bTrace)
              bMixerStreamsLocked = #True
            EndIf
          EndIf
          
          If bResetLoopInfo
            \nRelPassEnd = \rCurrLoopInfo\nRelLoopEnd
            ; debugMsgC(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nRelPassEnd=" + \nRelPassEnd)
          EndIf
          
          nMyFirstDev = \nFirstSoundingDev
          If (\bUsingSplitStream) And (gbUseBASSMixer = #False)
            nMyLastDev = nMyFirstDev
          Else
            nMyLastDev = \nLastSoundingDev
          EndIf
          
          qBytePosition = pBytePosition
          For d = nMyFirstDev To nMyLastDev
            nChannel = \nBassChannel[d]
            If \nMaxLoopInfo >= 0 And \rCurrLoopInfo\nLoopXFadeTime > 0
              nAltChannel = \nBassAltChannel[d]
            Else
              nAltChannel = 0
            EndIf
            If nChannel <> 0
              If d = \nFirstSoundingDev
                bPlaying = #False
                If gbUseBASSMixer
                  nBassResult = BASS_Mixer_ChannelFlags(nChannel, 0, 0)
                  ; debugMsgC3(sProcName, "BASS_Mixer_ChannelFlags(" & nChannel & ", 0, 0) returned " & decodeMixerChannelFlags(nBassResult))
                  If nBassResult & #BASS_MIXER_CHAN_PAUSE = 0
                    bPlaying = #True
                  EndIf
                Else
                  nBassResult = BASS_ChannelIsActive(nChannel)
                  If nBassResult = #BASS_ACTIVE_PLAYING
                    bPlaying = #True
                  EndIf
                EndIf
              EndIf
              If gbUseBASSMixer
                If \bStopping[d]
                  nBassResult = BASS_Mixer_ChannelFlags(nChannel, #BASS_MIXER_CHAN_PAUSE, #BASS_MIXER_CHAN_PAUSE) ; set the pause flag
                  debugMsgC3(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(nChannel) + ", BASS_MIXER_CHAN_PAUSE, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
                  If nAltChannel <> 0
                    nBassResult = BASS_Mixer_ChannelFlags(nAltChannel, #BASS_MIXER_CHAN_PAUSE, #BASS_MIXER_CHAN_PAUSE) ; set the pause flag
                    debugMsgC3(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(nAltChannel) + ", BASS_MIXER_CHAN_PAUSE, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
                  EndIf
                  \bStopping[d] = #False
                EndIf
              EndIf
              debugMsgC(sProcName, "calling SetPlayingPos(" + getAudLabel(pAudPtr) + ", " + d + ", #SCS_CHAN_MAIN, " + nAbsPosition + ", " + qBytePosition + ", #False, #False)")
              SetPlayingPos(pAudPtr, d, #SCS_CHAN_MAIN, nAbsPosition, qBytePosition, #False, #False)
              If nAltChannel <> 0
                If bManualChange = #False
                  SetPlayingPos(pAudPtr, d, #SCS_CHAN_ALT, nAltPosition, qAltBytePosition)
                EndIf
                If nAltPosition > \rCurrLoopInfo\nAbsLoopStart
                  If bPlaying
                    If gbUseBASSMixer
                      nBassResult = BASS_Mixer_ChannelFlags(nAltChannel, 0, #BASS_MIXER_CHAN_PAUSE)   ; remove pause flag
                      debugMsgC3(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(nAltChannel) + ", 0, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
                    Else
                      nBassResult = BASS_ChannelSetAttribute(nAltChannel, #BASS_ATTRIB_VOL, #SCS_MINVOLUME_SINGLE)
                      ;debugMsgC2(sProcName, "BASS_ChannelSetAttribute(" & nAltChannel & ", BASS_ATTRIB_VOL, " & SCS_MINVOLUME_SINGLE & ")", nBassResult)
                      ; need to use restart=basstrue to clear playback buffer, or loops can get incorrectly set
                      nBassResult = BASS_ChannelPlay(nAltChannel, #BASSTRUE)
                      debugMsgC2(sProcName, "BASS_ChannelPlay(" + decodeHandle(nAltChannel) + ", BASSTRUE)", nBassResult)
                      If nBassResult = #BASSFALSE
                        debugMsgC3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                      EndIf
                      ; need to reset playing pos immediately because BASS_ChannelPlay with restart=BASSTRUE sets the file back to the start
                      SetPlayingPos(pAudPtr, d, #SCS_CHAN_ALT, nAltPosition, qAltBytePosition, #False, #False)
                    EndIf
                    ; fade-in altchannel to current total level
                    fCurrLevel = \fCueTotalVolNow[d]
                    ; calculate time remaining for the cross-fade
                    nFadeTime = \rCurrLoopInfo\nLoopXFadeTime - (nAltPosition - \rCurrLoopInfo\nAbsLoopStart)
                    samAddRequest(#SCS_SAM_CHANNEL_SLIDE, nAltChannel, fCurrLevel, nFadeTime)
                    ; fade-out channel
                    samAddRequest(#SCS_SAM_CHANNEL_SLIDE, nChannel, #SCS_MINVOLUME_SINGLE, nFadeTime)
                  EndIf
                EndIf
              EndIf
              If d = \nFirstSoundingDev
                If pBytePosition >= 0
                  \qChannelBytePosition = pBytePosition
                Else
                  dTmpDouble = nAbsPosition / 1000.0
                  qTmpQuad = BASS_ChannelSeconds2Bytes(nChannel, dTmpDouble)
                  \qChannelBytePosition = qTmpQuad
                EndIf
                ; debugMsgC(sProcName, "pBytePosition=" + pBytePosition + ", \qChannelBytePosition=" + \qChannelBytePosition)
              EndIf
            EndIf
          Next d
          
          If nMTCSubPtr >= 0
            debugMsg(sProcName, "calling MTC_setSyncTimeCode(" + getSubLabel(nMTCSubPtr) + ")")
            MTC_setSyncTimeCode(nMTCSubPtr)
          EndIf
          
          If bCallResumeAudChannels And gbStoppingEverything = #False And gbInStopAud = #False ; Added "And gbStoppingEverything = #False And gbInStopAud = #False" 17Jan2023 11.9.8ad
            debugMsg(sProcName, "calling resumeAudChannels(" + getAudLabel(pAudPtr) + ")")
            resumeAudChannels(pAudPtr)
          EndIf
          
          If gbUseBASSMixer
            If bMixerStreamsLocked
              lockAllMixerStreams(#False, #False, bTrace)
              bMixerStreamsLocked = #False
            EndIf
          EndIf
          
        Else  ; SM-S
          ; nb need to adjust stop time if necessary before changing start time, because if the start time > (current) stop time then change to start time is ignored
          If (\nMaxLoopInfo >= 0) And (nAbsPosition > \rCurrLoopInfo\nAbsLoopEnd) ; And (\bLoopReleased = #False)
            If \sSyncPChanList
              sSMSCommandString = "set chan " + \sSyncPChanList + " track repeat clear"
              If \nEndAt < 0
                sSMSCommandString + " stop clear"
              ElseIf \qEndAtSamplePos > 0
                sSMSCommandString + " stop samples " + \qEndAtSamplePos
              Else
                sSMSCommandString + " stop time " + makeSMSTimeString(\nAbsEndAt)
              EndIf
              sSMSCommandString + " start time " + makeSMSTimeString(nAbsPosition)
              sendSMSCommand(sSMSCommandString)
            EndIf
            \rCurrLoopInfo\bLoopReleased = #True
            \nRelPassEnd = \nRelEndAt
            debugMsgC(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\rCurrLoopInfo\bLoopReleased=" + strB(aAud(pAudPtr)\rCurrLoopInfo\bLoopReleased) + ", \nRelPassEnd=" + \nRelPassEnd)
            debugMsgC(sProcName, "calling removeAudChannelLoopSyncs(" + getAudLabel(pAudPtr) + ")")
            removeAudChannelLoopSyncs(pAudPtr)
            
          ElseIf bResetLoopInfo
            \nRelPassEnd = \rCurrLoopInfo\nRelLoopEnd
            debugMsgC(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nRelPassEnd=" + \nRelPassEnd)
            If \sSyncPChanList
              sSMSCommandString = "set chan " + \sSyncPChanList + " track start time " + makeSMSTimeString(nAbsPosition)
              If \rCurrLoopInfo\nLoopXFadeTime <= 0
                If \rCurrLoopInfo\qLoopStartSamplePos >= 0
                  sSMSCommandString + " repeat samples " + \rCurrLoopInfo\qLoopStartSamplePos
                Else
                  sSMSCommandString + " repeat time " + makeSMSTimeString(\rCurrLoopInfo\nAbsLoopStart)
                EndIf
              EndIf
              If \rCurrLoopInfo\qLoopEndSamplePos >= 0
                sSMSCommandString + " stop samples " + \rCurrLoopInfo\qLoopEndSamplePos
              Else
                sSMSCommandString + " stop time " + makeSMSTimeString(\rCurrLoopInfo\nAbsLoopEnd)
              EndIf
              sendSMSCommand(sSMSCommandString)
            EndIf
            debugMsgC(sProcName, "calling setSMSSyncPointLoopReleased(" + getAudLabel(pAudPtr) + ", " + \nCurrLoopInfoIndex + ", " + strB(\rCurrLoopInfo\bLoopReleased) + ")")
            setSMSSyncPointLoopReleased(pAudPtr, \nCurrLoopInfoIndex, \rCurrLoopInfo\bLoopReleased)
            bListSMSSyncPoints = #True
            
          Else
            If \sSyncPChanList
              If qSamplePos >= 0
                sSMSCommandString = "set chan " + \sSyncPChanList + " track start samples " + qSamplePos
              Else
                sSMSCommandString = "set chan " + \sSyncPChanList + " track start time " + makeSMSTimeString(nAbsPosition)
              EndIf
              sendSMSCommand(sSMSCommandString)
            EndIf
            
          EndIf
          sTrackStatus = getSMSTrackStatus(\sPPrimaryChan)
          debugMsgC(sProcName, "getSMSTrackStatus(" + \sPPrimaryChan + ") returned " + sTrackStatus + ", \nAudState=" + decodeCueState(\nAudState))
          If sTrackStatus = "play"
            sendSMSCommand("stop " + \sSyncPChanList)
            If (\nAudState >= #SCS_CUE_FADING_IN) And (\nAudState <= #SCS_CUE_FADING_OUT) And (\nAudState <> #SCS_CUE_PAUSED)
              sendSMSCommand("play " + \sSyncPChanList)
              \bSyncPChanListPlaying = #True
            Else
              \bSyncPChanListPlaying = #False
            EndIf
          EndIf
          
          If bManualChange
            If \nAudState < #SCS_CUE_FADING_IN
              \nSMSManualStartPos = nAbsPosition
              \nRelFilePos = nAbsPosition - \nAbsMin
              debugMsgC(sProcName, "\nSMSManualStartPos=" + Str(\nSMSManualStartPos) + ", \nRelFilePos=" + \nRelFilePos)
            EndIf
          EndIf
          
          If (\nAudState >= #SCS_CUE_FADING_IN) And (\nAudState <= #SCS_CUE_FADING_OUT)
            \nRelFilePos = nAbsPosition - \nAbsMin
            \qTimePlayOrReposIssued = ElapsedMilliseconds()
          Else
            \nRelFilePos = nAbsPosition - \nAbsMin
          EndIf
          
          debugMsgC(sProcName, "calling setSMSLoopStart(" + getAudLabel(pAudPtr) + ")")
          setSMSLoopStart(pAudPtr)
          debugMsgC(sProcName, "calling setSMSLoopEnd(" + getAudLabel(pAudPtr) + ")")
          setSMSLoopEnd(pAudPtr)
          
;           \nCuePos = \nCuePosAtLoopStart + (\nRelFilePos - \nRelPassStart)
;           debugMsgC(sProcName, "\nCuePosAtLoopStart=" + \nCuePosAtLoopStart + ", \nRelFilePos=" + \nRelFilePos + ", \nRelPassStart=" + \nRelPassStart +
;                               ", >>\nCuePos=" + \nCuePos)
          \nCuePos = \nRelFilePos
          debugMsgC(sProcName, "\nRelFilePos=" + \nRelFilePos + ", >>\nCuePos=" + \nCuePos)
          sendRAICueSetPosIfReqd(pAudPtr)
          FMP_sendCommandIfReqd(#SCS_OSCINP_CUE_SET_POS, \nCueIndex, pAudPtr)
          
        EndIf
        
    EndSelect
    aCue(\nCueIndex)\nCuePanelUpdateFlags | #SCS_CUEPNL_PROGRESS | #SCS_CUEPNL_TRANSPORT
    ; debugMsgC(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\nCuePanelUpdateFlags=" + Str(aCue(\nCueIndex)\nCuePanelUpdateFlags))
    
    If bListSMSSyncPoints
      listSMSSyncPoints()
    EndIf
    
  EndWith
  
  debugMsgC(sProcName, #SCS_END)
  
EndProcedure

Procedure.s getBassErrorDesc(pErrorCode.l, pErrorMsg.s="")
  Protected sErrorDesc.s, sName.s
  Protected sBassFunction.s
  Protected nBassPtr, nEndPtr
  Protected nBracketPtr, nSpacePtr, nLength
  Protected bASIO
  
  ; note: the BASS_ASIO error codes are a sub-set of the BASS error codes
  
  If pErrorCode = #BASS_OK
    ProcedureReturn ""
  EndIf
  
  nLength = Len(pErrorMsg)
  If nLength > 0
    If FindString(pErrorMsg, "BASS_ASIO_") > 0
      bASIO = #True
    EndIf
    nBassPtr = FindString(pErrorMsg, "BASS_")
    If nBassPtr > 0
      nBracketPtr = FindString(pErrorMsg, "(", nBassPtr)
      nSpacePtr = FindString(pErrorMsg, " ", nBassPtr)
      nEndPtr = nLength + 1
      If nBracketPtr > 0 And nBracketPtr < nEndPtr
        nEndPtr = nBracketPtr
      EndIf
      If nSpacePtr > 0 And nSpacePtr < nEndPtr
        nEndPtr = nSpacePtr
      EndIf
      sBassFunction = Mid(pErrorMsg, nBassPtr, (nEndPtr - nBassPtr))
    EndIf
  EndIf
  
  Select pErrorCode
    Case #BASS_OK
      sErrorDesc = "OK"
    Case #BASS_ERROR_MEM
      sErrorDesc = "Memory error"
    Case #BASS_ERROR_FILEOPEN
      sErrorDesc = "Cannot open the file"
    Case #BASS_ERROR_DRIVER
      sErrorDesc = "Device already in use, or cannot find a free sound driver"
    Case #BASS_ERROR_BUFLOST
      sErrorDesc = "The sample buffer was lost"
    Case #BASS_ERROR_HANDLE
      If Left(sBassFunction, 18) = "BASS_Mixer_Channel"
        sErrorDesc = "The channel is not plugged into a mixer"
      Else
        sErrorDesc = "Invalid handle"
      EndIf
    Case #BASS_ERROR_FORMAT
      sErrorDesc = "Unsupported sample format"
    Case #BASS_ERROR_POSITION
      sErrorDesc = "Invalid position"
    Case #BASS_ERROR_INIT
      If bASIO
        sErrorDesc = "BASS_ASIO_Init has not been successfully called"
      Else
        sErrorDesc = "BASS_Init has not been successfully called"
      EndIf
    Case #BASS_ERROR_START
      If bASIO
        sErrorDesc = "BASS_ASIO_Start has not been successfully called"
      Else
        sErrorDesc = "BASS_Start has not been successfully called"
      EndIf
    Case #BASS_ERROR_ALREADY
      sErrorDesc = "Already initialized/paused/loaded/whatever"
    Case #BASS_ERROR_NOCHAN
      sErrorDesc = "Cannot get a free channel"
    Case #BASS_ERROR_ILLTYPE
      sErrorDesc = "An illegal type was specified"
    Case #BASS_ERROR_ILLPARAM
      sErrorDesc = "An illegal parameter was specified"
    Case #BASS_ERROR_NO3D
      sErrorDesc = "No 3D support"
    Case #BASS_ERROR_NOEAX
      sErrorDesc = "No EAX support"
    Case #BASS_ERROR_DEVICE
      sErrorDesc = "Device is invalid"
    Case #BASS_ERROR_NOPLAY
      sErrorDesc = "Not playing"
    Case #BASS_ERROR_FREQ
      sErrorDesc = "Illegal sample rate"
    Case #BASS_ERROR_NOTFILE
      sErrorDesc = "The stream is not a file stream"
    Case #BASS_ERROR_NOHW
      sErrorDesc = "No hardware voices available"
    Case #BASS_ERROR_EMPTY
      sErrorDesc = "The MOD music has no sequence data"
    Case #BASS_ERROR_NONET
      sErrorDesc = "No internet connection could be opened"
    Case #BASS_ERROR_CREATE
      sErrorDesc = "Couldn't create the file"
    Case #BASS_ERROR_NOFX
      sErrorDesc = "Effects are not available"
    Case #BASS_ERROR_NOTAVAIL
      Select sBassFunction
        Case "BASS_Mixer_ChannelSetMatrix", "BASS_Mixer_ChannelGetMatrix"
          sErrorDesc = "The channel is not using matrix mixing"
        Default
          sErrorDesc = "Not available"
      EndSelect
    Case #BASS_ERROR_DECODE
      sErrorDesc = "The channel is/isn't a 'decoding channel'"
    Case #BASS_ERROR_DX
      sErrorDesc = "A sufficient DirectX version is not installed"
    Case #BASS_ERROR_TIMEOUT
      sErrorDesc = "Connection timedout"
    Case #BASS_ERROR_FILEFORM
      sErrorDesc = "Unsupported file format"
    Case #BASS_ERROR_SPEAKER
      sErrorDesc = "Unavailable speaker"
    Case #BASS_ERROR_VERSION
      sErrorDesc = "Plugin requires a different BASS version"
    Case #BASS_ERROR_CODEC
      sErrorDesc = "The file uses a codec that's not available/supported"
    Case #BASS_ERROR_ENDED
      sErrorDesc = "The file/channel/stream has reached the end"
    Case #BASS_ERROR_BUSY
      sErrorDesc = "The device is busy"
    Case #BASS_ERROR_UNKNOWN
      sErrorDesc = "Unknown error"
      
      ; BASSWMA:
    Case #BASS_ERROR_WMA_LICENSE
      sName = "#BASS_ERROR_WMA_LICENSE" ; translate this message
    Case #BASS_ERROR_WMA
      sErrorDesc = "Windows Media (9 or above) is not installed"
    Case #BASS_ERROR_WMA_DENIED
      sErrorDesc = "Access denied (user/pass is invalid)"
    Case #BASS_ERROR_WMA_INDIVIDUAL
      sErrorDesc = "Individualization is needed"
    Case #BASS_ERROR_WMA_PUBINIT
      sErrorDesc = "Publishing point initialization problem"
      
      ; BASSEnc
    Case #BASS_ERROR_ACM_CANCEL
      sErrorDesc = "ACM codec selection canceled"
    Case #BASS_ERROR_CAST_DENIED
      sErrorDesc = "Access denied (invalid password)"
      
    ; BASS_VST
    Case #BASS_VST_ERROR_NOINPUTS
      sErrorDesc = "The given VST plugin has no inputs and is probably a VST instrument and no effect"
    Case #BASS_VST_ERROR_NOOUTPUTS
      sErrorDesc = "The given VST plugin has no outputs"
    Case #BASS_VST_ERROR_NOREALTIME
      sErrorDesc = "The given VST plugin does not support realtime processing"
      
    ; BASSWASAPI
    Case #BASS_ERROR_WASAPI
      sErrorDesc = "WASAPI is not available"
    Case #BASS_ERROR_WASAPI_BUFFER
      sErrorDesc = "Buffer is too large or too small"
    Case #BASS_ERROR_WASAPI_CATEGORY
      sErrorDesc = "The category/raw mode could not be set"
    Case #BASS_ERROR_WASAPI_DENIED
      sErrorDesc = "Access to the device is denied. This could be due to privacy settings."
      
  EndSelect
  
  If Len(sErrorDesc) = 0
    If Len(sName) > 0
      sErrorDesc = Lang("BASS", sName, sName) ; set default to 'sName' 17Nov2015 11.4.1.2m
    Else
      sErrorDesc = Lang("Common", "ErrorCode") + " " + pErrorCode
    EndIf
  EndIf
  ProcedureReturn sErrorDesc
EndProcedure

Procedure releaseCueLoop(pCuePtr)
  PROCNAMECQ(pCuePtr)
  Protected j

  debugMsg(sProcName, #SCS_START)

  If pCuePtr >= 0
    With aCue(pCuePtr)
      j = \nFirstSubIndex
      While j >= 0
        releaseSubLoop(j)
        j = aSub(j)\nNextSubIndex
      Wend
    EndWith
  EndIf

EndProcedure

Procedure releaseSubLoop(pSubPtr)
  PROCNAMECS(pSubPtr)
  Protected k

  debugMsg(sProcName, #SCS_START)

  If pSubPtr >= 0
    With aSub(pSubPtr)
      If \bSubTypeA Or \bSubTypeF Or \bSubTypeP
        k = \nFirstPlayIndex
        While k >= 0
          releaseAudLoop(k)
          k = aAud(k)\nNextPlayIndex
        Wend
      EndIf
    EndWith
  EndIf

EndProcedure

Procedure releaseAudLoop(pAudPtr, nLoopNo=0)
  PROCNAME(buildAudProcName(#PB_Compiler_Procedure, pAudPtr) + ".L#" + nLoopNo)
  Protected qTimeNow.q, nXFadeTimeRemaining
  Protected n, d, nBassResult.l, nPanelIndex
  Protected bInXfade, fReqdBVLevel.f
  Protected nChannel.l, nAltChannel.l
  Protected bSwapped
  Protected h, nTmpAudPtr
  Protected sSMSCommand.s, sSMSRepeatOffCommand.s
  Protected l2
  Protected bHoldIgnoreInStatusCheck
  
  debugMsg(sProcName, #SCS_START + ", nLoopNo=" + nLoopNo)
  
  gnSuspendGetCurrInfo + 1
  
  gbInReleaseAudLoop = #True
  bHoldIgnoreInStatusCheck = aAud(pAudPtr)\bIgnoreInStatusCheck
  aAud(pAudPtr)\bIgnoreInStatusCheck = #True
  ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\bIgnoreInStatusCheck=" + strB(aAud(pAudPtr)\bIgnoreInStatusCheck))
  THR_waitForCueStatusChecksToEnd()
  
  qTimeNow = ElapsedMilliseconds()
  
  For n = 1 To gnLastLoopSync
    With gaLoopSync(n)
      If (\bActive) And (\nAudPtr = pAudPtr) And (\nLoopInfoIndex = aAud(pAudPtr)\nCurrLoopInfoIndex)
        bInXfade = \bInXfade
        bSwapped = \bSwapped
        Break
      EndIf
    EndWith
  Next n
  
  If gbUseBASS  ; BASS
    
    For h = 0 To aAud(pAudPtr)\nMaxAudSetPtr2
      nTmpAudPtr = gaAudSet(pAudPtr, h)
      If nTmpAudPtr > 0
        With aAud(nTmpAudPtr)
          ; Added 2Feb2022 11.9.0rc7
          debugMsg(sProcName, "calling loadLvlPtRun(" + getAudLabel(nTmpAudPtr) + ", " + Str(\nCuePos+1) + ", #False, " + strB(#cTraceSetLevels) + ")")
          loadLvlPtRun(nTmpAudPtr, \nCuePos+1, #False, #cTraceSetLevels)
          ; End added 2Feb2022 11.9.0rc7
          If nLoopNo > 0
            l2 = nLoopNo - 1
          Else
            l2 = \nCurrLoopInfoIndex
          EndIf
          If (l2 >= 0) And (l2 <= \nMaxLoopInfo)
            \aLoopInfo(l2)\bLoopReleased = #True
            debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\aLoopInfo(" + l2 + ")\bLoopReleased=" + strB(aAud(nTmpAudPtr)\aLoopInfo(l2)\bLoopReleased))
          EndIf
          If l2 = \nCurrLoopInfoIndex
            \rCurrLoopInfo\bLoopReleased = #True
            debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex + ", \rCurrLoopInfo\bLoopReleased=" + strB(aAud(nTmpAudPtr)\rCurrLoopInfo\bLoopReleased))
            \bInLoopXFade = #False    ; added 11/02/2015 11.3.8f for issue reported by Christian Peters (Q91/Q97/Q98)
            \nRelPassEnd = \nRelEndAt
            debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nRelPassEnd=" + \nRelPassEnd)
            If bInXfade
              nXFadeTimeRemaining = \rCurrLoopInfo\nLoopXFadeTime - (qTimeNow - \qTimePassStarted)
              debugMsg(sProcName, \sAudLabel + ", nXFadeTimeRemaining=" + Str(nXFadeTimeRemaining))
              If nXFadeTimeRemaining > 0
                For d = \nFirstSoundingDev To \nLastSoundingDev
                  nChannel = \nBassChannel[d]
                  nAltChannel = \nBassAltChannel[d]
                  If nChannel <> 0
                    ; fade up current channel
                    fReqdBVLevel = \fBVLevelAtLoopEnd[d]
                    ; Added 28Sep2022 11.9.6
                    If fReqdBVLevel <= grLevels\fMinBVLevel
                      fReqdBVLevel = 0.0
                    EndIf
                    ; End added 28Sep2022 11.9.6
                    nBassResult = BASS_ChannelSlideAttribute(nChannel, #BASS_ATTRIB_VOL, fReqdBVLevel, nXFadeTimeRemaining)
                    debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nChannel) + ", BASS_ATTRIB_VOL, " + formatLevel(fReqdBVLevel) + ", " + Str(nXFadeTimeRemaining) + ")", nBassResult)
                    ; fade out and stop alt channel
                    ;debugMsg3(sProcName, "Calling BASS_ChannelSlideAttribute(" & nAltChannel & ", BASS_ATTRIB_VOL, -2.0, " & nXFadeTimeRemaining & ")")
                    nBassResult = BASS_ChannelSlideAttribute(nAltChannel, #BASS_ATTRIB_VOL, -2, nXFadeTimeRemaining)
                    debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nAltChannel) + ", BASS_ATTRIB_VOL, -2, " + Str(nXFadeTimeRemaining) + ")", nBassResult)
                  EndIf
                Next d
              EndIf
            EndIf
            If l2 < \nMaxLoopInfo ; Test added 6Jan2024 11.10.0
              nPanelIndex = getPanelIndexForAud(pAudPtr)
              debugMsg(sProcName, \sAudLabel + ", nPanelIndex=" + nPanelIndex)
              If nPanelIndex >= 0 And aAud(pAudPtr)\nCurrLoopInfoIndex >= aAud(pAudPtr)\nMaxLoopInfo ; Added nCurrLoopInfoIndex test 6Jan2024 11.10.0
                gaDispPanel(nPanelIndex)\bEnableRelease = #False
                debugMsg(sProcName, "gaDispPanel(" + nPanelIndex + ")\bEnableRelease=#False")
              EndIf
            EndIf
            aCue(\nCueIndex)\nCuePanelUpdateFlags | #SCS_CUEPNL_PROGRESS | #SCS_CUEPNL_TRANSPORT
            debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\nCuePanelUpdateFlags=" + aCue(\nCueIndex)\nCuePanelUpdateFlags)
          EndIf
        EndWith
      EndIf
    Next h
    
  Else ; SM-S
    ;{
    With aAud(pAudPtr)
      If nLoopNo > 0
        l2 = nLoopNo - 1
      Else
        l2 = \nCurrLoopInfoIndex
      EndIf
      If (l2 >= 0) And (l2 <= \nMaxLoopInfo)
        \aLoopInfo(l2)\bLoopReleased = #True
        debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\aLoopInfo(" + l2 + ")\bLoopReleased=" + strB(aAud(pAudPtr)\aLoopInfo(l2)\bLoopReleased))
      EndIf
      If l2 = \nCurrLoopInfoIndex
        \rCurrLoopInfo\bLoopReleased = #True
        \nRelPassEnd = \nRelEndAt
        debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nRelPassEnd=" + \nRelPassEnd)
      EndIf
      sSMSCommand = "set chan " + \sSyncPChanList + " track"
      If l2 < \nMaxLoopInfo
        setTrackTimesCommandStrings(pAudPtr, #False, l2+1)
        sSMSCommand + grSMS\sTrackTimesCommandString
        If grSMS\sTrackRepeatOffCommandString
          sSMSRepeatOffCommand = "set chan " + \sSyncPChanList + " track repeat off"
        EndIf
      Else
        If Len(\sAltSyncPChanList) = 0
          sSMSCommand = sSMSCommand + " repeat off"
        EndIf
        If \nEndAt < 0
          sSMSCommand = sSMSCommand + " stop clear"
        ElseIf \qEndAtSamplePos > 0
          sSMSCommand = sSMSCommand + " stop samples " + \qEndAtSamplePos
        Else
          sSMSCommand = sSMSCommand + " stop time " + makeSMSTimeString(\nAbsEndAt)
        EndIf
      EndIf
      If sSMSRepeatOffCommand
        sendSMSCommand(sSMSRepeatOffCommand)
        ; Delay(100)
      EndIf
      sendSMSCommand(sSMSCommand)
      If \sAltSyncPChanList
        sSMSCommand = "set chan " + \sAltSyncPChanList + " track"
        If l2 < \nMaxLoopInfo
          sSMSCommand + grSMS\sAltTrackTimesCommandString
        Else
          If \nEndAt < 0
            sSMSCommand = sSMSCommand + " stop clear"
          ElseIf \qEndAtSamplePos > 0
            sSMSCommand = sSMSCommand + " stop samples " + \qEndAtSamplePos
          Else
            sSMSCommand = sSMSCommand + " stop time " + makeSMSTimeString(\nAbsEndAt)
          EndIf
        EndIf
        sendSMSCommand(sSMSCommand)
        nPanelIndex = getPanelIndexForAud(pAudPtr)
        debugMsg(sProcName, \sAudLabel + ", nPanelIndex=" + nPanelIndex)
        If nPanelIndex >= 0 And aAud(pAudPtr)\nCurrLoopInfoIndex >= aAud(pAudPtr)\nMaxLoopInfo ; Added nCurrLoopInfoIndex test 6Jan2024 11.10.0
          gaDispPanel(nPanelIndex)\bEnableRelease = #False
        EndIf
        aCue(\nCueIndex)\nCuePanelUpdateFlags | #SCS_CUEPNL_PROGRESS | #SCS_CUEPNL_TRANSPORT
        debugMsg(sProcName, "aCue(" + getCueLabel(\nCueIndex) + ")\nCuePanelUpdateFlags=" + aCue(\nCueIndex)\nCuePanelUpdateFlags)
      EndIf
    EndWith
    ;}
  EndIf
  
  aAud(pAudPtr)\bIgnoreInStatusCheck = bHoldIgnoreInStatusCheck
  ; Added 6Jan2024 11.10.0
  If nEditAudPtr = pAudPtr
    If IsGadget(WQF\btnEditRelease)
      WQF_setReleaseBtnState()
    EndIf
  EndIf
  ; End added 6Jan2024 11.10.0
  gbInReleaseAudLoop = #False
  
  gnSuspendGetCurrInfo - 1
  
EndProcedure

Procedure LoopSyncProcStart(Handle.l, channel.l, nData, user)
  Protected bLockedMutex
  LockCueListMutex(501) ; Lock mutex BEFORE calling decodeHandle()
  PROCNAME("LoopSyncProcStart handle=" + decodeHandle(Handle) + ", channel=" + decodeHandle(channel) + ", user=" + user + ", l2=" + gaLoopSync(user)\nLoopInfoIndex)

  ;========================================
  ; no system calls in callback procedures!
  ;========================================

  Protected nAudPtr, d
  Protected nBassResult.l
  Protected nChannel.l, nAltChannel.l
  Protected nSourceChannel.l, nSourceAltChannel.l, nFirstSplitterChannel.l
  Protected nLoopSyncIndex
  Protected h, nTmpAudPtr, nCurrLoopInfoIndex
  Protected nStartDev, nEndDev
  Protected qChannelPos.q, nChannelActive.l
  
  ; debugMsg3_S(sProcName, #SCS_START)
  
  nLoopSyncIndex = user
  
  If nLoopSyncIndex >= 0
    nAudPtr = gaLoopSync(nLoopSyncIndex)\nAudPtr
    
    With aAud(nAudPtr)
      If \nAudState < #SCS_CUE_FADING_IN Or \nAudState > #SCS_CUE_FADING_OUT
        debugMsg3_S(sProcName, "setting bQuitPlaying=#True because aAud(" + getAudLabel(nAudPtr) + ")\nAudState=" + decodeCueState(\nAudState))
        UnlockCueListMutex()
        ProcedureReturn
      EndIf
      
      nStartDev = \nFirstSoundingDev
      nEndDev = \nLastSoundingDev
      For d = nStartDev To nEndDev
        If channel = \nBassAltChannel[d]
          debugMsg3_S(sProcName, "exiting because " + decodeHandle(channel) + " is an ALT channel")
          UnlockCueListMutex()
          ProcedureReturn
        EndIf
      Next d
    EndWith
    
    ; debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\nAudLinkCount=" + aAud(nAudPtr)\nAudLinkCount)
    For h = 0 To aAud(nAudPtr)\nMaxAudSetPtr2
      ; debugMsg(sProcName, "h=" + h)
      ; debugMsg(sProcName, "gaAudSet(" + getAudLabel(nAudPtr) + ", " + h + ")=" + getAudLabel(gaAudSet(nAudPtr, h)))
      nTmpAudPtr = gaAudSet(nAudPtr, h)
      If nTmpAudPtr > 0
        With aAud(nTmpAudPtr)
          ; set position to LS for each device channel
          For d = \nFirstSoundingDev To \nLastSoundingDev
            nAltChannel = \nBassAltChannel[d]
            If nAltChannel <> 0
              If gbUseBASSMixer
                If \bUsingSplitStream
                  If d = \nFirstSoundingDev
                    nSourceAltChannel = \nSourceAltChannel
                    qChannelPos = BASS_ChannelGetPosition(nSourceAltChannel, #BASS_POS_BYTE)
                    ; Added 25Nov2022 11.9.7am
                    If qChannelPos = -1
                      debugMsg(sProcName, "BASS_ChannelGetPosition(" + decodeHandle(nSourceAltChannel) + ", BASS_POS_BYTE) returned " + qChannelPos)
                      debugMsg(sProcName, "Error " + BASS_ErrorGetCode() + ": " + getBassErrorDesc(BASS_ErrorGetCode()))
                      qChannelPos = 0
                    EndIf
                    ; End added 25Nov2022 11.9.7am
                    If \rCurrLoopInfo\qBassLoopStartByte <> qChannelPos
                      nBassResult = BASS_ChannelSetPosition(nSourceAltChannel, \rCurrLoopInfo\qBassLoopStartByte, #BASS_POS_BYTE)
                      ; debugMsg2_S(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nSourceAltChannel) + ", " + \rCurrLoopInfo\qBassLoopStartByte + ", BASS_POS_BYTE)", nBassResult)
                      nBassResult = BASS_Split_StreamReset(nSourceAltChannel)  ; reset buffers of all the source's splitters
                      ; debugMsg2_S(sProcName, "BASS_Split_StreamReset(" + decodeHandle(nSourceAltChannel) + ")", nBassResult)
                    EndIf
                  EndIf
                Else
                  qChannelPos = BASS_ChannelGetPosition(nAltChannel, #BASS_POS_BYTE)
                  ; Added 25Nov2022 11.9.7am
                  If qChannelPos = -1
                    debugMsg(sProcName, "BASS_ChannelGetPosition(" + decodeHandle(nAltChannel) + ", BASS_POS_BYTE) returned " + qChannelPos)
                    debugMsg(sProcName, "Error " + BASS_ErrorGetCode() + ": " + getBassErrorDesc(BASS_ErrorGetCode()))
                    qChannelPos = 0
                  EndIf
                  ; End added 25Nov2022 11.9.7am
                  If \rCurrLoopInfo\qBassLoopStartByte <> qChannelPos
                    nBassResult = BASS_Mixer_ChannelSetPosition(nAltChannel, \rCurrLoopInfo\qBassLoopStartByte, #BASS_POS_BYTE)
                    ; debugMsg2_S(sProcName, "BASS_Mixer_ChannelSetPosition(" + decodeHandle(nAltChannel) + ", " + \rCurrLoopInfo\qBassLoopStartByte + ", BASS_POS_BYTE)", nBassResult)
                    nBassResult = BASS_ChannelUpdate(nAltChannel, 0)
                    ; debugMsg2_S(sProcName, "BASS_ChannelUpdate(" + decodeHandle(nAltChannel) + ", 0)", nBassResult)
                    ; nb BASS_ChannelUpdate(nAltChannel, 0) will fail with 'notavail' if nAltChannel is a decoding channel - haven't inclued a test for 'decoding channel' yet
                    If nBassResult = #BASSFALSE
                      debugMsg3_S(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                    EndIf
                  EndIf
                EndIf
              Else
                If \bUsingSplitStream
                  If d = \nFirstSoundingDev
                    nSourceAltChannel = \nSourceAltChannel
                    qChannelPos = BASS_ChannelGetPosition(nSourceAltChannel, #BASS_POS_BYTE)
                    ; Added 25Nov2022 11.9.7am
                    If qChannelPos = -1
                      debugMsg(sProcName, "Error " + BASS_ErrorGetCode() + ": " + getBassErrorDesc(BASS_ErrorGetCode()))
                      qChannelPos = 0
                    EndIf
                    ; End added 25Nov2022 11.9.7am
                    If \rCurrLoopInfo\qBassLoopStartByte <> qChannelPos
                      nFirstSplitterChannel = \nBassAltChannel[\nFirstSoundingDev]
                      nChannelActive = BASS_ChannelIsActive(nFirstSplitterChannel)
                      If nChannelActive <> #BASS_ACTIVE_PAUSED
                        nBassResult = BASS_ChannelPause(nFirstSplitterChannel) ; pause splitter streams (so that resumption following seek can be synchronized)
                        ; debugMsg2_S(sProcName, "BASS_ChannelPause(" + decodeHandle(nFirstSplitterChannel) + ")", nBassResult)
                      EndIf
                      nBassResult = BASS_ChannelSetPosition(nSourceAltChannel, \rCurrLoopInfo\qBassLoopStartByte, #BASS_POS_BYTE)
                      ; debugMsg2_S(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nSourceAltChannel) + ", " + \rCurrLoopInfo\qBassLoopStartByte + ", BASS_POS_BYTE)", nBassResult)
                      nBassResult = BASS_Split_StreamReset(nSourceAltChannel)  ; reset buffers of all the source's splitters
                      ; debugMsg2_S(sProcName, "BASS_Split_StreamReset(" + decodeHandle(nSourceAltChannel) + ")", nBassResult)
                    EndIf
                  EndIf
                Else
                  qChannelPos = BASS_ChannelGetPosition(nAltChannel, #BASS_POS_BYTE)
                  ; Added 25Nov2022 11.9.7am
                  If qChannelPos = -1
                    debugMsg(sProcName, "Error " + BASS_ErrorGetCode() + ": " + getBassErrorDesc(BASS_ErrorGetCode()))
                    qChannelPos = 0
                  EndIf
                  ; End added 25Nov2022 11.9.7am
                  If \rCurrLoopInfo\qBassLoopStartByte <> qChannelPos
                    ; debugMsg(sProcName, "\rCurrLoopInfo\nLoopStart=" + \rCurrLoopInfo\nLoopStart + ", \nLoopEnd=" + \rCurrLoopInfo\nLoopEnd + ", \nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex)
                    nBassResult = BASS_ChannelSetPosition(nAltChannel, \rCurrLoopInfo\qBassLoopStartByte, #BASS_POS_BYTE)
                    ; debugMsg2_S(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nAltChannel) + ", " + \rCurrLoopInfo\qBassLoopStartByte + ", BASS_POS_BYTE)", nBassResult)
                    nBassResult = BASS_ChannelUpdate(nAltChannel, 0)
                    ; debugMsg2_S(sProcName, "BASS_ChannelUpdate(" + decodeHandle(nAltChannel) + ", 0)", nBassResult)
                    ; nb BASS_ChannelUpdate(nAltChannel, 0) will fail with 'notavail' if nAltChannel is a decoding channel - haven't inclued a test for 'decoding channel' yet
                    If nBassResult = #BASSFALSE
                      debugMsg3_S(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                    EndIf
                  EndIf
                EndIf
              EndIf
            EndIf
          Next d
          
          ; debugMsg(sProcName, "calling getCurrLoopInfoIndexAndSetLoopReleasedIndsIfReqd(" + getAudLabel(nTmpAudPtr) + ", " + Str(\nRelFilePos+1) + ", #True, #False)")
          nCurrLoopInfoIndex = getCurrLoopInfoIndexAndSetLoopReleasedIndsIfReqd(nTmpAudPtr, \nRelFilePos+1, #True, #False) ; Added 2Feb2022 11.9.0rc7
          
          If \bRAISendSetPos = #False
            \bRAISendSetPos = #True
            grRAI\nSendSetPosCount + 1
          EndIf
          
          ; Added 11Jan2025 11.10.6-b03
          If \nMaxCueMarker >= 0
            debugMsg(sProcName, "calling samAddRequest(#SCS_SAM_LOAD_OCM_CUES, " + getAudLabel(nTmpAudPtr) + ", 0, " + \rCurrLoopInfo\nAbsLoopStart + ")")
            samAddRequest(#SCS_SAM_LOAD_OCM_CUES, nTmpAudPtr, 0, \rCurrLoopInfo\nAbsLoopStart)
          EndIf
          ; End added 11Jan2025 11.10.6-b03
          
        EndWith
      EndIf
    Next h
    
  EndIf
  
  UnlockCueListMutex()
  ; debugMsg3_S(sProcName, #SCS_END)
  
EndProcedure

Procedure LoopSyncProcMixTime(Handle.l, channel.l, nData, user)
  Protected bLockedMutex
  LockCueListMutex(502) ; Lock mutex BEFORE calling decodeHandle()
  PROCNAME("LoopSyncProcMixTime handle=" + decodeHandle(Handle) + ", channel=" + decodeHandle(channel) + ", user=" + user + ", l2=" + gaLoopSync(user)\nLoopInfoIndex)
  
  ;========================================
  ; no system calls in callback procedures!
  ;========================================
  
  Protected nAudPtr, d ;, l2
  Protected rMyLoopSync.tyLoopSync
  Protected fCurrLevel.f
  Protected nBassResult.l, nPanelIndex, fVolume.f
  Protected nChannel.l
  Protected nSourceChannel.l, nFirstSplitterChannel.l
  Protected nLoopSyncIndex
  Protected bExitNow
  Protected h, nTmpAudPtr
  Protected nTmpSubPtr, j, nReqdMTCPos
  Protected bQuitPlaying
  Protected dAbsLoopStart.d
  Protected qBassLoopStartByte.q
  
  ; debugMsg3_S(sProcName, #SCS_START)
  
  nLoopSyncIndex = user
  
  If nLoopSyncIndex >= 0
    rMyLoopSync = gaLoopSync(nLoopSyncIndex)
    nAudPtr = rMyLoopSync\nAudPtr
    ; l2 = rMyLoopSync\nLoopInfoIndex
    
    With aAud(nAudPtr)
      If \nAudState < #SCS_CUE_FADING_IN Or \nAudState > #SCS_CUE_FADING_OUT
        ; debugMsg3_S(sProcName, "exiting because aAud(" + getAudLabel(nAudPtr) + ")\nAudState=" + decodeCueState(\nAudState))
        UnlockCueListMutex()
        ProcedureReturn
      EndIf
;       debugMsg_S(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex + ", \rCurrLoopInfo\nRelLoopEnd=" + \rCurrLoopInfo\nRelLoopEnd +
;                           ", \rCurrLoopInfo\bLoopReleased=" + strB(\rCurrLoopInfo\bLoopReleased))
      If \rCurrLoopInfo\bLoopReleased
        ; removeAudChannelLoopSyncs(nAudPtr)
        ; Added 1Feb2022 11.9.0rc7
        ; debugMsg_S(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\nMaxLoopInfo=" + \nMaxLoopInfo + ", \nAbsEndAt=" + \nAbsEndAt + ", \rCurrLoopInfo\nAbsLoopEnd=" + \rCurrLoopInfo\nAbsLoopEnd)
        If \nMaxLoopInfo < 0 And \nAbsEndAt <= \rCurrLoopInfo\nAbsLoopEnd
          nSourceChannel = \nSourceChannel
          If nSourceChannel <> 0
            fVolume = #SCS_MINVOLUME_SINGLE
            nBassResult = BASS_ChannelSetAttribute(nSourceChannel, #BASS_ATTRIB_VOL, fVolume)
            ; debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nSourceChannel) + ", #BASS_ATTRIB_VOL, " + StrF(fVolume) + ")", nBassResult)
          EndIf
        EndIf
        ; End added 1Feb2022 11.9.0rc7
        ; save gaLoopSync changes
        gaLoopSync(nLoopSyncIndex) = rMyLoopSync
        ; debugMsg_S(sProcName, "calling loadCurrLoopInfo(" + getAudLabel(nAudPtr) + ", " + Str(aAud(nAudPtr)\rCurrLoopInfo\nRelLoopEnd + 1) + ")")
        loadCurrLoopInfo(nAudPtr, aAud(nAudPtr)\rCurrLoopInfo\nRelLoopEnd + 1)
        ; debugMsg_S(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex + ", \rCurrLoopInfo\nRelLoopEnd=" + \rCurrLoopInfo\nRelLoopEnd +
        ;                     ", \rCurrLoopInfo\bLoopReleased=" + strB(\rCurrLoopInfo\bLoopReleased))
        UnlockCueListMutex()
        ProcedureReturn
      EndIf
      
      rMyLoopSync\nLoopSyncPassNo + 1
      ; debugMsg_S(sProcName, "rMyLoopSync\nLoopSyncPassesReqd=" + rMyLoopSync\nLoopSyncPassesReqd + ", rMyLoopSync\nLoopSyncPassNo=" + rMyLoopSync\nLoopSyncPassNo)
      If rMyLoopSync\nLoopSyncPassesReqd > 0
        If rMyLoopSync\nLoopSyncPassNo > rMyLoopSync\nLoopSyncPassesReqd
          For h = 0 To aAud(nAudPtr)\nMaxAudSetPtr2
            nTmpAudPtr = gaAudSet(nAudPtr, h)
            If nTmpAudPtr > 0
              aAud(nTmpAudPtr)\rCurrLoopInfo\bLoopReleased = #True
              debugMsg_S(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\rCurrLoopInfo\bLoopReleased=" + strB(aAud(nTmpAudPtr)\rCurrLoopInfo\bLoopReleased) + ", aAud(" + getAudLabel(nTmpAudPtr) + ")\nCurrLoopInfoIndex=" + aAud(nTmpAudPtr)\nCurrLoopInfoIndex)
              nPanelIndex = getPanelIndexForAud(nTmpAudPtr)
              If nPanelIndex >= 0 And aAud(nTmpAudPtr)\nCurrLoopInfoIndex >= aAud(nTmpAudPtr)\nMaxLoopInfo ; Added nCurrLoopInfoIndex test 6Jan2024 11.10.0
                gaDispPanel(nPanelIndex)\bEnableRelease = #False
              EndIf
              ; Added 3Feb2022 11.9.0rc7
              nSourceChannel = aAud(nTmpAudPtr)\nSourceChannel
              If nSourceChannel <> 0
                fVolume = #SCS_MINVOLUME_SINGLE
                nBassResult = BASS_ChannelSetAttribute(nSourceChannel, #BASS_ATTRIB_VOL, fVolume)
                ; debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nSourceChannel) + ", #BASS_ATTRIB_VOL, " + StrF(fVolume) + ")", nBassResult)
              EndIf
              ; End added 3Feb2022 11.9.0rc7
            EndIf
          Next h
          ; debugMsg_S(sProcName, "calling samAddRequest(#SCS_SAM_RELEASE_LOOP, " + getAudLabel(nAudPtr) + ")")
          samAddRequest(#SCS_SAM_RELEASE_LOOP, nAudPtr) ; add request to formally release this loop
        EndIf
      EndIf
      
      If \rCurrLoopInfo\bLoopReleased
        ; no further action if loop released
        gaLoopSync(nLoopSyncIndex) = rMyLoopSync ; save changes
        UnlockCueListMutex()
        ProcedureReturn
      EndIf
      
    EndWith
    
    dAbsLoopStart = aAud(nAudPtr)\rCurrLoopInfo\nAbsLoopStart / 1000
;     If aAud(nAudPtr)\nAudLinkCount > 0
;       debugMsg3(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\nAudLinkCount=" + aAud(nAudPtr)\nAudLinkCount)
;     EndIf
    For h = 0 To aAud(nAudPtr)\nMaxAudSetPtr2
      nTmpAudPtr = gaAudSet(nAudPtr, h)
      ; debugMsg3_S(sProcName, "nTmpAudPtr=" + getAudLabel(nTmpAudPtr))
      If nTmpAudPtr > 0
        With aAud(nTmpAudPtr)
          nSourceChannel = \nSourceChannel
          If nSourceChannel <> 0
;             debugMsg_S(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nMaxLoopInfo=" + \nMaxLoopInfo + ", \nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex +
;                                   ", \rCurrLoopInfo\nAbsLoopStart=" + \rCurrLoopInfo\nAbsLoopStart + ", \rCurrLoopInfo\qBassLoopStartByte=" + \rCurrLoopInfo\qBassLoopStartByte +
;                                   ", dAbsLoopStart=" + StrD(dAbsLoopStart,4))
            If \nMaxLoopInfo >= 0
              qBassLoopStartByte = \rCurrLoopInfo\qBassLoopStartByte
            Else
              qBassLoopStartByte = BASS_ChannelSeconds2Bytes(nSourceChannel, dAbsLoopStart)
            EndIf
            nBassResult = BASS_ChannelSetPosition(nSourceChannel, qBassLoopStartByte, #BASS_POS_BYTE)
            ; debugMsg2_S(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nSourceChannel) + ", " + qBassLoopStartByte + ", BASS_POS_BYTE)", nBassResult)
            ; added 19May2017 11.6.2aa following email from Jonathan Delson about looping cue not looping
            ; it seems that if looping position is eof then the channel is stopped - although this didn't happen in 11.5.3 (don't know why the difference)
            nBassResult = BASS_ChannelIsActive(nSourceChannel)
            ; debugMsg2_S(sProcName, "BASS_ChannelIsActive(" + decodeHandle(nSourceChannel) + ")", nBassResult)
            If nBassResult <> #BASS_ACTIVE_PLAYING
              nBassResult = BASS_ChannelPlay(nSourceChannel, #BASSFALSE)
              ; debugMsg2_S(sProcName, "BASS_ChannelPlay(" + decodeHandle(nSourceChannel) + ", #BASSFALSE)", nBassResult)
              If nBassResult = #BASSFALSE
                debugMsg3_S(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
              EndIf
            EndIf
            ; end added 19May2017 11.6.2aa
            ; added 7Sep2016 11.5.2
            nTmpSubPtr = \nSubIndex
            If aSub(nTmpSubPtr)\bStartedInEditor = #False
              If aSub(nTmpSubPtr)\bSubTypeF
                If aSub(nTmpSubPtr)\nAFLinkedToMTCSubPtr >= 0
                  j = aSub(nTmpSubPtr)\nAFLinkedToMTCSubPtr
                  If aSub(j)\bSubTypeU
                    If aSub(j)\nMTCLinkedToAFSubPtr = nTmpSubPtr And aSub(j)\bSubEnabled
                      nReqdMTCPos = \rCurrLoopInfo\nAbsLoopStart - \nAbsStartAt
                      debugMsg(sProcName, "calling reposTimeCode(" + buildSubLabel(j) + ", " + nReqdMTCPos + ")")
                      reposTimeCode(j, nReqdMTCPos)
                    EndIf
                  EndIf ; EndIf aSub(j)\bSubTypeU
                EndIf   ; EndIf aSub(nTmpSubPtr)\nAFLinkedToMTCSubPtr >= 0
              EndIf     ; EndIf aSub(nTmpSubPtr)\bSubTypeF
            EndIf       ; EndIf aSub(nTmpSubPtr)\bStartedInEditor = #False
            ; end added 7Sep2016 11.5.2
            If \bRAISendSetPos = #False
              \bRAISendSetPos = #True
              grRAI\nSendSetPosCount + 1
            EndIf
          EndIf
        EndWith
      EndIf
    Next h
    
    ; save gaLoopSync changes
    gaLoopSync(nLoopSyncIndex) = rMyLoopSync
    
  EndIf
  UnlockCueListMutex()
  ; debugMsg3_S(sProcName, #SCS_END)
  
EndProcedure

Procedure LoopSyncProcHearBoth(Handle.l, channel.l, nData, user)
  Protected bLockedMutex
  LockCueListMutex(503) ; Lock mutex BEFORE calling decodeHandle()
  PROCNAME("LoopSyncProcHearBoth handle=" + decodeHandle(Handle) + ", channel=" + decodeHandle(channel) + ", user=" + user + ", l2=" + gaLoopSync(user)\nLoopInfoIndex)

  ;========================================
  ; no system calls in callback procedures!
  ;========================================

  ; this callback occurs when the loop crossfade is due to start

  Protected nAudPtr, d
  Protected rMyLoopSync.tyLoopSync
  Protected fCurrLevel.f
  Protected nBassResult.l, nPanelIndex
  Protected nFadeInTime, nFadeOutTime
  Protected nChannel.l, nAltChannel.l
  Protected nSourceChannel.l, nSourceAltChannel.l, nFirstSplitterChannel.l
  Protected nLoopSyncIndex, nCueMarkerIndex
  Protected bExitNow
  Protected nErrorCode.l
  Protected h, nTmpAudPtr
  Protected bQuitPlaying
  
  ; debugMsg3_S(sProcName, #SCS_START)
  
  nLoopSyncIndex = user
  
  If nLoopSyncIndex >= 0
    rMyLoopSync = gaLoopSync(nLoopSyncIndex)
    nAudPtr = rMyLoopSync\nAudPtr
    
    With aAud(nAudPtr)
      If \nAudState < #SCS_CUE_FADING_IN Or \nAudState > #SCS_CUE_FADING_OUT
        debugMsg3_S(sProcName, "setting bQuitPlaying=#True because aAud(" + getAudLabel(nAudPtr) + ")\nAudState=" + decodeCueState(\nAudState))
        ; 10/10/2014 11.3.4t: bQuitPlaying added because it appears that with ASIO (using BASS) it's possible for playback to continue if the cue is stopped
        ; during a crossfade (email from C.Peters 09/10/2014) - probably due to pre-buffering in the ASIO callback procedure
        bQuitPlaying = #True
        UnlockCueListMutex()
        ProcedureReturn
      EndIf
      
      For d = \nFirstSoundingDev To \nLastSoundingDev
        If channel = \nBassAltChannel[d]
          bExitNow = #True
          Break
        EndIf
      Next d
    EndWith
    If bExitNow
      UnlockCueListMutex()
      ProcedureReturn
    EndIf
    
    If aAud(nAudPtr)\rCurrLoopInfo\bLoopReleased
      debugMsg_S(sProcName, "calling removeAudChannelLoopSyncs(" + getAudLabel(nAudPtr) + ", " + strB(rMyLoopSync\bSwapped) + ")")
      removeAudChannelLoopSyncs(nAudPtr, rMyLoopSync\bSwapped)
      ; save gaLoopSync changes
      rMyLoopSync\bInXfade = #False
      gaLoopSync(nLoopSyncIndex) = rMyLoopSync
      aAud(nAudPtr)\bInLoopXFade = #False
      debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\bInLoopXFade=" + strB(aAud(nAudPtr)\bInLoopXFade))
      UnlockCueListMutex()
      ProcedureReturn
    EndIf
    
    rMyLoopSync\nLoopSyncPassNo + 1
    If rMyLoopSync\nLoopSyncPassesReqd > 0
      If rMyLoopSync\nLoopSyncPassNo > rMyLoopSync\nLoopSyncPassesReqd
        For h = 0 To (aAud(nAudPtr)\nAudLinkCount - 1) ; Added "- 1" 16Mar2023 11.10.0ak
          nTmpAudPtr = gaAudSet(nAudPtr, h)
          If nTmpAudPtr > 0
            aAud(nTmpAudPtr)\rCurrLoopInfo\bLoopReleased = #True
            debugMsg_S(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\rCurrLoopInfo\bLoopReleased=" + strB(aAud(nTmpAudPtr)\rCurrLoopInfo\bLoopReleased) + ", aAud(" + getAudLabel(nTmpAudPtr) + ")\nCurrLoopInfoIndex=" + aAud(nTmpAudPtr)\nCurrLoopInfoIndex)
            nPanelIndex = getPanelIndexForAud(nTmpAudPtr)
            If nPanelIndex >= 0 And aAud(nTmpAudPtr)\nCurrLoopInfoIndex >= aAud(nTmpAudPtr)\nMaxLoopInfo ; Added nCurrLoopInfoIndex test 6Jan2024 11.10.0
              gaDispPanel(nPanelIndex)\bEnableRelease = #False
            EndIf
          EndIf
        Next h
        If bQuitPlaying = #False
          debugMsg_S(sProcName, "calling samAddRequest(#SCS_SAM_RELEASE_LOOP, " + getAudLabel(nAudPtr) + ")")
          samAddRequest(#SCS_SAM_RELEASE_LOOP, nAudPtr) ; add request to formally release this loop
        EndIf
      EndIf
    EndIf
    
    nFadeInTime = rMyLoopSync\nLoopXFadeTime
    If rMyLoopSync\nLoopXFadeTime > 0
      nFadeOutTime = rMyLoopSync\nLoopXFadeTime
    Else
      nFadeOutTime = 0
    EndIf
    
    If aAud(nAudPtr)\rCurrLoopInfo\bLoopReleased
      ; no further action if loop released
      gaLoopSync(nLoopSyncIndex) = rMyLoopSync ; save changes
      UnlockCueListMutex()
      ProcedureReturn
    EndIf
    
    rMyLoopSync\bInXfade = #True
    
    For h = 0 To aAud(nAudPtr)\nMaxAudSetPtr2
      nTmpAudPtr = gaAudSet(nAudPtr, h)
      If nTmpAudPtr > 0
        With aAud(nTmpAudPtr)
          \bInLoopXFade = #True
          debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\bInLoopXFade=" + strB(aAud(nTmpAudPtr)\bInLoopXFade))
          ; for each device channel...
          For d = \nFirstSoundingDev To \nLastSoundingDev
            nChannel = \nBassChannel[d]
            nAltChannel = \nBassAltChannel[d]
            If nChannel <> 0
              ; get current level of channel
              nBassResult = BASS_ChannelGetAttribute(nChannel, #BASS_ATTRIB_VOL, @fCurrLevel)
              ;debugMsg2_S(sProcName, "BASS_ChannelGetAttribute(" & nChannel & ", BASS_ATTRIB_VOL, fCurrLevel)  fCurrLevel=" & formatLevel(fCurrLevel), nBassResult)
              \fBVLevelAtLoopEnd[d] = fCurrLevel ; keep current level in case needed for loop release
            EndIf
            
          Next d
          
          If bQuitPlaying = #False
            ; start altchannel
            If gbUseBASSMixer
              ; remove pause flags on alt channel(s)
              For d = \nFirstSoundingDev To \nLastSoundingDev
                nAltChannel = \nBassAltChannel[d]
                If nAltChannel <> 0
                  nBassResult = BASS_Mixer_ChannelFlags(nAltChannel, 0, #BASS_MIXER_CHAN_PAUSE)   ; remove pause flag
                  debugMsg3_S(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(nAltChannel) + ", 0, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
                EndIf
              Next d
            Else
              If \bUsingSplitStream
                For d = \nFirstSoundingDev To \nLastSoundingDev
                  nAltChannel = \nBassAltChannel[d]
                  If nAltChannel <> 0
                    nBassResult = BASS_ChannelSetAttribute(nAltChannel, #BASS_ATTRIB_VOL, #SCS_MINVOLUME_SINGLE)
                    ; debugMsg2_S(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nAltChannel) + ", BASS_ATTRIB_VOL, SCS_MINVOLUME_SINGLE)", nBassResult)
                  EndIf
                Next d
                nFirstSplitterChannel = \nBassAltChannel[\nFirstSoundingDev]
                nSourceAltChannel = \nSourceAltChannel
                nBassResult = BASS_ChannelPlay(nFirstSplitterChannel, #BASSFALSE)
                debugMsg2_S(sProcName, "(c1) BASS_ChannelPlay(" + decodeHandle(nFirstSplitterChannel) + ", #BASSFALSE)", nBassResult)
                If nBassResult = #BASSFALSE
                  debugMsg3_S(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                EndIf
              Else
                For d = \nFirstSoundingDev To \nLastSoundingDev
                  nAltChannel = \nBassAltChannel[d]
                  If nAltChannel <> 0
                    nBassResult = BASS_ChannelPlay(nAltChannel, #BASSFALSE)
                    debugMsg2_S(sProcName, "BASS_ChannelPlay(" + decodeHandle(nAltChannel) + ", BASSFALSE)", nBassResult)
                    If nBassResult = #BASSFALSE
                      debugMsg3_S(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                    EndIf
                  EndIf
                Next d
              EndIf
            EndIf
            
            For d = \nFirstSoundingDev To \nLastSoundingDev
              nAltChannel = \nBassAltChannel[d]
              If nAltChannel <> 0
                ; Changed 28Sep2022 11.9.6
                If \fBVLevelAtLoopEnd[d] <= grLevels\fMinBVLevel
                  nBassResult = BASS_ChannelSetAttribute(nAltChannel, #BASS_ATTRIB_VOL, 0.0)
                Else
                  nBassResult = BASS_ChannelSetAttribute(nAltChannel, #BASS_ATTRIB_VOL, \fBVLevelAtLoopEnd[d])
                EndIf
                ; End changed 28Sep2022 11.9.6
              EndIf
            Next d
            
            \qTimePassStarted = ElapsedMilliseconds()
            debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + "\qTimePassStarted=" + \qTimePassStarted)
            
          EndIf
          
          ; end of 'XFADE' coding
          ;
          ; =====================
          ;
          ; start of 'LE' coding
          
          For d = \nFirstSoundingDev To \nLastSoundingDev
            nChannel = \nBassChannel[d]
            If nChannel <> 0
              ; swap channel and altchannel
              \nBassChannel[d] = \nBassAltChannel[d]
              \nBassAltChannel[d] = nChannel
            EndIf
          Next d
          nSourceChannel = \nSourceChannel
          \nSourceChannel = \nSourceAltChannel
          \nSourceAltChannel = nSourceChannel
          
          ; swap channel and altchannel for triggering channel, in gaLoopSync
          rMyLoopSync\nChannel = rMyLoopSync\nAltChannel
          rMyLoopSync\nAltChannel = channel
          nSourceChannel = rMyLoopSync\nSourceChannel
          rMyLoopSync\nSourceChannel = rMyLoopSync\nSourceAltChannel
          rMyLoopSync\nSourceAltChannel = nSourceChannel
          If rMyLoopSync\bSwapped
            rMyLoopSync\bSwapped = #False
          Else
            rMyLoopSync\bSwapped = #True
          EndIf
          
          ; swap sync channels for cue markers
          For nCueMarkerIndex = 0 To \nMaxCueMarker
            Swap \aCueMarker(nCueMarkerIndex)\nBassMarkerSync, \aCueMarker(nCueMarkerIndex)\nBassMarkerAltSync
            Swap \aCueMarker(nCueMarkerIndex)\nBassMarkerSyncChannel, \aCueMarker(nCueMarkerIndex)\nBassMarkerAltSyncChannel
          Next nCueMarkerIndex
          
          ; settings for LE
          \nCuePosAtLoopStart + (\rCurrLoopInfo\nRelLoopEnd - \nRelPassStart)
          \nRelPassStart = \rCurrLoopInfo\nRelLoopStart
          \qTimeAudRestarted = \qTimePassStarted
          debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nCuePosAtLoopStart=" + \nCuePosAtLoopStart + ", \qTimeAudRestarted=" + traceTime(aAud(nTmpAudPtr)\qTimeAudRestarted))
          \nTotalTimeOnPause = 0
          \nPreFadeInTimeOnPause = 0
          \nPreFadeOutTimeOnPause = 0
          \nLoopPassNo + 1
          debugMsg0(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex + ", \nLoopPassNo=" + \nLoopPassNo)
          
          ;debugMsg3_S(sProcName, "Channels swapped")
          
          ; stop triggering channel (which will also stop linked channels)
          ;debugMsg3_S(sProcName, "Calling BASS_Mixer_ChannelFlags(" & channel & ", BASS_MIXER_CHAN_PAUSE, BASS_MIXER_CHAN_PAUSE)")
          If gbUseBASSMixer
            For d = \nFirstSoundingDev To \nLastSoundingDev
              nAltChannel = \nBassAltChannel[d]
              If nAltChannel <> 0
                nBassResult = BASS_Mixer_ChannelFlags(nAltChannel, #BASS_MIXER_CHAN_PAUSE, #BASS_MIXER_CHAN_PAUSE) ; set the pause flag
                debugMsg3_S(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(nAltChannel) + ", BASS_MIXER_CHAN_PAUSE, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
              EndIf
            Next d
            If \bUsingSplitStream
              If \nFirstSoundingDev >= 0
                nFirstSplitterChannel = \nBassAltChannel[\nFirstSoundingDev]
                nSourceAltChannel = \nSourceAltChannel
                nBassResult = BASS_ChannelSetPosition(nSourceAltChannel, \rCurrLoopInfo\qBassLoopStartByte, #BASS_POS_BYTE)
                debugMsg2_S(sProcName, "(c2) BASS_ChannelSetPosition(" + decodeHandle(nSourceAltChannel) + ", " + \rCurrLoopInfo\qBassLoopStartByte + ", BASS_POS_BYTE)", nBassResult)
                nBassResult = BASS_Split_StreamReset(nSourceAltChannel)  ; reset buffers of all the source's splitters
                debugMsg2_S(sProcName, "(c2) BASS_Split_StreamReset(" + decodeHandle(nSourceAltChannel) + ")", nBassResult)
                If nBassResult <> #BASSTRUE
                  nErrorCode = BASS_ErrorGetCode()
                  debugMsg3_S(sProcName, "(c2) BASS_Split_StreamReset Error=" + getBassErrorDesc(nErrorCode))
                EndIf
              EndIf
            EndIf
          Else
            If \bUsingSplitStream
              If \nFirstSoundingDev >= 0
                nFirstSplitterChannel = \nBassAltChannel[\nFirstSoundingDev]
                nSourceAltChannel = \nSourceAltChannel
                nBassResult = BASS_ChannelStop(nFirstSplitterChannel)
                debugMsg2_S(sProcName, "(c3) BASS_ChannelStop(" + decodeHandle(nFirstSplitterChannel) + ")", nBassResult)
                nBassResult = BASS_ChannelSetPosition(nSourceAltChannel, \rCurrLoopInfo\qBassLoopStartByte, #BASS_POS_BYTE)
                debugMsg2_S(sProcName, "(c3) BASS_ChannelSetPosition(" + decodeHandle(nSourceAltChannel) + ", " + \rCurrLoopInfo\qBassLoopStartByte + ", BASS_POS_BYTE)", nBassResult)
                nBassResult = BASS_Split_StreamReset(nSourceAltChannel)  ; reset buffers of all the source's splitters
                debugMsg2_S(sProcName, "(c3) BASS_Split_StreamReset(" + decodeHandle(nSourceAltChannel) + ")", nBassResult)
              EndIf
            Else
              For d = \nFirstSoundingDev To \nLastSoundingDev
                nAltChannel = \nBassAltChannel[d]
                If nAltChannel <> 0
                  nBassResult = BASS_ChannelStop(nAltChannel)
                  debugMsg2_S(sProcName, "BASS_ChannelStop(" + decodeHandle(nAltChannel) + ")", nBassResult)
                EndIf
              Next d
            EndIf
          EndIf
          
          If bQuitPlaying = #False
            ; set position to LS for each device channel
            For d = \nFirstSoundingDev To \nLastSoundingDev
              nAltChannel = \nBassAltChannel[d]
              If nAltChannel <> 0
                If gbUseBASSMixer
                  If \bUsingSplitStream
                    ; LS position already set - no further action required
                  Else
                    nBassResult = BASS_Mixer_ChannelSetPosition(nAltChannel, \rCurrLoopInfo\qBassLoopStartByte, #BASS_POS_BYTE)
                    debugMsg2_S(sProcName, "BASS_Mixer_ChannelSetPosition(" + decodeHandle(nAltChannel) + ", " + \rCurrLoopInfo\qBassLoopStartByte + ", BASS_POS_BYTE)", nBassResult)
                  EndIf
                Else
                  If \bUsingSplitStream
                    ; LS position already set - no further action required
                  Else
                    nBassResult = BASS_ChannelSetPosition(nAltChannel, \rCurrLoopInfo\qBassLoopStartByte, #BASS_POS_BYTE)
                    debugMsg2_S(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nAltChannel) + ", " + \rCurrLoopInfo\qBassLoopStartByte + ", BASS_POS_BYTE)", nBassResult)
                  EndIf
                EndIf
              EndIf
            Next d
          EndIf
          
          \bInLoopXFade = #False
          debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\bInLoopXFade=" + strB(\bInLoopXFade))
          
          If \bRAISendSetPos = #False
            \bRAISendSetPos = #True
            grRAI\nSendSetPosCount + 1
          EndIf

        EndWith
      EndIf
    Next h
    
    ; save gaLoopSync changes
    gaLoopSync(nLoopSyncIndex) = rMyLoopSync
    
  EndIf
  UnlockCueListMutex()
  debugMsg3_S(sProcName, #SCS_END)
  
EndProcedure

Procedure LoopSyncProcHearLE(Handle.l, channel.l, nData, user)
  Protected bLockedMutex
  LockCueListMutex(504) ; Lock mutex BEFORE calling decodeHandle()
  PROCNAME("LoopSyncProcHearLE handle=" + decodeHandle(Handle) + ", channel=" + decodeHandle(channel) + ", user=" + user + ", l2=" + gaLoopSync(user)\nLoopInfoIndex)
  
  ;========================================
  ; no system calls in callback procedures!
  ;========================================
  
  ; this callback occurs 100ms after the loop crossfade is due to end ???? (29Jan2022 11.9.0) not sure if that is correct - possibly was correct before #cSingleFileIfNoXFade was introduced
  
  Protected nAudPtr, d
  Protected rMyLoopSync.tyLoopSync
  Protected nBassResult.l, nStreamCreateFlags.l
  Protected nChannel.l, nAltChannel.l
  Protected nSourceChannel.l, nSourceAltChannel.l, nFirstSplitterChannel.l
  Protected nVSTHandle.l
  Protected nLoopSyncIndex, nCueMarkerIndex
  Protected bExitNow
  Protected nErrorCode.l
  Protected h, nTmpAudPtr
  Protected nStartDev, nEndDev, nStep
  
  ; debugMsg3_S(sProcName, #SCS_START)
  
  nLoopSyncIndex = user
  
  If nLoopSyncIndex >= 0
    rMyLoopSync = gaLoopSync(nLoopSyncIndex)
    nAudPtr = rMyLoopSync\nAudPtr
    
    With aAud(nAudPtr)
      If \nAudState < #SCS_CUE_FADING_IN Or \nAudState > #SCS_CUE_FADING_OUT
        debugMsg(sProcName, "Exiting because aAud(" + getAudLabel(nAudPtr) + ")\nAudState=" + decodeCueState(\nAudState))
        UnlockCueListMutex()
        ProcedureReturn
      EndIf
      
      If rMyLoopSync\bSwitchAtLE = #False
        nStartDev = \nFirstSoundingDev
        nEndDev = \nLastSoundingDev
        nStep = 1
        rMyLoopSync\bSwitchAtLE = #True
      Else
        nStartDev = \nLastSoundingDev
        nEndDev = \nFirstSoundingDev
        nStep = -1
        rMyLoopSync\bSwitchAtLE = #False
      EndIf
      d = nStartDev
      Repeat
        If channel = \nBassAltChannel[d]
          debugMsg3_S(sProcName, "LoopSyncProcHearLE exiting because " + decodeHandle(channel) + " is an ALT channel")
          bExitNow = #True
          Break
        EndIf
        If d = nEndDev
          Break
        EndIf
        d + nStep
      ForEver
      If bExitNow
        UnlockCueListMutex()
        ProcedureReturn
      EndIf
      
      If aAud(nAudPtr)\rCurrLoopInfo\bLoopReleased
        ; removeAudChannelLoopSyncs(nAudPtr, rMyLoopSync\bSwapped)
        ; save gaLoopSync changes
        rMyLoopSync\bInXfade = #False
        gaLoopSync(nLoopSyncIndex) = rMyLoopSync
        aAud(nAudPtr)\bInLoopXFade = #False
        debugMsg_S(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\bInLoopXFade=" + strB(aAud(nAudPtr)\bInLoopXFade))
        debugMsg_S(sProcName, "calling loadCurrLoopInfo(" + getAudLabel(nAudPtr) + ", " + Str(aAud(nAudPtr)\rCurrLoopInfo\nRelLoopEnd + 1) + ")")
        loadCurrLoopInfo(nAudPtr, aAud(nAudPtr)\rCurrLoopInfo\nRelLoopEnd + 1)
        debugMsg_S(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex + ", \rCurrLoopInfo\nRelLoopEnd=" + \rCurrLoopInfo\nRelLoopEnd +
                              ", \rCurrLoopInfo\bLoopReleased=" + strB(\rCurrLoopInfo\bLoopReleased))
        UnlockCueListMutex()
        ProcedureReturn
      EndIf
    EndWith
    
    For h = 0 To aAud(nAudPtr)\nMaxAudSetPtr2
      nTmpAudPtr = gaAudSet(nAudPtr, h)
      If nTmpAudPtr > 0
        With aAud(nTmpAudPtr)
          ;debugMsg3_S(sProcName, .sAudLabel)
          
          For d = \nFirstSoundingDev To \nLastSoundingDev
            nChannel = \nBassChannel[d]
            If nChannel <> 0
              ; swap channel and altchannel
              \nBassChannel[d] = \nBassAltChannel[d]
              \nBassAltChannel[d] = nChannel
            EndIf
          Next d
          nSourceChannel = \nSourceChannel
          \nSourceChannel = \nSourceAltChannel
          \nSourceAltChannel = nSourceChannel
          nVSTHandle = \nVSTHandle
          \nVSTHandle = \nVSTAltHandle
          \nVSTAltHandle = nVSTHandle
          
          If nTmpAudPtr = nAudPtr
            ; swap channel and altchannel for triggering channel, in gaLoopSync
            rMyLoopSync\nChannel = rMyLoopSync\nAltChannel
            rMyLoopSync\nAltChannel = channel
            If rMyLoopSync\bSwapped
              rMyLoopSync\bSwapped = #False
            Else
              rMyLoopSync\bSwapped = #True
            EndIf
          EndIf
          
          ; swap sync channels for cue markers
          For nCueMarkerIndex = 0 To \nMaxCueMarker
            Swap \aCueMarker(nCueMarkerIndex)\nBassMarkerSync, \aCueMarker(nCueMarkerIndex)\nBassMarkerAltSync
            Swap \aCueMarker(nCueMarkerIndex)\nBassMarkerSyncChannel, \aCueMarker(nCueMarkerIndex)\nBassMarkerAltSyncChannel
          Next nCueMarkerIndex
          
          ; settings for LE
          \nCuePosAtLoopStart + (\rCurrLoopInfo\nRelLoopEnd - \nRelPassStart)
          \nRelPassStart = \rCurrLoopInfo\nRelLoopStart
          \qTimeAudRestarted = \qTimePassStarted
          debugMsg_S(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nCuePosAtLoopStart=" + \nCuePosAtLoopStart + ", \qTimeAudRestarted=" + traceTime(aAud(nTmpAudPtr)\qTimeAudRestarted))
          \nTotalTimeOnPause = 0
          \nPreFadeInTimeOnPause = 0
          \nPreFadeOutTimeOnPause = 0
          CompilerIf 1=2  ; bypassed 25May2018 11.7.1ar because "\nLoopPassNo + 1" is also set in StatusCheck() under label 2075, and performing this twice caused \nLoopPassNo to be incremented twice
            ; This "CompilerIf" had been commented out in SCS 11.9.0 (don't know why) but reinstated 28Apr2022 11.9.1bd following tests of "Loop Test 3.scs11".
            ; Note that this procedure (LoopSyncProcHearLE) is only used for XFade loops, so the original file is opened twice.
            \nLoopPassNo + 1
            debugMsg0(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex + ", \nLoopPassNo=" + \nLoopPassNo)
            ; debugMsg_S(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex + ", \nLoopPassNo=" + \nLoopPassNo)
          CompilerEndIf
          
          ;debugMsg3_S(sProcName, "Channels swapped")
          
          ; stop triggering channel (which will also stop linked channels)
          If gbUseBASSMixer
            ; If nTmpAudPtr = nAudPtr   ; commented out this test 14Sep2017 11.7.0 following test of linked audio files with xfade loops - problem reported by Lars Stokdijk 8Sep2017 and earlier
            d = nStartDev
            Repeat
              nAltChannel = \nBassAltChannel[d]
              If nAltChannel <> 0
                nBassResult = BASS_Mixer_ChannelFlags(nAltChannel, #BASS_MIXER_CHAN_PAUSE, #BASS_MIXER_CHAN_PAUSE) ; set the pause flag
                debugMsg3_S(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(nAltChannel) + ", BASS_MIXER_CHAN_PAUSE, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
              EndIf
              If d = nEndDev
                Break
              EndIf
              d + nStep
            ForEver
            ; EndIf
          Else
            If \bUsingSplitStream
              d = nStartDev
              Repeat
                nAltChannel = \nBassAltChannel[d]
                If nAltChannel <> 0
                  nBassResult = BASS_ChannelSetAttribute(nAltChannel, #BASS_ATTRIB_VOL, #SCS_MINVOLUME_SINGLE)
                EndIf
                If d = nEndDev
                  Break
                EndIf
                d + nStep
              ForEver
            Else
              d = nStartDev
              Repeat
                nAltChannel = \nBassAltChannel[d]
                If nAltChannel <> 0
                  nBassResult = BASS_ChannelPause(nAltChannel)
                  debugMsg2_S(sProcName, "BASS_ChannelPause(" + decodeHandle(nAltChannel) + ")", nBassResult)
                  nBassResult = BASS_ChannelSetAttribute(nAltChannel, #BASS_ATTRIB_VOL, #SCS_MINVOLUME_SINGLE)
                EndIf
                If d = nEndDev
                  Break
                EndIf
                d + nStep
              ForEver
            EndIf
          EndIf
          
          ; set position to LS for each device channel
          For d = \nFirstSoundingDev To \nLastSoundingDev
            nStreamCreateFlags = \nBassStreamCreateFlags[d]
            nAltChannel = \nBassAltChannel[d]
            If nAltChannel <> 0
              If gbUseBASSMixer
                If \bUsingSplitStream
                  If d = \nFirstSoundingDev
                    nSourceAltChannel = \nSourceAltChannel
                    nBassResult = BASS_ChannelSetPosition(nSourceAltChannel, \rCurrLoopInfo\qBassLoopStartByte, #BASS_POS_BYTE)
                    debugMsg2_S(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nSourceAltChannel) + ", " + \rCurrLoopInfo\qBassLoopStartByte + ", BASS_POS_BYTE)", nBassResult)
                    If nBassResult = #BASSFALSE : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
                    nBassResult = BASS_Split_StreamReset(nSourceAltChannel)  ; reset buffers of all the source's splitters
                    debugMsg2_S(sProcName, "BASS_Split_StreamReset(" + decodeHandle(nSourceAltChannel) + ")", nBassResult)
                    If nBassResult = #BASSFALSE : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
                  EndIf
                Else
                  nBassResult = BASS_Mixer_ChannelSetPosition(nAltChannel, \rCurrLoopInfo\qBassLoopStartByte, #BASS_POS_BYTE)
                  debugMsg2_S(sProcName, "BASS_Mixer_ChannelSetPosition(" + decodeHandle(nAltChannel) + ", " + \rCurrLoopInfo\qBassLoopStartByte + ", BASS_POS_BYTE)", nBassResult)
                  If nBassResult = #BASSFALSE : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
                  If nStreamCreateFlags & #BASS_STREAM_DECODE = 0
                    nBassResult = BASS_ChannelUpdate(nAltChannel, 0)
                    debugMsg2_S(sProcName, "BASS_ChannelUpdate(" + decodeHandle(nAltChannel) + ", 0)", nBassResult)
                    If nBassResult = #BASSFALSE : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
                  EndIf
                EndIf
              Else
                If \bUsingSplitStream
                  If d = \nFirstSoundingDev
                    nFirstSplitterChannel = \nBassAltChannel[\nFirstSoundingDev]
                    nBassResult = BASS_ChannelPause(nFirstSplitterChannel) ; pause splitter streams (so that resumption following seek can be synchronized)
                    debugMsg2_S(sProcName, "BASS_ChannelPause(" + decodeHandle(nFirstSplitterChannel) + ")", nBassResult)
                    If nBassResult = #BASSFALSE : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
                    nSourceAltChannel = \nSourceAltChannel
                    nBassResult = BASS_ChannelSetPosition(nSourceAltChannel, \rCurrLoopInfo\qBassLoopStartByte, #BASS_POS_BYTE)
                    debugMsg2_S(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nSourceAltChannel) + ", " + \rCurrLoopInfo\qBassLoopStartByte + ", BASS_POS_BYTE)", nBassResult)
                    If nBassResult = #BASSFALSE : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
                    nBassResult = BASS_Split_StreamReset(nSourceAltChannel)  ; reset buffers of all the source's splitters
                    debugMsg2_S(sProcName, "BASS_Split_StreamReset(" + decodeHandle(nSourceAltChannel) + ")", nBassResult)
                    If nBassResult = #BASSFALSE : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
                  EndIf
                Else
                  debugMsg(sProcName, "\rCurrLoopInfo\nLoopStart=" + \rCurrLoopInfo\nLoopStart + ", \nLoopEnd=" + \rCurrLoopInfo\nLoopEnd + ", \nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex)
                  nBassResult = BASS_ChannelSetPosition(nAltChannel, \rCurrLoopInfo\qBassLoopStartByte, #BASS_POS_BYTE)
                  If nBassResult = #BASSFALSE : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
                  debugMsg2_S(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nAltChannel) + ", " + \rCurrLoopInfo\qBassLoopStartByte + ", BASS_POS_BYTE)", nBassResult)
                  If nStreamCreateFlags & #BASS_STREAM_DECODE = 0
                    nBassResult = BASS_ChannelUpdate(nAltChannel, 0)
                    debugMsg2_S(sProcName, "BASS_ChannelUpdate(" + decodeHandle(nAltChannel) + ", 0)", nBassResult)
                    If nBassResult = #BASSFALSE : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
                  EndIf
                EndIf
              EndIf
            EndIf
          Next d
          
          \bInLoopXFade = #False
          debugMsg_S(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\bInLoopXFade=" + strB(\bInLoopXFade))
          
          If \bRAISendSetPos = #False
            \bRAISendSetPos = #True
            grRAI\nSendSetPosCount + 1
          EndIf
          
        EndWith
      EndIf
    Next h
    
    ; save gaLoopSync changes
    rMyLoopSync\bInXfade = #False
    gaLoopSync(nLoopSyncIndex) = rMyLoopSync
    
  EndIf
  
  UnlockCueListMutex()
  
  debugMsg3_S(sProcName, #SCS_END)
  
EndProcedure

Procedure LoopSyncProcHearXFade(Handle.l, channel.l, nData, user)
  Protected bLockedMutex
  LockCueListMutex(505) ; Lock mutex BEFORE calling decodeHandle()
  PROCNAME("LoopSyncProcHearXFade handle=" + decodeHandle(Handle) + ", channel=" + decodeHandle(channel) + ", user=" + user + ", l2=" + gaLoopSync(user)\nLoopInfoIndex)

  ;========================================
  ; no system calls in callback procedures!
  ;========================================

  ; this callback occurs when the loop crossfade is due to start

  Protected nAudPtr, d
  Protected rMyLoopSync.tyLoopSync
  Protected fCurrLevel.f
  Protected nBassResult.l, nPanelIndex
  Protected nFadeInTime, nFadeOutTime
  Protected nChannel.l, nAltChannel.l
  Protected nSourceAltChannel.l, nFirstSplitterChannel.l
  Protected nLoopSyncIndex
  Protected bExitNow
  Protected h, nTmpAudPtr, qTimeNow.q
  Protected nStartDev, nEndDev, nStep
  Protected nMixerStreamPtr, nMixerStreamHandle.l
  Protected Dim aMixerNode.BASS_MIXER_NODE(2), nNodeCount.l
  Protected dFadeInTime.d
  Protected qNextSync.q, qLength.q
  
  ; debugMsg3_S(sProcName, #SCS_START)
  
  nLoopSyncIndex = user
  qTimeNow = ElapsedMilliseconds()
  
  If nLoopSyncIndex >= 0
    
    rMyLoopSync = gaLoopSync(nLoopSyncIndex)
    nAudPtr = rMyLoopSync\nAudPtr
    
    With aAud(nAudPtr)
      If \nAudState < #SCS_CUE_FADING_IN Or \nAudState > #SCS_CUE_FADING_OUT
        debugMsg(sProcName, "Exiting because aAud(" + getAudLabel(nAudPtr) + ")\nAudState=" + decodeCueState(\nAudState))
        UnlockCueListMutex()
        ProcedureReturn
      EndIf
      If rMyLoopSync\bSwitchAtXFade = #False
        nStartDev = \nFirstSoundingDev
        nEndDev = \nLastSoundingDev
        nStep = 1
        rMyLoopSync\bSwitchAtXFade = #True
      Else
        nStartDev = \nLastSoundingDev
        nEndDev = \nFirstSoundingDev
        nStep = -1
        rMyLoopSync\bSwitchAtXFade = #False
      EndIf
      
      d = nStartDev
      Repeat
        If channel = \nBassAltChannel[d]
          debugMsg3_S(sProcName, "LoopSyncProcHearXFade exiting because " + decodeHandle(channel) + " is an ALT channel")
          bExitNow = #True
          Break
        EndIf
        If d = nEndDev
          Break
        EndIf
        d + nStep
      ForEver
    EndWith
    If bExitNow
      UnlockCueListMutex()
      ProcedureReturn
    EndIf
    
    rMyLoopSync\nLoopSyncPassNo + 1
    If rMyLoopSync\nLoopSyncPassesReqd > 0
      If rMyLoopSync\nLoopSyncPassNo > rMyLoopSync\nLoopSyncPassesReqd
        For h = 0 To aAud(nAudPtr)\nMaxAudSetPtr2
          nTmpAudPtr = gaAudSet(nAudPtr, h)
          If nTmpAudPtr > 0
            aAud(nTmpAudPtr)\rCurrLoopInfo\bLoopReleased = #True
            debugMsg_S(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\rCurrLoopInfo\bLoopReleased=" + strB(aAud(nTmpAudPtr)\rCurrLoopInfo\bLoopReleased) + ", aAud(" + getAudLabel(nTmpAudPtr) + ")\nCurrLoopInfoIndex=" + aAud(nTmpAudPtr)\nCurrLoopInfoIndex)
            nPanelIndex = getPanelIndexForAud(nTmpAudPtr)
            If nPanelIndex >= 0 And aAud(nTmpAudPtr)\nCurrLoopInfoIndex >= aAud(nTmpAudPtr)\nMaxLoopInfo ; Added nCurrLoopInfoIndex test 6Jan2024 11.10.0
              gaDispPanel(nPanelIndex)\bEnableRelease = #False
            EndIf
          EndIf
        Next h
        ; debugMsg(sProcName, "calling samAddRequest(#SCS_SAM_RELEASE_LOOP, " + getAudLabel(nAudPtr) + ")")
        samAddRequest(#SCS_SAM_RELEASE_LOOP, nAudPtr) ; add request to formally release this loop
      EndIf
    EndIf
    
    nFadeInTime = rMyLoopSync\nLoopXFadeTime
    If rMyLoopSync\nLoopXFadeTime > 0
      nFadeOutTime = rMyLoopSync\nLoopXFadeTime
    Else
      nFadeOutTime = 0
    EndIf
    
    If aAud(nAudPtr)\rCurrLoopInfo\bLoopReleased
      ; no further action if loop released
      gaLoopSync(nLoopSyncIndex) = rMyLoopSync ; save changes
      debugMsg(sProcName, "exiting because aAud(" + getAudLabel(nAudPtr) + ")\rCurrLoopInfo\bLoopReleased=#True")
      UnlockCueListMutex()
      ProcedureReturn
    EndIf
    
    rMyLoopSync\bInXfade = #True
    
    ; debugMsg3_S(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\nAudLinkCount=" + Str(aAud(nAudPtr)\nAudLinkCount))
    For h = 0 To aAud(nAudPtr)\nMaxAudSetPtr2
      nTmpAudPtr = gaAudSet(nAudPtr, h)
      If nTmpAudPtr > 0
        With aAud(nTmpAudPtr)
          ; debugMsg3_S(sProcName, \sAudLabel)
          \bInLoopXFade = #True
          ; debugMsg_S(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\bInLoopXFade=" + strB(\bInLoopXFade))
          d = nStartDev
          Repeat
            nChannel = \nBassChannel[d]
            nAltChannel = \nBassAltChannel[d]
            ; debugMsg3_S(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\nBassChannel[" + d + "]=" + decodeHandle(nChannel) + ", \nBassAltChannel[" + d + "]=" + decodeHandle(nAltChannel))
            If nChannel <> 0
              ; get current level of channel
              nBassResult = BASS_ChannelGetAttribute(nChannel, #BASS_ATTRIB_VOL, @fCurrLevel)
              ; debugMsg2_S(sProcName, "BASS_ChannelGetAttribute(" + decodeHandle(nChannel) + ", BASS_ATTRIB_VOL, fCurrLevel)  fCurrLevel=" + StrF(fCurrLevel,3), nBassResult)
              CompilerIf #cUseBassMixerEnvelopeForXFades = #False
                ; fade-in altchannel to current level of channel
                If nFadeInTime > 0
                  nBassResult = BASS_ChannelSetAttribute(nAltChannel, #BASS_ATTRIB_VOL, #SCS_MINVOLUME_SINGLE)
                  ; debugMsg2_S(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nAltChannel) + ", BASS_ATTRIB_VOL, " + StrF(#SCS_MINVOLUME_SINGLE,3) + ")", nBassResult)
                EndIf
              CompilerEndIf
              \fBVLevelAtLoopEnd[d] = fCurrLevel ; keep current level in case needed for loop release
            EndIf
            If d = nEndDev
              Break
            EndIf
            d + nStep
          ForEver
          
          If gbUseBASSMixer
            ; remove pause flags on alt channel(s)
            d = nStartDev
            Repeat
              nAltChannel = \nBassAltChannel[d]
              If nAltChannel <> 0
                nBassResult = BASS_ChannelIsActive(nAltChannel)
                ; debugMsg2(sProcName, "BASS_ChannelIsActive(" + decodeHandle(nAltChannel) + ")", nBassResult)
                If nBassResult <> #BASS_ACTIVE_PLAYING
                  nBassResult = BASS_ChannelPlay(nAltChannel, #BASSFALSE)
                  ; debugMsg2(sProcName, "BASS_ChannelPlay(" + decodeHandle(nAltChannel) + ", #BASSFALSE)", nBassResult)
                  If nBassResult = #BASSFALSE : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
                EndIf
                nBassResult = BASS_Mixer_ChannelFlags(nAltChannel, 0, #BASS_MIXER_CHAN_PAUSE)   ; remove pause flag
                ; debugMsg3_S(sProcName, "BASS_Mixer_ChannelFlags(" + decodeHandle(nAltChannel) + ", 0, BASS_MIXER_CHAN_PAUSE) returned " + decodeMixerChannelFlags(nBassResult))
              EndIf
              If d = nEndDev
                Break
              EndIf
              d + nStep
            ForEver
          Else
            If \bUsingSplitStream
              If \nFirstSoundingDev >= 0
                nFirstSplitterChannel = \nBassAltChannel[\nFirstSoundingDev]
                nSourceAltChannel = \nSourceAltChannel
                nBassResult = BASS_ChannelPause(nFirstSplitterChannel) ; pause splitter streams (so that resumption following seek can be synchronized)
                ; debugMsg2_S(sProcName, "BASS_ChannelPause(" + decodeHandle(nFirstSplitterChannel) + ")", nBassResult)
                If nBassResult = #BASSFALSE : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
                nBassResult = BASS_ChannelSetPosition(nSourceAltChannel, \rCurrLoopInfo\qBassLoopStartByte, #BASS_POS_BYTE)
                ; debugMsg2_S(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nSourceAltChannel) + ", " + \rCurrLoopInfo\qBassLoopStartByte + ", BASS_POS_BYTE)", nBassResult)
                If nBassResult = #BASSFALSE : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
                nBassResult = BASS_Split_StreamReset(nSourceAltChannel)  ; reset buffers of all the source's splitters
                ; debugMsg2_S(sProcName, "BASS_Split_StreamReset(" + decodeHandle(nSourceAltChannel) + ")", nBassResult)
                If nBassResult = #BASSFALSE : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
                nBassResult = BASS_ChannelPlay(nFirstSplitterChannel, #BASSFALSE)
                ; debugMsg2_S(sProcName, "BASS_ChannelPlay(" + decodeHandle(nFirstSplitterChannel) + ", #BASSFALSE)", nBassResult)
                If nBassResult = #BASSFALSE : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
              EndIf
            Else
              d = nStartDev
              Repeat
                nAltChannel = \nBassAltChannel[d]
                If nAltChannel <> 0
                  nBassResult = BASS_ChannelPlay(nAltChannel, #BASSFALSE)
                  ; debugMsg2_S(sProcName, "BASS_ChannelPlay(" + decodeHandle(nAltChannel) + ", BASSFALSE)", nBassResult)
                  If nBassResult = #BASSFALSE : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
                EndIf
                If d = nEndDev
                  Break
                EndIf
                d + nStep
              ForEver
            EndIf
          EndIf
          
          d = nStartDev
          Repeat
            nAltChannel = \nBassAltChannel[d]
            If nAltChannel <> 0
              nChannel = \nBassChannel[d]
              fCurrLevel = \fBVLevelAtLoopEnd[d]
              ; Added 28Sep2022 11.9.6
              If fCurrLevel <= grLevels\fMinBVLevel
                fCurrLevel = 0.0
              EndIf
              ; End added 28Sep2022 11.9.6
              CompilerIf #cUseBassMixerEnvelopeForXFades
                nMixerStreamPtr = getMixerStreamPtrForLogicalDev(\sLogicalDev[d])
                If nMixerStreamPtr >= 0
                  nMixerStreamHandle = gaMixerStreams(nMixerStreamPtr)\nMixerStreamHandle
                  If nMixerStreamHandle <> 0
                    qLength = BASS_ChannelGetLength(nChannel, #BASS_POS_BYTE) ; // get channel's length
                    aMixerNode(0)\pos = 0
                    aMixerNode(0)\val = fCurrLevel
                    dFadeInTime = nFadeInTime / 1000
                    aMixerNode(1)\pos = BASS_ChannelSeconds2Bytes(nMixerStreamHandle, dFadeInTime)
                    debugMsg2_S(sProcName, "BASS_ChannelSeconds2Bytes(" + decodeHandle(nMixerStreamHandle) + ", " + StrD(dFadeInTime,3) + ")", aMixerNode(1)\pos)
                    aMixerNode(1)\val = 0
                    debugMsg3_S(sProcName, "aMixerNode(0)\pos=" + aMixerNode(0)\pos + ", aMixerNode(0)\val=" + StrF(aMixerNode(0)\val,3) +
                                           ", aMixerNode(1)\pos=" + aMixerNode(1)\pos + ", aMixerNode(1)\val=" + StrF(aMixerNode(1)\val,3))
                    nBassResult = BASS_Mixer_ChannelSetEnvelope(nChannel, #BASS_MIXER_ENV_VOL, @aMixerNode(0), 2)
                    debugMsg2_S(sProcName, "BASS_Mixer_ChannelSetEnvelope(" + decodeHandle(nChannel) + ", #BASS_MIXER_ENV_VOL, @aMixerNode(0), 2)", nBassResult)
                    ; switch to other stream
                    nBassResult = BASS_ChannelSetPosition(nAltChannel, 0, #BASS_POS_BYTE)
                    debugMsg2_S(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nAltChannel) + ", 0, #BASS_POS_BYTE)", nBassResult)
                    nBassResult = BASS_Mixer_StreamAddChannel(nMixerStreamHandle, nAltChannel, #BASS_MIXER_NORAMPIN) ; add it to the mix
                    debugMsg2_S(sProcName, "BASS_Mixer_StreamAddChannel(" + decodeHandle(nMixerStreamHandle) + ", " + decodeHandle(nAltChannel) + ", #BASS_MIXER_NORAMPIN)", nBassResult)
                    ; switch envelope values for fade-in
                    aMixerNode(0)\val = 0
                    aMixerNode(1)\val = fCurrLevel
                    debugMsg3_S(sProcName, "aMixerNode(0)\pos=" + aMixerNode(0)\pos + ", aMixerNode(0)\val=" + StrF(aMixerNode(0)\val,3) +
                                           ", aMixerNode(1)\pos=" + aMixerNode(1)\pos + ", aMixerNode(1)\val=" + StrF(aMixerNode(1)\val,3))
                    nBassResult = BASS_Mixer_ChannelSetEnvelope(nAltChannel, #BASS_MIXER_ENV_VOL, @aMixerNode(0), 2)
                    debugMsg2_S(sProcName, "BASS_Mixer_ChannelSetEnvelope(" + decodeHandle(nAltChannel) + ", #BASS_MIXER_ENV_VOL, @aMixerNode(0), 2)", nBassResult)
                  EndIf
                  qNextSync = BASS_ChannelGetPosition(nMixerStreamHandle, #BASS_POS_BYTE|#BASS_POS_DECODE) + BASS_ChannelSeconds2Bytes(nMixerStreamHandle, BASS_ChannelBytes2Seconds(nAltChannel, qLength)); // position of next sync = current pos + length of channel
                  nBassResult = BASS_ChannelSetSync(nMixerStreamHandle, #BASS_SYNC_POS|#BASS_SYNC_MIXTIME|#BASS_SYNC_ONETIME, qNextSync, @LoopSyncProcHearXFade(), #Null)                                  ; // set a one-time sync there
                  debugMsg2_S(sProcName, "BASS_ChannelSetSync(" + decodeHandle(nMixerStreamHandle) + ", #BASS_SYNC_POS|#BASS_SYNC_MIXTIME|#BASS_SYNC_ONETIME, " + qNextSync + ", @LoopSyncProcHearXFade(), #Null)", nBassResult)
                EndIf
              CompilerElse
                ; fade-in altchannel to current level of channel
                nBassResult = BASS_ChannelSlideAttribute(nAltChannel, #BASS_ATTRIB_VOL, fCurrLevel, nFadeInTime)
                CompilerIf #cTraceSetLevels
                  debugMsg2_S(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nAltChannel) + ", #BASS_ATTRIB_VOL, " + StrF(fCurrLevel,3) + ", " + nFadeInTime + ")", nBassResult)
                CompilerEndIf
                ; fade-out channel
                CompilerIf 1=2 ; Testing not fading out completely - trying to avoid tempoary drop in volume at start of cross-fade. Seems to help, but reluctant to make this change permanent.
                               ; Should investigate further the use of BASS_Mixer_ChannelSetEnvelope() and associated routines as an alternative.
                  nBassResult = BASS_ChannelSlideAttribute(nChannel, #BASS_ATTRIB_VOL, (fCurrLevel / 5), nFadeOutTime)
                  CompilerIf #cTraceSetLevels
                    debugMsg2_S(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nChannel) + ", #BASS_ATTRIB_VOL, " + StrF(fCurrLevel/5,3) + ", " + nFadeOutTime + ")", nBassResult)
                  CompilerEndIf
                CompilerElse
                  nBassResult = BASS_ChannelSlideAttribute(nChannel, #BASS_ATTRIB_VOL, #SCS_MINVOLUME_SINGLE, nFadeOutTime)
                  CompilerIf #cTraceSetLevels
                    debugMsg2_S(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nChannel) + ", #BASS_ATTRIB_VOL, " + StrF(#SCS_MINVOLUME_SINGLE,3) + ", " + nFadeOutTime + ")", nBassResult)
                  CompilerEndIf
                CompilerEndIf
              CompilerEndIf
            EndIf
            If d = nEndDev
              Break
            EndIf
            d + nStep
          ForEver
          
          \qTimePassStarted = qTimeNow
          ; debugMsg(sProcName, "aAud(" + getAudLabel(nTmpAudPtr) + ")\qTimePassStarted=" + \qTimePassStarted)
          
          If \bRAISendSetPos = #False
            \bRAISendSetPos = #True
            grRAI\nSendSetPosCount + 1
          EndIf
          
        EndWith
        
      EndIf
      
    Next h
    
    ; save gaLoopSync changes
    gaLoopSync(nLoopSyncIndex) = rMyLoopSync
    
  EndIf
  
  UnlockCueListMutex()
  ; debugMsg3_S(sProcName, #SCS_END)
  
EndProcedure

Procedure continueXfade(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nBassResult.l
  Protected nChannel.l, nAltChannel.l
  Protected fMainLevel.f, fAltLevel.f
  Protected bInXfade, nLoopXFadeTime, qTimeNow.q, nXFadeTimeRemaining
  Protected fAdjBVLevel.f
  Protected fPan.f
  Protected nDevMapDevPtr = -1
  Protected fOutputGain.f
  Protected d
  
  debugMsg(sProcName, #SCS_START)
  
  If pAudPtr >= 0
    With aAud(pAudPtr)
      
      nLoopXFadeTime = \rCurrLoopInfo\nLoopXFadeTime
      qTimeNow = ElapsedMilliseconds()
      nXFadeTimeRemaining = nLoopXFadeTime - (qTimeNow - \qTimePassStarted)
      If nXFadeTimeRemaining < 0
        nXFadeTimeRemaining = 0
      EndIf
      
      For d = \nFirstSoundingDev To \nLastSoundingDev
        
        nChannel = \nBassChannel[d]
        nAltChannel = \nBassAltChannel[d]
        
        If nChannel <> 0
          fAdjBVLevel = \fLCBVLevel[d]
          fPan = \fLCPan[d]
          
          If gbUseBASSMixer = #False
            nDevMapDevPtr = \nOutputDevMapDevPtr[d]
            If nDevMapDevPtr >= 0
              fOutputGain = grMaps\aDev(nDevMapDevPtr)\fDevOutputGain
              If fOutputGain <> 1.0
                fAdjBVLevel * fOutputGain
              EndIf
            EndIf
          EndIf
          
          fMainLevel = #SCS_MINVOLUME_SINGLE
          nBassResult = BASS_ChannelSlideAttribute(nChannel, #BASS_ATTRIB_VOL, fMainLevel, nXFadeTimeRemaining)
          CompilerIf #cTraceSetLevels
            debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nChannel) + ", #BASS_ATTRIB_VOL, " + traceLevel(fMainLevel) + ", " + Str(nXFadeTimeRemaining) + ")", nBassResult)
          CompilerEndIf
          
          fAltLevel = fAdjBVLevel
          ; Added 28Sep2022 11.9.6
          If fAltLevel <= grLevels\fMinBVLevel
            fAltLevel = 0.0
          EndIf
          ; End added 28Sep2022 11.9.6
          nBassResult = BASS_ChannelSlideAttribute(nAltChannel, #BASS_ATTRIB_VOL, fAltLevel, nXFadeTimeRemaining)
          CompilerIf #cTraceSetLevels
            debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nAltChannel) + ", #BASS_ATTRIB_VOL, " + traceLevel(fAltLevel) + ", " + Str(nXFadeTimeRemaining) + ")", nBassResult)
          CompilerEndIf
          
          If fPan <> \fCuePanNow[d]
            nBassResult = BASS_ChannelSlideAttribute(nChannel, #BASS_ATTRIB_PAN, fPan, nXFadeTimeRemaining)
            CompilerIf #cTraceSetLevels
              debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nChannel) + ", #BASS_ATTRIB_PAN, " + formatLevel(fPan) + ", " + Str(nXFadeTimeRemaining) + ")", nBassResult)
            CompilerEndIf
            If nAltChannel <> 0
              nBassResult = BASS_ChannelSlideAttribute(nAltChannel, #BASS_ATTRIB_PAN, fPan, nXFadeTimeRemaining)
              CompilerIf #cTraceSetLevels
                debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nAltChannel) + ", #BASS_ATTRIB_PAN, " + formatLevel(fPan) + ", " + Str(nXFadeTimeRemaining) + ")", nBassResult)
              CompilerEndIf
            EndIf
          EndIf
          
        EndIf
      Next d
    EndWith
  EndIf
  
EndProcedure

Procedure setAudioDriverBuffersEtc(nAudioDriver)
  PROCNAMEC()
  Protected nBassResult.l
  
  debugMsg(sProcName, #SCS_START + ", nAudioDriver=" + decodeDriver(nAudioDriver))
  
  Select nAudioDriver
    Case #SCS_DRV_BASS_DS, #SCS_DRV_BASS_WASAPI ; BASS_DS, BASS_WASAPI
      ; NOTE see warning against #c_single_thread_bass in TopLevel.pbi. #c_single_thread_bass MUST be set to #True
      CompilerIf #c_single_thread_bass
        nBassResult = BASS_SetConfig(#BASS_CONFIG_UPDATETHREADS, 1)
        debugMsg2(sProcName, "BASS_SetConfig(BASS_CONFIG_UPDATETHREADS, 1)", nBassResult)
      CompilerElse
        nBassResult = BASS_SetConfig(#BASS_CONFIG_UPDATETHREADS, 2)
        debugMsg2(sProcName, "BASS_SetConfig(BASS_CONFIG_UPDATETHREADS, 2)", nBassResult)
      CompilerEndIf
      
      CompilerIf #cAlwaysUseMixerForBass
        gnDefaultBuffer = #SCS_DEFAULT_BUFFER_USING_MIXER
        gnDefaultUpdatePeriod = #SCS_DEFAULT_UPDATE_PERIOD_USING_MIXER
      CompilerElse
        If grDriverSettings\bUseBASSMixer
          gnDefaultBuffer = #SCS_DEFAULT_BUFFER_USING_MIXER
          gnDefaultUpdatePeriod = #SCS_DEFAULT_UPDATE_PERIOD_USING_MIXER
        Else
          gnDefaultBuffer = #SCS_DEFAULT_BUFFER_NO_MIXER
          gnDefaultUpdatePeriod = #SCS_DEFAULT_UPDATE_PERIOD_NO_MIXER
        EndIf
      CompilerEndIf
      debugMsg(sProcName, "grDriverSettings\bUseBASSMixer=" + strB(grDriverSettings\bUseBASSMixer) + ", gnDefaultBuffer=" + Str(gnDefaultBuffer) + ", gnDefaultUpdatePeriod=" + Str(gnDefaultUpdatePeriod))
      
      mmSetPlaybackBufLength()
      mmSetUpdatePeriodLength()
      
    Case #SCS_DRV_BASS_ASIO  ; BASS_ASIO
      
    Case #SCS_DRV_SMS_ASIO ; SM-S
      
  EndSelect
  
  Select nAudioDriver
    Case #SCS_DRV_BASS_DS, #SCS_DRV_BASS_WASAPI, #SCS_DRV_BASS_ASIO
      nBassResult = BASS_SetConfig(#BASS_CONFIG_FLOATDSP, #BASSTRUE)
      debugMsg2(sProcName, "BASS_SetConfig(BASS_CONFIG_FLOATDSP, BASSTRUE)", nBassResult)
      
      ; added 9Aug2016 11.5.2 to enable panning when using speaker flags but not using the bass mixer
      If gbUseBASSMixer = #False
        nBassResult = BASS_SetConfig(#BASS_CONFIG_VISTA_SPEAKERS, #BASSTRUE)
        debugMsg2(sProcName, "BASS_SetConfig(BASS_CONFIG_VISTA_SPEAKERS, BASSTRUE)", nBassResult)
      EndIf
      ; end added 9Aug2016
      
      nBassResult = BASS_SetConfig(#BASS_CONFIG_WMA_BASSFILE, #BASSTRUE)
      debugMsg2(sProcName, "BASS_SetConfig(BASS_CONFIG_WMA_BASSFILE, BASSTRUE)", nBassResult)
      
  EndSelect
  
EndProcedure

Procedure initBassForAudioDriver(nAudioDriver)
  PROCNAMEC()
  Protected nAudioDriverUsed
  
  debugMsg(sProcName, #SCS_START + ", nAudioDriver=" + decodeDriver(nAudioDriver))
  
  debugMsg(sProcName, "calling setAudioDriverGlobalFlags()")
  setAudioDriverGlobalFlags()
  
  nAudioDriverUsed = nAudioDriver
  If (nAudioDriver <> #SCS_DRV_BASS_DS) And (nAudioDriver <> #SCS_DRV_BASS_WASAPI) And (gbBassNoSoundDevInitialised = #False)
    initBassNoSoundDev() ; initialize BASS with "no sound" device so that various BASS functions may be used, eg BASS_Encode...
  EndIf
  
  setAudioDriverBuffersEtc(nAudioDriver)
  gaDriverInfo(nAudioDriver)\bBassInitialised = #True
  
  debugMsg(sProcName, #SCS_END + ", nAudioDriverUsed=" + decodeDriver(nAudioDriverUsed))
  ProcedureReturn nAudioDriverUsed
  
EndProcedure

Procedure mmInit()
  PROCNAMEC()
  Protected m, n, v, nBassResult.l
  Protected nWindowNo
  Protected nAvailableDevices
  Protected sMsg.s
  Protected svMixCommand.s
  Protected nNull
  
  debugMsg(sProcName, #SCS_START)
  
  If IsWindow(#WMN) = #False
    ; ensure window #WMN is created so that BASS_Init() can use this as "the application's main window". previously, SCS would use #WSP (the splash window)
    ; for BASS_Init(), but technically this could throw the error #BASS_ERROR_BUFLOST in BASS_ChannelPlay() (and others) if the window no longer exists.
    debugMsg(sProcName, "calling createfmMain()")
    createfmMain()
  EndIf

  ; nb use BASS_ASIO_SetUnicode(#BASSTRUE) soon(!), and also use BASS_CONFIG_UNICODE, but when this is implemented we need to replace
  ; some VBStrFromAnsiPtr macro calls with Peeks() to change the flag to UTF-8 or Unicode - not sure which, so need to test.
  ; check BASS documentation - BASS_CONFIG_UNICODE says UTF-8 but BASS_ASIO_SetUnicode says UTF-16.
  ; nBassResult = BASS_ASIO_SetUnicode(#BASSTRUE)
  ; debugMsg2(sProcName, "BASS_ASIO_SetUnicode(#BASSTRUE)", nBassResult)
  
  nBassResult = BASS_WASAPI_SetNotify(@wasapiNotifyProc(), nNull)
  debugMsg2(sProcName, "BASS_WASAPI_SetNotify(@wasapiNotifyProc(), nNull)", nBassResult)
  If nBassResult = #False
    debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
  EndIf
  
  ; debugMsg(sProcName, "calling UseBriefLZPacker()")
  UseBriefLZPacker()  ; used for compressing/uncompressing sample data stored in the production database blob
  
  If grLicInfo\nLicLevel >= #SCS_LIC_STD
    nAvailableDevices = gnDSDeviceCount + gnWASAPIDeviceCount + gnAsioDeviceCount
  Else
    nAvailableDevices = gnDSDeviceCount + gnWASAPIDeviceCount
  EndIf
  If nAvailableDevices = 0
    sMsg = Lang("Errors", "CannotFindAudioDev")
    debugMsg(sProcName, sMsg)
    scsMessageRequester(#SCS_TITLE, sMsg, #MB_ICONERROR)
    ProcedureReturn #False
  EndIf
  If gnDSDeviceCount > 0
    gnDefaultAudioDriver = #SCS_DRV_BASS_DS
  ElseIf gnWASAPIDeviceCount > 0
    gnDefaultAudioDriver = #SCS_DRV_BASS_WASAPI
  ElseIf gnAsioDeviceCount > 0
    gnDefaultAudioDriver = #SCS_DRV_BASS_ASIO
  EndIf
  
  debugMsg(sProcName, "grLicInfo\sLicUser=" + grLicInfo\sLicUser + ", gnDSDeviceCount=" + gnDSDeviceCount + ", gnAsioDeviceCount=" + gnAsioDeviceCount + ", gnDefaultAudioDriver=" + decodeDriver(gnDefaultAudioDriver))
  
  grDevMapDef\nAudioDriver = gnDefaultAudioDriver
  For n = 0 To ArraySize(grMaps\aMap())
    grMaps\aMap(n)\nAudioDriver = gnDefaultAudioDriver
  Next n
  
  gnStopFadeTime = 100
  gnMaxCuePoint = -1
  gnMaxAudCuePoint = -1
  gnMaxAnalyzedFile = -1
  gnDefaultBuffer = #SCS_DEFAULT_BUFFER_NO_MIXER
  gnDefaultUpdatePeriod = #SCS_DEFAULT_UPDATE_PERIOD_NO_MIXER
  
  debugMsg(sProcName, "calling buildOutputArray()")
  buildOutputArray()

  ;- free stream array defaults
  ; nb cannot do this in setDefaultsAll() because that has not yet been called
  With grFreeStreamDef
    \bDone = #True
  EndWith
  ReDim gaFreeStreams(50)
  ; debugMsg(sProcName, "grFreeStreamDef\bDone=" + strB(grFreeStreamDef\bDone))
  For n = 0 To ArraySize(gaFreeStreams())
    gaFreeStreams(n) = grFreeStreamDef
  Next n
  ; debugMsg(sProcName, "gaFreeStreams(0)\bDone=" + strB(gaFreeStreams(0)\bDone))

  setFileTypeList()

  For n = 0 To grLicInfo\nLastVidPicTarget
    With grVidPicTarget(n)
      \nVidPicTarget = n
      \nPrimaryAudPtr = -1
      \nPrevPrimaryAudPtr = -1
      \nPlayingSubPtr = -1
      \nPrevPlayingSubPtr = -1
      ; debugMsg(sProcName, "grVidPicTarget(" + decodeVidPicTarget(n) + ")\nPrimaryAudPtr=" + getAudLabel(\nPrimaryAudPtr) + ", \nPlayingSubPtr=" + getSubLabel(\nPlayingSubPtr))
      \bImageOnMonitor = #False
      Select n
        Case #SCS_VID_PIC_TARGET_F2 To grLicInfo\nLastVidPicTarget
          \nMainWindowNo = #WV2 + n - #SCS_VID_PIC_TARGET_F2
        Case #SCS_VID_PIC_TARGET_P
          \nMainWindowNo = #WED
      EndSelect
      ; debugMsg(sProcName, "grVidPicTarget(" + n + ")\nVidPicTarget=" + decodeVidPicTarget(\nVidPicTarget) + ", \nMainWindowNo=" + decodeWindow(\nMainWindowNo))
    EndWith
  Next n
  
  grPreview\nPreviewMixerStreamPtr = 0
  
  ReDim gaLoopSync(50)
  gnLastLoopSync = 0

  openMediaInfoLib()
  
  CompilerIf #c_include_tvg And 1=2 ; initTVG() now called from initialisePart1B()
    initTVG()
  CompilerEndIf
  
  debugMsg(sProcName, #SCS_END)
  ProcedureReturn #True
  
EndProcedure

Procedure mmSetDevice(nBassDevice.l, sCalledFrom.s, sCue.s)
  ; PROCNAMEC()
  PROCNAME(sCalledFrom)
  Protected nBassResult.l

  nBassResult = BASS_SetDevice(nBassDevice)
  debugMsg2(sProcName, "BASS_SetDevice(" + nBassDevice + ")", nBassResult)
  If nBassResult = #BASSFALSE
    Error_(sProcName, RTrim("Failed to set device " + nBassDevice + ", cue=" + sCue))
  EndIf
  ProcedureReturn nBassResult
EndProcedure

Procedure mmSetPlaybackBufLength()
  PROCNAMEC()
  Protected nBassResult.l, nReqdPlaybackBufLength.l

  With grDriverSettings
    CompilerIf #cAlwaysUseMixerForBass  ; 28Dec2015 - always use default buffer length
      nReqdPlaybackBufLength = gnDefaultBuffer
    CompilerElse
      If (\bUseBASSMixer = #False) And (gbUseBASSMixer)
        nReqdPlaybackBufLength = #SCS_DEFAULT_BUFFER_USING_MIXER
      ElseIf \sPlaybackBufOption = "Default" Or \nPlaybackBufLength = 0
        nReqdPlaybackBufLength = gnDefaultBuffer
      Else
        nReqdPlaybackBufLength = \nPlaybackBufLength
      EndIf
    CompilerEndIf
    nBassResult = BASS_SetConfig(#BASS_CONFIG_BUFFER, nReqdPlaybackBufLength)
    debugMsg2(sProcName, "BASS_SetConfig(BASS_CONFIG_BUFFER, " + nReqdPlaybackBufLength + ")", nBassResult)
  EndWith
EndProcedure

Procedure mmSetUpdatePeriodLength()
  PROCNAMEC()
  Protected nBassResult.l, nReqdUpdatePeriod.l

  With grDriverSettings
    CompilerIf #cAlwaysUseMixerForBass  ; 28Dec2015 - always use default update period
      nReqdUpdatePeriod = gnDefaultUpdatePeriod
    CompilerElse
      debugMsg(sProcName, "gnCurrAudioDriver=" + decodeDriver(gnCurrAudioDriver) + ", grDriverSettings\sUpdatePeriodOption=" + \sUpdatePeriodOption + ", \nUpdatePeriodLength=" + \nUpdatePeriodLength + ", gnDefaultUpdatePeriod=" + gnDefaultUpdatePeriod)
      If gnCurrAudioDriver = #SCS_DRV_BASS_ASIO ; ASIO test added 20Feb2022 11.9.1ac
        nReqdUpdatePeriod = #SCS_DEFAULT_UPDATE_PERIOD_USING_MIXER
      ElseIf (\bUseBASSMixer = #False) And (gbUseBASSMixer)
        nReqdUpdatePeriod = #SCS_DEFAULT_UPDATE_PERIOD_USING_MIXER
      ElseIf (\sUpdatePeriodOption = "Default") Or (\nUpdatePeriodLength = 0)
        nReqdUpdatePeriod = gnDefaultUpdatePeriod
      Else
        nReqdUpdatePeriod = \nUpdatePeriodLength
      EndIf
    CompilerEndIf
    nBassResult = BASS_SetConfig(#BASS_CONFIG_UPDATEPERIOD, nReqdUpdatePeriod)
    debugMsg2(sProcName, "BASS_SetConfig(BASS_CONFIG_UPDATEPERIOD, " + nReqdUpdatePeriod + ")", nBassResult)
  EndWith
EndProcedure

Procedure mmTerminate()
  PROCNAMEC()
  
  debugMsg(sProcName, #SCS_START)
  
  CompilerIf #c_include_tvg
    destroyAllTVGControls()
  CompilerEndIf
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure PlayEndSyncProc(pHandle.l, pChannel.l, pData, pUser)
  PROCNAME("PlayEndSyncProc pHandle=" + decodeHandle(pHandle) + ", pChannel=" + decodeHandle(pChannel) + ", pUser=" + getAudLabel(pUser))

  ;========================================
  ; no system calls in callback procedures!
  ;========================================

  Protected nAudPtr, nLinkedToAudPtr
  Protected nBassResult.l
  Protected nSourceChannel.l
  Protected k, nAudLinkCount, fVolume.f
  
  ; debugMsg3_S(sProcName, #SCS_START)
  
  nAudPtr = pUser
  
  With aAud(nAudPtr)
    
    ; debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\bPlayEndSyncOccurred=" + strB(\bPlayEndSyncOccurred))
    If \bPlayEndSyncOccurred = #False
      
      ; debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\rCurrLoopInfo\nAbsLoopEnd=" + \rCurrLoopInfo\nAbsLoopEnd + ", \rCurrLoopInfo\bLoopReleased=" + strB(\rCurrLoopInfo\bLoopReleased))
      If (\rCurrLoopInfo\nAbsLoopEnd > 0) And (\rCurrLoopInfo\bLoopReleased = #False)
        ; don't end yet because the cue has a loop and the loop hasn't been released
        ProcedureReturn
      EndIf
      
      nLinkedToAudPtr = \nLinkedToAudPtr
      If nLinkedToAudPtr >= 0
        ; debugMsg(sProcName, "aAud(" + getAudLabel(nLinkedToAudPtr) + ")\rCurrLoopInfo\nAbsLoopEnd=" + aAud(nLinkedToAudPtr)\rCurrLoopInfo\nAbsLoopEnd +
        ;                     ", \rCurrLoopInfo\bLoopReleased=" + strB(aAud(nLinkedToAudPtr)\rCurrLoopInfo\bLoopReleased))
        If (aAud(nLinkedToAudPtr)\rCurrLoopInfo\nAbsLoopEnd > 0) And (aAud(nLinkedToAudPtr)\rCurrLoopInfo\bLoopReleased = #False)
          ; don't end yet because the cue has a loop and the loop hasn't been released
          ProcedureReturn
        EndIf
      EndIf        
      
      If \bAudUseGaplessStream
        \bPlayEndSyncOccurred = #True
        ; debugMsg(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\bPlayEndSyncOccurred=" + strB(\bPlayEndSyncOccurred))
        ; apart from setting \bPlayEndSyncOccurred = #True, the main eof processing will be handled by PlayEndSyncProcGapless()
        ProcedureReturn
      EndIf
      
      \bPlayEndSyncOccurred = #True
      ; debugMsg3(sProcName, "aAud(" + getAudLabel(nAudPtr) + ")\bPlayEndSyncOccurred=" + strB(\bPlayEndSyncOccurred))
      
      ; Added 3Feb2022 11.9.0rc7
      nSourceChannel = \nSourceChannel
      If nSourceChannel <> 0
        fVolume = #SCS_MINVOLUME_SINGLE
        nBassResult = BASS_ChannelSetAttribute(nSourceChannel, #BASS_ATTRIB_VOL, fVolume)
        ; debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(nSourceChannel) + ", #BASS_ATTRIB_VOL, " + StrF(fVolume) + ")", nBassResult)
      EndIf
      ; End added 3Feb2022 11.9.0rc7
      
      ; added 01/04/2014 following problem reported by Derek Dumais - linked cue 27<2> not stopping when 27<1> stopped (as the play end sync callback was not called for 27<2>)
      If \nAudLinkCount > 0
        nAudLinkCount = \nAudLinkCount
        For k = \nFirstAudLink To gnLastAud
          If aAud(k)\nLinkedToAudPtr = nAudPtr
            aAud(k)\bPlayEndSyncOccurred = #True
            ; debugMsg3_S(sProcName, "set aAud(" + getAudLabel(k) + ")\bPlayEndSyncOccurred=#True")
            nAudLinkCount - 1
            If nAudLinkCount = 0
              Break
            EndIf
          EndIf
        Next k
      EndIf
      ; end of added 01/04/2014
      
    EndIf
  EndWith
  
  ; debugMsg3_S(sProcName, #SCS_END)
EndProcedure

Procedure MarkerSyncProc(pHandle.l, pChannel.l, pData, pUser)
  ; PROCNAME("MarkerSyncProc pHandle=" + decodeHandle(pHandle) + ", pChannel=" + decodeHandle(pChannel) + ", pUser=" + getAudLabel(pUser))

  ;========================================
  ; no system calls in callback procedures!
  ;========================================
  
  Protected nChannelAudPtr, nChannelSubPtr, sLinkCue.s, nLinkCuePtr, nLinkSubPtr
  Protected nCueMarkerIndex, nCueMarkerId
  Protected n
  
  ; debugMsg3_S(sProcName, #SCS_START)
  
  nChannelAudPtr = pUser
  nChannelSubPtr = aAud(nChannelAudPtr)\nSubIndex
  If (aSub(nChannelSubPtr)\bStartedInEditor = #False) Or (grEditingOptions\bActivateOCMAutoStarts)
    For nCueMarkerIndex = 0 To aAud(nChannelAudPtr)\nMaxCueMarker
      With aAud(nChannelAudPtr)\aCueMarker(nCueMarkerIndex)
        ; debugMsg_S(sProcName, "aAud(" + getAudLabel(nChannelAudPtr) + ")\aCueMarker(" + nCueMarkerIndex + ")\nBassMarkerSync=" + decodeHandle(\nBassMarkerSync) + ", \nCueMarkerId=" + \nCueMarkerId)
        If (\nBassMarkerSync = pHandle) Or (\nBassMarkerAltSync = pHandle)
          nCueMarkerId = \nCueMarkerId
          ; debugMsg_S(sProcName, "nCueMarkerId=" + nCueMarkerId)
          For n = 0 To gnMaxOCMMatrixItem
            If gaOCMMatrix(n)\nCueMarkerId = nCueMarkerId
              nLinkCuePtr = gaOCMMatrix(n)\nOCMCuePtr
              nLinkSubPtr = gaOCMMatrix(n)\nOCMSubPtr
              If nLinkSubPtr >= 0
                If aSub(nLinkSubPtr)\bSubEnabled
                  ; debugMsg3_S(sProcName, "PostEvent(#SCS_Event_PlaySub, #WMN, 0, 0, " + aSub(nLinkSubPtr)\sSubLabel + ")")
                  PostEvent(#SCS_Event_PlaySub, #WMN, 0, 0, nLinkSubPtr)
                EndIf
              ElseIf nLinkCuePtr >= 0
                If aCue(nLinkCuePtr)\bCueEnabled
                  ; debugMsg3_S(sProcName, "PostEvent(#SCS_Event_PlayCue, #WMN, 0, 0, " + aCue(nLinkCuePtr)\sCue + ")")
                  PostEvent(#SCS_Event_PlayCue, #WMN, 0, 0, nLinkCuePtr)
                EndIf
              EndIf
            EndIf
          Next n
          setNextCueMarker(nChannelAudPtr, \nCueMarkerPosition+1)
        EndIf
      EndWith
    Next nCueMarkerIndex
  EndIf
  
  ; debugMsg3_S(sProcName, #SCS_END)
  
EndProcedure

Procedure setChannelPosition(pAudPtr, pDev, nPosition, qBytePosition=-2.0)
  PROCNAMECA(pAudPtr)
  
  debugMsg(sProcName, "pDev=" + pDev + ", nPosition=" + nPosition + ", qBytePosition=" + qBytePosition)

  With aAud(pAudPtr)
    If \nFileFormat = #SCS_FILEFORMAT_AUDIO
      debugMsg(sProcName, "calling SetPlayingPos(" + getAudLabel(pAudPtr) + ", " + pDev + ", #SCS_CHAN_MAIN, " + nPosition + ", " + qBytePosition + ")")
      SetPlayingPos(pAudPtr, pDev, #SCS_CHAN_MAIN, nPosition, qBytePosition)
      
    ElseIf \nFileFormat = #SCS_FILEFORMAT_VIDEO
      setVideoPosition(pAudPtr, \nAudVidPicTarget, nPosition)
      
    EndIf
  EndWith
EndProcedure

Procedure setFileStateEtc(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected bFileOpen, d
  Protected rChanInfo.BASS_CHANNELINFO
  Protected nChannel.l, nChans.l
  Protected nBassResult.l
  
  If pAudPtr >= 0
    With aAud(pAudPtr)
      If (\nFileState = #SCS_FILESTATE_OPEN) And (\nFirstSoundingDev >= 0)
        If \nBassChannel[\nFirstSoundingDev] <> 0
          nBassResult = BASS_ChannelGetInfo(\nBassChannel[\nFirstSoundingDev], @rChanInfo)
          debugMsg2(sProcName, "BASS_ChannelGetInfo(" + decodeHandle(\nBassChannel[\nFirstSoundingDev]) + ", rChanInfo)", nBassResult)
          If nBassResult = #BASSTRUE
            ; handle OK, so file must be open
            bFileOpen = #True
          EndIf
        EndIf
      EndIf
      
      If bFileOpen = #False
        \nFileState = #SCS_FILESTATE_CLOSED
        debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nFileState=" + decodeFileState(\nFileState))
        \nAudState = #SCS_CUE_NOT_LOADED
        For d = 0 To grLicInfo\nMaxAudDevPerAud
          \nBassChannel[d] = grAudDef\nBassChannel[d]
          \nBassAltChannel[d] = grAudDef\nBassAltChannel[d]
        Next d
      EndIf
      
    EndWith
  EndIf
  
EndProcedure

Macro macSetFirstAndLastDev(pAud)
  ; To use this macro, call setFirstAndLastDev()
  If pAud\bAudTypeA ; Video/Image
    pAud\nFirstDev = 0
    pAud\nLastDev = 0
    pAud\nFirstSoundingDev = 0
    pAud\nLastSoundingDev = 0
    pAud\nSoundingDevCount = 1
    pAud\nFirstInputDev = -1
    pAud\nLastInputDev = -2
  Else
    If pAud\bAudTypeF ; Audio File
      nMaxAudDev = grLicInfo\nMaxAudDevPerAud
      nMaxInputDev = -1
    ElseIf pAud\bAudTypeI ; Live Input
      nMaxAudDev = grLicInfo\nMaxAudDevPerAud
      nMaxInputDev = grLicInfo\nMaxLiveDevPerAud
    ElseIf pAud\bAudTypeP ; Playlist
      nMaxAudDev = grLicInfo\nMaxAudDevPerSub
      nMaxInputDev = -1
    EndIf
    
    nFirstDev = -1
    nLastDev = -2   ; make less than nFirstDev so if neither gets set in aAud() then loops from 'first' to 'last' will exit immediately
    nFirstSoundingDev = -1
    nLastSoundingDev = -2
    nSoundingDevCount = 0
    nFirstInputDev = -1
    nLastInputDev = -2
    
    For d = 0 To nMaxAudDev
      ; cannot use pAud\nBassChannel[d] as this may not yet be assigned
      If pAud\sLogicalDev[d]
        ; debugMsg(sProcName, "\sLogicalDev[" + d + "]=" + pAud\sLogicalDev[d] + ", pAud\bIgnoreDev[" + d + "]=" + strB(\bIgnoreDev[d]))
        If nFirstDev < 0
          nFirstDev = d
        EndIf
        nLastDev = d
        If pAud\bIgnoreDev[d] = #False
          If nFirstSoundingDev < 0
            nFirstSoundingDev = d
          EndIf
          nLastSoundingDev = d
          nSoundingDevCount + 1
        EndIf
      EndIf
    Next d
    ; end of code reinstated from 11.4.1.1
    
    If pAud\bAudTypeI ; Live Input
      For d = 0 To nMaxInputDev
        ; debugMsg0(sProcName, "\sInputLogicalDev[" + d + "]=" + pAud\sInputLogicalDev[d])
        If pAud\sInputLogicalDev[d]
          If nFirstInputDev < 0
            nFirstInputDev = d
          EndIf
          nLastInputDev = d
        EndIf
      Next d
    EndIf
    
    ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nFirstSoundingDev=" + Str(aAud(pAudPtr)\nFirstSoundingDev) + ", nFirstSoundingDev=" + Str(nFirstSoundingDev))
    If (pAud\nFirstDev <> nFirstDev Or pAud\nFirstSoundingDev <> nFirstSoundingDev Or pAud\nLastDev <> nLastDev Or pAud\nLastSoundingDev <> nLastSoundingDev Or pAud\nSoundingDevCount <> nSoundingDevCount)
      ; debugMsg(sProcName, "calling removeAudChannelLoopSyncs(" + getAudLabel(pAudPtr) + ")")
      If gbLoadingCueFile = #False
        If bPrimaryFile
          removeAudChannelLoopSyncs(pAudPtr)
        EndIf
      EndIf
      pAud\nFirstDev = nFirstDev
      pAud\nLastDev = nLastDev
      pAud\nFirstSoundingDev = nFirstSoundingDev
      pAud\nLastSoundingDev = nLastSoundingDev
      pAud\nSoundingDevCount = nSoundingDevCount
      If bPrimaryFile
        If gbLoadingCueFile = #False
          If pAud\rCurrLoopInfo\nAbsLoopEnd > 0
            ; debugMsg(sProcName, "calling setBassLoopEnd(" + getAudLabel(pAudPtr) + ")")
            setBassLoopEnd(pAudPtr)
          EndIf
          debugMsg(sProcName, "calling setBassPlayEnd(" + getAudLabel(pAudPtr) + ")")
          setBassPlayEnd(pAudPtr)
          debugMsg(sProcName, "calling setBassMarkerPositions(" + getAudLabel(pAudPtr) + ")")
          setBassMarkerPositions(pAudPtr)
        EndIf
      EndIf
    EndIf
    
    pAud\nFirstInputDev = nFirstInputDev
    pAud\nLastInputDev = nLastInputDev
    
  EndIf
EndMacro

Procedure setFirstAndLastDev(pAudPtr, bPrimaryFile=#True)
  PROCNAMECA(pAudPtr)
  Protected d, nFirstDev, nLastDev, nMaxAudDev
  Protected nFirstSoundingDev
  Protected nLastSoundingDev
  Protected nFirstInputDev, nLastInputDev, nMaxInputDev
  Protected nSoundingDevCount
  Protected nDevMapDevPtr

  ; debugMsg(sProcName, #SCS_START)
  
  If bPrimaryFile
    macSetFirstAndLastDev(aAud(pAudPtr))
  Else
    macSetFirstAndLastDev(a2ndAud(pAudPtr))
  EndIf
  
EndProcedure

Procedure setBassLoopStart(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nBassResult.l, nSourceChannel.l
  Protected dTmpDouble.d
  Protected l2
  
  If gbUseSMS
    ProcedureReturn
  EndIf
  
  aAud(pAudPtr)\bUsingBassLoop = #False
  For l2 = 0 To aAud(pAudPtr)\nMaxLoopInfo
    With aAud(pAudPtr)\aLoopInfo(l2)
      If \nAbsLoopStart <= 0 Or \nAbsLoopStart >= aAud(pAudPtr)\nFileDuration
        \qBassLoopStartByte = 0
      Else
        If \qLoopStartSamplePos >= 0.0
          \qBassLoopStartByte = \qLoopStartSamplePos * aAud(pAudPtr)\nBytesPerSamplePos
        Else
          nSourceChannel = aAud(pAudPtr)\nSourceChannel
          If nSourceChannel <> 0
            dTmpDouble = \nAbsLoopStart / 1000.0
            \qBassLoopStartByte = BASS_ChannelSeconds2Bytes(nSourceChannel, dTmpDouble)
            ; debugMsg(sProcName, "BASS_ChannelSeconds2Bytes(" + decodeHandle(nSourceChannel) + ", " + StrD(dTmpDouble) + ") returned " + \qBassLoopStartByte)
          EndIf
        EndIf
      EndIf
      ; debugMsg(sProcName, "\qBassLoopStartByte=" + \qBassLoopStartByte)
    EndWith
  Next l2
EndProcedure

Procedure setBassLoopEnd(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected d, n, l2, s2.s
  Protected nLoopSyncIndex
  Protected qLoopEndByteXFade.q, qLoopEndByteLE.q, qFileDurationByte.q  ; quads
  Protected qLoopStartByte.q
  Protected nChannel.l, nAltChannel.l, nSourceChannel.l, nBassResult.l
  Protected nSyncTypeEnd.l, sSyncTypeEnd.s, qSyncPosBytesEnd.q, dTmpDoubleEnd.d
  Protected nSyncTypeStart.l, sSyncTypeStart.s, qSyncPosBytesStart.q, dTmpDoubleStart.d
  Protected bUsingLoopXFade
  
  ; debugMsg(sProcName, #SCS_START)
  
  With aAud(pAudPtr)
    
    ; debugMsg(sProcName, "calling removeAudChannelLoopSyncs(" + getAudLabel(pAudPtr) + ")")
    removeAudChannelLoopSyncs(pAudPtr)
    
    If gbUseSMS
      ProcedureReturn
    EndIf
    
    If \nMaxLoopInfo < 0 Or \nSoundingDevCount = 0
      ; no loop
      ProcedureReturn
    EndIf
    
    If \nSourceChannel = 0
      ; not yet opened
      ProcedureReturn
    EndIf
    
    If \nLinkedToAudPtr >= 0
      ; looping will be controlled by the primary Aud
      ProcedureReturn
    EndIf
    
    bUsingLoopXFade = usingLoopXFade(pAudPtr)
    
    d = \nFirstSoundingDev
    nChannel = \nBassChannel[d]
    nAltChannel = \nBassAltChannel[d]
    nSourceChannel = \nSourceChannel
;     debugMsg3(sProcName, "\nFirstSoundingDev=" + \nFirstSoundingDev +
;                          ", \nBassChannel[" + d + "]=" + decodeHandle(\nBassChannel[d]) +
;                          ", \nBassAltChannel[" + d + "]=" + decodeHandle(\nBassAltChannel[d]) +
;                          ", \nSourceChannel=" + decodeHandle(\nSourceChannel))
    ; set qFileDurationByte
    qFileDurationByte = BASS_ChannelGetLength(nSourceChannel, #BASS_POS_BYTE)
    
  EndWith
  
  For l2 = 0 To aAud(pAudPtr)\nMaxLoopInfo
    s2 = "l2=" + l2 + ", "
    With aAud(pAudPtr)\aLoopInfo(l2)
      nLoopSyncIndex = -1
      For n = 1 To gnLastLoopSync
        If gaLoopSync(n)\bActive = #False
          nLoopSyncIndex = n
          Break
        EndIf
      Next n
      If nLoopSyncIndex = -1
        gnLastLoopSync + 1
        If gnLastLoopSync > ArraySize(gaLoopSync())
          ReDim gaLoopSync(gnLastLoopSync + 50)
        EndIf
        nLoopSyncIndex = gnLastLoopSync
      EndIf
      gaLoopSync(nLoopSyncIndex)\bActive = #True
      gaLoopSync(nLoopSyncIndex)\bChannelSwapAtXFade = #False
      
      ; set qLoopStartByte
      If (\qLoopStartSamplePos >= 0) And (\dLoopStartCPTime >= 0.0)
        ; using cue point
        qLoopStartByte = \qLoopStartSamplePos * aAud(pAudPtr)\nBytesPerSamplePos
      Else
        ; not using cue point
        dTmpDoubleStart = \nAbsLoopStart / 1000.0
        qLoopStartByte = BASS_ChannelSeconds2Bytes(nSourceChannel, dTmpDoubleStart)
      EndIf
      If qLoopStartByte < 0
        qLoopStartByte = 0
      EndIf
      \qLoopStartByte = qLoopStartByte
      
      ; set qLoopEndByteXFade
      If (\qLoopEndSamplePos >= 0) And (\dLoopEndCPTime >= 0.0)
        ; using cue point
        If \nLoopXFadeTime > 0
          dTmpDoubleEnd = \dLoopEndCPTime - (\nLoopXFadeTime / 1000)
          qLoopEndByteXFade = BASS_ChannelSeconds2Bytes(nSourceChannel, dTmpDoubleEnd)
        Else
          qLoopEndByteXFade = \qLoopEndSamplePos * aAud(pAudPtr)\nBytesPerSamplePos
        EndIf
      Else
        ; not using cue point
        If \nLoopXFadeTime > 0
          dTmpDoubleEnd = (\nAbsLoopEnd - \nLoopXFadeTime) / 1000.0
        Else
          dTmpDoubleEnd = \nAbsLoopEnd / 1000.0
        EndIf
        qLoopEndByteXFade = BASS_ChannelSeconds2Bytes(nSourceChannel, dTmpDoubleEnd)
      EndIf
      If qLoopEndByteXFade >= qFileDurationByte
        qLoopEndByteXFade = qFileDurationByte - 1
      EndIf
      \qLoopEndByteXFade = qLoopEndByteXFade
      
      ; set qLoopEndByteLE
      If (\qLoopEndSamplePos >= 0) And (\dLoopEndCPTime >= 0.0)
        ; using cue point
        qLoopEndByteLE = \qLoopEndSamplePos * aAud(pAudPtr)\nBytesPerSamplePos
      Else
        ; not using cue point
        dTmpDoubleEnd = \nAbsLoopEnd / 1000.0
        qLoopEndByteLE = BASS_ChannelSeconds2Bytes(nSourceChannel, dTmpDoubleEnd)
      EndIf
      If qLoopEndByteLE >= qFileDurationByte
        qLoopEndByteLE = qFileDurationByte - 1
      EndIf
      \qLoopEndByteLE = qLoopEndByteLE
      
      ; debugMsg3(sProcName, s2 + "d=" + d + ", \nAbsLoopEnd=" + \nAbsLoopEnd + ", \nLoopXFadeTime=" + \nLoopXFadeTime)
      ; debugMsg3(sProcName, s2 + "qLoopEndByteXFade=" + qLoopEndByteXFade + ", qLoopEndByteLE=" + qLoopEndByteLE + ", qFileDurationByte=" + qFileDurationByte)
      
      gaLoopSync(nLoopSyncIndex)\nAudPtr = pAudPtr
      gaLoopSync(nLoopSyncIndex)\nLoopInfoIndex = l2
      gaLoopSync(nLoopSyncIndex)\nDevNo = d
      gaLoopSync(nLoopSyncIndex)\nChannel = nChannel
      gaLoopSync(nLoopSyncIndex)\nAltChannel = nAltChannel
      gaLoopSync(nLoopSyncIndex)\nLoopXFadeTime = \nLoopXFadeTime
      gaLoopSync(nLoopSyncIndex)\nLoopSyncPassNo = 1
      gaLoopSync(nLoopSyncIndex)\nLoopSyncPassesReqd = \nNumLoops
      gaLoopSync(nLoopSyncIndex)\bSwapped = #False
      
      \nLoopSyncIndex = nLoopSyncIndex
      
      ; =========================
      ; set loop start sync point
      ; =========================
      ; debugMsg(sProcName, s2 + "qLoopStartByte=" + qLoopStartByte + ", \nLoopStart=" + \nLoopStart)
      ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nMaxLoopInfo=" + aAud(pAudPtr)\nMaxLoopInfo + ", \nLoopXFadeTime=" + \nLoopXFadeTime)
      If aAud(pAudPtr)\bUsingBassLoop = #False
        nSyncTypeStart = #BASS_SYNC_POS
        sSyncTypeStart = "BASS_SYNC_POS"
        qSyncPosBytesStart = qLoopStartByte
        If (gbUseBASSMixer) Or (nAltChannel = 0)
          nSyncTypeStart | #BASS_SYNC_MIXTIME
          sSyncTypeStart + "|BASS_SYNC_MIXTIME"
        EndIf
        If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False)
          \nBassLoopSyncStart = BASS_Mixer_ChannelSetSync(nChannel, nSyncTypeStart, qSyncPosBytesStart, @LoopSyncProcStart(), nLoopSyncIndex)
          newHandle(#SCS_HANDLE_SYNC, \nBassLoopSyncStart, #False)
          debugMsg2(sProcName, s2 + "BASS_Mixer_ChannelSetSync(" + decodeHandle(nChannel) + ", " + sSyncTypeStart + ", " + qSyncPosBytesStart + ", @LoopSyncProcStart(), " + nLoopSyncIndex + ")", \nBassLoopSyncStart)
          If \nBassLoopSyncStart = 0
            debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
          EndIf
          If nAltChannel <> 0
            \nBassAltLoopSyncStart = BASS_Mixer_ChannelSetSync(nAltChannel, nSyncTypeStart, qSyncPosBytesStart, @LoopSyncProcStart(), nLoopSyncIndex)
            newHandle(#SCS_HANDLE_SYNC, \nBassAltLoopSyncStart, #False)
            debugMsg2(sProcName, s2 + "BASS_Mixer_ChannelSetSync(" + decodeHandle(nAltChannel) + ", " + sSyncTypeStart + ", " + qSyncPosBytesStart + ", @LoopSyncProcStart(), " + nLoopSyncIndex + ")", \nBassAltLoopSyncStart)
            If \nBassAltLoopSyncStart = 0
              debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
            EndIf
          EndIf
        Else
          \nBassLoopSyncStart = BASS_ChannelSetSync(nChannel, nSyncTypeStart, qSyncPosBytesStart, @LoopSyncProcStart(), nLoopSyncIndex)
          newHandle(#SCS_HANDLE_SYNC, \nBassLoopSyncStart, #False)
          debugMsg2(sProcName, s2 + "BASS_ChannelSetSync(" + decodeHandle(nChannel) + ", " + sSyncTypeStart + ", " + qSyncPosBytesStart + ", @LoopSyncProcStart(), " + nLoopSyncIndex + ")", \nBassLoopSyncStart)
          If \nBassLoopSyncStart = 0
            debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
          EndIf
          If nAltChannel <> 0
            \nBassAltLoopSyncStart = BASS_ChannelSetSync(nAltChannel, nSyncTypeStart, qSyncPosBytesStart, @LoopSyncProcStart(), nLoopSyncIndex)
            newHandle(#SCS_HANDLE_SYNC, \nBassAltLoopSyncStart, #False)
            debugMsg2(sProcName, s2 + "BASS_ChannelSetSync(" + decodeHandle(nAltChannel) + ", " + sSyncTypeStart + ", " + qSyncPosBytesStart + ", @LoopSyncProcStart(), " + nLoopSyncIndex + ")", \nBassAltLoopSyncStart)
            If \nBassAltLoopSyncStart = 0
              debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
            EndIf
          EndIf
        EndIf
      EndIf ; EndIf aAud(pAudPtr)\bUsingBassLoop = #False
      
      ; debugMsg(sProcName, s2 + "qLoopEndByteLE=" + qLoopEndByteLE + ", qLoopEndByteXFade=" + qLoopEndByteXFade + ", qFileDurationByte=" + qFileDurationByte + ", \nLoopEnd=" + \nLoopEnd)
      If qLoopEndByteLE = qLoopEndByteXFade
        ; ===================================================================================
        ; no cross-fade requested or possible, so only set one sync ("Both") for each channel
        ; ===================================================================================
        If aAud(pAudPtr)\bUsingBassLoop
          nBassResult = BASS_ChannelSetPosition(nSourceChannel, #BASS_POS_END, qLoopEndByteLE)
          debugMsg2(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nSourceChannel) + ", #BASS_POS_END, " + qLoopEndByteLE + ")", nBassResult)
          If nBassResult = #False : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
;           nBassResult = BASS_ChannelFlags(nSourceChannel, #BASS_SAMPLE_LOOP, #BASS_SAMPLE_LOOP)
;           debugMsg2(sProcName, "BASS_ChannelFlags(" + decodeHandle(nSourceChannel) + ", #BASS_SAMPLE_LOOP, #BASS_SAMPLE_LOOP)", nBassResult)
;           If nBassResult = #False : debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode())) : EndIf
        Else
          If (qLoopEndByteLE >= qFileDurationByte) Or (\nLoopEnd = -2)  ; 28Jun2017 11.6.3ab added " Or (\nLoopEnd = -2)" to catch blank loop end where qLoopEndByteLE < qFileDurationByte
            ; set sync point at end
            nSyncTypeEnd = #BASS_SYNC_END  ; | #BASS_SYNC_MIXTIME  ; don't use MIXTIME as we are swapping files and MIXTIME causes the second file to start (but see below re 23Sep2016)
            sSyncTypeEnd = "BASS_SYNC_END" ; | BASS_SYNC_MIXTIME"  ; when the first one reaches the loop end point in the buffer, not audibly
            qSyncPosBytesEnd = 0
          Else
            ; set sync point at specified position
            nSyncTypeEnd = #BASS_SYNC_POS  ; | #BASS_SYNC_MIXTIME
            sSyncTypeEnd = "BASS_SYNC_POS" ; | BASS_SYNC_MIXTIME"
            qSyncPosBytesEnd = qLoopEndByteLE
          EndIf
          If (gbUseBASSMixer) Or (nAltChannel = 0)  ; 19May2017 11.6.2ab added test on nAltChannel following email from Jonathan Delson about looping cue not looping
                                                    ; added BASS_SYNC_MIXTIME 23Sep2016 11.5.2.2 in line with changes in setBassPlayEnd(), q.v.
            nSyncTypeEnd | #BASS_SYNC_MIXTIME
            sSyncTypeEnd + "|BASS_SYNC_MIXTIME"
          EndIf
          
          If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False)
            \nBassLoopSyncMixTime = BASS_Mixer_ChannelSetSync(nChannel, nSyncTypeEnd, qSyncPosBytesEnd, @LoopSyncProcMixTime(), nLoopSyncIndex)
            newHandle(#SCS_HANDLE_SYNC, \nBassLoopSyncMixTime, #False)
            debugMsg2(sProcName, s2 + "BASS_Mixer_ChannelSetSync(" + decodeHandle(nChannel) + ", " + sSyncTypeEnd + ", " + qSyncPosBytesEnd + ", @LoopSyncProcMixTime(), " + nLoopSyncIndex + ")", \nBassLoopSyncMixTime)
            If \nBassLoopSyncMixTime = 0
              debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
            EndIf
            If nAltChannel <> 0
              \nBassAltLoopSyncMixTime = BASS_Mixer_ChannelSetSync(nAltChannel, nSyncTypeEnd, qSyncPosBytesEnd, @LoopSyncProcMixTime(), nLoopSyncIndex)
              newHandle(#SCS_HANDLE_SYNC, \nBassAltLoopSyncMixTime, #False)
              debugMsg2(sProcName, s2 + "BASS_Mixer_ChannelSetSync(" + decodeHandle(nAltChannel) + ", " + sSyncTypeEnd + ", " + qSyncPosBytesEnd + ", @LoopSyncProcMixTime(), " + nLoopSyncIndex + ")", \nBassAltLoopSyncMixTime)
              If \nBassAltLoopSyncMixTime = 0
                debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
              EndIf
            EndIf
          Else
            \nBassLoopSyncMixTime = BASS_ChannelSetSync(nChannel, nSyncTypeEnd, qSyncPosBytesEnd, @LoopSyncProcMixTime(), nLoopSyncIndex)
            newHandle(#SCS_HANDLE_SYNC, \nBassLoopSyncMixTime, #False)
            debugMsg2(sProcName, s2 + "BASS_ChannelSetSync(" + decodeHandle(nChannel) + ", " + sSyncTypeEnd + ", " + qSyncPosBytesEnd + ", @LoopSyncProcMixTime(), " + nLoopSyncIndex + ")", \nBassLoopSyncMixTime)
            If \nBassLoopSyncMixTime = 0
              debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
            EndIf
            If nAltChannel <> 0
              \nBassAltLoopSyncMixTime = BASS_ChannelSetSync(nAltChannel, nSyncTypeEnd, qSyncPosBytesEnd, @LoopSyncProcMixTime(), nLoopSyncIndex)
              newHandle(#SCS_HANDLE_SYNC, \nBassAltLoopSyncMixTime, #False)
              debugMsg2(sProcName, s2 + "BASS_ChannelSetSync(" + decodeHandle(nAltChannel) + ", " + sSyncTypeEnd + ", " + qSyncPosBytesEnd + ", @LoopSyncProcMixTime(), " + nLoopSyncIndex + ")", \nBassAltLoopSyncMixTime)
              If \nBassAltLoopSyncMixTime = 0
                debugMsg3(sProcName, s2 + "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
              EndIf
            EndIf
            
          EndIf
        EndIf ; EndIf aAud(pAudPtr)\bUsingBassLoop / Else
        
      Else
        ; =======================================================================================
        ; cross-fade requested and possible, so set two syncs ("XFade" and "LE") for each channel
        ; =======================================================================================
        ; XFade sync point
        If qLoopEndByteXFade >= qFileDurationByte
          ; set sync point at end
          nSyncTypeEnd = #BASS_SYNC_END
          sSyncTypeEnd = "BASS_SYNC_END"
          qSyncPosBytesEnd = 0
        Else
          ; set sync point at specified position
          nSyncTypeEnd = #BASS_SYNC_POS
          sSyncTypeEnd = "BASS_SYNC_POS"
          qSyncPosBytesEnd = qLoopEndByteXFade
        EndIf
        If gbUseBASSMixer
          ; added BASS_SYNC_MIXTIME 23Sep2016 11.5.2.2 in line with changes in setBassPlayEnd(), q.v.
          nSyncTypeEnd | #BASS_SYNC_MIXTIME
          sSyncTypeEnd + "|BASS_SYNC_MIXTIME"
        EndIf
        If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False)
          \nBassLoopSyncHearXFade = BASS_Mixer_ChannelSetSync(nChannel, nSyncTypeEnd, qSyncPosBytesEnd, @LoopSyncProcHearXFade(), nLoopSyncIndex)
          newHandle(#SCS_HANDLE_SYNC, \nBassLoopSyncHearXFade, #False)
          debugMsg2(sProcName, s2 + "BASS_Mixer_ChannelSetSync(" + decodeHandle(nChannel) + ", " + sSyncTypeEnd + ", " + Str(qSyncPosBytesEnd) + ", @LoopSyncProcHearXFade(), " + nLoopSyncIndex + ")", \nBassLoopSyncHearXFade)
          \nBassAltLoopSyncHearXFade = BASS_Mixer_ChannelSetSync(nAltChannel, nSyncTypeEnd, qSyncPosBytesEnd, @LoopSyncProcHearXFade(), nLoopSyncIndex)
          newHandle(#SCS_HANDLE_SYNC, \nBassAltLoopSyncHearXFade, #False)
          debugMsg2(sProcName, s2 + "BASS_Mixer_ChannelSetSync(" + decodeHandle(nAltChannel) + ", " + sSyncTypeEnd + ", " + Str(qSyncPosBytesEnd) + ", @LoopSyncProcHearXFade(), " + nLoopSyncIndex + ")", \nBassAltLoopSyncHearXFade)
        Else
          \nBassLoopSyncHearXFade = BASS_ChannelSetSync(nChannel, nSyncTypeEnd, qSyncPosBytesEnd, @LoopSyncProcHearXFade(), nLoopSyncIndex)
          newHandle(#SCS_HANDLE_SYNC, \nBassLoopSyncHearXFade, #False)
          debugMsg2(sProcName, s2 + "BASS_ChannelSetSync(" + decodeHandle(nChannel) + ", " + sSyncTypeEnd + ", " + qSyncPosBytesEnd + ", @LoopSyncProcHearXFade(), " + nLoopSyncIndex + ")", \nBassLoopSyncHearXFade)
          \nBassAltLoopSyncHearXFade = BASS_ChannelSetSync(nAltChannel, nSyncTypeEnd, qSyncPosBytesEnd, @LoopSyncProcHearXFade(), nLoopSyncIndex)
          newHandle(#SCS_HANDLE_SYNC, \nBassAltLoopSyncHearXFade, #False)
          debugMsg2(sProcName, s2 + "BASS_ChannelSetSync(" + decodeHandle(nAltChannel) + ", " + sSyncTypeEnd + ", " + qSyncPosBytesEnd + ", @LoopSyncProcHearXFade(), " + nLoopSyncIndex + ")", \nBassAltLoopSyncHearXFade)
        EndIf
        
        ; LE sync point
        If qLoopEndByteLE >= qFileDurationByte
          ; set sync point at end
          nSyncTypeEnd = #BASS_SYNC_END
          sSyncTypeEnd = "BASS_SYNC_END"
          qSyncPosBytesEnd = 0
        Else
          ; set sync point at specified position
          nSyncTypeEnd = #BASS_SYNC_POS
          sSyncTypeEnd = "BASS_SYNC_POS"
          qSyncPosBytesEnd = qLoopEndByteLE
        EndIf
        If gbUseBASSMixer
          ; added BASS_SYNC_MIXTIME 23Sep2016 11.5.2.2 in line with changes in setBassPlayEnd(), q.v.
          nSyncTypeEnd | #BASS_SYNC_MIXTIME
          sSyncTypeEnd + "|BASS_SYNC_MIXTIME"
        EndIf
        If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False)
          \nBassLoopSyncHearLE = BASS_Mixer_ChannelSetSync(nChannel, nSyncTypeEnd, qSyncPosBytesEnd, @LoopSyncProcHearLE(), nLoopSyncIndex)
          newHandle(#SCS_HANDLE_SYNC, \nBassLoopSyncHearLE, #False)
          debugMsg2(sProcName, s2 + "BASS_Mixer_ChannelSetSync(" + decodeHandle(nChannel) + ", " + sSyncTypeEnd + ", " + Str(qSyncPosBytesEnd) + ", @LoopSyncProcHearLE(), " + nLoopSyncIndex + ")", \nBassLoopSyncHearLE)
          \nBassAltLoopSyncHearLE = BASS_Mixer_ChannelSetSync(nAltChannel, nSyncTypeEnd, qSyncPosBytesEnd, @LoopSyncProcHearLE(), nLoopSyncIndex)
          newHandle(#SCS_HANDLE_SYNC, \nBassAltLoopSyncHearLE, #False)
          debugMsg2(sProcName, s2 + "BASS_Mixer_ChannelSetSync(" + decodeHandle(nAltChannel) + ", " + sSyncTypeEnd + ", " + Str(qSyncPosBytesEnd) + ", @LoopSyncProcHearLE(), " + nLoopSyncIndex + ")", \nBassAltLoopSyncHearLE)
        Else
          \nBassLoopSyncHearLE = BASS_ChannelSetSync(nChannel, nSyncTypeEnd, qSyncPosBytesEnd, @LoopSyncProcHearLE(), nLoopSyncIndex)
          newHandle(#SCS_HANDLE_SYNC, \nBassLoopSyncHearLE, #False)
          debugMsg2(sProcName, s2 + "BASS_ChannelSetSync(" + decodeHandle(nChannel) + ", " + sSyncTypeEnd + ", " + Str(qSyncPosBytesEnd) + ", @LoopSyncProcHearLE(), " + nLoopSyncIndex + ")", \nBassLoopSyncHearLE)
          \nBassAltLoopSyncHearLE = BASS_ChannelSetSync(nAltChannel, nSyncTypeEnd, qSyncPosBytesEnd, @LoopSyncProcHearLE(), nLoopSyncIndex)
          newHandle(#SCS_HANDLE_SYNC, \nBassAltLoopSyncHearLE, #False)
          debugMsg2(sProcName, s2 + "BASS_ChannelSetSync(" + decodeHandle(nAltChannel) + ", " + sSyncTypeEnd + ", " + Str(qSyncPosBytesEnd) + ", @LoopSyncProcHearLE(), " + nLoopSyncIndex + ")", \nBassAltLoopSyncHearLE)
        EndIf
        
        debugMsg(sProcName, s2 + "gaLoopSync(" + nLoopSyncIndex + ")\bChannelSwapAtXFade=" + strB(gaLoopSync(nLoopSyncIndex)\bChannelSwapAtXFade))
        
      EndIf
      
    EndWith
  Next l2

EndProcedure

Procedure setBassPlayEnd(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected d, n
  Protected nIndex
  Protected qFileDurationByte.q
  Protected nChannel.l, nAltChannel.l
  Protected dTmpDouble.d, qTmpQuad.q
  Protected nPosSyncType.l, sPosSyncType.s
  Protected nEndSyncType.l, sEndSyncType.s
  
  debugMsg(sProcName, #SCS_START)
  
  If aAud(pAudPtr)\nFileFormat <> #SCS_FILEFORMAT_AUDIO
    ProcedureReturn
  EndIf
  
  debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nFirstSoundingDev=" + Str(aAud(pAudPtr)\nFirstSoundingDev))
  ; debugMsg(sProcName, "calling removeAudChannelPlayEndSyncs(" + getAudLabel(pAudPtr) + ")")
  removeAudChannelPlayEndSyncs(pAudPtr)
  
  If gbUseSMS
    ProcedureReturn
  EndIf
  
  If gbUseBASSMixer
    ; added BASS_SYNC_MIXTIME 23Sep2016 11.5.2.2 following suggestion by Ian Luck in the BASS Forum
    ; regarding a problem reported by Eric Snodgrass re a bit of extra audio being played after the designated end point
    nPosSyncType = #BASS_SYNC_POS|#BASS_SYNC_MIXTIME
    sPosSyncType = "BASS_SYNC_POS|BASS_SYNC_MIXTIME"
    nEndSyncType = #BASS_SYNC_END|#BASS_SYNC_MIXTIME
    sEndSyncType = "BASS_SYNC_END|BASS_SYNC_MIXTIME"
  Else
    nPosSyncType = #BASS_SYNC_POS
    sPosSyncType = "BASS_SYNC_POS"
    nEndSyncType = #BASS_SYNC_END
    sEndSyncType = "BASS_SYNC_END"
  EndIf

  ; commented out as we always need to set BASS_SYNC_END or BASS_SYNC_POS.
  ; omitting either can cause the file to stop playback slightly before the expected end, esp mp3 - eg with kalimba.mp3
  ; If aAud(pAudPtr)\bAudTypeP = #False
    ; If aAud(pAudPtr)\nEndAt <= 0
      ; ; no nominated end point
      ; aAud(pAudPtr)\qBassPlayEndByte = 0
      ; ProcedureReturn
    ; EndIf
  ; EndIf
  
  With aAud(pAudPtr)
    
    If \nMaxLoopInfo >= 0
      d = \nFirstSoundingDev
      If d >= 0
        nChannel = \nBassChannel[d]
        nAltChannel = \nBassAltChannel[d]
      EndIf
    ElseIf \bUsingSplitStream
      d = \nFirstSoundingDev
      If d >= 0
        nChannel = \nBassChannel[d]
      EndIf
    Else
      nChannel = \nSourceChannel
    EndIf
    
    debugMsg(sProcName, "nChannel=" + decodeHandle(nChannel) + ", \nEndAt=" + \nEndAt + ", \qEndAtSamplePos=" + \qEndAtSamplePos)
    If nChannel <> 0
      
      If (\nEndAt > 0) Or (\qEndAtSamplePos > 0)
        ; an 'end at' position has been supplied, either as a time or as a cue point / marker
        If \qEndAtBytePos >= 0
          \qBassPlayEndByte = \qEndAtBytePos
        Else
          dTmpDouble = \nAbsEndAt / 1000.0
          \qBassPlayEndByte = BASS_ChannelSeconds2Bytes(nChannel, dTmpDouble)
        EndIf
        qFileDurationByte = BASS_ChannelGetLength(nChannel, #BASS_POS_BYTE)
        
        debugMsg(sProcName, "\qBassPlayEndByte=" + \qBassPlayEndByte + ", qFileDurationByte=" + qFileDurationByte)
        
        If \qBassPlayEndByte < qFileDurationByte
          ; set sync point at specified position
          If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False) ; And \bContainsLoop
            \nBassPlayEndSync = BASS_Mixer_ChannelSetSync(nChannel, nPosSyncType, \qBassPlayEndByte, @PlayEndSyncProc(), pAudPtr)
            newHandle(#SCS_HANDLE_SYNC, \nBassPlayEndSync, #False)
            debugMsg2(sProcName, "BASS_Mixer_ChannelSetSync(" + decodeHandle(nChannel) + ", " + sPosSyncType + ", " + \qBassPlayEndByte + ", @PlayEndSyncProc(), " + getAudLabel(pAudPtr) + ")", \nBassPlayEndSync)
            If \nBassPlayEndSync = 0
              debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
            EndIf
            If nAltChannel <> 0
              \nBassAltPlayEndSync = BASS_Mixer_ChannelSetSync(nAltChannel, nPosSyncType, \qBassPlayEndByte, @PlayEndSyncProc(), pAudPtr)
              newHandle(#SCS_HANDLE_SYNC, \nBassAltPlayEndSync, #False)
              debugMsg2(sProcName, "BASS_Mixer_ChannelSetSync(" + decodeHandle(nAltChannel) + ", " + sPosSyncType + ", " + \qBassPlayEndByte + ", @PlayEndSyncProc(), " + getAudLabel(pAudPtr) + ")", \nBassAltPlayEndSync)
            Else
              \nBassAltPlayEndSync = 0
            EndIf
          Else
            \nBassPlayEndSync = BASS_ChannelSetSync(nChannel, nPosSyncType, \qBassPlayEndByte, @PlayEndSyncProc(), pAudPtr)
            newHandle(#SCS_HANDLE_SYNC, \nBassPlayEndSync, #False)
            debugMsg2(sProcName, "BASS_ChannelSetSync(" + decodeHandle(nChannel) + ", " + sPosSyncType + ", " + \qBassPlayEndByte + ", @PlayEndSyncProc(), " + getAudLabel(pAudPtr) + ")", \nBassPlayEndSync)
            If \nBassPlayEndSync = 0
              debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
            EndIf
            If nAltChannel <> 0
              \nBassAltPlayEndSync = BASS_ChannelSetSync(nAltChannel, nPosSyncType, \qBassPlayEndByte, @PlayEndSyncProc(), pAudPtr)
              newHandle(#SCS_HANDLE_SYNC, \nBassAltPlayEndSync, #False)
              debugMsg2(sProcName, "BASS_ChannelSetSync(" + decodeHandle(nAltChannel) + ", " + sPosSyncType + ", " + \qBassPlayEndByte + ", @PlayEndSyncProc(), " + getAudLabel(pAudPtr) + ")", \nBassAltPlayEndSync)
            Else
              \nBassAltPlayEndSync = 0
            EndIf
          EndIf
        EndIf
      EndIf
      
      ; set sync point at end (always set as catch-all in case \qBassPlayEndByte as beyond EOF, eg in an MP3 file where the duration could not be accurately calculated)
      If (gbUseBASSMixer) And (#c_use_BassChannelSetSync_not_BassMixerChannelSetSync = #False)
        qTmpQuad = 0
        debugMsg(sProcName, "calling BASS_Mixer_ChannelSetSync(" + decodeHandle(nChannel) + ", " + sEndSyncType + ", " + qTmpQuad + ", @PlayEndSyncProc(), " + getAudLabel(pAudPtr) + ")")
        \nBassChannelEndSync = BASS_Mixer_ChannelSetSync(nChannel, nEndSyncType, qTmpQuad, @PlayEndSyncProc(), pAudPtr)
        debugMsg(sProcName, "\nBassChannelEndSync=" + \nBassChannelEndSync)
        newHandle(#SCS_HANDLE_SYNC, \nBassChannelEndSync, #False)
        debugMsg2(sProcName, "BASS_Mixer_ChannelSetSync(" + decodeHandle(nChannel) + ", " + sEndSyncType + ", " + qTmpQuad + ", @PlayEndSyncProc(), " + getAudLabel(pAudPtr) + ")", \nBassChannelEndSync)
        If \nBassChannelEndSync = 0
          debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
        EndIf
        If nAltChannel <> 0
          \nBassAltChannelEndSync = BASS_Mixer_ChannelSetSync(nAltChannel, nEndSyncType, qTmpQuad, @PlayEndSyncProc(), pAudPtr)
          newHandle(#SCS_HANDLE_SYNC, \nBassAltChannelEndSync, #False)
          debugMsg2(sProcName, "BASS_Mixer_ChannelSetSync(" + decodeHandle(nAltChannel) + ", " + sEndSyncType + ", " + qTmpQuad + ", @PlayEndSyncProc(), " + getAudLabel(pAudPtr) + ")", \nBassAltChannelEndSync)
        Else
          \nBassAltChannelEndSync = 0
        EndIf
      Else
        \nBassChannelEndSync = BASS_ChannelSetSync(nChannel, nEndSyncType, qTmpQuad, @PlayEndSyncProc(), pAudPtr)
        newHandle(#SCS_HANDLE_SYNC, \nBassChannelEndSync, #False)
        debugMsg2(sProcName, "BASS_ChannelSetSync(" + decodeHandle(nChannel) + ", " + sEndSyncType + ", " + qTmpQuad + ", @PlayEndSyncProc(), " + getAudLabel(pAudPtr) + ")", \nBassChannelEndSync)
        If \nBassChannelEndSync = 0
          debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
        EndIf
        If nAltChannel <> 0
          \nBassAltChannelEndSync = BASS_ChannelSetSync(nAltChannel, nEndSyncType, qTmpQuad, @PlayEndSyncProc(), pAudPtr)
          newHandle(#SCS_HANDLE_SYNC, \nBassAltChannelEndSync, #False)
          debugMsg2(sProcName, "BASS_ChannelSetSync(" + decodeHandle(nAltChannel) + ", " + sEndSyncType + ", " + qTmpQuad + ", @PlayEndSyncProc(), " + getAudLabel(pAudPtr) + ")", \nBassAltChannelEndSync)
        Else
          \nBassAltChannelEndSync = 0
        EndIf
      EndIf
      
    EndIf
    
  EndWith
  
  debugMsg(sProcName,#SCS_END)
  
EndProcedure

Procedure setBassMarkerPositions(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected d
  Protected nMarkerIndex
  Protected qFileDurationByte.q
  Protected nChannel.l, nAltChannel.l, nPassChannel.l, nPass
  Protected dTmpDouble.d
  Protected nPosSyncType.l, sPosSyncType.s
  Protected qChannelDecodePosition.q, qChannelBytePosition.q, qChannelStartPosition.q, nBassResult.l
  Protected nCueMarkerId, nOCMMatrixItem, bSyncThis
  
  debugMsg(sProcName, #SCS_START)
  
  If aAud(pAudPtr)\nFileFormat <> #SCS_FILEFORMAT_AUDIO
    ProcedureReturn
  EndIf
  
  ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nFirstSoundingDev=" + Str(aAud(pAudPtr)\nFirstSoundingDev))
  ; debugMsg(sProcName, "calling removeAudChannelMarkerSyncs(" + getAudLabel(pAudPtr) + ")")
  removeAudChannelMarkerSyncs(pAudPtr)
  
  If gbUseSMS
    ProcedureReturn
  EndIf
  
  If aAud(pAudPtr)\bAudUseGaplessStream
    ; Following up on a test by Tom Eagle (email 31Jul2018), it appears that setting sync points for a gapless stream do not work well,
    ; especially on the second and subsequent files in the gapless stream. Since this is a rare requirement and the cue markers can be
    ; triggered by checkNextCueMarker(), do not try to set BASS sync points for gapless streams.
    debugMsg(sProcName, "exiting because aAud(" + getAudLabel(pAudPtr) + ")\bAudUseGaplessStream=#True")
    ProcedureReturn
  EndIf
  
  If gbUseBASSMixer
    ; added BASS_SYNC_MIXTIME 23Sep2016 11.5.2.2 following suggestion by Ian Luck in the BASS Forum
    ; regarding a problem reported by Eric Snodgrass re a bit of extra audio being played after the designated end point
    nPosSyncType = #BASS_SYNC_POS|#BASS_SYNC_MIXTIME
    sPosSyncType = "BASS_SYNC_POS|BASS_SYNC_MIXTIME"
  Else
    nPosSyncType = #BASS_SYNC_POS
    sPosSyncType = "BASS_SYNC_POS"
  EndIf
  
  For nMarkerIndex = 0 To aAud(pAudPtr)\nMaxCueMarker
    With aAud(pAudPtr)\aCueMarker(nMarkerIndex)
      ; added 7Mar2020 11.8.2.2be
      ; check if it's necessary to set a sync point for this cue marker
      bSyncThis = #False
      nCueMarkerId = \nCueMarkerId
      For nOCMMatrixItem = 0 To gnMaxOCMMatrixItem
        ; debugMsg(sProcName, "gaOCMMatrix(" + nOCMMatrixItem + ")\nCueMarkerId=" + gaOCMMatrix(nOCMMatrixItem)\nCueMarkerId)
        If gaOCMMatrix(nOCMMatrixItem)\nCueMarkerId = nCueMarkerId
          bSyncThis = #True
          Break
        EndIf
      Next nOCMMatrixItem
      ; end added 7Mar2020 11.8.2.2be
      ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\aCueMarker(" + nMarkerIndex + ")\nCueMarkerId=" + \nCueMarkerId + ", \nCueMarkerPosition=" + \nCueMarkerPosition + ", \nCueMarkerType=" + \nCueMarkerType + ", bSyncThis=" + strB(bSyncThis))
      If bSyncThis ; test added 7Mar2020 11.8.2.2be
        If aAud(pAudPtr)\bUsingSplitStream
          d = aAud(pAudPtr)\nFirstSoundingDev
          If d >= 0
            nChannel = aAud(pAudPtr)\nBassChannel[d]
            nAltChannel = aAud(pAudPtr)\nBassAltChannel[d]
          EndIf
        Else
          nChannel = aAud(pAudPtr)\nSourceChannel
          nAltChannel = aAud(pAudPtr)\nSourceAltChannel
        EndIf
        If (nChannel <> 0) And (\nCueMarkerPosition >= 0)
          dTmpDouble = \nCueMarkerPosition / 1000.0
          \qBassMarkerByte = BASS_ChannelSeconds2Bytes(nChannel, dTmpDouble)
          qFileDurationByte = BASS_ChannelGetLength(nChannel, #BASS_POS_BYTE)
          debugMsg2(sProcName, "BASS_ChannelGetLength(" + decodeHandle(nChannel) + ", #BASS_POS_BYTE)", qFileDurationByte)
          If qFileDurationByte = -1
            debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
          EndIf
          
          debugMsg(sProcName, "\aCueMarker(" + nMarkerIndex + ")\sCueMarkerName=" + \sCueMarkerName + ", \qBassMarkerByte=" + \qBassMarkerByte + ", qFileDurationByte=" + qFileDurationByte)
          
          If \qBassMarkerByte < qFileDurationByte Or 1=1
            ; Tests of cue marker processing found that under some circumstances the procedure MarkerSyncProc() was not called when expected.
            ; -------------------------------------------------------------------------------------------------------------------------------
            ; After raising this issue with Ian Luck (BASS developer) 27-30 Jun 2018, Ian replied:
            ;   From what you say, it sounds like a case of the sync's position having already passed when the sync is set. To confirm whether this is the 
            ;   case, please try checking the "decoding" position just before setting the sync, by using the BASS_POS_DECODE flag in a BASS_ChannelGetPosition 
            ;   call. If that position is ahead of the sync's position then the sync won't be triggered (until playback is restarted from an earlier 
            ;   position). The reason for that is that BASS_SYNC_POS syncs are triggered when decoding reaches the requested position (the SYNCPROC call is then 
            ;   delayed until the position is heard if the sync isn't "mixtime")
            ; Following further testing and advice from Ian, it appears this can occur if BASS_ChannelUpdate() is called BEFORE BASS_ChannelSetSync() for a sync
            ; position that is within the update period (ie the size of the playback buffer, which is 5 seconds by default in SCS).
            ; If the condition DOES occur, then it can be fixed in this procedure by resetting the position to 0, then calling BASS_ChannelSetSync(), and then
            ; resetting back to the prior position. Hopefully this bit of code will rarely be called as openMediaFile() has now been modified to ensure
            ; BASS_ChannelUpdate() calls are performed AFTER BASS_ChannelSetSync() calls.
            ; 
            For nPass = 1 To 2
              If nPass = 1
                nPassChannel = nChannel
              Else
                nPassChannel = nAltChannel
              EndIf
              If nPassChannel <> 0
                ; step 1: get the current decode position
                qChannelDecodePosition = BASS_ChannelGetPosition(nPassChannel, #BASS_POS_DECODE)
                debugMsg3(sProcName, "BASS_ChannelGetPosition(" + decodeHandle(nPassChannel) + ", #BASS_POS_DECODE) returned qChannelDecodePosition=" + qChannelDecodePosition +
                                     " (" + StrD(BASS_ChannelBytes2Seconds(nPassChannel, qChannelDecodePosition),3) + ")")
                ; Added 25Nov2022 11.9.7am
                If qChannelDecodePosition = -1
                  debugMsg(sProcName, "Error " + BASS_ErrorGetCode() + ": " + getBassErrorDesc(BASS_ErrorGetCode()))
                  qChannelDecodePosition = 0
                EndIf
                ; End added 25Nov2022 11.9.7am
                
                ; step 2: check if the current decode position is ahead of the required marker position 
                If qChannelDecodePosition > \qBassMarkerByte
                  ; the current decode position IS ahead of the required marker position
                  ; get the current playback position (so we can re-position the channel after the reset)
                  qChannelBytePosition = BASS_ChannelGetPosition(nPassChannel, #BASS_POS_BYTE)
                  ; Added 25Nov2022 11.9.7am
                  If qChannelBytePosition = -1
                    debugMsg(sProcName, "Error " + BASS_ErrorGetCode() + ": " + getBassErrorDesc(BASS_ErrorGetCode()))
                    qChannelBytePosition = 0
                  EndIf
                  ; End added 25Nov2022 11.9.7am
                  ; debugMsg3(sProcName, "BASS_ChannelBytes2Seconds(" + decodeHandle(nPassChannel) + ", " + qChannelBytePosition + ") returned " + StrD(BASS_ChannelBytes2Seconds(nPassChannel, qChannelBytePosition),3))
                  ; now reset the channel (see the BASS documentation for more info)
                  nBassResult = BASS_ChannelSetPosition(nPassChannel, 0, #BASS_POS_BYTE)
                  debugMsg2(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nPassChannel) + ", 0, #BASS_POS_BYTE)", nBassResult)
                  ; set sync point at specified position
                  If nPass = 1
                    aAud(pAudPtr)\aCueMarker(nMarkerIndex)\nBassMarkerSync = BASS_ChannelSetSync(nPassChannel, nPosSyncType, \qBassMarkerByte, @MarkerSyncProc(), pAudPtr)
                    newHandle(#SCS_HANDLE_SYNC, \nBassMarkerSync, #False)
                    debugMsg2(sProcName, "BASS_ChannelSetSync(" + decodeHandle(nPassChannel) + ", " + sPosSyncType + ", " + \qBassMarkerByte + ", @MarkerSyncProc(), " + getAudLabel(pAudPtr) + ")", \nBassMarkerSync)
                    If \nBassMarkerSync = 0
                      debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                    EndIf
                  Else
                    aAud(pAudPtr)\aCueMarker(nMarkerIndex)\nBassMarkerAltSync = BASS_ChannelSetSync(nPassChannel, nPosSyncType, \qBassMarkerByte, @MarkerSyncProc(), pAudPtr)
                    newHandle(#SCS_HANDLE_SYNC, \nBassMarkerAltSync, #False)
                    debugMsg2(sProcName, "BASS_ChannelSetSync(" + decodeHandle(nPassChannel) + ", " + sPosSyncType + ", " + \qBassMarkerByte + ", @MarkerSyncProc(), " + getAudLabel(pAudPtr) + ")", \nBassMarkerAltSync)
                    If \nBassMarkerAltSync = 0
                      debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                    EndIf
                  EndIf
                  ; now reset the playback position
                  nBassResult = BASS_ChannelSetPosition(nPassChannel, qChannelBytePosition, #BASS_POS_BYTE)
                  debugMsg2(sProcName, "BASS_ChannelSetPosition(" + decodeHandle(nPassChannel) + ", " + qChannelBytePosition + ", #BASS_POS_BYTE)", nBassResult)
                  ; all done!
                  
                Else
                  ; the current decode position IS NOT ahead of the required marker position, so no special action required
                  ; set sync point at specified position
                  If nPass = 1
                    aAud(pAudPtr)\aCueMarker(nMarkerIndex)\nBassMarkerSync = BASS_ChannelSetSync(nPassChannel, nPosSyncType, \qBassMarkerByte, @MarkerSyncProc(), pAudPtr)
                    newHandle(#SCS_HANDLE_SYNC, \nBassMarkerSync, #False)
                    debugMsg2(sProcName, "BASS_ChannelSetSync(" + decodeHandle(nPassChannel) + ", " + sPosSyncType + ", " + \qBassMarkerByte + ", @MarkerSyncProc(), " + getAudLabel(pAudPtr) + ")", \nBassMarkerSync)
                    If \nBassMarkerSync = 0
                      debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                    EndIf
                    aAud(pAudPtr)\aCueMarker(nMarkerIndex)\nBassMarkerSyncChannel = nPassChannel                
                  Else
                    aAud(pAudPtr)\aCueMarker(nMarkerIndex)\nBassMarkerAltSync = BASS_ChannelSetSync(nPassChannel, nPosSyncType, \qBassMarkerByte, @MarkerSyncProc(), pAudPtr)
                    newHandle(#SCS_HANDLE_SYNC, \nBassMarkerAltSync, #False)
                    debugMsg2(sProcName, "BASS_ChannelSetSync(" + decodeHandle(nPassChannel) + ", " + sPosSyncType + ", " + \qBassMarkerByte + ", @MarkerSyncProc(), " + getAudLabel(pAudPtr) + ")", \nBassMarkerAltSync)
                    If \nBassMarkerAltSync = 0
                      debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
                    EndIf
                    aAud(pAudPtr)\aCueMarker(nMarkerIndex)\nBassMarkerAltSyncChannel = nPassChannel                
                  EndIf
                  
                EndIf
              EndIf ; EndIf nPassChannel <> 0
            Next nPass
          EndIf ; EndIf \qBassMarkerByte < qFileDurationByte
        EndIf ; EndIf (nChannel <> 0) And (\nCueMarkerPosition >= 0)
      EndIf ; EndIf bSyncThis
    EndWith
  Next nMarkerIndex
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure slideChannelAttributes(pAudPtr, nDev, fBVLevel.f, fPan.f, nTime, nLabel=0)
  PROCNAMECA(pAudPtr)
  Protected nBassResult.l
  Protected nChannel.l, nAltChannel.l
  Protected fMainLevel.f, fAltLevel.f
  Protected bInXfade, nLoopXFadeTime, qTimeNow.q, nXFadeTimeRemaining
  Protected nSlideTime.l
  Protected fAdjBVLevel.f
  Protected nDevMapDevPtr = -1
  Protected fOutputGain.f
  
  If nLabel > 0
    sProcName + "(" + nLabel + ")"
  EndIf
  
  CompilerIf #cTraceSetLevels
    debugMsg(sProcName, #SCS_START + ", nDev=" + nDev + ", fBVLevel=" + formatLevel(fBVLevel) + ", fPan=" + formatPan(fPan) + ", nTime=" + nTime + ", nLabel=" + nLabel)
  CompilerEndIf

  With aAud(pAudPtr)
    
    fAdjBVLevel = fBVLevel
    If fBVLevel <> #SCS_NOVOLCHANGE_SINGLE
      If gbUseBASSMixer = #False
        nDevMapDevPtr = \nOutputDevMapDevPtr[nDev]
        If nDevMapDevPtr >= 0
          fOutputGain = grMaps\aDev(nDevMapDevPtr)\fDevOutputGain
          If fOutputGain <> 1.0
            fAdjBVLevel * fOutputGain
          EndIf
        EndIf
      EndIf
      CompilerIf #cTraceSetLevels
        debugMsg(sProcName, "pAudPtr=" + getAudLabel(pAudPtr) + ", nDev=" + Str(nDev) + ", fBVLevel=" + formatLevel(fBVLevel) + ", fAdjBVLevel=" + formatLevel(fAdjBVLevel) + ", fPan=" + Str(fPan))
        If nDevMapDevPtr >= 0
          debugMsg(sProcName, "grMaps\aDev(" + nDevMapDevPtr + ")\fDevOutputGain=" + traceLevel(grMaps\aDev(nDevMapDevPtr)\fDevOutputGain))
        EndIf
      CompilerEndIf
    EndIf
    
    nChannel = \nBassChannel[nDev]
    nAltChannel = \nBassAltChannel[nDev]
    bInXfade = \bInLoopXFade
    
    nSlideTime = nTime
    CompilerIf 1=2 ; blocked out 11Dec2019 11.8.2.1ab as this causes 'instant' level changes to not be instant - see also continueXFade() which handles the continuation of a cross-fade after the end of a level change cue
      If bInXfade
        ; debugMsg(sProcName, "bInXfade=" + strB(bInXfade) + ", nChannel=" + decodeHandle(nChannel) + ", nAltChannel=" + decodeHandle(nAltChannel))
        nLoopXFadeTime = \rCurrLoopInfo\nLoopXFadeTime
        qTimeNow = ElapsedMilliseconds()
        nXFadeTimeRemaining = \rCurrLoopInfo\nLoopXFadeTime - (qTimeNow - \qTimePassStarted)
        ; debugMsg(sProcName, "\nLoopXFadeTime=" + \nLoopXFadeTime + ", qTimeNow=" + qTimeNow + ", \qTimePassStarted=" + \qTimePassStarted + ", nXFadeTimeRemaining=" + nXFadeTimeRemaining)
        If nXFadeTimeRemaining < 0
          nXFadeTimeRemaining = 0
        EndIf
        If (nSlideTime > nXFadeTimeRemaining) Or (nSlideTime = 0) ; 20May2017 11.6.2ac added test (nSlideTime = 0) in fix for C.Peters error about Shift+F11/F12 jumping levels
          nSlideTime = nXFadeTimeRemaining
        EndIf
      EndIf
    CompilerEndIf
  EndWith
  
  If gbUseBASS  ; BASS
    If nChannel <> 0
      ; Added 4Feb2025 11.10.6 following bug reported by Mika Filpus related to very short fade-in times
      If aAud(pAudPtr)\nAudState = #SCS_CUE_FADING_IN And aAud(pAudPtr)\bFadeInOneAudIssuedSlideChannelAttributes
        ; No action here because fadeInOneAud() called BASS_ChannelSlideAttribute() to execute the whole fade in.
      Else
        ; End added 4Feb2025 11.10.6
        If (nAltChannel = 0) Or (bInXfade = #False) Or (fAdjBVLevel = #SCS_NOVOLCHANGE_SINGLE)
          fMainLevel = fAdjBVLevel
          fAltLevel = #SCS_NOVOLCHANGE_SINGLE
        ElseIf bInXfade
          ; added 20May2017 11.6.2ac in fix for C.Peters error about Shift+F11/F12 jumping levels
          fMainLevel = #SCS_MINVOLUME_SINGLE
          fAltLevel = fBVLevel
        Else
          fMainLevel = fAdjBVLevel * (nXFadeTimeRemaining / nLoopXFadeTime)
          fAltLevel = fAdjBVLevel - fMainLevel
          ; debugMsg3(sProcName, "fAdjBVLevel=" + formatLevel(fAdjBVLevel) + ", fMainLevel=" + traceLevel(fMainLevel) + ", fAltLevel=" + formatLevel(fAltLevel) + ", \nLoopXFadeTime=" + Str(aAud(pAudPtr)\nLoopXFadeTime) + ", nTimeNow=" + traceTime(nTimeNow) + ", \qTimePassStarted=" + traceTime(aAud(pAudPtr)\qTimePassStarted) + ", nXFadeTimeRemaining=" + Str(nXFadeTimeRemaining))
          If fMainLevel < #SCS_MINVOLUME_SINGLE
            fMainLevel = #SCS_MINVOLUME_SINGLE
          EndIf
          If fAltLevel < #SCS_MINVOLUME_SINGLE
            fAltLevel = #SCS_MINVOLUME_SINGLE
          EndIf
        EndIf
        ; debugMsg(sProcName, "fMainLevel=" + formatLevel(fMainLevel))
        If fMainLevel <> #SCS_NOVOLCHANGE_SINGLE
          ; debugMsg(sProcName, "change")
          ; Added 27Sep2022 11.9.6
          If fMainLevel <= grLevels\fMinBVLevel
            fMainLevel = 0.0
          EndIf
          ; End added 27Sep2022 11.9.6
          nBassResult = BASS_ChannelSlideAttribute(nChannel, #BASS_ATTRIB_VOL, fMainLevel, nSlideTime)
          CompilerIf #cTraceSetLevels
            debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nChannel) + ", #BASS_ATTRIB_VOL, " + traceLevel(fMainLevel) + ", " + nSlideTime + ")", nBassResult)
          CompilerElse
            If nLabel = 250001
              debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nChannel) + ", #BASS_ATTRIB_VOL, " + traceLevel(fMainLevel) + ", " + nSlideTime + ")", nBassResult)
            EndIf
          CompilerEndIf
          ; Else
          ; debugMsg(sProcName, "NO change")
        EndIf
        
        If fAltLevel <> #SCS_NOVOLCHANGE_SINGLE
          ; Added 27Sep2022 11.9.6
          If fAltLevel <= grLevels\fMinBVLevel
            fAltLevel = 0.0
          EndIf
          ; End added 27Sep2022 11.9.6
          nBassResult = BASS_ChannelSlideAttribute(nAltChannel, #BASS_ATTRIB_VOL, fAltLevel, nSlideTime)
          CompilerIf #cTraceSetLevels
            debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nAltChannel) + ", #BASS_ATTRIB_VOL, " + traceLevel(fAltLevel) + ", " + nSlideTime + ")", nBassResult)
          CompilerElse
            If nLabel = 250001
              debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nAltChannel) + ", #BASS_ATTRIB_VOL, " + traceLevel(fAltLevel) + ", " + nSlideTime + ")", nBassResult)
            EndIf
          CompilerEndIf
        EndIf
        
        If fPan <> #SCS_NOPANCHANGE_SINGLE
          nBassResult = BASS_ChannelSlideAttribute(nChannel, #BASS_ATTRIB_PAN, fPan, nSlideTime)
          CompilerIf #cTraceSetLevels
            debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nChannel) + ", #BASS_ATTRIB_PAN, " + formatLevel(fPan) + ", " + Str(nSlideTime) + ")", nBassResult)
          CompilerEndIf
          If nAltChannel <> 0
            nBassResult = BASS_ChannelSlideAttribute(nAltChannel, #BASS_ATTRIB_PAN, fPan, nSlideTime)
            CompilerIf #cTraceSetLevels
              debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nAltChannel) + ", #BASS_ATTRIB_PAN, " + formatLevel(fPan) + ", " + Str(nSlideTime) + ")", nBassResult)
            CompilerEndIf
          EndIf
        EndIf
        
      EndIf
      
    EndIf
    
  ElseIf gbUseSMS ; SM-S
    
  EndIf
  
  If WCN\nPlayingSubTypeF = aAud(pAudPtr)\nSubIndex
    WCN\bRefreshAudioChannelFaders = #True
    ; debugMsg(sProcName, "WCN\bRefreshAudioChannelFaders=" + strB(WCN\bRefreshAudioChannelFaders))
  EndIf
  
EndProcedure

Procedure initDevice(nPhysicalDevIndex, bDisplayErrors=#True)
  PROCNAMEC()
  Protected nBassResult.l, nFlags.l, n
  Protected nMyDSSampleRate.l, dMyAsioSampleRate.d
  Protected bModalDisplayed
  Protected nMySpeakers.l
  Protected sMsg.s
  Protected nReturnValue
  Protected nBassInitWindowHandle.l, sBassInitWindowHandle.s
  Protected sSampleRate.s
  Protected nTmpFreq.l  ; long
  Protected nRealPhysDevPtr
  Protected nMousePointer
  Protected nAudioDriver
  Protected d
  Protected nDefaultDevPtr
  
  debugMsg(sProcName, #SCS_START + ", nPhysicalDevIndex=" + nPhysicalDevIndex)
  
  nReturnValue = #BASS_OK
  
  nMousePointer = getMouseCursor()
  setMouseCursorBusy()
  
  nAudioDriver = gaAudioDev(nPhysicalDevIndex)\nAudioDriver
  debugMsg(sProcName, "nAudioDriver=" + decodeDriver(nAudioDriver))
  
  If gaAudioDev(nPhysicalDevIndex)\bNoDevice
    nRealPhysDevPtr = gaAudioDev(nPhysicalDevIndex)\nRealPhysDevPtr
    debugMsg(sProcName, "gaAudioDev(" + nPhysicalDevIndex + ")\bNoDevice=" + strB(gaAudioDev(nPhysicalDevIndex)\bNoDevice) + ", nRealPhysDevPtr=" + nRealPhysDevPtr)
    If nRealPhysDevPtr >= 0
      If gaAudioDev(nRealPhysDevPtr)\bInitialized = #False
        debugMsg(sProcName, "calling initDevice(" + nRealPhysDevPtr + ", " + strB(bDisplayErrors) + ")")
        nReturnValue = initDevice(nRealPhysDevPtr, bDisplayErrors)
      EndIf
      If nReturnValue = #BASS_OK
        gaAudioDev(nPhysicalDevIndex)\bInitialized = #True
      EndIf
      SetMouseCursor(nMousePointer)
      debugMsg(sProcName, "exiting, returning " + getBassErrorDesc(nReturnValue)) ; nb getBassErrorDesc() handles #BASS_OK as well as #BASS_ERROR_...
      ProcedureReturn nReturnValue
    EndIf
  EndIf
  
  bModalDisplayed = gbModalDisplayed
  
  If IsWindow(#WDU) = #False
    createfmDummy()
  EndIf
  If IsWindow(#WDU)
    nBassInitWindowHandle = WindowID(#WDU)
    sBassInitWindowHandle = "WindowID(#WDU)"
  ElseIf IsWindow(#WMN)
    nBassInitWindowHandle = WindowID(#WMN)
    sBassInitWindowHandle = "WindowID(#WMN)"
  ElseIf IsWindow(#WSP)
    nBassInitWindowHandle = WindowID(#WSP)
    sBassInitWindowHandle = "WindowID(#WSP)"
  EndIf
  
  With gaAudioDev(nPhysicalDevIndex)
    
    nMyDSSampleRate = \nSampleRate
    If nMyDSSampleRate = 0
      nMyDSSampleRate = grDriverSettings\nDSSampleRate
      If nMyDSSampleRate = 0
        nMyDSSampleRate = 44100
      EndIf
    EndIf
    
    debugMsg3(sProcName, "gaAudioDev(" + nPhysicalDevIndex + ")\bASIO=" + strB(gaAudioDev(nPhysicalDevIndex)\bASIO))
    
    Select nAudioDriver
      Case #SCS_DRV_BASS_DS, #SCS_DRV_BASS_WASAPI ; SCS_ADRV_BASS_DS, SCS_DRV_BASS_WASAPI
        debugMsg(sProcName, decodeDriver(nAudioDriver))
        
        nFlags = \nBassInitFlags
        If gbWasapiAvailable = #False Or nAudioDriver = #SCS_DRV_BASS_DS
          nFlags | #BASS_DEVICE_DSOUND
        EndIf
        
        debugMsg(sProcName, "Initialising device " + \nBassDevice + ", " + \sDesc + ", nFlags=" + decodeInitFlags(nFlags))
        nBassResult = BASS_Init(\nBassDevice, nMyDSSampleRate, nFlags, nBassInitWindowHandle, 0)     ; NB sample rate not used - see BASS help and forum
        debugMsg2(sProcName, "BASS_Init(" + \nBassDevice + ", " + nMyDSSampleRate + ", " + decodeInitFlags(nFlags) + ", " + sBassInitWindowHandle + ", 0)", nBassResult)
        If nBassResult = #BASSTRUE
          \nBassInitErrorCode = #BASS_OK
        Else
          \nBassInitErrorCode = BASS_ErrorGetCode()
          debugMsg3(sProcName, "(ds) error: " + getBassErrorDesc(\nBassInitErrorCode))
          If \nBassInitErrorCode = #BASS_ERROR_ALREADY
            \nBassInitErrorCode = #BASS_OK
          EndIf
        EndIf
        
        If \nBassInitErrorCode = #BASS_OK
          \bInitialized = #True
          nBassResult = BASS_GetInfo(@\rBassInfo)
          debugMsg2(sProcName, "BASS_GetInfo(@\rBassInfo)", nBassResult)
          ; freq not available on Windows prior to Vista, and will be set to 0 by BASS
          \nSampleRate = \rBassInfo\freq
          debugMsg(sProcName, "gaAudioDev(" + nPhysicalDevIndex + ")\nSampleRate=" + \nSampleRate)
          If (\nSampleRate <> 0) And (\nSampleRate <> nMyDSSampleRate) And (\bNoDevice = #False) And (\nBassInitErrorCode = #BASS_OK)
            ; sample rate of device is different to the initialized rate, so free the device and reinitialize with the required sample rate
            nMyDSSampleRate = \nSampleRate
            
            nBassResult = BASS_Free()
            debugMsg2(sProcName, "BASS_Free() for device " + \nBassDevice, nBassResult)
            \bInitialized = #False
            
            nBassResult = BASS_Init(\nBassDevice, nMyDSSampleRate, nFlags, nBassInitWindowHandle, 0)     ; NB sample rate not used - see BASS help and forum
            debugMsg2(sProcName, "BASS_Init(" + \nBassDevice + ", " + nMyDSSampleRate + ", " + decodeInitFlags(nFlags) + ", " + sBassInitWindowHandle + ", 0)", nBassResult)
            If nBassResult = #BASSTRUE
              \nBassInitErrorCode = #BASS_OK
            Else
              \nBassInitErrorCode = BASS_ErrorGetCode()
              debugMsg3(sProcName, "(ds) error: " + getBassErrorDesc(\nBassInitErrorCode))
              If \nBassInitErrorCode = #BASS_ERROR_ALREADY
                \nBassInitErrorCode = #BASS_OK
              EndIf
            EndIf
            
            If \nBassInitErrorCode = #BASS_OK
              \bInitialized = #True
              nBassResult = BASS_GetInfo(@\rBassInfo)
              debugMsg2(sProcName, "BASS_GetInfo(@\rBassInfo)", nBassResult)
              ; freq not available on Windows prior to Vista, and will be set to 0 by BASS
              \nSampleRate = \rBassInfo\freq
              debugMsg(sProcName, "gaAudioDev(" + Str(nPhysicalDevIndex) + ")\nSampleRate=" + \nSampleRate)
            EndIf
            
          EndIf
          
          If \nBassInitErrorCode = #BASS_OK
            debugMsg3(sProcName, "gaAudioDev(" + nPhysicalDevIndex + ")\rBassInfo\flags=$" + Hex(\rBassInfo\flags) + ", \minrate=" + \rBassInfo\minrate + ", \maxrate=" + \rBassInfo\maxrate +
                                 ", \minbuf=" + \rBassInfo\minbuf + ", \dsver=" + \rBassInfo\dsver + ", \initflags=" + decodeInitFlags(\rBassInfo\initflags ) + ", \speakers=" + \rBassInfo\speakers + ", \freq=" + \rBassInfo\freq)
            If \rBassInfo\speakers = 0
              ; freq not available on Windows prior to Vista, and will be set to 0 by BASS
              \rBassInfo\speakers = 2
            EndIf
          EndIf
          
          If \nBassInitErrorCode <> #BASS_OK
            nReturnValue = \nBassInitErrorCode
            If bDisplayErrors
              sMsg = \sDesc + " cannot be used as it could not be initialized. "
              If \nBassInitErrorCode = #BASS_ERROR_DRIVER
                sMsg + "This may because a free sound driver cannot be found (which can occur for emulated sound devices like 'Modem #0 Line Playback'), "
                sMsg + "or the device is already in use (which can occur with some sound cards if a required output channel is already assigned to ASIO output)."
              Else
                sMsg + getBassErrorDesc(\nBassInitErrorCode)
              EndIf
              gbModalDisplayed = #True
              debugMsg(sProcName, sMsg)
              ensureSplashNotOnTop()
              scsMessageRequester("Initialize Device", sMsg, #PB_MessageRequester_Error)
              gbModalDisplayed = bModalDisplayed
            EndIf
          EndIf
          
        EndIf
        
      Case #SCS_DRV_BASS_ASIO    ; SCS_ADRV_BASS_ASIO
        ; debugMsg(sProcName, "BASS_ASIO")
        \nBassDevice = initBassNoSoundDev()
        debugMsg(sProcName, "gaAudioDev(" + nPhysicalDevIndex + ")\nBassDevice=" + \nBassDevice)
        
        debugMsg(sProcName, "calling BASS_ASIO_Init(" + \nDevBassASIODevice + ", #BASS_ASIO_THREAD)")
        nBassResult = BASS_ASIO_Init(\nDevBassASIODevice, #BASS_ASIO_THREAD)
        debugMsg2(sProcName, "BASS_ASIO_Init(" + \nDevBassASIODevice + ", #BASS_ASIO_THREAD)", nBassResult)
        ; Added 26May2020 11.8.3rc5c following emails from Ross Gerbasi where BASS_ASIO_THREAD seems to prevent BASS_ASIO_Init() succeeding when initializing a Dante Via ASIO device
        If nBassResult = #BASSFALSE
          nBassResult = BASS_ASIO_Init(\nDevBassASIODevice, 0)
          debugMsg2(sProcName, "BASS_ASIO_Init(" + \nDevBassASIODevice + ", 0)", nBassResult)
        EndIf
        ; End added 26May2020 11.8.3rc5c
        If nBassResult = #BASSTRUE
          \nBassInitErrorCode = #BASS_OK
        Else
          \nBassInitErrorCode = BASS_ASIO_ErrorGetCode()
          If \nBassInitErrorCode = #BASS_ERROR_ALREADY
            \nBassInitErrorCode = #BASS_OK
          EndIf
        EndIf
        
        If \nBassInitErrorCode = #BASS_OK
          gbAsioInitDone = #True
          \bInitialized = #True
          dMyAsioSampleRate = BASS_ASIO_GetRate()
          debugMsg(sProcName, "BASS_ASIO_GetRate() returned " + StrD(dMyAsioSampleRate,0))
          If dMyAsioSampleRate = -1
            ; shouldn't get here
            dMyAsioSampleRate = grDriverSettings\nDSSampleRate
          EndIf
          \nSampleRate = dMyAsioSampleRate
          debugMsg(sProcName, "\nSampleRate=" + \nSampleRate)
          If \nAudioDriver = gnCurrAudioDriver
            setMasterFader(grProd\fMasterBVLevel)
            debugMsg(sProcName, "calling setAllInputGains()")
            setAllInputGains()
            debugMsg(sProcName, "calling setAllLiveEQ()")
            setAllLiveEQ()
          EndIf
        Else
          nReturnValue = \nBassInitErrorCode
          debugMsg3(sProcName, "(asio) error: " + getBassErrorDesc(nReturnValue))
          If bDisplayErrors
            gbModalDisplayed = #True
            ASIO_Error_(sProcName, "Can't initialize ASIO device " + \nDevBassASIODevice + ", " + \sDesc)
            gbModalDisplayed = bModalDisplayed
          EndIf
        EndIf
        
      Case #SCS_DRV_SMS_ASIO     ; SCS_ADRV_SMS_ASIO
        debugMsg(sProcName, "SMS_ASIO")
        \nBassDevice = initBassNoSoundDev() ;initialize BASS with "no sound" device so that various BASS functions may be used, eg BASS_Encode...
        debugMsg(sProcName, "gaAudioDev(" + nPhysicalDevIndex + ")\nBassDevice=" + \nBassDevice)
        \bInitialized = #True
        If \nAudioDriver = gnCurrAudioDriver
          setMasterFader(grProd\fMasterBVLevel)
          debugMsg(sProcName, "calling setAllInputGains()")
          setAllInputGains()
          debugMsg(sProcName, "calling setAllLiveEQ()")
          setAllLiveEQ()
        EndIf
        
    EndSelect
    
    If \bDefaultDev = #False
      nDefaultDevPtr = getPhysicalDevPtrOfDefaultDev(#SCS_DEVTYPE_AUDIO_OUTPUT)
      If nDefaultDevPtr >= 0
        Select nAudioDriver
          Case #SCS_DRV_BASS_DS, #SCS_DRV_BASS_WASAPI
            If gaAudioDev(nDefaultDevPtr)\nBassDevice = \nBassDevice
              gaAudioDev(nDefaultDevPtr)\bInitialized = \bInitialized
              debugMsg(sProcName, "(defaultdev) gaAudioDev(" + nDefaultDevPtr + ")\bInitialized=" + strB(gaAudioDev(nDefaultDevPtr)\bInitialized))
            EndIf
        EndSelect
      EndIf
    EndIf
    
  EndWith
  
  setMouseCursor(nMousePointer)
  
  debugMsg(sProcName, #SCS_END + ", returning " + getBassErrorDesc(nReturnValue)) ; nb getBassErrorDesc() handles #BASS_OK as well as #BASS_ERROR_...
  ProcedureReturn nReturnValue
  
EndProcedure

Procedure initVidAudDevice(nPhysicalDevIndex, bDisplayErrors=#True)
  PROCNAMEC()
  Protected nReturnValue
  
  debugMsg(sProcName, #SCS_START + ", nPhysicalDevIndex=" + Str(nPhysicalDevIndex))
  
  nReturnValue = #BASS_OK
  ; nMousePointer = getMouseCursor()
  ; setMouseCursorBusy()
  
  With gaVideoAudioDev(nPhysicalDevIndex)
    \bVidAudInitialized = #True
  EndWith
  
  ; setMouseCursor(nMousePointer)
  
  debugMsg(sProcName, #SCS_END + ", returning " + Str(nReturnValue))
  ProcedureReturn nReturnValue
  
EndProcedure

Procedure initVidCapDevice(nPhysicalDevIndex, bDisplayErrors=#True)
  PROCNAMEC()
  Protected nReturnValue
  
  debugMsg(sProcName, #SCS_START + ", nPhysicalDevIndex=" + nPhysicalDevIndex)
  
  nReturnValue = #BASS_OK
  ; nMousePointer = getMouseCursor()
  ; setMouseCursorBusy()
  
  With gaVideoCaptureDev(nPhysicalDevIndex)
    \bVidCapInitialized = #True
  EndWith
  
  ; setMouseCursor(nMousePointer)
  
  debugMsg(sProcName, #SCS_END + ", returning " + nReturnValue)
  ProcedureReturn nReturnValue
  
EndProcedure

Procedure openNormal(pAudPtr, d, nBassSpeaker, nStreamCreateFlags.l, nDecodeStreamCreateFlags.l)
  PROCNAME(buildAudProcName(#PB_Compiler_Procedure, pAudPtr) + "(" + d + ")")
  Protected bOKToUseFloat
  Protected nBassResult.l
  Protected nFlags.l, nHoldFlags.l
  Protected nDevChans
  Protected bDownmixLeft, bDownmixRight
  Protected nDevMapPtr, nDevMapDevPtr
  Protected nBassError.l
  Protected sMsg.s, nReply
  Protected nUserParam.l
  Protected nSplitStreamSourceChannel.l
  Protected nSplitterChannel.l, nSplitterAltChannel.l
  Protected nOrigGaplessStream, bCreatedGaplessStream
  Protected bCreateSplitStream ;, bIgnoreDSPProcessing
  Protected nFirstGaplessAudPtr
  Protected bVSTLoadResult.i
  
  debugMsg3(sProcName, #SCS_START)
  
  nDevMapPtr = grProd\nSelectedDevMapPtr
  If nDevMapPtr < 0
    ProcedureReturn
  EndIf
  
  With aAud(pAudPtr)
    
    nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_AUDIO_OUTPUT, \sLogicalDev[d])
    \nOutputDevMapDevPtr[d] = nDevMapDevPtr
    If nDevMapDevPtr >= 0
      nDevChans = grMaps\aDev(nDevMapDevPtr)\nNrOfDevOutputChans
    EndIf
    
    debugMsg(sProcName, "\nFileChannels=" + \nFileChannels + ", nDevChans=" + nDevChans)
    If nStreamCreateFlags <> 0 Or nDecodeStreamCreateFlags <> 0
      debugMsg(sProcName, "nStreamCreateFlags=" + decodeStreamCreateFlags(nStreamCreateFlags) + ", nDecodeStreamCreateFlags=" + decodeStreamCreateFlags(nDecodeStreamCreateFlags))
    EndIf
    
    \nDSPInd[d] = #SCS_DSP_NONE
    \nBassStreamCreateFlags[d] = nStreamCreateFlags | nBassSpeaker
    ; do not add nBassSpeaker to nBassDecodeStreamCreateFlags
    \nBassDecodeStreamCreateFlags[d] = nDecodeStreamCreateFlags
    If \nBassStreamCreateFlags[d] <> 0 Or \nBassDecodeStreamCreateFlags[d] <> 0
      debugMsg(sProcName, "\nBassStreamCreateFlags[" + d + "]=" + decodeStreamCreateFlags(\nBassStreamCreateFlags[d]) + ",\nBassDecodeStreamCreateFlags[" + d + "]=" + decodeStreamCreateFlags(\nBassDecodeStreamCreateFlags[d]))
    EndIf
    
    If grDriverSettings\bNoFloatingPoint = #False
      bOKToUseFloat = #True
    EndIf
    
    If bOKToUseFloat
      SetFlag(\nBassStreamCreateFlags[d], #BASS_SAMPLE_FLOAT)
      SetFlag(\nBassDecodeStreamCreateFlags[d], #BASS_SAMPLE_FLOAT)
      \bBassFloat = #True  ; nb may be overridden if the file cannot be opened with float
    Else
      \bBassFloat = #False
    EndIf
    
    debugMsg(sProcName, "\nBassDevice[" + d + "]=" + \nBassDevice[d] + ", gbUseBASSMixer=" + strB(gbUseBASSMixer))
    If (\nBassDevice[d] = 0) Or (gbUseBASSMixer) 
      ; The "no sound" BASS device can only be used with decoding channels
      \nBassStreamCreateFlags[d] = \nBassDecodeStreamCreateFlags[d] ; throw away any flags not permitted with decode channels
      \nBassStreamCreateFlags[d] | #BASS_STREAM_DECODE
    EndIf
    
    If d = \nFirstSoundingDev
      
      ; attempt 1: no special flags
      \nSourceChannel = openFileForBASS(pAudPtr, d)
      If \nSourceChannel <> 0
        If usingLoopXFade(pAudPtr)
          \nSourceAltChannel = openFileForBASS(pAudPtr, d)
        EndIf
      EndIf
      
      If \nSourceChannel = 0
        ; attempt 2 if #BASS_ERROR_SPEAKER: try with #BASS_SAMPLE_MONO flag
        If grMMedia\nStreamCreateError = #BASS_ERROR_SPEAKER
          nHoldFlags = \nBassStreamCreateFlags[d]
          SetFlag(\nBassStreamCreateFlags[d], #BASS_SAMPLE_MONO)
          \nSourceChannel = openFileForBASS(pAudPtr, d)
          If \nSourceChannel <> 0
            If usingLoopXFade(pAudPtr)
              \nSourceAltChannel = openFileForBASS(pAudPtr, d)
            EndIf
          Else
            ; that didn't work, so undo change to flags
            \nBassStreamCreateFlags[d] = nHoldFlags
          EndIf
        EndIf
      EndIf
      
      If \nSourceChannel = 0
        debugMsg(sProcName, "\bBassFloat=" + strB(\bBassFloat) + ", nDevChans=" + nDevChans + ", \nFileChannels=" + \nFileChannels)
        ; attempt 3 if #BASS_ERROR_SPEAKER: try using SCS downmix (only if stereo to a 'left' or 'right' mono output - not downmixes like 5.1 to mono or stereo, etc)
        ; (this method only available when using #BASS_SAMPLE_FLOAT as the DSP code is currently only float-compatible)
        If (grMMedia\nStreamCreateError = #BASS_ERROR_SPEAKER) And (\bBassFloat)
          If nDevChans = 1 ; And \nFileChannels = 2
            ; need to get SCS to downmix stereo to mono, because #BASS didn't handle this with #BASS_SAMPLE_MONO
            nHoldFlags = \nBassStreamCreateFlags[d]
            If (nHoldFlags & #BASS_SPEAKER_LEFT) = #BASS_SPEAKER_LEFT
              bDownmixLeft = #True
              \nBassStreamCreateFlags[d] ! #BASS_SPEAKER_LEFT
              debugMsg(sProcName, "downmix left")
            ElseIf (nHoldFlags & #BASS_SPEAKER_RIGHT) = #BASS_SPEAKER_RIGHT
              bDownmixRight = #True
              \nBassStreamCreateFlags[d] ! #BASS_SPEAKER_RIGHT
              debugMsg(sProcName, "downmix right")
            EndIf
            If bDownmixLeft
              \nSourceChannel = openFileForBASS(pAudPtr, d)
              If \nSourceChannel <> 0
                \nDSPInd[d] = #SCS_DSP_LEFT
                nBassResult = BASS_ChannelSetDSP(\nSourceChannel, @Stereo2MonoLeftDSP(), (pAudPtr * 100) + d, 1)
                debugMsg2(sProcName, "BASS_ChannelSetDSP(" + decodeHandle(\nSourceChannel) + ", @Stereo2MonoLeftDSP(), " + Str((pAudPtr * 100) + d) + ", 1)", nBassResult)
                If usingLoopXFade(pAudPtr)
                  \nSourceAltChannel = openFileForBASS(pAudPtr, d)
                  nBassResult = BASS_ChannelSetDSP(\nSourceAltChannel, @Stereo2MonoLeftDSP(), (pAudPtr * 100) + d, 1)
                  debugMsg2(sProcName, "BASS_ChannelSetDSP(" + decodeHandle(\nSourceAltChannel) + ", @Stereo2MonoLeftDSP(), " + Str((pAudPtr * 100) + d) + ", 1)", nBassResult)
                EndIf
              EndIf
            ElseIf bDownmixRight
              \nSourceChannel = openFileForBASS(pAudPtr, d)
              If \nSourceChannel <> 0
                \nDSPInd[d] = #SCS_DSP_RIGHT
                nBassResult = BASS_ChannelSetDSP(\nSourceChannel, @Stereo2MonoRightDSP(), (pAudPtr * 100) + d, 1)
                debugMsg2(sProcName, "BASS_ChannelSetDSP(" + decodeHandle(\nSourceChannel) + ", @Stereo2MonoRightDSP(), " + Str((pAudPtr * 100) + d) + ", 1)", nBassResult)
                If usingLoopXFade(pAudPtr)
                  \nSourceAltChannel = openFileForBASS(pAudPtr, d)
                  nBassResult = BASS_ChannelSetDSP(\nSourceAltChannel, @Stereo2MonoRightDSP(), (pAudPtr * 100) + d, 1)
                  debugMsg2(sProcName, "BASS_ChannelSetDSP(" + decodeHandle(\nSourceAltChannel) + ", @Stereo2MonoRightDSP(), " + Str((pAudPtr * 100) + d) + ", 1)", nBassResult)
                EndIf
              EndIf
            EndIf
            If \nSourceChannel = 0
              ; that didn't work, so undo change to flags
              \nBassStreamCreateFlags[d] = nHoldFlags
            EndIf
          EndIf
        EndIf
      EndIf
      
      If \nSourceChannel = 0
        ; attempt 4: if we still can't create the stream, try without #BASS_SAMPLE_FLOAT
        ClearFlag(\nBassStreamCreateFlags[d], #BASS_SAMPLE_FLOAT)
        ClearFlag(\nBassDecodeStreamCreateFlags[d], #BASS_SAMPLE_FLOAT)
        \nSourceChannel = openFileForBASS(pAudPtr, d)
        If \nSourceChannel <> 0
          \bBassFloat = #False
          If usingLoopXFade(pAudPtr)
            \nSourceAltChannel = openFileForBASS(pAudPtr, d)
          EndIf
        EndIf
      EndIf
      
      If \nSourceChannel <> 0
        \sDriver = "BASS"
        ; VST Load Start Code
        VST_setReqdPluginInfo(pAudPtr)
        If \sVSTReqdPluginName
          ; bVSTLoadResult not used but VST_loadAudVSTPlugin returns True or False depending upon result of loading plugin
          debugMsg(sProcName, "calling VST_loadAudVSTPlugin(" + getAudLabel(pAudPtr) + ")")
          bVSTLoadResult = VST_loadAudVSTPlugin(pAudPtr)
        EndIf
      EndIf
      If (\bAudUseGaplessStream) And (\nAudGaplessSeqPtr >= 0)
        debugMsg(sProcName, "\sDriver=" + \sDriver + ", \bAudUseGaplessStream=" + strB(\bAudUseGaplessStream) + ", \nAudGaplessSeqPtr=" + \nAudGaplessSeqPtr)
        nOrigGaplessStream = \nAudGaplessStream
        \nAudGaplessStream = createGaplessStreamIfReqd(\nAudGaplessSeqPtr, pAudPtr)
        If \nAudGaplessStream <> nOrigGaplessStream
          bCreatedGaplessStream = #True
        EndIf
      Else
        \nAudGaplessStream = 0
      EndIf
      
    EndIf ; EndIf d = \nFirstSoundingDev
    
    ; debugMsg(sProcName, "\bUsingSplitStream=" + strB(\bUsingSplitStream))
    If \bUsingSplitStream
      
      bCreateSplitStream = #True
      
      If \nAudGaplessStream = 0 Or \nAudGaplessSeqPtr < 0
        nSplitStreamSourceChannel = \nSourceChannel
      Else
        debugMsg(sProcName, "\nAudGaplessStream=" + decodeHandle(\nAudGaplessStream) + ", \nAudGaplessSeqPtr=" + \nAudGaplessSeqPtr)
        nSplitStreamSourceChannel = \nAudGaplessStream
        nFirstGaplessAudPtr = gaGaplessSeqs(\nAudGaplessSeqPtr)\nFirstGaplessAudPtr
        debugMsg(sProcName, "nFirstGaplessAudPtr=" + getAudLabel(nFirstGaplessAudPtr) + ", gaGaplessSeqs(" + \nAudGaplessSeqPtr + ")\nSplitterChannel[" + d + "]=" + decodeHandle(gaGaplessSeqs(\nAudGaplessSeqPtr)\nSplitterChannel[d]))
        If gaGaplessSeqs(\nAudGaplessSeqPtr)\nSplitterChannel[d] = 0
          If (pAudPtr <> nFirstGaplessAudPtr) And (nFirstGaplessAudPtr >= 0)
            ; for gapless streams, the splitter streams (if reqd) are only created once - when opening the first aAud() for the gapless sequence
            bCreateSplitStream = #False
            nSplitterChannel = gaGaplessSeqs(\nAudGaplessSeqPtr)\nSplitterChannel[d]  ; nb a condition of gapless is that the output devices are the same
            nSplitterAltChannel = 0
;             bIgnoreDSPProcessing = #True
          EndIf
        Else
          bCreateSplitStream = #False
          nSplitterChannel = gaGaplessSeqs(\nAudGaplessSeqPtr)\nSplitterChannel[d]  ; nb a condition of gapless is that the output devices are the same
          nSplitterAltChannel = 0
        EndIf
      EndIf
      
      ; debugMsg(sProcName, "bCreateSplitStream=" + strB(bCreateSplitStream))
      If bCreateSplitStream
        If gbUseBASSMixer
          nFlags = \nBassDecodeStreamCreateFlags[d] | #BASS_STREAM_DECODE
        Else
          nFlags = \nBassStreamCreateFlags[d]
        EndIf
        ; added 28Apr2016 11.6.1av, hopefully to fix a problem of files not playing reported by Brian O'Connor.
        ; #BASS_STREAM_PRESCAN is not listed as a valid flag for BASS_Split_StreamCreate(), and the value clashes with #BASS_MIXER_CHAN_PAUSE, although I don't know if that's significant
        If (nFlags & #BASS_STREAM_PRESCAN) = #BASS_STREAM_PRESCAN
          nFlags ! #BASS_STREAM_PRESCAN
        EndIf
        ; end added 28Apr2016 11.6.1av
        ; debugMsg(sProcName, "calling BASS_Split_StreamCreate(" + decodeHandle(nSplitStreamSourceChannel) + ", " + decodeStreamCreateFlags(nFlags) + ", #Null)")
        \nBassChannel[d] = BASS_Split_StreamCreate(nSplitStreamSourceChannel, nFlags, #Null)
        newHandle(#SCS_HANDLE_SPLITTER, \nBassChannel[d])
        debugMsg2(sProcName, "BASS_Split_StreamCreate(" + decodeHandle(nSplitStreamSourceChannel) + ", " + decodeStreamCreateFlags(nFlags) + ", #Null)", \nBassChannel[d])
        If \nBassChannel[d] <> 0
          ; logKeyEvent("BASS_Split_StreamCreate(" + decodeHandle(nSplitStreamSourceChannel) + ", " + decodeStreamCreateFlags(nFlags) + ", 0) returned " + decodeHandle(\nBassChannel[d]))
        Else
          nBassError = BASS_ErrorGetCode()
          If nBassError = #BASS_ERROR_SPEAKER ; And \bBassFloat = #True
            If (nDevChans = 1) And (\nFileChannels = 2)
              ; need to get SCS to downmix stereo to mono, because #BASS didn't handle this with #BASS_SAMPLE_MONO
              nHoldFlags = nFlags
              If (nHoldFlags & #BASS_SPEAKER_LEFT) = #BASS_SPEAKER_LEFT
                bDownmixLeft = #True
                nFlags ! #BASS_SPEAKER_LEFT
                debugMsg(sProcName, "downmix left")
              ElseIf (nHoldFlags & #BASS_SPEAKER_RIGHT) = #BASS_SPEAKER_RIGHT
                bDownmixRight = #True
                nFlags ! #BASS_SPEAKER_RIGHT
                debugMsg(sProcName, "downmix right")
              EndIf
              If bDownmixLeft
                \nBassChannel[d] = BASS_Split_StreamCreate(nSplitStreamSourceChannel, nFlags, 0)
                newHandle(#SCS_HANDLE_SPLITTER, \nBassChannel[d])
                debugMsg2(sProcName, "BASS_Split_StreamCreate(" + decodeHandle(nSplitStreamSourceChannel) + ", " + decodeStreamCreateFlags(nFlags) + ", 0)", \nBassChannel[d])
                If \nBassChannel[d] <> 0
                  ; logKeyEvent("BASS_Split_StreamCreate(" + decodeHandle(nSplitStreamSourceChannel) + ", " + decodeStreamCreateFlags(nFlags) + ", 0) returned " + decodeHandle(\nBassChannel[d]))
                  \nDSPInd[d] = #SCS_DSP_LEFT
                  nBassResult = BASS_ChannelSetDSP(\nBassChannel[d], @Stereo2MonoLeftDSP(), (pAudPtr * 100) + d, 1)
                  debugMsg2(sProcName, "BASS_ChannelSetDSP(" + decodeHandle(\nBassChannel[d]) + ", @Stereo2MonoLeftDSP(), " + Str((pAudPtr * 100) + d) + ", 1)", nBassResult)
                  If usingLoopXFade(pAudPtr)
                    \nBassAltChannel[d] = BASS_Split_StreamCreate(\nSourceAltChannel, nFlags, 0)
                    newHandle(#SCS_HANDLE_SPLITTER, \nBassAltChannel[d])
                    debugMsg2(sProcName, "BASS_Split_StreamCreate(" + decodeHandle(\nSourceAltChannel) + ", " + decodeStreamCreateFlags(nFlags) + ", 0)", \nBassAltChannel[d])
                    ; logKeyEvent("BASS_Split_StreamCreate(" + decodeHandle(\nSourceAltChannel) + ", " + decodeStreamCreateFlags(nFlags) + ", 0) returned " + decodeHandle(\nBassAltChannel[d]))
                    debugMsg(sProcName, "\nBassAltChannel[" + d + "]=" + decodeHandle(\nBassAltChannel[d]))
                    nBassResult = BASS_ChannelSetDSP(\nBassAltChannel[d], @Stereo2MonoLeftDSP(), (pAudPtr * 100) + d, 1)
                    debugMsg2(sProcName, "BASS_ChannelSetDSP(" + decodeHandle(\nBassAltChannel[d]) + ", @Stereo2MonoLeftDSP(), " + Str((pAudPtr * 100) + d) + ", 1)", nBassResult)
                  EndIf
                EndIf
              ElseIf bDownmixRight
                debugMsg(sProcName, "d=" + d + ", nSplitStreamSourceChannel=" + decodeHandle(nSplitStreamSourceChannel) + ", nFlags=$" + Hex(nFlags))
                \nBassChannel[d] = BASS_Split_StreamCreate(nSplitStreamSourceChannel, nFlags, 0)
                newHandle(#SCS_HANDLE_SPLITTER, \nBassChannel[d])
                debugMsg2(sProcName, "BASS_Split_StreamCreate(" + decodeHandle(nSplitStreamSourceChannel) + ", " + decodeStreamCreateFlags(nFlags) + ", 0)", \nBassChannel[d])
                If \nBassChannel[d] <> 0
                  ; logKeyEvent("BASS_Split_StreamCreate(" + decodeHandle(nSplitStreamSourceChannel) + ", " + decodeStreamCreateFlags(nFlags) + ", 0) returned " + decodeHandle(\nBassChannel[d]))
                  \nDSPInd[d] = #SCS_DSP_RIGHT
                  nBassResult = BASS_ChannelSetDSP(\nBassChannel[d], @Stereo2MonoRightDSP(), (pAudPtr * 100) + d, 1)
                  debugMsg2(sProcName, "BASS_ChannelSetDSP(" + decodeHandle(\nBassChannel[d]) + ", @Stereo2MonoRightDSP(), " + Str((pAudPtr * 100) + d) + ", 1)", nBassResult)
                  If usingLoopXFade(pAudPtr)
                    \nBassAltChannel[d] = BASS_Split_StreamCreate(\nSourceAltChannel, nFlags, 0)
                    newHandle(#SCS_HANDLE_SPLITTER, \nBassAltChannel[d])
                    debugMsg2(sProcName, "BASS_Split_StreamCreate(" + decodeHandle(\nSourceAltChannel) + ", " + decodeStreamCreateFlags(nFlags) + ", 0)", \nBassAltChannel[d])
                    ; logKeyEvent("BASS_Split_StreamCreate(" + decodeHandle(\nSourceAltChannel) + ", " + decodeStreamCreateFlags(nFlags) + ", 0) returned " + decodeHandle(\nBassAltChannel[d]))
                    debugMsg(sProcName, "\nBassAltChannel[" + d + "]=" + decodeHandle(\nBassAltChannel[d]))
                    nBassResult = BASS_ChannelSetDSP(\nBassAltChannel[d], @Stereo2MonoRightDSP(), (pAudPtr * 100) + d, 1)
                    debugMsg2(sProcName, "BASS_ChannelSetDSP(" + decodeHandle(\nBassAltChannel[d]) + ", @Stereo2MonoRightDSP(), " + Str((pAudPtr * 100) + d) + ", 1)", nBassResult)
                  EndIf
                EndIf
              EndIf
              If \nBassChannel[d] = 0
                ; that didn't work, so undo change to flags
                nFlags = nHoldFlags
              EndIf
            EndIf
            ProcedureReturn
          Else
            ; debugMsg3(sProcName, "Error: " + getBassErrorDesc(nBassError))
            Error_2(sProcName, nBassError, "(a) BASS_Split_StreamCreate(" + decodeHandle(nSplitStreamSourceChannel) + ", " + decodeStreamCreateFlags(nFlags) + ", 0) failed")
            ProcedureReturn
          EndIf
        EndIf
        
        If \nSourceAltChannel <> 0
          \nBassAltChannel[d] = BASS_Split_StreamCreate(\nSourceAltChannel, nFlags, 0)
          newHandle(#SCS_HANDLE_SPLITTER, \nBassAltChannel[d])
          debugMsg2(sProcName, "BASS_Split_StreamCreate(" + decodeHandle(\nSourceAltChannel) + ", " + decodeStreamCreateFlags(nFlags) + ", 0)", \nBassAltChannel[d])
          If \nBassAltChannel[d] = 0
            nBassError = BASS_ErrorGetCode()
            Error_2(sProcName, nBassError, "(b) BASS_Split_StreamCreate(" + decodeHandle(\nSourceAltChannel) + ", " + decodeStreamCreateFlags(nFlags) + ", 0) failed")
            ProcedureReturn
          EndIf
          ; logKeyEvent("BASS_Split_StreamCreate(" + decodeHandle(\nSourceAltChannel) + ", " + decodeStreamCreateFlags(nFlags) + ", 0) returned " + decodeHandle(\nBassAltChannel[d]))
          debugMsg(sProcName, "\nBassAltChannel[" + d + "]=" + decodeHandle(\nBassAltChannel[d]))
        EndIf
        
        If (\bAudUseGaplessStream) And (\nAudGaplessSeqPtr >= 0)
          gaGaplessSeqs(\nAudGaplessSeqPtr)\nSplitterChannel[d] = \nBassChannel[d]
          debugMsg(sProcName, "gaGaplessSeqs(" + Str(\nAudGaplessSeqPtr) + ")\nSplitterChannel[" + d + "]=" + decodeHandle(gaGaplessSeqs(\nAudGaplessSeqPtr)\nSplitterChannel[d]))
        EndIf
        
      Else  ; bCreateSplitStream = #False (because split stream already created)
        \nBassChannel[d] = nSplitterChannel
        \nBassAltChannel[d] = nSplitterAltChannel
      EndIf
      
    Else  ; \bUsingSplitStream = #False
      \nBassChannel[d] = \nSourceChannel
      \nBassAltChannel[d] = \nSourceAltChannel
      
    EndIf
    \bAutoFollowStarted = #False
    
    debugMsg(sProcName, "\bAudUseGaplessStream=" + strB(\bAudUseGaplessStream) + ", \bUsingSplitStream=" + strB(\bUsingSplitStream) + ", \nSourceChannel=" + decodeHandle(\nSourceChannel))
    sMsg = ""
    For d = \nFirstDev To \nLastDev
      If \nBassChannel[d] <> 0
        sMsg + ", \nBassChannel[" + d + "]=" + decodeHandle(\nBassChannel[d])
        If \nBassAltChannel[d] <> 0
          sMsg + ", \nBassAltChannel[" + d + "]=" + decodeHandle(\nBassAltChannel[d])
        EndIf
      EndIf
    Next d
    If sMsg
      debugMsg(sProcName, Mid(sMsg, 3))
    EndIf
  EndWith
  
  debugMsg3(sProcName, #SCS_END)
  
EndProcedure

Procedure freeStreamRequest(nBassChannel.l, nBassDevice, nAudPtr=-1, nDevNo=0, bDecodeStream=#False, nMixerStreamPtr=-1, bUsingSplitStream=#False, bFreeSteamNow=#False)
  PROCNAMEC()
  Protected n, nArraySize, nIndex, bAudUsingVST
  
  debugMsg(sProcName, #SCS_START + ", nBassChannel=" + decodeHandle(nBassChannel) + ", nBassDevice=" + nBassDevice +
                      ", nAudPtr=" + getAudLabel(nAudPtr) + ", nDevNo=" + nDevNo + ", bDecodeStream=" + strB(bDecodeStream) + ", nMixerStreamPtr=" + nMixerStreamPtr +
                      ", bFreeStreamNow=" + strB(bFreeSteamNow))
  
  If nAudPtr > 0
    If aAud(nAudPtr)\nVSTHandle <> 0
      bAudUsingVST = #True
    EndIf
  EndIf
  
  ; note: bFreeSteamNow and bAudUsingVST were added and included in the following test to ensure that freeing a stream is NOT deferred if a VST plugin is assigned to this Aud,
  ; because if it is deferred then the freestream may cancel the VST DSP assignment if that freestream occurs after the file is reopened and DSP reassigned.
  ; issue solved 14Dec2018 11.8.0rc3 when testing repeated use of Stop Everything and re-playing the cue.
  
  If (gbStoppingEverything) And (bAudUsingVST = #False) And (bFreeSteamNow = #False)
    nIndex = -1
    nArraySize = ArraySize(gaFreeStreams())
    For n = 0 To nArraySize
      With gaFreeStreams(n)
        If \bLocked = #False
          If \bDone
            nIndex = n
            Break
          EndIf
        EndIf
      EndWith
    Next n
    If nIndex = -1
      REDIM_ARRAY(gaFreeStreams, nArraySize + 10, grFreeStreamDef, "gaFreeStreams()")
      debugMsg(sProcName, "ArraySize(gaFreeStreams()) increased to " + ArraySize(gaFreeStreams()))
      nIndex = nArraySize + 1  ; first new entry
    EndIf
    If (nIndex >= 0) And (nIndex <= ArraySize(gaFreeStreams()))
      With gaFreeStreams(nIndex)
        debugMsg(sProcName, "saving request to gaFreeStreams(" + nIndex + ")")
        \bLocked = #True
        \nBassChannel = nBassChannel
        \nBassDevice = nBassDevice
        \qTimeRequested = ElapsedMilliseconds()
        \nAudPtr = nAudPtr
        \nDevNo = nDevNo
        \bDecodeStream = bDecodeStream
        \nMixerStreamPtr = nMixerStreamPtr
        \bUsingSplitStream = bUsingSplitStream
        \bDone = #False
        gnFreeStreamCount + 1
        debugMsg(sProcName, "gnFreeStreamCount=" + gnFreeStreamCount)
        \bLocked = #False
      EndWith
    EndIf
    
  Else
    With grMMedia\rFreeStream
      \nBassChannel = nBassChannel
      \nBassDevice = nBassDevice
      \qTimeRequested = ElapsedMilliseconds()
      \nAudPtr = nAudPtr
      \nDevNo = nDevNo
      \bDecodeStream = bDecodeStream
      \nMixerStreamPtr = nMixerStreamPtr
      \bUsingSplitStream = bUsingSplitStream
      \bDone = #False
    EndWith
    ; debugMsg(sProcName, "calling freeOneStreamNow()")
    freeOneStreamNow()
  EndIf
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure freeGaplessStreams()
  PROCNAMEC()
  Protected n
  Protected i, j, k
  Protected nBassResult.l
  
  debugMsg(sProcName, #SCS_START)
  
  For n = 0 To (gnGaplessSeqCount-1)
    With gaGaplessSeqs(n)
      If \nGaplessStream > 0
        nBassResult = BASS_StreamFree(\nGaplessStream)
        debugMsg2(sProcName, "BASS_StreamFree(" + decodeHandle(\nGaplessStream) + ")", nBassResult)
        \nGaplessStream = 0
        For i = 1 To gnLastCue
          j = aCue(i)\nFirstSubIndex
          While j >= 0
            If aSub(j)\bSubTypeHasAuds And aSub(j)\bSubEnabled
              k = aSub(j)\nFirstAudIndex
              While k >= 0
                If aAud(k)\nAudGaplessSeqPtr = n
                  aAud(k)\nAudGaplessSeqPtr = grAudDef\nAudGaplessSeqPtr
                  aAud(k)\bAudUseGaplessStream = grAudDef\bAudUseGaplessStream
                  aAud(k)\nAudGaplessStream = grAudDef\nAudGaplessStream
                EndIf
                k = aAud(k)\nNextAudIndex
              Wend
            EndIf
            aSub(j)\bSubUseGaplessStream = grSubDef\bSubUseGaplessStream
            aSub(j)\nSubGaplessSeqPtr = grSubDef\nSubGaplessSeqPtr
            aSub(j)\bSubContainsGapless = grSubDef\bSubContainsGapless
            j = aSub(j)\nNextSubIndex
          Wend
          aCue(i)\bCueContainsGapless = grCueDef\bCueContainsGapless
        Next i
      EndIf
    EndWith
  Next n
  gnGaplessSeqCount = 0
  
EndProcedure

Procedure freeOneStreamNow()
  PROCNAMEC()
  Protected nBassResult.l
  Protected nChannel.l, nVSTHandle.l
  Protected nAudPtr
  Protected nErrorCode.l
  Protected bCallFreeHandle
  
  With grMMedia\rFreeStream
    nChannel = \nBassChannel
    nAudPtr = \nAudPtr
    If nAudPtr > 0
      nVSTHandle = aAud(nAudPtr)\nVSTHandle
      If nVSTHandle <> 0
        ; Remove the currently loaded VST plugin
        debugMsg(sProcName, "calling BASS_VST_ChannelRemoveDSP(" + decodeHandle(nChannel) + ", " + decodeHandle(nVSTHandle) + ")")
        BASS_VST_ChannelRemoveDSP(nChannel, nVSTHandle)
        debugMsg(sProcName, "BASS_VST_ChannelRemoveDSP(" + decodeHandle(nChannel) + ", " + decodeHandle(nVSTHandle) + ")")
        aAud(nAudPtr)\nVSTHandle = 0
      EndIf
    EndIf

    If (\nMixerStreamPtr >= 0) And (\bUsingSplitStream = #False)
      nBassResult = BASS_Mixer_ChannelRemove(nChannel)
      debugMsg3(sProcName, "BASS_Mixer_ChannelRemove(" + decodeHandle(nChannel) + ") returned " + nBassResult + ", nAudPtr=" + getAudLabel(nAudPtr))
      If nBassResult = #BASSFALSE
        nErrorCode = BASS_ErrorGetCode()
        debugMsg3(sProcName, "Error " + nErrorCode + ": " + getBassErrorDesc(nErrorCode))
      Else
        nBassResult = BASS_StreamFree(nChannel)
        debugMsg3(sProcName, "BASS_StreamFree(" + decodeHandle(nChannel) + ") returned " + nBassResult + ", nAudPtr=" + getAudLabel(nAudPtr))
        bCallFreeHandle = #True
        ; freeHandle(nChannel)
      EndIf
      \bDone = #True
      ; do NOT reduce gnFreeStreamCount because freeStreamNow() operates indpendently of the gaFreeStreams() array
;       gnFreeStreamCount - 1
;       debugMsg(sProcName, "gnFreeStreamCount=" + gnFreeStreamCount)
    Else
      nBassResult = BASS_ChannelIsActive(nChannel)
      debugMsg3(sProcName, "BASS_ChannelIsActive(" + decodeHandle(nChannel) + ") returned " + decodeActiveState(nBassResult) + ", nAudPtr=" + getAudLabel(nAudPtr))
      If (nBassResult <> #BASS_ACTIVE_PLAYING) Or (\nBassDevice = 0) Or (\bDecodeStream) Or (nAudPtr < 0)
        debugMsg3(sProcName, "calling BASS_StreamFree(" + decodeHandle(nChannel) + ")")
        nBassResult = BASS_StreamFree(nChannel)
        debugMsg3(sProcName, "BASS_StreamFree(" + decodeHandle(nChannel) + ") returned " + nBassResult + ", nAudPtr=" + getAudLabel(nAudPtr))
        bCallFreeHandle = #True
        ; freeHandle(nChannel)
        \bDone = #True
      ; do NOT reduce gnFreeStreamCount because freeStreamNow() operates indpendently of the gaFreeStreams() array
;         gnFreeStreamCount - 1
;       debugMsg(sProcName, "gnFreeStreamCount=" + gnFreeStreamCount)
      EndIf
    EndIf
    If nAudPtr >= 0
      debugMsg(sProcName, "nAudPtr=" + getAudLabel(nAudPtr) + ", \nDevNo=" + \nDevNo + ", \nFirstSoundingDev=" + Str(aAud(nAudPtr)\nFirstSoundingDev) + ", nChannel=" + decodeHandle(nChannel) + ", \nSourceChannel=" + decodeHandle(aAud(nAudPtr)\nSourceChannel))
      If \nDevNo = aAud(nAudPtr)\nFirstSoundingDev
        If (aAud(nAudPtr)\nSourceChannel = nChannel) Or (aAud(nAudPtr)\nSourceChannel = 0)
          aAud(nAudPtr)\nBassPlayEndSync = 0
          aAud(nAudPtr)\nBassAltChannelEndSync = 0
          aAud(nAudPtr)\nBassChannelEndSync = 0
          aAud(nAudPtr)\nBassAltChannelEndSync = 0
        EndIf
      EndIf
    EndIf
    If bCallFreeHandle
      ; nb calling freeHandle() deferred until now so all prior debug messages in this procedure pick up the handle code (eg source#1)
      freeHandle(nChannel)
    EndIf
  EndWith
EndProcedure

Procedure freeStreams(bFreeNow=#False)
  PROCNAMEC()
  Protected n, nBassResult.l, nProcessCountDown
  Protected nChannel.l, nBassDevice
  Protected nAudPtr, nDevNo
  Protected nErrorCode.l
  Protected bUsingSplitStream
  Protected bCallFreeHandle

  ; debugMsg(sProcName, #SCS_START + ", bFreeNow=" + strB(bFreeNow) + ", gnFreeStreamCount=" + gnFreeStreamCount + ", ArraySize(gaFreeStreams())=" + ArraySize(gaFreeStreams()))
  
  If gnFreeStreamCount > 0
    nProcessCountDown = gnFreeStreamCount
    For n = 0 To ArraySize(gaFreeStreams())
      bCallFreeHandle = #False
      debugMsg(sProcName, "n=" + n + ", \bLocked=" + strB(gaFreeStreams(n)\bLocked) + ", \bDone=" + strB(gaFreeStreams(n)\bDone) +
                          ", \qTimeRequested=" + traceTime(gaFreeStreams(n)\qTimeRequested) + ", \nBassChannel=" + decodeHandle(gaFreeStreams(n)\nBassChannel))
      If gaFreeStreams(n)\bLocked = #False
        If gaFreeStreams(n)\bDone = #False
          If ((gqTimeNow - gaFreeStreams(n)\qTimeRequested) >= 120) Or (bFreeNow)
            nChannel = gaFreeStreams(n)\nBassChannel
            nAudPtr = gaFreeStreams(n)\nAudPtr
            nDevNo = gaFreeStreams(n)\nDevNo
            ; bUsingSplitStream = #False
            ; If nAudPtr >= 0
              ; bUsingSplitStream = aAud(nAudPtr)\bUsingSplitStream
            ; EndIf
            bUsingSplitStream = gaFreeStreams(n)\bUsingSplitStream
            If (gaFreeStreams(n)\nMixerStreamPtr >= 0) And (bUsingSplitStream = #False)
              nBassResult = BASS_Mixer_ChannelRemove(nChannel)
              If nBassResult = #BASSFALSE
                nErrorCode = BASS_ErrorGetCode()
                debugMsg3(sProcName, "Error " + nErrorCode + ": " + getBassErrorDesc(nErrorCode))
              Else
                debugMsg3(sProcName, "BASS_Mixer_ChannelRemove(" + decodeHandle(nChannel) + ") returned " + nBassResult + ", nAudPtr=" + getAudLabel(nAudPtr))
                nBassResult = BASS_StreamFree(nChannel)
                If nBassResult = #BASSTRUE
                  debugMsg3(sProcName, "BASS_StreamFree(" + decodeHandle(nChannel) + ") returned " + nBassResult + ", nAudPtr=" + getAudLabel(nAudPtr))
                EndIf
                bCallFreeHandle = #True
                ; freeHandle(nChannel)
              EndIf
              gaFreeStreams(n)\bDone = #True
              gnFreeStreamCount - 1
              ; debugMsg(sProcName, "gnFreeStreamCount=" + gnFreeStreamCount)
            Else
              nBassDevice = gaFreeStreams(n)\nBassDevice
              nBassResult = BASS_ChannelIsActive(nChannel)
              ; debugMsg3(sProcName, "BASS_ChannelIsActive(" + decodeHandle(nChannel) + ") returned " + nBassResult + ", nAudPtr=" + getAudLabel(nAudPtr))
              If (nBassResult <> #BASS_ACTIVE_PLAYING) Or (nBassDevice = 0) Or (gaFreeStreams(n)\bDecodeStream)
                nBassResult = BASS_StreamFree(nChannel)
                If nBassResult = #BASSTRUE
                  debugMsg3(sProcName, "BASS_StreamFree(" + decodeHandle(nChannel) + ") returned " + nBassResult + ", nAudPtr=" + getAudLabel(nAudPtr))
                EndIf
                bCallFreeHandle = #True
                ; freeHandle(nChannel)
                gaFreeStreams(n)\bDone = #True
                gnFreeStreamCount - 1
                ; debugMsg(sProcName, "gnFreeStreamCount=" + gnFreeStreamCount)
              EndIf
            EndIf
            If nAudPtr >= 0
              With aAud(nAudPtr)
                ; debugMsg(sProcName, "nAudPtr=" + getAudLabel(nAudPtr) + ", nDevNo=" + nDevNo + ", \nFirstSoundingDev=" + \nFirstSoundingDev + ", nChannel=" + decodeHandle(nChannel) + ", \nSourceChannel=" + decodeHandle(\nSourceChannel))
                If nDevNo = \nFirstSoundingDev
                  If (\nSourceChannel = nChannel) Or (\nSourceChannel = 0)
                    \nBassPlayEndSync = 0
                    \nBassAltChannelEndSync = 0
                    \nBassChannelEndSync = 0
                    \nBassAltChannelEndSync = 0
                  EndIf
                EndIf
              EndWith
            EndIf
          EndIf
          If bCallFreeHandle
            ; nb calling freeHandle() deferred until now so all prior debug messages in this procedure pick up the handle code (eg source#1)
            freeHandle(nChannel)
          EndIf
          nProcessCountDown - 1
          If nProcessCountDown <= 0
            Break
          EndIf
        EndIf
      EndIf
    Next n
  EndIf
  ; debugMsg(sProcName, #SCS_END)
EndProcedure

Procedure displayMidiError(nErrCode.l, pMciString.s,pWhere.s)
  PROCNAMEC()
  Protected *lpError
  Protected sError.s
  Protected nRetVal.l, nLength.l
  
  *lpError = AllocateMemory(512)
  nLength = 256
  nRetVal = mciGetErrorString_(nErrCode, *lpError, nLength)
  sError = "MCI Error Number " + nErrCode + ": " + PeekS(*lpError) ; , -1, #PB_Ascii)
  debugMsg3(sProcName, "sError=" + sError)
  FreeMemory(*lpError)
  
  scsMessageRequester(#SCS_TITLE, sError + " [mciString=" + #DQUOTE$ + pMciString + #DQUOTE$ + "]", #MB_ICONEXCLAMATION)
  
EndProcedure

Procedure createOneMixerStream(pMixerStreamPtr, pDevMapDevPtr, bIgnoreNotFounds=#False)
  PROCNAMEC()
  Protected sMyPhysicalDevDesc.s
  Protected d2
  Protected nBassResult.l, nErrorCode.l
  Protected fMatrixLeft.f, fMatrixRight.f
  Protected nBuffer.l, nReqdBuffer.l
  Protected nNrOfOutputChans
  Protected nFirstASIOChannel
  Protected sMyAudioLogicalDev.s
  Protected nBassDevice.l
  Protected nDevMapPtr, nReassignDevMapDevPtr
  Protected sMsg.s
  
  If gbUseBASSMixer = #False
    ProcedureReturn
  EndIf
  
  debugMsg(sProcName, #SCS_START + ", pMixerStreamPtr=" + pMixerStreamPtr + ", pDevMapDevPtr=" + pDevMapDevPtr)
  
  nDevMapPtr = grProd\nSelectedDevMapPtr
  If pMixerStreamPtr < 0 Or pDevMapDevPtr < 0 Or nDevMapPtr < 0
    ProcedureReturn
  EndIf
  
  debugMsg(sProcName, "grMaps\aDev(" + pDevMapDevPtr + ")\nReassignDevMapDevPtr=" + grMaps\aDev(pDevMapDevPtr)\nReassignDevMapDevPtr + ", \nMixerStreamPtr=" + grMaps\aDev(nReassignDevMapDevPtr)\nMixerStreamPtr)
  nReassignDevMapDevPtr = grMaps\aDev(pDevMapDevPtr)\nReassignDevMapDevPtr
  If nReassignDevMapDevPtr >= 0
    If grMaps\aDev(pDevMapDevPtr)\nNrOfDevOutputChans = grMaps\aDev(nReassignDevMapDevPtr)\nNrOfDevOutputChans ; This test added 8Dec2020 11.8.3.3at
      ; no need to create a mixer stream for this device as it has been reassigned to another device
      With grMaps\aDev(pDevMapDevPtr)
        \nMixerStreamPtr = grMaps\aDev(nReassignDevMapDevPtr)\nMixerStreamPtr
        \nNrOfDevOutputChans = grMaps\aDev(nReassignDevMapDevPtr)\nNrOfDevOutputChans
        debugMsg(sProcName, "grMaps\aDev(" + pDevMapDevPtr + ")\nMixerStreamPtr=" + \nMixerStreamPtr + ", \nNrOfDevOutputChans=" + \nNrOfDevOutputChans)
      EndWith
      ProcedureReturn
    Else
      grMaps\aDev(pDevMapDevPtr)\nReassignDevMapDevPtr = grDevMapDevDef\nReassignDevMapDevPtr ; Added 8Dec2020 11.8.3.3at
      ; debugMsg(sProcName, "grMaps\aDev(" + pDevMapDevPtr + ")\nReassignDevMapDevPtr=" + grMaps\aDev(pDevMapDevPtr)\nReassignDevMapDevPtr)
    EndIf
  EndIf
  
  With gaMixerStreams(pMixerStreamPtr)
    
    ; create (or re-create) mixer stream
    If Len(grMaps\aDev(pDevMapDevPtr)\sReassignPhysicalDev) > 0
      sMyPhysicalDevDesc = grMaps\aDev(pDevMapDevPtr)\sReassignPhysicalDev
    Else
      sMyPhysicalDevDesc = grMaps\aDev(pDevMapDevPtr)\sPhysicalDev
    EndIf
    debugMsg(sProcName, "grMaps\aDev(" + pDevMapDevPtr + ")\sReassignPhysicalDev=" + grMaps\aDev(pDevMapDevPtr)\sReassignPhysicalDev +
                        ", grMaps\aDev(" + pDevMapDevPtr + ")\sPhysicalDev=" + grMaps\aDev(pDevMapDevPtr)\sPhysicalDev +
                        ", sMyPhysicalDevDesc=" + sMyPhysicalDevDesc)
    
    sMyAudioLogicalDev = grMaps\aDev(pDevMapDevPtr)\sLogicalDev
    debugMsg(sProcName, "calling getBassDeviceForLogicalDev(" + sMyAudioLogicalDev + ")")
    nBassDevice = getBassDeviceForLogicalDev(sMyAudioLogicalDev)
    debugMsg(sProcName, "nBassDevice=" + nBassDevice)
    \nSpeakerFlag = grMMedia\nBassSpeaker    ; set by getBassDeviceForLogicalDev()
    \nSpeakerCount = grMMedia\nSpeakerCount  ; set by getBassDeviceForLogicalDev()
    
    ; added or modified 1Jan2016
    debugMsg(sProcName, "grMaps\aDev(" + pDevMapDevPtr + ")\nNrOfDevOutputChans=" + grMaps\aDev(pDevMapDevPtr)\nNrOfDevOutputChans + ", \nFirstASIOChannel=" + grMaps\aDev(pDevMapDevPtr)\nFirstASIOChannel)
    \nOutputs = grMaps\aDev(pDevMapDevPtr)\nNrOfDevOutputChans
    \nFirstOutputChannel = grMaps\aDev(pDevMapDevPtr)\nFirstASIOChannel
    \bIgnoreDevThisRun = grMaps\aDev(pDevMapDevPtr)\bIgnoreDevThisRun
    ; debugMsg(sProcName, "grMaps\aDev(" + pDevMapDevPtr + ")\bIgnoreDevThisRun=" + strB(grMaps\aDev(pDevMapDevPtr)\bIgnoreDevThisRun) + ", \bReroutedToDefault=" + strB(grMaps\aDev(pDevMapDevPtr)\bReroutedToDefault))
    If grMaps\aDev(pDevMapDevPtr)\bReroutedToDefault ; Test added 14Nov2022 11.9.7ae following bug reported by Michel Winogradoff
      \nPhysicalDevPtr = 0
    ElseIf \bIgnoreDevThisRun
      \nPhysicalDevPtr = -1
      \nBassDevice = 0  ; 'no sound' device
      \bNoSoundDevice = #True
      \bDecodeStream = #True  ; 'no sound' device must use decoding stream
    Else
      \nPhysicalDevPtr = getPhysicalDevPtr(#SCS_DEVTYPE_AUDIO_OUTPUT, sMyPhysicalDevDesc, grMaps\aMap(nDevMapPtr)\nAudioDriver, "", 0, grMaps\aDev(pDevMapDevPtr)\bDummy, grMaps\aDev(pDevMapDevPtr)\bDefaultDev)
    EndIf
    If \nPhysicalDevPtr >= 0
      grMaps\aDev(pDevMapDevPtr)\bDevFound = #True
    Else
      grMaps\aDev(pDevMapDevPtr)\bDevFound = #False
      sMsg = "Cannot find physical device " + sMyPhysicalDevDesc
      debugMsg(sProcName, sMsg)
      If bIgnoreNotFounds = #False
        If (grMaps\aDev(pDevMapDevPtr)\bReroutedToDefault = #False) And (grMaps\aDev(pDevMapDevPtr)\bNotFoundMsgDisplayed = #False) ; tests added 10Feb2020 11.8.2.2ak
          ensureSplashNotOnTop()
          scsMessageRequester(#SCS_TITLE, sMsg, #PB_MessageRequester_Error)
          grMaps\aDev(pDevMapDevPtr)\bNotFoundMsgDisplayed = #True  ; added 10Feb2020 11.8.2.2ak
        EndIf
      EndIf
      ProcedureReturn
    EndIf
    If gaAudioDev(\nPhysicalDevPtr)\nBassInitErrorCode = #BASS_ERROR_DRIVER
      debugMsg(sProcName, "exiting because gaAudioDev(" + \nPhysicalDevPtr + ")\nBassInitErrorCode = BASS_ERROR_DRIVER")
      ProcedureReturn
    EndIf
    If gaAudioDev(\nPhysicalDevPtr)\bInitialized = #False
      debugMsg(sProcName, "calling initDevice(" + \nPhysicalDevPtr + ")")
      initDevice(\nPhysicalDevPtr)
    EndIf
    \bNoDevice = gaAudioDev(\nPhysicalDevPtr)\bNoDevice
    \bASIO = gaAudioDev(\nPhysicalDevPtr)\bASIO
    \nBassASIODevice = gaAudioDev(\nPhysicalDevPtr)\nDevBassASIODevice
    \nBassDevice = gaAudioDev(\nPhysicalDevPtr)\nBassDevice
    \nSampleRate = gaAudioDev(\nPhysicalDevPtr)\nSampleRate
    \bNoSoundDevice = gaAudioDev(\nPhysicalDevPtr)\bNoSoundDevice
    debugMsg(sProcName, "gaMixerStreams(" + pMixerStreamPtr + ")\nOutputs=" + \nOutputs + ", \nFirstOutputChannel=" + \nFirstOutputChannel + ", \nSampleRate=" + \nSampleRate +
                        ", \bASIO=" + strB(\bASIO) + ", \nBassASIODevice=" + \nBassASIODevice + ", \nBassDevice=" + \nBassDevice + ", \bNoSoundDevice=" + strB(\bNoSoundDevice))
    If \nSampleRate = 0
      \nSampleRate = grDriverSettings\nDSSampleRate
      If \nSampleRate = 0
        \nSampleRate = grMixerStreamDef\nSampleRate
      EndIf
      debugMsg(sProcName, "\nSampleRate=" + \nSampleRate)
    EndIf
    
    \nMixerChans = \nOutputs
    
    If \bASIO
      \bUseMatrix = #False
      ; Quote from BASS Forum: The BASS_CONFIG_BUFFER setting only applies when using the standard BASS/DirectSound output,
      ; so you don't need to bother with that when using ASIO output. In that case, the output buffer size is determined
      ; by the BASS_ASIO_Start call's "buflen" parameter. You can still set BASS_CONFIG_UPDATEPERIOD (or BASS_CONFIG_UPDATETHREADS)
      ; to 0 though, to disable the BASS update thread, as it isn't needed.
      
      ; NOTE: use BASS_SAMPLE_FLOAT for all ASIO streams, INCLUDING streams for Creative Labs devices
      \nFlags = #BASS_SAMPLE_FLOAT | #BASS_STREAM_DECODE | #BASS_MIXER_NONSTOP
      \nMixerStreamHandle = BASS_Mixer_StreamCreate(\nSampleRate, \nMixerChans, \nFlags)
      newHandle(#SCS_HANDLE_MIXER, \nMixerStreamHandle)
      debugMsg2(sProcName, "BASS_Mixer_StreamCreate(" + \nSampleRate + ", " + \nMixerChans + ", " + decodeStreamCreateFlags(\nFlags, #True) + ")", \nMixerStreamHandle)
      ; logKeyEvent("BASS_Mixer_StreamCreate(" + \nSampleRate + ", " + \nMixerChans + ", " + decodeStreamCreateFlags(\nFlags, #True) + ") returned " + decodeHandle(\nMixerStreamHandle))
      \nPushStreamHandle = 0
      \nBufBytes = 0
      \bDecodeStream = #True
      
    Else ; not ASIO
      ; debugMsg(sProcName, "\nNrOfOutputChans=" + \nNrOfOutputChans)
      \bUseMatrix = #False
      debugMsg(sProcName, "\nSpeakerFlag=" + \nSpeakerFlag + ", $" + Hex(\nSpeakerFlag))
      \nFlags = \nSpeakerFlag | #BASS_MIXER_NONSTOP
      If grDriverSettings\bNoFloatingPoint = #False
        \nFlags | #BASS_SAMPLE_FLOAT
      EndIf
      If \bNoSoundDevice
        ; 'no sound' device (as set for \bIgnoreDevThisRun) can only use decoding channels
        \nFlags | #BASS_STREAM_DECODE
        \bDecodeStream = #True
      Else
        \bDecodeStream = #False
      EndIf
      
      If \bNoDevice
        \nMixerStreamHandle = 0
      Else
        nBassResult = BASS_SetDevice(\nBassDevice)
        debugMsg2(sProcName, "BASS_SetDevice(" + \nBassDevice + ")", nBassResult)
        \nMixerStreamHandle = BASS_Mixer_StreamCreate(\nSampleRate, \nMixerChans, \nFlags)
        newHandle(#SCS_HANDLE_MIXER, \nMixerStreamHandle)
        debugMsg2(sProcName, "BASS_Mixer_StreamCreate(" + \nSampleRate + ", " + \nMixerChans + ", " + decodeStreamCreateFlags(\nFlags, #True) + ")", \nMixerStreamHandle)
        ; logKeyEvent("BASS_Mixer_StreamCreate(" + \nSampleRate + ", " + \nMixerChans + ", " + decodeStreamCreateFlags(\nFlags, #True) + ") returned " + decodeHandle(\nMixerStreamHandle))
        If \nMixerStreamHandle = 0
          nErrorCode = BASS_ErrorGetCode()
          If nErrorCode = #BASS_ERROR_FORMAT Or nErrorCode = #BASS_ERROR_UNKNOWN
            ; if BASS_SAMPLE_FLOAT was used, then try again without this flag
            If (\nFlags & #BASS_SAMPLE_FLOAT) = #BASS_SAMPLE_FLOAT
              \nFlags ! #BASS_SAMPLE_FLOAT  ; ! is bitwise XOR in PB
              \nMixerStreamHandle = BASS_Mixer_StreamCreate(\nSampleRate, \nMixerChans, \nFlags)
              newHandle(#SCS_HANDLE_MIXER, \nMixerStreamHandle)
              debugMsg2(sProcName, "(nf) BASS_Mixer_StreamCreate(" + \nSampleRate + ", " + \nMixerChans + ", " + decodeStreamCreateFlags(\nFlags, #True) + ")", \nMixerStreamHandle)
              ; logKeyEvent("BASS_Mixer_StreamCreate(" + \nSampleRate + ", " + \nMixerChans + ", " + decodeStreamCreateFlags(\nFlags, #True) + ") returned " + decodeHandle(\nMixerStreamHandle))
            EndIf
          EndIf
        EndIf
      EndIf
      
    EndIf
    
    nErrorCode = #BASS_OK
    If (\nMixerStreamHandle = 0) And (\bNoDevice = #False)
      nErrorCode = BASS_ErrorGetCode()
      debugMsg3(sProcName, "BASS_Mixer_StreamCreate Error=" + getBassErrorDesc(nErrorCode))
      If nErrorCode = #BASS_ERROR_SPEAKER
        ; if "unavailable speaker" raised when trying to use mono speaker (with mono mixer) then try using matrix instead
        If \nMixerChans = 1
          \nFlags ! \nSpeakerFlag     ; remove existing speaker flags
          If \nSpeakerFlag & #BASS_SPEAKER_LEFT = #BASS_SPEAKER_LEFT
            debugMsg(sProcName, "left")
            \nSpeakerFlag ! #BASS_SPEAKER_LEFT
            \bUseMatrix = #True
            \fMatrixLeftValue = 1
            \fMatrixRightValue = 0
            \nMatrixOutputs = 2
          ElseIf \nSpeakerFlag & #BASS_SPEAKER_RIGHT = #BASS_SPEAKER_RIGHT
            debugMsg(sProcName, "right")
            \nSpeakerFlag ! #BASS_SPEAKER_RIGHT
            \bUseMatrix = #True
            \fMatrixLeftValue = 0
            \fMatrixRightValue = 1
            \nMatrixOutputs = 2
          EndIf
          \nFlags | \nSpeakerFlag  ; reset \nFlags to specify speaker flag with the left/right removed
          \nMixerStreamHandle = BASS_Mixer_StreamCreate(\nSampleRate, \nMatrixOutputs, \nFlags)    ; nb set channels to \nMatrixOutputs
          newHandle(#SCS_HANDLE_MIXER, \nMixerStreamHandle)
          debugMsg2(sProcName, "(matrix) BASS_Mixer_StreamCreate(" + \nSampleRate + ", " + \nMatrixOutputs + " , " + decodeStreamCreateFlags(\nFlags, #True) + ")", \nMixerStreamHandle)
          If \nMixerStreamHandle <> 0
            ; logKeyEvent("BASS_Mixer_StreamCreate(" + \nSampleRate + ", " + \nMatrixOutputs + ", " + decodeStreamCreateFlags(\nFlags, #True) + ") returned " + decodeHandle(\nMixerStreamHandle))
          Else
            nErrorCode = BASS_ErrorGetCode()
            debugMsg3(sProcName, "BASS_Mixer_StreamCreate Error=" + getBassErrorDesc(nErrorCode))
            If nErrorCode = #BASS_ERROR_SPEAKER
              ; still no good, so use default speakers and matrix (values already setup)
              \nFlags ! \nSpeakerFlag     ; remove existing speaker flags
              \nSpeakerFlag = 0
              \nMixerStreamHandle = BASS_Mixer_StreamCreate(\nSampleRate, \nMatrixOutputs, \nFlags)    ; nb set channels to \nMatrixOutputs
              newHandle(#SCS_HANDLE_MIXER, \nMixerStreamHandle)
              debugMsg2(sProcName, "(matrix2) BASS_Mixer_StreamCreate(" + \nSampleRate + ", " + \nMatrixOutputs + ", " + decodeStreamCreateFlags(\nFlags, #True) + ")", \nMixerStreamHandle)
              If \nMixerStreamHandle <> 0
                ; logKeyEvent("BASS_Mixer_StreamCreate(" + \nSampleRate + ", " + \nMixerChans + ", " + decodeStreamCreateFlags(\nFlags, #True) + ") returned " + decodeHandle(\nMixerStreamHandle))
                nErrorCode = #BASS_OK
              Else
                nErrorCode = BASS_ErrorGetCode()
                debugMsg3(sProcName, "BASS_Mixer_StreamCreate Error=" + getBassErrorDesc(nErrorCode))
              EndIf
            EndIf
          EndIf
        Else
          \nFlags ! \nSpeakerFlag     ; remove existing speaker flags
          \nMixerStreamHandle = BASS_Mixer_StreamCreate(\nSampleRate, \nMixerChans, \nFlags)
          newHandle(#SCS_HANDLE_MIXER, \nMixerStreamHandle)
          debugMsg2(sProcName, "BASS_Mixer_StreamCreate(" + \nSampleRate + ", " + \nMixerChans + ", " + decodeStreamCreateFlags(\nFlags, #True) + ")", \nMixerStreamHandle)
          If \nMixerStreamHandle <> 0
            ; logKeyEvent("BASS_Mixer_StreamCreate(" + \nSampleRate + ", " + \nMixerChans + ", " + decodeStreamCreateFlags(\nFlags, #True) + ") returned " + decodeHandle(\nMixerStreamHandle))
            nErrorCode = #BASS_OK
          Else
            nErrorCode = BASS_ErrorGetCode()
            debugMsg3(sProcName, "BASS_Mixer_StreamCreate Error=" + getBassErrorDesc(nErrorCode))
          EndIf
        EndIf
      EndIf
      
      If nErrorCode <> #BASS_OK
        Error_(sProcName, "BASS_Mixer_StreamCreate failed for " + grMaps\aDev(pDevMapDevPtr)\sLogicalDev)
        ProcedureReturn
      EndIf
      If \bASIO
        debugMsg3(sProcName, "\nMixerStreamHandle=" + \nMixerStreamHandle + ", \bUseMatrix=" + strB(\bUseMatrix) + ", \nBassASIODevice=" + \nBassASIODevice)
      Else
        debugMsg3(sProcName, "\nMixerStreamHandle=" + \nMixerStreamHandle + ", \bUseMatrix=" + strB(\bUseMatrix) + ", \nBassDevice=" + \nBassDevice)
      EndIf
    EndIf
    
    grMaps\aDev(pDevMapDevPtr)\nMixerStreamPtr = pMixerStreamPtr
    debugMsg(sProcName, "grMaps\aDev(" + pDevMapDevPtr + ")\sLogicalDev=" + grMaps\aDev(pDevMapDevPtr)\sLogicalDev + ", \nMixerStreamPtr=" + grMaps\aDev(pDevMapDevPtr)\nMixerStreamPtr)
    
    d2 = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
    While d2 >= 0
      If d2 <> pDevMapDevPtr
        If grMaps\aDev(d2)\nReassignDevMapDevPtr = pDevMapDevPtr
          grMaps\aDev(d2)\nMixerStreamPtr = grMaps\aDev(pDevMapDevPtr)\nMixerStreamPtr
          ; 6Apr2018 11.7.0.1 start: blocked out the following to fix problem reported by Dik Thacker in Forum bug report "Problem playing cue to one side of a stereo output"
          ; and tested using "\SCS Files\ASIO Stereo and Mono to same device.scs11:
          ;   grMaps\aDev(d2)\nNrOfOutputChans = grMaps\aDev(pDevMapDevPtr)\nNrOfOutputChans
          ; 6Apr2018 11.7.0.1 end
          debugMsg(sProcName, "grMaps\aDev(" + d2 + ")\nMixerStreamPtr=" + grMaps\aDev(d2)\nMixerStreamPtr)
        EndIf
      EndIf
      d2 = grMaps\aDev(d2)\nNextDevIndex
    Wend
    
    If \bDecodeStream = #False
      ; debugMsg(sProcName, "calling BASS_ChannelPlay(" + decodeHandle(\nMixerStreamHandle) + ", BASSFALSE)")
      nBassResult = BASS_ChannelPlay(\nMixerStreamHandle, #BASSFALSE)
      debugMsg2(sProcName, "BASS_ChannelPlay(" + decodeHandle(\nMixerStreamHandle) + ", BASSFALSE)", nBassResult)
      If nBassResult = #BASSFALSE
        debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
        Error_(sProcName, "BASS_ChannelPlay failed")
      EndIf
    EndIf
    
    \bRecreateMixerStream = #False
    
  EndWith
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure createMixerStreams(bIgnoreNotFounds=#False)
  PROCNAMEC()
  Protected d, nMyAsioCount, nMyDSCount
  Protected nBassResult.l
  Protected rChanInfo.BASS_CHANNELINFO
  Protected n, nFirstASIOChannel.l, nErrorCode
  Protected dMyAsioSampleRate.d
  Protected sErrorMsg.s
  Protected nDevMapPtr
  Protected bCreateOneMixerStream
  Protected nFreq.l ; long
  Protected nMixerStreamHandle.l
  
  debugMsg(sProcName, #SCS_START)
  
  If gbUseBASSMixer = #False
    ProcedureReturn
  EndIf
  
  nDevMapPtr = grProd\nSelectedDevMapPtr
  If nDevMapPtr < 0
    ProcedureReturn
  EndIf
  
  debugMsg(sProcName, "calling mergeDuplicateAsioDevs()")
  mergeDuplicateAsioDevs()
  
  gnMixerStreamCount = 0
  
  d = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
  While d >= 0
    With grMaps\aDev(d)
      bCreateOneMixerStream = #False
      If (\nDevGrp = #SCS_DEVGRP_AUDIO_OUTPUT) And (\bExists)
        debugMsg(sProcName, "grMaps\aDev(" + d + ")\sLogicalDev=" + \sLogicalDev + ", \bBassASIO=" + strB(\bBassASIO) + ", \sSpeaker=" + \sSpeaker + ", \nNrOfDevOutputChans=" + \nNrOfDevOutputChans +
                            ", \bBassASIO=" + strB(\bBassASIO) + ", \nMixerStreamPtr=" + \nMixerStreamPtr)
        If \bBassASIO
          nMyAsioCount + 1
        Else
          nMyDSCount + 1
        EndIf
        If \nMixerStreamPtr < 0
          bCreateOneMixerStream = #True
        Else
          nMixerStreamHandle = gaMixerStreams(\nMixerStreamPtr)\nMixerStreamHandle
          nBassResult = BASS_ChannelGetInfo(nMixerStreamHandle, @rChanInfo)
          debugMsg2(sProcName, "BASS_ChannelGetInfo(" + decodeHandle(nMixerStreamHandle) + ", rChanInfo)", nBassResult)
          If nBassResult = #BASSFALSE
            ; stream no longer exists so re-create it using the same mixer stream pointer
            debugMsg(sProcName, decodeHandle(nMixerStreamHandle) + " no longer exists")
            debugMsg(sProcName, "calling createOneMixerStream(" + \nMixerStreamPtr + ", " + d + ", " + strB(bIgnoreNotFounds) + ")")
            createOneMixerStream(\nMixerStreamPtr, d, bIgnoreNotFounds)
          EndIf
        EndIf
      EndIf
      If bCreateOneMixerStream
        debugMsg(sProcName, "calling createOneMixerStream(" + gnMixerStreamCount + ", " + d + ", " + strB(bIgnoreNotFounds) + ")")
        createOneMixerStream(gnMixerStreamCount, d, bIgnoreNotFounds)
      EndIf
      If \sLogicalDev
        If \nMixerStreamPtr >= 0
          gnMixerStreamCount + 1
        EndIf
      EndIf
      d = \nNextDevIndex
    EndWith
  Wend
  
  debugMsg(sProcName, "nMyAsioCount=" + nMyAsioCount + ", nMyDSCount=" + nMyDSCount + ", gnMixerStreamCount=" + gnMixerStreamCount)
  ; Deleted 20Feb2022 11.9.1ac - not sure we should be setting this to zero since for ASIO we are now using BASS_ASIO_ChannelEnableBASS()
  ;   If (nMyAsioCount > 0) And (nMyDSCount = 0)
  ;     ; not playing anything via BASS, so don't need an update thread
  ;     nBassResult = BASS_SetConfig(#BASS_CONFIG_UPDATEPERIOD, 0)
  ;     debugMsg2(sProcName, "BASS_SetConfig(BASS_CONFIG_UPDATEPERIOD, 0)", nBassResult)
  ;   Else
  ;     mmSetUpdatePeriodLength()
  ;   EndIf
  ; End deleted 20Feb2022 11.9.1ac
  mmSetUpdatePeriodLength() ; Added 20Feb2022 11.9.1ac as a replacement for the above (ie the line that was in the 'Else' part of the 'If')
  
  ; first of all, stop all ASIO devices and disable and unjoin all output channels
  If gbAsioInitDone
    debugMsg3(sProcName, "stopping ASIO devices")
    For d = 0 To ArraySize(gaAudioDev())
      With gaAudioDev(d)
        If \bInitialized
          If \bASIO
            nBassResult = BASS_ASIO_SetDevice(\nDevBassASIODevice) ; set the ASIO device to work with
            debugMsg2(sProcName, "BASS_ASIO_SetDevice(" + \nDevBassASIODevice + ")", nBassResult)
            
            nBassResult = BASS_ASIO_IsStarted()
            debugMsg2(sProcName, "BASS_ASIO_IsStarted", nBassResult)
            
            If nBassResult = #BASSTRUE
              
              nBassResult = BASS_ASIO_Stop()  ; stop the device
              debugMsg2(sProcName, "BASS_ASIO_Stop for ASIO device " + \nDevBassASIODevice, nBassResult)
              
              nBassResult = BASS_ASIO_ChannelReset(#BASSFALSE, -1, #BASS_ASIO_RESET_ENABLE | #BASS_ASIO_RESET_JOIN) ; disable & unjoin all output channels
              debugMsg2(sProcName, "BASS_ASIO_ChannelReset(BASSFALSE, -1, BASS_ASIO_RESET_ENABLE|BASS_ASIO_RESET_JOIN)", nBassResult)
              
            EndIf
          EndIf
        EndIf
      EndWith
    Next d
    gbAsioStarted = #False
  EndIf
  
  If nMyAsioCount > 0
    debugMsg3(sProcName, "setting up ASIO devices")
    For d = 0 To ArraySize(gaMixerStreams())
      With gaMixerStreams(d)
        If \bASIO
          debugMsg(sProcName, "gaMixerStreams(" + d + ")\nFirstOutputChannel=" + \nFirstOutputChannel)
          nBassResult = BASS_ASIO_SetDevice(\nBassASIODevice) ; set the ASIO device to work with
          debugMsg2(sProcName, "BASS_ASIO_SetDevice(" + \nBassASIODevice + ")", nBassResult)
          
          ;get channel info to get number of channels to be joined, and frequency (sample rate)
          nBassResult = BASS_ChannelGetInfo(\nMixerStreamHandle, @rChanInfo)
          debugMsg2(sProcName, "BASS_ChannelGetInfo(" + decodeHandle(\nMixerStreamHandle) + ", rChanInfo)", nBassResult)
          \nSampleRate = rChanInfo\freq
          
          nFirstASIOChannel = \nFirstOutputChannel
          debugMsg(sProcName, "Calling BASS_ASIO_ChannelEnableBASS(#BASSFALSE, " + nFirstASIOChannel + ", " + decodeHandle(\nMixerStreamHandle) + ", #BASSTRUE)")
          nBassResult = BASS_ASIO_ChannelEnableBASS(#BASSFALSE, nFirstASIOChannel, \nMixerStreamHandle, #BASSTRUE)
          debugMsg2(sProcName, "BASS_ASIO_ChannelEnableBASS(#BASSFALSE, " + nFirstASIOChannel + ", " + decodeHandle(\nMixerStreamHandle) + ", #BASSTRUE)", nBassResult)
          If nBassResult = #BASSFALSE
            nErrorCode = BASS_ASIO_ErrorGetCode()
            If nErrorCode = #BASS_ERROR_ILLPARAM
              sErrorMsg = LangPars("Errors", "CannotEnableASIOChan", Str(nFirstASIOChannel))
              debugMsg3(sProcName, sErrorMsg)
              ensureSplashNotOnTop()
              scsMessageRequester("SCS Device Initialization", sErrorMsg, #PB_MessageRequester_Error)
              \bRecreateMixerStream = #True
            Else
              debugMsg3(sProcName, "BASS_ASIO_ErrorGetCode=" + nErrorCode + " (" + getBassErrorDesc(nErrorCode) + ")")
              ASIO_Error_(sProcName, "Can't enable ASIO channel")
              ProcedureReturn
            EndIf
          EndIf ; EndIf nBassResult = #BASSFALSE
        EndIf ; EndIf \bASIO
      EndWith
    Next d
    
    ; after all channel-enables and channel-joins have been done, start the ASIO devices used
    startAsioDevices()
    
  EndIf
  
  If grVST\nMaxDevVSTPlugin >= 0
    debugMsg(sProcName, "calling VST_loadAllDevVSTPlugins()")
    VST_loadAllDevVSTPlugins()
  EndIf
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure assignGaplessSeqEntry()
  PROCNAMEC()
  Protected nGaplessSeqPtr
  
  nGaplessSeqPtr = gnGaplessSeqCount
  If nGaplessSeqPtr > ArraySize(gaGaplessSeqs())
    ReDim gaGaplessSeqs(nGaplessSeqPtr+5)
  EndIf
  gaGaplessSeqs(nGaplessSeqPtr) = grGaplessSeqDef
  gnGaplessSeqCount + 1
  
  ProcedureReturn nGaplessSeqPtr
  
EndProcedure

Procedure createGaplessStreamIfReqd(nGaplessSeqPtr, pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nGaplessStream
  
  debugMsg(sProcName, #SCS_START + ", nGaplessSeqPtr=" + nGaplessSeqPtr)
  ; listStreamStatuses()
  
  If nGaplessSeqPtr >= 0
    With gaGaplessSeqs(nGaplessSeqPtr)
      If \nGaplessStream = 0
        If \nSampleRate = 0
          \nSampleRate = 44100
        EndIf
        If \nMaxFileChannels = 0
          \nMaxFileChannels = 2
        EndIf
        \nFlags = #BASS_SAMPLE_FLOAT | #BASS_MIXER_END
        If gbUseBASSMixer
          \nFlags | #BASS_STREAM_DECODE
        ElseIf pAudPtr >= 0
          If aAud(pAudPtr)\bUsingSplitStream
            \nFlags | #BASS_STREAM_DECODE
          EndIf
        EndIf
        nGaplessStream = BASS_Mixer_StreamCreate(\nSampleRate, \nMaxFileChannels, \nFlags)
        newHandle(#SCS_HANDLE_GAPLESS, nGaplessStream)
        debugMsg2(sProcName, "BASS_Mixer_StreamCreate(" + \nSampleRate + ", " + \nMaxFileChannels + ", " + decodeStreamCreateFlags(\nFlags, #True) + ")", nGaplessStream)
        ; logKeyEvent("BASS_Mixer_StreamCreate(" + \nSampleRate + ", " + \nMaxFileChannels + ", " + decodeStreamCreateFlags(\nFlags, #True) + ") returned " + decodeHandle(nGaplessStream))
        \nGaplessStream = nGaplessStream
        \nSyncHandle = BASS_ChannelSetSync(nGaplessStream, #BASS_SYNC_END|#BASS_SYNC_MIXTIME, 0, @PlayEndSyncProcGapless(), nGaplessSeqPtr); // set sync for end
        newHandle(#SCS_HANDLE_SYNC, \nSyncHandle)
        debugMsg2(sProcName, "BASS_ChannelSetSync(" + decodeHandle(nGaplessStream) + ", #BASS_SYNC_END|#BASS_SYNC_MIXTIME, 0, @PlayEndSyncProcGapless(), " + nGaplessSeqPtr + ")", \nSyncHandle)
        If \nSyncHandle = 0
          debugMsg3(sProcName, "BASS_ErrorGetCode()=" + getBassErrorDesc(BASS_ErrorGetCode()))
        EndIf
      Else
        nGaplessStream = \nGaplessStream
      EndIf
    EndWith
  EndIf
  
  ; listStreamStatuses()
  debugMsg(sProcName, #SCS_END + ", returning " + decodeHandle(nGaplessStream))
  ProcedureReturn nGaplessStream
  
EndProcedure

Procedure populateCboTrim(hCboTrim)
  PROCNAMEC()
  
  ClearGadgetItems(hCboTrim)
  addGadgetItemWithData(hCboTrim, #SCS_ZERO_DBTRIM, 0)
  addGadgetItemWithData(hCboTrim, "-10", -10)
  addGadgetItemWithData(hCboTrim, "-20", -20)
  addGadgetItemWithData(hCboTrim, "-30", -30)
  addGadgetItemWithData(hCboTrim, "-40", -40)
  addGadgetItemWithData(hCboTrim, "-50", -50)
EndProcedure

Procedure populateCboTracksForAud(hCboTracks, pAudPtr, nDevNo)
  PROCNAMECA(pAudPtr)
  Protected n, nFileChannels, nNrOfOutputChans
  Protected nLogicalDevPtr
  
  ; debugMsg(sProcName, #SCS_START)
  
  ClearGadgetItems(hCboTracks)
  
  If pAudPtr < 0
    ProcedureReturn
  EndIf
  
  ; debugMsg(sProcName, "\sLogicalDev[" + nDevNo + "]=" + aAud(pAudPtr)\sLogicalDev[nDevNo])
  If Len(aAud(pAudPtr)\sLogicalDev[nDevNo]) = 0
    ProcedureReturn
  EndIf
  
  nLogicalDevPtr = getProdLogicalDevPtrForLogicalDev(aAud(pAudPtr)\sLogicalDev[nDevNo])
  If nLogicalDevPtr >= 0
    nNrOfOutputChans = grProd\aAudioLogicalDevs(nLogicalDevPtr)\nNrOfOutputChans
  EndIf
  
  AddGadgetItem(hCboTracks, -1, #SCS_TRACKS_DFLT)
  
  nFileChannels = aAud(pAudPtr)\nFileChannels
  If nFileChannels > 1
    For n = 1 To nFileChannels
      AddGadgetItem(hCboTracks, -1, Str(n))
    Next n
    If nNrOfOutputChans > 1
      AddGadgetItem(hCboTracks, -1, #SCS_TRACKS_ALL)
    EndIf
  EndIf
  
EndProcedure

Procedure populateCboTracksForSub(hCboTracks, pSubPtr, nDevNo)
  PROCNAMECS(pSubPtr)
  Protected n, nMaxFileChannels, nNrOfOutputChans
  Protected nLogicalDevPtr
  Protected k
  
  ; debugMsg(sProcName, #SCS_START)
  
  ClearGadgetItems(hCboTracks)
  
  If pSubPtr < 0
    ProcedureReturn
  EndIf
  
  ; debugMsg(sProcName, "\sPLLogicalDev[" + nDevNo + "]=" + aSub(pSubPtr)\sPLLogicalDev[nDevNo])
  If Len(aSub(pSubPtr)\sPLLogicalDev[nDevNo]) = 0
    ProcedureReturn
  EndIf
  
  k = aSub(pSubPtr)\nFirstAudIndex
  While k >= 0
    If aAud(k)\nFileChannels > nMaxFileChannels
      nMaxFileChannels = aAud(k)\nFileChannels
    EndIf
    k = aAud(k)\nNextAudIndex
  Wend
  
  nLogicalDevPtr = getProdLogicalDevPtrForLogicalDev(aSub(pSubPtr)\sPLLogicalDev[nDevNo])
  If nLogicalDevPtr >= 0
    nNrOfOutputChans = grProd\aAudioLogicalDevs(nLogicalDevPtr)\nNrOfOutputChans
  EndIf
  
  AddGadgetItem(hCboTracks, -1, #SCS_TRACKS_DFLT)
  
  If nMaxFileChannels > 1
    For n = 1 To nMaxFileChannels
      AddGadgetItem(hCboTracks, -1, Str(n))
    Next n
    If nNrOfOutputChans > 1
      AddGadgetItem(hCboTracks, -1, #SCS_TRACKS_ALL)
    EndIf
  EndIf
  
EndProcedure

Procedure mergeDuplicateAsioDevs()
  PROCNAMEC()
  Protected bResult
  Protected d1, d2
  Protected nSpeakerFlag
  Protected nSpeakerCount
  Protected nFirstOutputChannel.l
  Protected nFirstD1Channel.l, nLastD1Channel.l
  Protected nFirstD2Channel.l, nLastD2Channel.l
  Protected sPrompt.s, sTitle.s
  Protected bChanged
  Protected nDevMapPtr

  debugMsg(sProcName, #SCS_START)
  
  bResult = #True
  
  If gbUseSMS
    debugMsg(sProcName, "exiting because gbUseSMS=#True")
    ProcedureReturn #True
  EndIf
  
  If gbUseBASSMixer = #False
    debugMsg(sProcName, "exiting because gbUseBASSMixer=#False")
    ProcedureReturn #True
  EndIf
  
  nDevMapPtr = grProd\nSelectedDevMapPtr
  If nDevMapPtr < 0
    debugMsg(sProcName, "exiting because nDevMapPtr=" + nDevMapPtr)
    ProcedureReturn #False
  EndIf
  
  ; NOTE: Pass 1: initial settings
  debugMsg(sProcName, "pass 1")
  d1 = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
  While d1 >= 0
    With grMaps\aDev(d1)
      ; debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\bBassASIO=" + strB(\bBassASIO) + ", \nNextDevIndex=" + \nNextDevIndex)
      If (\nDevType = #SCS_DEVTYPE_AUDIO_OUTPUT) And (\bExists)
        ; debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\sLogicalDev=" + \sLogicalDev + ", \bBassASIO=" + strB(\bBassASIO) + ", \nReassignDevMapDevPtr=" + \nReassignDevMapDevPtr)
        If \bBassASIO
          \nFirstASIOChannel = -1
          \nLastASIOChannel = -1
          \sReassignPhysicalDev = ""
          \sReassignSpeaker = ""
          \nReassignDevMapDevPtr = -1   ; added 21Oct2015 11.4.1 to fix loop encountered by Christian Peters in 11.4.1v - see comments further down this procedure
          \nFirst1BasedOutputChan = getFirst1BasedChanFromRange(\s1BasedOutputRange)
          \nNrOfDevOutputChans = getNumChansFromRange(\s1BasedOutputRange)
          \nFirstASIOChannel = \nFirst1BasedOutputChan - 1
          \nLastASIOChannel = \nFirstASIOChannel + \nNrOfDevOutputChans - 1
          debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\sLogicalDev=" + \sLogicalDev + ", \bBassASIO=" + strB(\bBassASIO) + ", \nReassignDevMapDevPtr=" + \nReassignDevMapDevPtr +
                              ", \nFirst1BasedOutputChan=" + \nFirst1BasedOutputChan + ", \nNrOfDevOutputChans=" + \nNrOfDevOutputChans)
        EndIf
      EndIf
      d1 = \nNextDevIndex
    EndWith
  Wend
  
  ; NOTE: Pass 2: look for duplicates
  debugMsg(sProcName, "pass 2")
  d1 = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
  While d1 >= 0
    With grMaps\aDev(d1)
      If (\nDevType = #SCS_DEVTYPE_AUDIO_OUTPUT) And (\bExists)
        If \bBassASIO
          nFirstD1Channel = \nFirstASIOChannel
          nLastD1Channel = \nLastASIOChannel
          debugMsg(sProcName, "d1:" + \sLogicalDev + ", \nFirstASIOChannel=" + Str(\nFirstASIOChannel) + ", \nLastASIOChannel=" + Str(\nLastASIOChannel))
          d2 = \nNextDevIndex
          While d2 >= 0
            If grMaps\aDev(d2)\nDevType = #SCS_DEVTYPE_AUDIO_OUTPUT And grMaps\aDev(d2)\bExists
              If grMaps\aDev(d2)\bBassASIO
                debugMsg(sProcName, "d2:" + grMaps\aDev(d2)\sLogicalDev + ", \nFirstASIOChannel=" + Str(grMaps\aDev(d2)\nFirstASIOChannel) + ", \nLastASIOChannel=" + Str(grMaps\aDev(d2)\nLastASIOChannel))
                If grMaps\aDev(d2)\sPhysicalDev = \sPhysicalDev
                  nFirstD2Channel = grMaps\aDev(d2)\nFirstASIOChannel
                  nLastD2Channel = grMaps\aDev(d2)\nLastASIOChannel
                  If (nFirstD2Channel <= nLastD1Channel) And (nLastD2Channel >= nFirstD1Channel)
                    ; we have an overlap
                    debugMsg(sProcName, "overlap")
                    If ((nFirstD2Channel < nFirstD1Channel) And (nLastD2Channel < nLastD1Channel)) Or ((nFirstD1Channel < nFirstD2Channel) And (nLastD1Channel < nLastD2Channel))
                      ; illegal overlap - the smaller channel range MUST be fully contained within the larger channel range
                      debugMsg(sProcName, "overlap illegal")
                      setMouseCursorNormal()
                      ensureSplashNotOnTop()
                      gbModalDisplayed = #True
                      sPrompt = "Devices " + \sLogicalDev + " and " + grMaps\aDev(d2)\sLogicalDev + " have incompatible ASIO output selections. Where the same ASIO outputs are used then SCS needs to merge the device outputs," + " and can only do this if the smaller range of outputs is fully contained within the larger range of outputs."
                      sTitle = "SCS Device Check"
                      ensureSplashNotOnTop()
                      scsMessageRequester(sTitle, sPrompt, #PB_MessageRequester_Error)
                      ProcedureReturn #False
                    Else
                      ;overlap is OK - reassign the smaller range to the larger range
                      debugMsg(sProcName, "overlap ok")
                      If \nNrOfDevOutputChans < grMaps\aDev(d2)\nNrOfDevOutputChans
                        \nReassignDevMapDevPtr = d2
                        \sReassignPhysicalDev = grMaps\aDev(d2)\sPhysicalDev
                        \sReassignSpeaker = grMaps\aDev(d2)\sSpeaker
                        \nBassDevice = grMaps\aDev(d2)\nBassDevice
                        debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\nBassDevice=" + \nBassDevice)
                        \nBassASIODevice = grMaps\aDev(d2)\nBassASIODevice
                        \nMixerStreamPtr = grMaps\aDev(d2)\nMixerStreamPtr
                      Else
                        grMaps\aDev(d2)\nReassignDevMapDevPtr = d1
                        ; debugMsg(sProcName, "grMaps\aDev(" + d2 + ")\nReassignDevMapDevPtr=" + grMaps\aDev(d2)\nReassignDevMapDevPtr)
                        grMaps\aDev(d2)\sReassignPhysicalDev = \sPhysicalDev
                        grMaps\aDev(d2)\sReassignSpeaker = \sSpeaker
                        grMaps\aDev(d2)\nBassDevice = \nBassDevice
                        debugMsg(sProcName, "grMaps\aDev(" + d2 + ")\nBassDevice=" + Str(grMaps\aDev(d2)\nBassDevice))
                        grMaps\aDev(d2)\nBassASIODevice = \nBassASIODevice
                        grMaps\aDev(d2)\nMixerStreamPtr = \nMixerStreamPtr
                      EndIf
                      debugMsg(sProcName, "grMaps\aMap(" + nDevMapPtr + ")\rAudioDev(" + d2 + ")\nMixerStreamPtr=" + grMaps\aDev(d2)\nMixerStreamPtr)
                    EndIf
                  EndIf
                EndIf
              EndIf
            EndIf
            d2 = grMaps\aDev(d2)\nNextDevIndex
          Wend
        EndIf
      EndIf
      d1 = \nNextDevIndex
    EndWith
  Wend
  
  ; now look for any re-assignments to devices that are themselves re-assigned, and change the assignment to the re-assignment
  Repeat
    bChanged = #False
    d1 = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
    While d1 >= 0
      With grMaps\aDev(d1)
        If (\nDevType = #SCS_DEVTYPE_AUDIO_OUTPUT) And (\bExists)
          If \nReassignDevMapDevPtr >= 0
            d2 = grMaps\aDev(\nReassignDevMapDevPtr)\nReassignDevMapDevPtr
            If (d2 >= 0) And (d2 <> d1)
              ; (d2 <> d1) test should not be necessary now that \nReassignDevMapDevPtr is initialised at -1 in 'pass 1'
              ; but added as an extra precaution after loop encountered by Christian Peters in 11.4.1v 20/10/2015
              bChanged = #True
              debugMsg(sProcName, "changing " + d1 + " to reassign to " + d2)
              \nReassignDevMapDevPtr = d2
              ; debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\nReassignDevMapDevPtr=" + \nReassignDevMapDevPtr)
              \sReassignPhysicalDev = grMaps\aDev(d2)\sPhysicalDev
              \sReassignSpeaker = grMaps\aDev(d2)\sSpeaker
              \nBassDevice = grMaps\aDev(d2)\nBassDevice
              debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\nBassDevice=" + \nBassDevice)
              \nBassASIODevice = grMaps\aDev(d2)\nBassASIODevice
              \nMixerStreamPtr = grMaps\aDev(d2)\nMixerStreamPtr
              debugMsg(sProcName, "grMaps\aMap(" + getDevMapName(nDevMapPtr) + ")\rAudioDev(" + d2 + ")\nMixerStreamPtr=" + Str(grMaps\aDev(d2)\nMixerStreamPtr))
            EndIf
          EndIf
        EndIf
        d1 = \nNextDevIndex
      EndWith
    Wend
    If bChanged = #False
      Break
    EndIf
  ForEver
  
  d1 = grMaps\aMap(nDevMapPtr)\nFirstDevIndex
  While d1 >= 0
    With grMaps\aDev(d1)
      If \nDevType = #SCS_DEVTYPE_AUDIO_OUTPUT And \bExists
        If (\sLogicalDev) And (\bBassASIO)
          debugMsg(sProcName, "grMaps\aDev(" + d1 + ")\sLogicalDev=" + \sLogicalDev + ", \sPhysicalDev=" + \sPhysicalDev + ", \sSpeaker=" + \sSpeaker)
          debugMsg(sProcName, ".. \sReassignPhysicalDev=" + \sReassignPhysicalDev + ", \nFirstASIOChannel=" + \nFirstASIOChannel + ", \nLastASIOChannel=" + \nLastASIOChannel)
          debugMsg(sProcName, ".. \nBassDevice=" + \nBassDevice + ", \nBassASIODevice=" + \nBassASIODevice)
          debugMsg(sProcName, ".. \nReassignDevMapDevPtr=" + \nReassignDevMapDevPtr + ", \nMixerStreamPtr=" + \nMixerStreamPtr + ", \nNrOfDevOutputChans=" + \nNrOfDevOutputChans)
        EndIf
      EndIf
      d1 = \nNextDevIndex
    EndWith
  Wend
  
  ProcedureReturn bResult
  
EndProcedure

Procedure setTestToneLevel()
  PROCNAMEC()
  Protected nBassResult.l

  If gbUseBASS
    If grTestTone\bPlayingTestTone
      If grTestTone\nTestToneChan <> 0
        If grTestTone\bSetLevelInStreamProcTestTone = #False
          nBassResult = BASS_ChannelSetAttribute(grTestTone\nTestToneChan, #BASS_ATTRIB_VOL, grProd\fTestToneBVLevel)
          ; debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(grTestTone\nTestToneChan) + ", BASS_ATTRIB_VOL, " + formatLevel(grProd\fTestToneBVLevel) + ")", nBassResult)
        EndIf
      EndIf
    EndIf
  Else  ; SM-S
    With grMMedia
      If grTestTone\bPlayingTestTone
        If Len(\sTestToneChan) > 0
          sendSMSCommand("set chan x1000." + \sTestToneChan + " gaindb " + grProd\sTestToneDBLevel + " fadetime " + \sTestToneFadeTime)
        EndIf
      EndIf
    EndWith
  EndIf

EndProcedure

Procedure setTestTonePan()
  ; Added 4May2022
  PROCNAMEC()
  Protected nBassResult.l
  Protected sTestToneChanL.s, sTestToneChanR.s
  Protected fMyLevel.f, fMyPan.f
  Protected fBVLevelLeft.f, fBVLevelRight.f, fPanFactor.f
  Protected sLeft.s, sRight.s, sFadeString.s
  Protected sLeftFinal.s, sRightFinal.s, sFadeStringFinal.s
  Protected sCommandString.s
  
  If gbUseBASS
    If grTestTone\bPlayingTestTone
      If grTestTone\nTestToneChan <> 0
        nBassResult = BASS_ChannelSetAttribute(grTestTone\nTestToneChan, #BASS_ATTRIB_PAN, grProd\fTestTonePan)
        ; debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(grTestTone\nTestToneChan) + ", #BASS_ATTRIB_PAN, " + formatPan(grProd\fTestTonePan) + ")", nBassResult)
      EndIf
    EndIf
  Else  ; SM-S
    With grMMedia
      If grTestTone\bPlayingTestTone
        If \sTestToneChan
          fMyLevel = grProdForDevChgs\fTestToneBVLevel
          fMyPan = grProdForDevChgs\fTestTonePan
          If fMyPan = #SCS_PANCENTRE_SINGLE
            fBVLevelLeft = fMyLevel
            fBVLevelRight = fMyLevel
          ElseIf fMyPan < 0  ; pan left
            fBVLevelLeft = fMyLevel
            fPanFactor = 1 - (fMyPan * -1)
            fBVLevelRight = fMyLevel * fPanFactor
          Else              ; pan right
            fBVLevelRight = fMyLevel
            fPanFactor = 1 - fMyPan
            fBVLevelLeft = fMyLevel * fPanFactor
          EndIf
          sTestToneChanL = StringField(\sTestToneChan, 1, "-")
          sTestToneChanR = StringField(\sTestToneChan, 2, "-")
          sLeftFinal = " gaindb " + makeSMSGainDBString(fBVLevelLeft)
          sRightFinal = " gaindb " + makeSMSGainDBString(fBVLevelRight)
          sCommandString = "set chan x1000." + sTestToneChanL + sLeftFinal + " chan x1000." + sTestToneChanR + sRightFinal
          sendSMSCommand(sCommandString, #False)
        EndIf
      EndIf
    EndWith
  EndIf

EndProcedure

Procedure setTimeOverrides(nFadeFieldType, nSFRAction, nTimeOverride, nFromCuePtr, nUptoCuePtr, nSFRCueType, nSubNo=-1, nExcludeCuePtr=-1, bExcludeSFRCueList=#False)
  PROCNAMEC()
  ; nb nSubNo added for SCS 11.2.1
  ; nSubNo ignored if nUptoCuePtr <> nFromCuePtr
  ; if nSubNo = -1 this means ignore nSubNo, ie apply time overrides to all subs for the cue
  Protected i, j, k
  Protected nItemState, bWantThisCue, bWantThisSub, bWantThisAud
  Protected nMySubNo
  Protected bAnyCues, bPlayingCuesOnly, bAudioOnly, bVideoOnly, bLiveOnly
  Protected nCurrPlayIndex, nNextPlayIndex

  debugMsg(sProcName, #SCS_START + ", nFadeFieldType=" + decodeFadeFieldType(nFadeFieldType) + ", nSFRAction=" + decodeSFRAction(nSFRAction) + ", nTimeOverride=" + nTimeOverride +
                      ", nFromCuePtr=" + getCueLabel(nFromCuePtr) + ", nUptoCuePtr=" + getCueLabel(nUptoCuePtr) +
                      ", nSFRCueType=" + decodeSFRCueType(nSFRCueType) + ", nSubNo=" + nSubNo + ", nExcludeCuePtr=" + getCueLabel(nExcludeCuePtr) + ", bExcludeSFRCueList=" + strB(bExcludeSFRCueList))
  
  setProcSFRFlags(nSFRCueType)  ; macro sets bPlayingCuesOnly, bAudioOnly and bVideoOnly, based on nSRCueType
  debugMsg(sProcName, "bPlayingCuesOnly=" + strB(bPlayingCuesOnly) + ", bAudioOnly=" + strB(bAudioOnly) + ", bVideoOnly=" + strB(bVideoOnly) + ", bLiveOnly=" + strB(bLiveOnly))
  
  If nFromCuePtr = nUptoCuePtr
    ; only one cue requested so can use nSubNo
    nMySubNo = nSubNo
  Else
    nMySubNo = -1
  EndIf
  
  For i = nFromCuePtr To nUptoCuePtr
    nItemState = aCue(i)\nCueState
    ; debugMsg(sProcName, "aCue(" + getCueLabel(i) + ")\nCueState=" + decodeCueState(aCue(i)\nCueState))
    bWantThisCue = #False
    If i <> nExcludeCuePtr
      If bPlayingCuesOnly
        If (nItemState >= #SCS_CUE_FADING_IN) And (nItemState <= #SCS_CUE_FADING_OUT)
          bWantThisCue = #True
        EndIf
      Else
        If (nItemState < #SCS_CUE_COMPLETED)
          bWantThisCue = #True
        EndIf
      EndIf
    EndIf
    If bWantThisCue
      If aCue(i)\nActivationMethod = #SCS_ACMETH_AUTO
        If aCue(i)\nAutoActCuePtr = nExcludeCuePtr
          bWantThisCue = #False
        EndIf
      EndIf
    EndIf
    If bWantThisCue
      j = aCue(i)\nFirstSubIndex
      While j >= 0
        With aSub(j)
          debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\sSubType=" + \sSubType + ", \bSubTypeP=" + strB(\bSubTypeP) + ", \bSubTypeF=" + strB(\bSubTypeF) + ", \bSubTypeA=" + strB(\bSubTypeA))
          bWantThisSub = #False
          If nMySubNo = -1 Or nMySubNo = \nSubNo
            nItemState = \nSubState
            If bPlayingCuesOnly
              If (nItemState >= #SCS_CUE_FADING_IN) And (nItemState <= #SCS_CUE_FADING_OUT)
                bWantThisSub = #True
              EndIf
            Else
              If (nItemState < #SCS_CUE_COMPLETED)
                bWantThisSub = #True
              EndIf
            EndIf
          EndIf
          If bWantThisSub
            If \bSubEnabled = #False
              bWantThisSub = #False
            EndIf
            If bAudioOnly And \bSubTypeForP = #False
              bWantThisSub = #False
            EndIf
            If bVideoOnly And \bSubTypeA = #False
              bWantThisSub = #False
            EndIf
            If bLiveOnly And \bSubTypeI = #False
              bWantThisSub = #False
            EndIf
          EndIf
          If bWantThisSub
            If \bSubTypeAorP
              Select nFadeFieldType
                Case #SCS_FADE_IN_FIELD
                  If nTimeOverride >= 0
                    \nPLCurrFadeInTime = nTimeOverride
                  Else
                    \nPLCurrFadeInTime = \nPLFadeInTime
                  EndIf
                  debugMsg(sProcName, \sSubLabel + ", \nPLCurrFadeInTime=" + \nPLCurrFadeInTime)
                  ; added 17Mar2019 11.8.0.2ce following email from Rob Taylor that SFR time override is not applied on resuming a hibernated playlist cue
                  nCurrPlayIndex = \nCurrPlayIndex
                  If nCurrPlayIndex >= 0
                    Select nSFRAction
                      Case #SCS_SFR_ACT_RESUMEHIB
                        aAud(nCurrPlayIndex)\nCurrFadeInTime = \nPLCurrFadeInTime
                        debugMsg(sProcName, "aAud(" + getAudLabel(nCurrPlayIndex) + ")\nCurrFadeInTime=" + aAud(nCurrPlayIndex)\nCurrFadeInTime)
                      Case #SCS_SFR_ACT_RESUMEHIBNEXT
                        nNextPlayIndex = aAud(nCurrPlayIndex)\nNextPlayIndex
                        If nNextPlayIndex >= 0
                          aAud(nNextPlayIndex)\nCurrFadeInTime = \nPLCurrFadeInTime
                          debugMsg(sProcName, "aAud(" + getAudLabel(nNextPlayIndex) + ")\nCurrFadeInTime=" + aAud(nNextPlayIndex)\nCurrFadeInTime)
                        EndIf
                    EndSelect
                  EndIf
                  ; end added 17Mar2019 11.8.0.2ce
                Case #SCS_FADE_OUT_FIELD
                  If nTimeOverride >= 0
                    \nPLCurrFadeOutTime = nTimeOverride
                  Else
                    \nPLCurrFadeOutTime = \nPLFadeOutTime
                  EndIf
                  debugMsg(sProcName, \sSubLabel + ", \nPLCurrFadeOutTime=" + \nPLCurrFadeOutTime)
                  ; added 18Mar2019 11.8.0.2ce to follow 17Mar2019 changes made above
                  nCurrPlayIndex = \nCurrPlayIndex
                  If nCurrPlayIndex >= 0
                    aAud(nCurrPlayIndex)\nCurrFadeOutTime = \nPLCurrFadeOutTime
                  EndIf
                  ; end added 18Mar2019 11.8.0.2ce
              EndSelect
            EndIf
            If \bSubTypeAorF Or \bSubTypeI
              k = \nFirstPlayIndex
              While k >= 0
                bWantThisAud = #False
                nItemState = aAud(k)\nAudState
                If bPlayingCuesOnly
                  If (nItemState >= #SCS_CUE_FADING_IN) And (nItemState <= #SCS_CUE_FADING_OUT)
                    bWantThisAud = #True
                  EndIf
                Else
                  If (nItemState < #SCS_CUE_COMPLETED)
                    bWantThisAud = #True
                  EndIf
                EndIf
                If (bWantThisAud) And (aAud(k)\nFileFormat <> #SCS_FILEFORMAT_MIDI)
                  Select nFadeFieldType
                    Case #SCS_FADE_IN_FIELD
                      If nTimeOverride >= 0
                        aAud(k)\nCurrFadeInTime = nTimeOverride
                      Else
                        aAud(k)\nCurrFadeInTime = aAud(k)\nFadeInTime
                      EndIf
                      debugMsg(sProcName, aAud(k)\sAudLabel + ", \nCurrFadeInTime=" + aAud(k)\nCurrFadeInTime)
                    Case #SCS_FADE_OUT_FIELD
                      If nTimeOverride >= 0
                        aAud(k)\nCurrFadeOutTime = nTimeOverride
                      Else
                        aAud(k)\nCurrFadeOutTime = aAud(k)\nFadeOutTime
                      EndIf
                      debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\nCurrFadeOutTime=" + aAud(k)\nCurrFadeOutTime)
                  EndSelect
                EndIf
                k = aAud(k)\nNextPlayIndex
              Wend
            EndIf
          EndIf
          j = \nNextSubIndex
        EndWith
      Wend
    EndIf
  Next i

EndProcedure

Procedure playTestTone(nDevNo, fBVLevel.f, fPan.f)
  ; Modified 4May2022 11.9.1 to include fPan
  PROCNAMEC()
  Protected nBassDevice
  Protected bFound
  Protected nBassError, bResult
  Protected bDevInitialized
  Protected nDevMapDevPtr
  Protected sMyLogicalDev.s
  Protected sMsg.s
  
  bResult = #True
  
  debugMsg(sProcName, #SCS_START + ", nDevNo=" + nDevNo)
  
  sMyLogicalDev = grProdForDevChgs\aAudioLogicalDevs(nDevNo)\sLogicalDev
  nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMapsForDevChgs, #SCS_DEVGRP_AUDIO_OUTPUT, sMyLogicalDev)
  debugMsg(sProcName, "sLogicalDev=" + sMyLogicalDev + ", nDevMapDevPtr=" + nDevMapDevPtr)
  grTestTone\nDevMapDevPtr = nDevMapDevPtr
  If nDevMapDevPtr < 0
    ProcedureReturn #False
  EndIf
  
  With grMapsForDevChgs\aDev(nDevMapDevPtr)
    
    debugMsg(sProcName, "\nPhysicalDevPtr=" + \nPhysicalDevPtr)
    If \nPhysicalDevPtr >= 0
      bFound = #True
      nBassDevice = gaAudioDev(\nPhysicalDevPtr)\nBassDevice
      If gaAudioDev(\nPhysicalDevPtr)\bInitialized = #False
        debugMsg(sProcName, "calling initDevice(" + \nPhysicalDevPtr + ")")
        initDevice(\nPhysicalDevPtr)
      EndIf
      bDevInitialized = gaAudioDev(\nPhysicalDevPtr)\bInitialized
    EndIf
    
    debugMsg(sProcName, "bFound=" + strB(bFound) + ", bDevInitialized=" + strB(bDevInitialized) + ", gbUseBASS=" + strB(gbUseBASS) + ", gnCurrAudioDriver=" + decodeDriver(gnCurrAudioDriver))
    If bFound And bDevInitialized
      If gbUseBASS
        ; Changed 3May2022pm 11.9.1
        Select grProd\nTestSound 
          Case #SCS_TEST_TONE_PINK
            debugMsg(sProcName, "calling playResFile(" + nDevNo + ", 4, " +#DQUOTE$ + "PINK" + #DQUOTE$ + ", " + formatLevel(fBVLevel) + ", " + formatPan(fPan) + ")")
            nBassError = playResFile(nDevNo, 4, "PINK", fBVLevel, fPan) ; Changed 4May2022 11.9.1
          Default ; sine wave
            debugMsg(sProcName, "calling playResFile(" + nDevNo + ", 3, " +#DQUOTE$ + "WAVE" + #DQUOTE$ + ", " + formatLevel(fBVLevel) + ", " + formatPan(fPan) + ")")
            nBassError = playResFile(nDevNo, 3, "WAVE", fBVLevel, fPan) ; Changed 4May2022 11.9.1) 
        EndSelect
        ; End changed 3May2022pm 11.9.1
        If nBassError = #BASS_ERROR_SPEAKER
          bResult = #False
          sMsg = "Unavailable Speaker" + Chr(10) + Chr(10) + "'" + \s1BasedOutputRange + "' not available for '" + \sPhysicalDev + "'"
          scsMessageRequester(Lang("Requesters","TestTone"), sMsg, #PB_MessageRequester_Ok|#MB_ICONEXCLAMATION)
        ElseIf nBassError <> #BASS_OK
          bResult = #False
          Error_2(sProcName, nBassError, "Cannot play test tone")
        EndIf
        
      Else ; SM-S
        grTestTone\dTestTonePos = 0
        grMMedia\sTestToneChan = \s0BasedOutputRangeAG ; get0BasedFrom1BasedChanString(\s1BasedOutputRange)
        ; Changed 3May2022pm 11.9.1
        Select grProd\nTestSound 
          Case #SCS_TEST_TONE_PINK
            sendSMSCommand("set gen 1000 shape pink")
          Default ; sine wave
            sendSMSCommand("set gen 1000 shape sine freq 440")     ; 440Hz Sine Wave
        EndSelect
        ; End changed 3May2022pm 11.9.1
        sendSMSCommand("set chan i1000 mute off gain 1")
        sendSMSCommand("set chan x1000." + grMMedia\sTestToneChan + " gaindb " + grProdForDevChgs\sTestToneDBLevel + " fadetime " + grMMedia\sTestToneFadeTime)
        ; sendSMSCommand("set chan x1000." + grMMedia\sTestToneChan + " gaindb " + grProdForDevChgs\sTestToneDBLevel) ; + " fadetime " + grMMedia\sTestToneFadeTime)
        grTestTone\bPlayingTestTone = #True
        ; ??? ntimetoremovetimer = 0
      EndIf
    EndIf
    
    grTestTone\nTestToneChan = \nTestToneChan
    grTestTone\nTestToneDevNo = nDevNo
    grTestTone\qTimeTestToneStarted = ElapsedMilliseconds()
    grTestTone\bPlayingTestTone = #True
    grTestTone\nMixerStreamPtr = \nMixerStreamPtr
    grTestTone\bSetLevelInStreamProcTestTone = #False
    
  EndWith
  
  samAddRequest(#SCS_SAM_BUILD_DEV_CHANNEL_LIST)
  startVUDisplayIfReqd()
  
  ProcedureReturn bResult
  
EndProcedure

Procedure playStreamProcTestTone(nDevNo, fBVLevel.f, fPan.f)
  PROCNAMEC()
  Protected hTestToneChannel.l, nResult.l
  Protected d
  Protected nBassDevice.l, bFound
  Protected nBassError.l
  Protected nMySampleRate.l
  Protected nFlags.l, nChans.l
  Protected sMsg.s
  Protected bDevInitialized
  Protected nDevMapDevPtr
  Protected sMyLogicalDev.s
  Protected nPass
  
  debugMsg(sProcName, #SCS_START + ", nDevNo=" + nDevNo)
  
  If gbUseBASS = #False
    ProcedureReturn #True
  EndIf
  
  sMyLogicalDev = grProdForDevChgs\aAudioLogicalDevs(nDevNo)\sLogicalDev
  nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMapsForDevChgs, #SCS_DEVGRP_AUDIO_OUTPUT, sMyLogicalDev)
  debugMsg(sProcName, "sLogicalDev=" + sMyLogicalDev + ", nDevMapDevPtr=" + nDevMapDevPtr)
  grTestTone\nDevMapDevPtr = nDevMapDevPtr
  If nDevMapDevPtr < 0
    ProcedureReturn #False
  EndIf
  
  With grMapsForDevChgs\aDev(nDevMapDevPtr)
    bFound = #False
    For nPass = 1 To 2
      For d = 0 To gnPhysicalAudDevs - 1
        If comparePhysDevDescs(gaAudioDev(d)\sDesc, \sPhysicalDev, nPass)
          nBassDevice = gaAudioDev(d)\nBassDevice
          bFound = #True
          If gaAudioDev(d)\bInitialized = #False
            debugMsg(sProcName, "calling initDevice(" + d + ")")
            initDevice(d)
          EndIf
          bDevInitialized = gaAudioDev(d)\bInitialized
          nMySampleRate = gaAudioDev(d)\nSampleRate
          Break
        EndIf
      Next d
      If bFound
        Break
      EndIf
    Next nPass
    debugMsg(sProcName, "sPhysicalDev=" + \sPhysicalDev + ", bFound=" + strB(bFound) + ", bDevInitialized=" + strB(bDevInitialized))
    
    If bFound And bDevInitialized
      
      If nMySampleRate = 0
        nMySampleRate = grDriverSettings\nDSSampleRate
      EndIf
      If nMySampleRate = 0
        nMySampleRate = 44100
      EndIf
      
      grTestTone\dTestToneSampleRate = nMySampleRate
      grTestTone\dTestToneFreq = 440
      grTestTone\dTestTonePos = 0
      grTestTone\bSetLevelInStreamProcTestTone = #True
      
      nResult = BASS_SetDevice(\nBassDevice)
      debugMsg2(sProcName, "BASS_SetDevice(" + \nBassDevice + ")", nResult)
      
      nFlags = \nBassSpeakerFlags
      ; nFlags | #BASS_SAMPLE_FLOAT   ; cannot use BASS_SAMPLE_FLOAT because streamTestTone() does not build a float stream
      ; nChans = \nNrOfOutputChans
      nChans = 1                      ; set nChans = 1 because streamTestTone() builds a mono stream
      
      nResult = BASS_SetConfig(#BASS_CONFIG_BUFFER, 300)
      debugMsg2(sProcName, "BASS_SetConfig(BASS_CONFIG_BUFFER, 300)", nResult)
      hTestToneChannel = BASS_StreamCreate(nMySampleRate, nChans, nFlags, @streamTestTone(), 0)
      newHandle(#SCS_HANDLE_SOURCE, hTestToneChannel)
      debugMsg2(sProcName, "BASS_StreamCreate(" + Str(nMySampleRate) + ", " + Str(nChans) + ", " + decodeStreamCreateFlags(nFlags) + ", @streamTestTone(), 0)", hTestToneChannel)
      If hTestToneChannel = 0
        nBassError = BASS_ErrorGetCode()
        If nBassError = #BASS_ERROR_SPEAKER
          sMsg = "Unavailable Speaker" + #CRLF$ + #CRLF$ + "'" + \sSpeaker + "' not available for '" + \sPhysicalDev + "'"
          debugMsg(sProcName, ReplaceString(sMsg, #CRLF$, " "))
          scsMessageRequester(Lang("Requesters","TestTone"), sMsg, #PB_MessageRequester_Ok|#MB_ICONEXCLAMATION)
          ProcedureReturn #False
        Else
          Error_2(sProcName, nBassError, "BASS_StreamCreate failed")
          ProcedureReturn #False
        EndIf
      EndIf
      
      nResult = BASS_ChannelSetAttribute(hTestToneChannel, #BASS_ATTRIB_VOL, #SCS_MINVOLUME_SINGLE)
      debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(hTestToneChannel) + ", BASS_ATTRIB_VOL, " + traceLevel(#SCS_MINVOLUME_SINGLE) + ")", nResult)
      ; Added 4May2022 11.9.1
      nResult = BASS_ChannelSetAttribute(hTestToneChannel, #BASS_ATTRIB_PAN, fPan)
      debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(hTestToneChannel) + ", BASS_ATTRIB_PAN, " + formatPan(fPan) + ")", nResult)
      ; End added 4May2022 11.9.1
      ; Added 28Sep2022 11.9.6
      If fBVLevel <= grLevels\fMinBVLevel
        fBVLevel = 0.0
      EndIf
      ; End added 28Sep2022 11.9.6
      nResult = BASS_ChannelSlideAttribute(hTestToneChannel, #BASS_ATTRIB_VOL, fBVLevel, 100)
      debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(hTestToneChannel) + ", BASS_ATTRIB_VOL, " + traceLevel(fBVLevel) + ", 100)", nResult)
      
      grTestTone\dTestToneIndex = 0
      nResult = BASS_ChannelPlay(hTestToneChannel, #BASSTRUE)
      debugMsg2(sProcName, "BASS_ChannelPlay(" + decodeHandle(hTestToneChannel) + ", BASSTRUE)", nResult)
      If nResult = #BASSFALSE
        Error_(sProcName, "Cannot play test tone")
        ProcedureReturn #False
      EndIf
      
      \nTestToneChan = hTestToneChannel
      grTestTone\nTestToneChan = \nTestToneChan
      grTestTone\nTestToneDevNo = nDevNo
      grTestTone\qTimeTestToneStarted = ElapsedMilliseconds()
      grTestTone\bPlayingTestTone = #True
      grTestTone\nMixerStreamPtr = -1
      
    EndIf
    
  EndWith
  
  If gbUseBASSMixer = #False
    samAddRequest(#SCS_SAM_BUILD_DEV_CHANNEL_LIST, #True)
  EndIf
  startVUDisplayIfReqd()
  
  ProcedureReturn #True
  
EndProcedure

Procedure playStreamProcTestToneToMixerStream(pMixerStreamPtr, pDevNo, fBVLevel.f, fPan.f, pDevMapDevPtr=-1)
  PROCNAMEC()
  Protected nMyMixerStreamHandle.l
  Protected hTestToneChannel.l, nResult.l
  Protected nTestToneChannels.l ; channel count (will be set to 1 for test tones)
  Protected nBassError.l
  Protected nMySampleRate.l
  Protected nMixerChannelFlags.l, nReassignDevMapDevPtr
  Protected Dim aMatrix.f(0)
  Protected nMatrixOutputOffSet, fMatrixFactor.f
  Protected nMatrixOutputs, nMatrixInputs, bUseMatrix, nSelectedDeviceOutputs
  Protected n, m
  
  debugMsg(sProcName, #SCS_START + ", pMixerStreamPtr=" + pMixerStreamPtr + ", pDevNo=" + pDevNo + ", pDevMapDevPtr=" + pDevMapDevPtr)
  
  If gbUseBASS = #False
    ProcedureReturn #True
  EndIf
  
  If gaMixerStreams(pMixerStreamPtr)\bRecreateMixerStream
    debugMsg3(sProcName, "calling createOneMixerStream(" + pMixerStreamPtr + ")")
    createOneMixerStream(pMixerStreamPtr, pDevNo)
    createMixerStreams()     ; calling createMixerStreams forces any ASIO streams to be re-built
  EndIf
  
  nMyMixerStreamHandle = gaMixerStreams(pMixerStreamPtr)\nMixerStreamHandle
  
  nMySampleRate = gaMixerStreams(pMixerStreamPtr)\nSampleRate
  If nMySampleRate = 0
    nMySampleRate = grDriverSettings\nDSSampleRate
  EndIf
  If nMySampleRate = 0
    nMySampleRate = 44100
  EndIf
  
  grTestTone\dTestToneSampleRate = nMySampleRate
  grTestTone\dTestToneFreq = 440
  grTestTone\dTestTonePos = 0
  grTestTone\bSetLevelInStreamProcTestTone = #False
  debugMsg(sProcName, "dTestToneSampleRate=" + grTestTone\dTestToneSampleRate + ", dTestToneFreq=" + grTestTone\dTestToneFreq)
  
  nTestToneChannels = 1 ; always single channel for test tones
  
  ; allow ramp-in instead of using ChannelSlideAttribute, partly because ChannelSlideAttribute seems to give a double-hit at the start
  hTestToneChannel = BASS_StreamCreate(nMySampleRate, nTestToneChannels, #BASS_STREAM_DECODE, @streamTestTone(), 0)
  newHandle(#SCS_HANDLE_SOURCE, hTestToneChannel)
  debugMsg2(sProcName, "BASS_StreamCreate(" + nMySampleRate + ", " + nTestToneChannels + ", " + decodeStreamCreateFlags(#BASS_STREAM_DECODE) + ", @streamTestTone(), 0)", hTestToneChannel)
  If hTestToneChannel = 0
    nBassError = BASS_ErrorGetCode()
    Error_2(sProcName, nBassError, "BASS_StreamCreate failed")
    ProcedureReturn #False
  EndIf
  
  ; Added 28Sep2022 11.9.6
  If fBVLevel <= grLevels\fMinBVLevel
    fBVLevel = 0.0
  EndIf
  ; End added 28Sep2022 11.9.6
  nResult = BASS_ChannelSetAttribute(hTestToneChannel, #BASS_ATTRIB_VOL, fBVLevel)
  debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(hTestToneChannel) + ", BASS_ATTRIB_VOL, " + traceLevel(fBVLevel) + ")", nResult)
  ; Added 4May2022 11.9.1
  nResult = BASS_ChannelSetAttribute(hTestToneChannel, #BASS_ATTRIB_PAN, fPan )
  debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(hTestToneChannel) + ", BASS_ATTRIB_PAN, " + formatPan(fPan) + ")", nResult)
  ; End added 4May2022 11.9.1
  
  grTestTone\dTestToneIndex = 0
  
  nMixerChannelFlags = #BASS_MIXER_CHAN_BUFFER
  ; Added matrix processing if required 1-8Apr2025
  If pDevMapDevPtr >= 0
    debugMsg(sProcName, "(pDevMapDevPtr) grMaps\aDev(" + pDevMapDevPtr + ")\nNrOfDevOutputChans=" + grMaps\aDev(pDevMapDevPtr)\nNrOfDevOutputChans)
    nReassignDevMapDevPtr = grMaps\aDev(pDevMapDevPtr)\nReassignDevMapDevPtr
    If nReassignDevMapDevPtr >= 0
      debugMsg(sProcName, "(nReassignDevMapDevPtr) grMaps\aDev(" + nReassignDevMapDevPtr + ")\nNrOfDevOutputChans=" + grMaps\aDev(nReassignDevMapDevPtr)\nNrOfDevOutputChans)
      If grMaps\aDev(pDevMapDevPtr)\nNrOfDevOutputChans < grMaps\aDev(nReassignDevMapDevPtr)\nNrOfDevOutputChans
        debugMsg(sProcName, "grMaps\aDev(" + pDevMapDevPtr + ")\nNrOfDevOutputChans=" + grMaps\aDev(pDevMapDevPtr)\nNrOfDevOutputChans + ", grMaps\aDev(" + nReassignDevMapDevPtr + ")\nNrOfDevOutputChans=" + Str(grMaps\aDev(nReassignDevMapDevPtr)\nNrOfDevOutputChans))
        nMixerChannelFlags = #BASS_MIXER_CHAN_BUFFER | #BASS_MIXER_CHAN_MATRIX
        bUseMatrix = #True
        nMatrixOutputs = grMaps\aDev(nReassignDevMapDevPtr)\nNrOfDevOutputChans ; matrix outputs
        nMatrixInputs = 1                                                       ; matrix inputs
        nSelectedDeviceOutputs = grMaps\aDev(pDevMapDevPtr)\nNrOfDevOutputChans
        debugMsg3(sProcName, Str(nMatrixOutputs) + " matrix outputs, " + Str(nMatrixInputs) + " matrix inputs, calling ReDim aMatrix(" + Str(nMatrixOutputs * nMatrixInputs) + ")")
        ReDim aMatrix(nMatrixOutputs * nMatrixInputs)
        fMatrixFactor = nSelectedDeviceOutputs / nMatrixInputs
        debugMsg(sProcName, "fMatrixFactor=" + fMatrixFactor)
        If fMatrixFactor > 1
          fMatrixFactor = 1
        EndIf
        debugMsg3(sProcName, "nMatrixOutputs=" + nMatrixOutputs + ", nMatrixInputs=" + nMatrixInputs + ", fMatrixFactor=" + fMatrixFactor)
        nMatrixOutputOffSet = grMaps\aDev(pDevMapDevPtr)\nFirstASIOChannel - grMaps\aDev(nReassignDevMapDevPtr)\nFirstASIOChannel
        debugMsg(sProcName, "grMaps\aDev(pDevMapDevPtr)\nFirstASIOChannel=" + grMaps\aDev(pDevMapDevPtr)\nFirstASIOChannel + ", grMaps\aDev(nReassignDevMapDevPtr)\nFirstASIOChannel=" + grMaps\aDev(nReassignDevMapDevPtr)\nFirstASIOChannel +
                            ", nMatrixOutputOffSet=" + nMatrixOutputOffSet) 
        debugMsg3(sProcName, "nMatrixOutputOffSet=" + nMatrixOutputOffSet + ", (nMatrixOutputOffSet + nMatrixInputs - 1)=" + Str(nMatrixOutputOffSet + nMatrixInputs - 1))
        For n = nMatrixOutputOffSet To (nMatrixOutputOffSet + nSelectedDeviceOutputs - 1)
          For m = 0 To (nMatrixInputs - 1)
            If (nMatrixInputs = 1) Or (nSelectedDeviceOutputs = 1) Or (m = (n - nMatrixOutputOffSet))
              debugMsg(sProcName, "n=" + n + ", nMatrixInputs=" + nMatrixInputs + ", m=" + m + ", ((n * nMatrixInputs) + m)=" + Str((n * nMatrixInputs) + m))
              aMatrix((n * nMatrixInputs) + m) = fMatrixFactor
            EndIf
          Next m
        Next n
        For n = 1 To (nMatrixOutputs * nMatrixInputs)
          debugMsg3(sProcName, "aMatrix(" + Str(n-1) + ")=" + aMatrix(n-1))
        Next n
      EndIf
    ElseIf grMaps\aDev(pDevMapDevPtr)\nNrOfDevOutputChans > 1
      nMixerChannelFlags = #BASS_MIXER_CHAN_BUFFER | #BASS_MIXER_CHAN_MATRIX
      bUseMatrix = #True
      nMatrixOutputs = grMaps\aDev(pDevMapDevPtr)\nNrOfDevOutputChans
      nMatrixInputs = 1 ; matrix inputs
      debugMsg3(sProcName, Str(nMatrixOutputs) + " matrix outputs, " + Str(nMatrixInputs) + " matrix inputs, calling ReDim aMatrix(" + Str(nMatrixOutputs * nMatrixInputs) + ")")
      ReDim aMatrix(nMatrixOutputs * nMatrixInputs)
      fMatrixFactor = 1
      nMatrixOutputOffSet = 0
      For n = 1 To (nMatrixOutputs * nMatrixInputs)
        aMatrix(n-1) = fMatrixFactor
        debugMsg3(sProcName, "aMatrix(" + Str(n-1) + ")=" + aMatrix(n-1))
      Next n
    EndIf
  EndIf
  ; End added matrix processing if required 1-8Apr2025
  
  ; plug stream into mixer, but don't use 'pause' flag. Not using the 'pause' flag means the file will play now.
  If gaMixerStreams(pMixerStreamPtr)\bNoDevice = #False
    nResult = BASS_Mixer_StreamAddChannel(nMyMixerStreamHandle, hTestToneChannel, nMixerChannelFlags)
    debugMsg2(sProcName, "BASS_Mixer_StreamAddChannel(" + decodeHandle(nMyMixerStreamHandle) + ", " + decodeHandle(hTestToneChannel) + ", " + decodeMixerChannelFlags(nMixerChannelFlags) + ")", nResult)
  EndIf
  
  If bUseMatrix
    nResult = BASS_Mixer_ChannelSetMatrix(hTestToneChannel, @aMatrix(0))
    debugMsg2(sProcName, "BASS_Mixer_ChannelSetMatrix(" + decodeHandle(hTestToneChannel) + ", @aMatrix(0))", nResult)
    If nResult = #BASSFALSE
      Error_(sProcName, "BASS_Mixer_ChannelSetMatrix failed")
    EndIf
  EndIf
  
  gaMixerStreams(pMixerStreamPtr)\nTestToneChan = hTestToneChannel
  grTestTone\nTestToneChan = hTestToneChannel
  grTestTone\nTestToneDevNo = pDevNo
  grTestTone\qTimeTestToneStarted = ElapsedMilliseconds()
  grTestTone\bPlayingTestTone = #True
  grTestTone\nMixerStreamPtr = pMixerStreamPtr
  
  startVUDisplayIfReqd()
  
  ProcedureReturn #True
  
EndProcedure

Procedure streamTestTone(Handle.l, *buffer, length.l, *user)
  ; PROCNAMEC()
  Protected c, n, qDataLength.q
  Protected fTestTonePos.f
  
  ; debugMsg(sProcName, #SCS_START)
  
  If gbUseBASS
    
    If gbClosingDown
      ProcedureReturn #BASS_STREAMPROC_END
    EndIf
    
    qDataLength = length >> 1
    
    If grTestTone\nTestToneDataLength < qDataLength
      grTestTone\nTestToneDataLength = qDataLength
      ReDim gaTestToneData(grTestTone\nTestToneDataLength - 1)
    EndIf
    
    For c = 0 To (qDataLength - 1)
      fTestTonePos = grTestTone\dTestTonePos
      If grTestTone\bSetLevelInStreamProcTestTone
        ; setting the level in this procedure appears to be necessary for the likes of the M-Audio FTU DS driver as this driver seems to ignore
        ; levels set by BASS_ChannelSetAttribute() when not using BASSMix, which presumably means the driver ignores levels set by DirectSound.
        gaTestToneData(c) = (32767 * Sin(fTestTonePos) * grProd\fTestToneBVLevel) ; sine wave
      Else
        gaTestToneData(c) = (32767 * Sin(fTestTonePos)) ; sine wave
      EndIf
      ; debugMsg(sProcName, "length=" + length + ", fTestTonePos=" + StrF(fTestTonePos,4) + ", gaTestToneData(" + c + ")=" + gaTestToneData(c))
      grTestTone\dTestTonePos + (grTestTone\dTestToneFreq * 6.283185 / grTestTone\dTestToneSampleRate)   ; 6.283185 = 2PI (approx)
      If grTestTone\dTestTonePos > 6.283185
        grTestTone\dTestToneIndex = 0.0
      EndIf
    Next c
    ; Debug sProcName + " CopyMemory"
    CopyMemory(@gaTestToneData(0), *buffer, length)
    
    ProcedureReturn length
  EndIf
EndProcedure

Procedure confirmGo(nConfirmMethod)
  PROCNAMEC()
  Protected bFound
  Protected i
  Protected sStatusField.s
  
  debugMsg(sProcName, #SCS_START)
  
  ; Added 18Jan2025 11.10.6cn following email from Hans Jrgen Moser where SCS crashed after receiving a network GoConfirm message
  ; Assumed this was due to this procedure being called in the network thread
  If gnThreadNo <> #SCS_THREAD_MAIN
    PostEvent(#SCS_Event_GoConfirm, #WMN, 0, 0, nConfirmMethod)
    ProcedureReturn
  EndIf
  ; End added 18Jan2025 11.10.6cn
  
  If grLicInfo\bCueStartConfirmationAvailable
    
    For i = 1 To gnLastCue
      With aCue(i)
        If \nCueState = #SCS_CUE_WAITING_FOR_CONFIRM
          bFound = #True
          debugMsg(sProcName, "calling playCue(" + getCueLabel(i) + ", #True)")
          playCue(i, #True)
        EndIf
      EndWith
    Next i
    
    If bFound = #False
      Select nConfirmMethod
        Case #SCS_GOCONFIRM_MIDI
          sStatusField = "MIDI"
        Case #SCS_GOCONFIRM_KEYBOARD
          sStatusField = "Keyboard"
        Case #SCS_OSCINP_CTRL_GO_CONFIRM
          sStatusField = "Network"
      EndSelect
      sStatusField + " 'Go Confirm' command received but no cue found waiting for 'Go Confirm'"
      WMN_setStatusField(Trim(sStatusField), #SCS_STATUS_WARN, 3000)    ; leave display up for 7 seconds (3 + 4)
    EndIf
    
  EndIf
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure setWholeCueState(pCuePtr, pCurrentState, pNewState)
  PROCNAMECQ(pCuePtr)
  Protected j, k
  
  If pCuePtr > 0
    With aCue(pCuePtr)
      If \nCueState = pCurrentState
        j = \nFirstSubIndex
        While j >= 0
          If aSub(j)\bSubEnabled
            If aSub(j)\nSubState = pCurrentState
              If aSub(j)\bSubTypeA Or aSub(j)\bSubTypeF Or aSub(j)\bSubTypeP
                k = aSub(j)\nFirstAudIndex
                While k >= 0
                  If aAud(k)\nAudState = pCurrentState
                    aAud(k)\nAudState = pNewState
                  EndIf
                  k = aAud(k)\nNextAudIndex
                Wend
              EndIf
              aSub(j)\nSubState = pNewState
            EndIf
          EndIf
          j = aSub(j)\nNextSubIndex
        Wend
        If \nCueState <> pNewState
          debugMsg(sProcName, "setting aCue(" + getCueLabel(pCuePtr) + ")\nCueState=" + decodeCueState(pNewState) + ", was " + decodeCueState(aCue(pCuePtr)\nCueState))
          \nCueState = pNewState
        EndIf
      EndIf
    EndWith
  EndIf
  
EndProcedure

Procedure completeOtherWaitingCues(pCuePtr)
	PROCNAMECQ(pCuePtr)
	Protected i

  If (aCue(pCuePtr)\bHotkey = #False) And (aCue(pCuePtr)\bExtAct = #False) And (aCue(pCuePtr)\bCallableCue = #False)
    For i = 1 To gnLastCue
      If i <> pCuePtr
        If aCue(i)\nCueState = #SCS_CUE_WAITING_FOR_CONFIRM
          debugMsg(sProcName, "calling stopCue(" + aCue(i)\sCue + ", 'ALL', #False")
          stopCue(i, "ALL", #False)
          If aCue(i)\nHideCueOpt = #SCS_HIDE_NO
            debugMsg(sProcName, "(16) setting gbCallLoadDispPanels=#True")
            gbCallLoadDispPanels = #True
          EndIf
        EndIf
      EndIf
    Next i
  EndIf
  
EndProcedure

Procedure completeAud(pAudPtr)
  PROCNAMECA(pAudPtr)
  
  debugMsg(sProcName, #SCS_START)
  If pAudPtr >= 0
    With aAud(pAudPtr)
      debugMsg(sProcName, "\nAudState=" + decodeCueState(\nAudState))
      If (\nAudState >= #SCS_CUE_FADING_IN) And (\nAudState <= #SCS_CUE_FADING_OUT)
        debugMsg(sProcName, "calling closeAud(" + getAudLabel(pAudPtr) + ")")
        closeAud(pAudPtr)
        \nAudState = #SCS_CUE_COMPLETED
        debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\nAudState=" + decodeCueState(\nAudState))
        debugMsg(sProcName, "calling setCueState(" + aCue(\nCueIndex)\sCue + ")")
        setCueState(\nCueIndex)
        gnCallOpenNextCues = 1
        debugMsg(sProcName, "gnCallOpenNextCues=" + gnCallOpenNextCues)
        If aCue(\nCueIndex)\nHideCueOpt = #SCS_HIDE_NO
          debugMsg(sProcName, "(17) setting gbCallLoadDispPanels=#True")
          gbCallLoadDispPanels = #True
        EndIf
      EndIf
      ; listCueStates(\nCueIndex)
    EndWith
  EndIf
  debugMsg(sProcName,#SCS_END)
EndProcedure

Procedure buildAudSetArray()
  PROCNAMEC()
  Protected k1, nMaxAudLinkCount, nMaxAudLinkAudPtr
  Protected k2, nAudSetPtr2
  Protected nMyAudLinkCount
  Protected bTrace = #False
  
  debugMsgC(sProcName, #SCS_START)
  
  ; This procedure builds the two-dimensional array gaAudSet.
  ;
  ; Every aAud() will have at least one entry in the array, and if an aAud() has other aAud()'s that are linked to it,
  ; then each of those linked Aud()'s will be included effectively in the second dimension.
  ;
  ; For example, here are entries related to Martin Norris's 'Dream' cue file, where cue 8 has 5 sub-cues linked to the first sub-cue, ie 8<2> to 8<6> are all linked to 8<1>.
  ;  gaAudSet(1,0)=Q1        Cue Q1 has no linked audio file sub-cues so just has it's own entry
  ;  gaAudSet(2,0)=8<1>      Sub-Cue 8<1> has it's own entry plus 5 linked audio file sub-cues
  ;  gaAudSet(2,1)=8<2>
  ;  gaAudSet(2,2)=8<3>
  ;  gaAudSet(2,3)=8<4>
  ;  gaAudSet(2,4)=8<5>
  ;  gaAudSet(2,5)=8<6>
  ;  gaAudSet(3,0)=8<2>      Sub-Cue 8<2> has it's own entry, as well as the 'linked' entry shown earlier in this list
  ;  gaAudSet(4,0)=8<3>      Sub-Cue 8<3> ditto
  ;  gaAudSet(5,0)=8<4>
  ;  gaAudSet(6,0)=8<5>
  ;  gaAudSet(7,0)=8<6>
  ;  gaAudSet(8,0)=8<7>      NB 8<7> is NOT linked to 8<1> as 8<7> in this cue file is a Control Send sub-cue that plays a MIDI file
  ;  gaAudSet(9,0)=9         Cue 9 has no linked audio file sub-cues so just has it's own entry
  ;  gaAudSet(10,0)=10       Cue 10 ditto
  ;
  ;  For the above, aAud(1)\nMaxAudSetPtr2 will be set to 0 as the maximum 2nd dimension value used for 1st dimension 1 is 0, ie gaAudSet(1,0)
  ;                 aAud(2)\nMaxAudSetPtr2 will be set to 5 as the maximum 2nd dimension value used for 1st dimension 2 is 5, ie gaAudSet(2,5)
  ;  and the remaining aAud(n)\nMaxAudSetPtr2 will all be set to 0 (same reason as for aAud(1))
  
  nMaxAudLinkCount = 0
  
  For k1 = 1 To gnLastAud
    If aAud(k1)\bExists
      nMyAudLinkCount = 0
      If aAud(k1)\nFirstAudLink > 0
        For k2 = aAud(k1)\nFirstAudLink To gnLastAud
          If aAud(k2)\bExists
            If aAud(k2)\nLinkedToAudPtr = k1
              nMyAudLinkCount + 1
            EndIf
          EndIf
        Next k2
      EndIf
      aAud(k1)\nAudLinkCount = nMyAudLinkCount
      If nMyAudLinkCount > nMaxAudLinkCount
        nMaxAudLinkCount = nMyAudLinkCount
        nMaxAudLinkAudPtr = k1
      EndIf
      ; debugMsg(sProcName, "aAud(" + getAudLabel(k1) + ")\nAudLinkCount=" + aAud(k1)\nAudLinkCount + ", nMaxAudLinkCount=" + nMaxAudLinkCount)
    EndIf
  Next k1
  
  If nMaxAudLinkCount = 0
    ; debugMsg(sProcName, "nMaxAudLinkCount=" + nMaxAudLinkCount)
  Else
    debugMsgC(sProcName, "nMaxAudLinkCount=" + nMaxAudLinkCount + ", nMaxAudLinkAudPtr=" + aAud(nMaxAudLinkAudPtr)\sAudLabel)
  EndIf
  
  Dim gaAudSet(gnLastAud, nMaxAudLinkCount) ; was ReDim in VB6, but ReDim in PB doesn't reset the contents to zero, whereas Dim does.
  
  For k1 = 1 To gnLastAud
    If aAud(k1)\bExists
      nAudSetPtr2 = 0
      gaAudSet(k1, nAudSetPtr2) = k1
      debugMsgC(sProcName, "gaAudSet(" + k1 + "," + nAudSetPtr2 + ")=" + getAudLabel(k1))
      nMyAudLinkCount = 0
      If aAud(k1)\nFirstAudLink > 0
        For k2 = aAud(k1)\nFirstAudLink To gnLastAud
          If aAud(k2)\bExists
            If aAud(k2)\nLinkedToAudPtr = k1
              nAudSetPtr2 + 1
              gaAudSet(k1, nAudSetPtr2) = k2
              debugMsgC(sProcName, "gaAudSet(" + k1 + "," + nAudSetPtr2 + ")=" + getAudLabel(k2))
              nMyAudLinkCount + 1
            EndIf
          EndIf
        Next k2
      EndIf
      aAud(k1)\nAudLinkCount = nMyAudLinkCount
      aAud(k1)\nMaxAudSetPtr2 = nAudSetPtr2
      debugMsgC(sProcName, "aAud(" + getAudLabel(k1) + ")\nAudLinkCount=" + aAud(k1)\nAudLinkCount + ", \nMaxAudSetPtr2=" + aAud(k1)\nMaxAudSetPtr2)
    EndIf
  Next k1
  
  debugMsgC(sProcName, #SCS_END)
  
EndProcedure

Procedure Stereo2MonoRightDSP(Handle.l, channel.l, *Buffer, nLength.l, *user)
  ; PROCNAMEC()
  Protected Dim B.f(0)
  Protected a
  
  ; debugMsg0(sProcName, #SCS_START + ", Handle=" + Handle + ", channel=" + decodeHandle(channel) + ", *Buffer=" + *Buffer + ", nLength=" + nLength + ", *user=" + *user)
  
  ReDim B.f(nLength / 4)
  CopyMemory(*Buffer, @B(0), nLength)
  For a = 0 To (nLength / 4) - 1 Step 2
    B(a + 1) = (B(a) + B(a + 1)) / 2          ; right = mono sound
    B(a) = 0                                  ; left = silence
  Next a
  CopyMemory(@B(0), *Buffer, nLength)
  
EndProcedure

Procedure Stereo2MonoLeftDSP(Handle.l, channel.l, *Buffer, nLength.l, *user)
  ; PROCNAMEC()
  Protected Dim B.f(0)
  Protected a
  
  ; debugMsg0(sProcName, #SCS_START + ", Handle=" + Handle + ", channel=" + decodeHandle(channel) + ", *Buffer=" + *Buffer + ", nLength=" + nLength + ", *user=" + *user)
  
  ReDim B.f(nLength / 4)
  CopyMemory(*Buffer, @B(0), nLength)
  For a = 0 To (nLength / 4) - 1 Step 2
    B(a) = (B(a) + B(a + 1)) / 2              ; left = mono sound
    B(a + 1) = 0                              ; right = silence
  Next a
  CopyMemory(@B(0), *Buffer, nLength)
  
EndProcedure

Procedure.s decodeStreamCreateFlags(nStreamCreateFlags.l, bMixerStreamCreate=#False, bMixerStreamAddChannel=#False)
  PROCNAMEC()
  Protected nHoldFlags.l, nTmp.l
  Protected nTmpFlag.l
  Protected sDecoded.s, sMixerDecoded.s
  Protected n
  
  nHoldFlags = nStreamCreateFlags
  If nHoldFlags = 0
    ProcedureReturn "0"
  EndIf
  
  ; debugMsg(sProcName, "nStreamCreateFlags=$" + Hex(nStreamCreateFlags) + ", bMixerStream=" + strB(bMixerStream))
  
  If bMixerStreamCreate
    ; nb some mixer stream flags have same values as non-mixer stream flags, so sort these out first
    decodeFlag(nHoldFlags, #BASS_MIXER_END, "|BASS_MIXER_END", sMixerDecoded)
    decodeFlag(nHoldFlags, #BASS_MIXER_NONSTOP, "|BASS_MIXER_NONSTOP", sMixerDecoded)
    decodeFlag(nHoldFlags, #BASS_MIXER_POSEX, "|BASS_MIXER_POSEX", sMixerDecoded)
    decodeFlag(nHoldFlags, #BASS_MIXER_RESUME, "|BASS_MIXER_RESUME", sMixerDecoded)
  EndIf
  
  If bMixerStreamAddChannel
    ; nb some mixer stream flags have same values as non-mixer stream flags, so sort these out first
    decodeFlag(nHoldFlags, #BASS_MIXER_CHAN_MATRIX, "|BASS_MIXER_CHAN_MATRIX", sMixerDecoded)
    decodeFlag(nHoldFlags, #BASS_MIXER_CHAN_DOWNMIX, "|BASS_MIXER_CHAN_DOWNMIX", sMixerDecoded)
    decodeFlag(nHoldFlags, #BASS_MIXER_CHAN_BUFFER, "|BASS_MIXER_CHAN_BUFFER", sMixerDecoded)
    decodeFlag(nHoldFlags, #BASS_MIXER_CHAN_LIMIT, "|BASS_MIXER_CHAN_LIMIT", sMixerDecoded)
    decodeFlag(nHoldFlags, #BASS_MIXER_CHAN_NORAMPIN, "|BASS_MIXER_CHAN_NORAMPIN", sMixerDecoded)
    decodeFlag(nHoldFlags, #BASS_MIXER_CHAN_PAUSE, "|BASS_MIXER_CHAN_PAUSE", sMixerDecoded)
  EndIf
  
  decodeFlag(nHoldFlags, #BASS_SAMPLE_FLOAT, "|BASS_SAMPLE_FLOAT", sDecoded)
  decodeFlag(nHoldFlags, #BASS_SAMPLE_MONO, "|BASS_SAMPLE_MONO", sDecoded)
  decodeFlag(nHoldFlags, #BASS_SAMPLE_LOOP, "|BASS_SAMPLE_LOOP", sDecoded)
  decodeFlag(nHoldFlags, #BASS_STREAM_PRESCAN, "|BASS_STREAM_PRESCAN", sDecoded)
  decodeFlag(nHoldFlags, #BASS_STREAM_AUTOFREE, "|BASS_STREAM_AUTOFREE", sDecoded)
  decodeFlag(nHoldFlags, #BASS_STREAM_DECODE, "|BASS_STREAM_DECODE", sDecoded)
  decodeFlag(nHoldFlags, #BASS_UNICODE, "|BASS_UNICODE", sDecoded)
  decodeFlag(nHoldFlags, #BASS_ASYNCFILE, "|BASS_ASYNCFILE", sDecoded)
  decodeFlag(nHoldFlags, #BASS_ENCODE_PCM, "|BASS_ENCODE_PCM", sDecoded)
  decodeFlag(nHoldFlags, #BASS_ENCODE_AUTOFREE, "|BASS_ENCODE_AUTOFREE", sDecoded)
  decodeFlag(nHoldFlags, #BASS_FX_FREESOURCE, "|BASS_FX_FREESOURCE", sDecoded)
  
  ; must check anything that involves BASS_SPEAKER_CENLFE before anything that involves BASS_SPEAKER_FRONT | #BASS_SPEAKER_REAR
  ; as BASS_SPEAKER_CENLFE = BASS_SPEAKER_FRONT & BASS_SPEAKER_REAR
  decodeFlag(nHoldFlags, #BASS_SPEAKER_CENTER, "|BASS_SPEAKER_CENTER", sDecoded)
  decodeFlag(nHoldFlags, #BASS_SPEAKER_LFE, "|BASS_SPEAKER_LFE", sDecoded)
  decodeFlag(nHoldFlags, #BASS_SPEAKER_CENLFE, "|BASS_SPEAKER_CENLFE", sDecoded)
  decodeFlag(nHoldFlags, #BASS_SPEAKER_FRONTLEFT, "|BASS_SPEAKER_FRONTLEFT", sDecoded)
  decodeFlag(nHoldFlags, #BASS_SPEAKER_FRONTRIGHT, "|BASS_SPEAKER_FRONTRIGHT", sDecoded)
  decodeFlag(nHoldFlags, #BASS_SPEAKER_FRONT, "|BASS_SPEAKER_FRONT", sDecoded)
  decodeFlag(nHoldFlags, #BASS_SPEAKER_REARLEFT, "|BASS_SPEAKER_REARLEFT", sDecoded)
  decodeFlag(nHoldFlags, #BASS_SPEAKER_REARRIGHT, "|BASS_SPEAKER_REARRIGHT", sDecoded)
  decodeFlag(nHoldFlags, #BASS_SPEAKER_REAR, "|BASS_SPEAKER_REAR", sDecoded)
  decodeFlag(nHoldFlags, #BASS_SPEAKER_REAR2LEFT, "|BASS_SPEAKER_REAR2LEFT", sDecoded)
  decodeFlag(nHoldFlags, #BASS_SPEAKER_REAR2RIGHT, "|BASS_SPEAKER_REAR2RIGHT", sDecoded)
  decodeFlag(nHoldFlags, #BASS_SPEAKER_REAR2, "|BASS_SPEAKER_REAR2", sDecoded)
  
  If nHoldFlags <> 0
    For n = 1 To 16
      nTmp = nHoldFlags & BASS_SPEAKER_N(n)
      If nTmp = BASS_SPEAKER_N(n)
        sDecoded + "|BASS_SPEAKER_N(" + n + ")"
        nHoldFlags ! nTmp
        ; debugMsg(sProcName, "nHoldFlags=$" + Hex(nHoldFlags) + ", sDecoded=" + sDecoded)
      EndIf
    Next n
    decodeFlag(nHoldFlags, #BASS_SPEAKER_LEFT, "|BASS_SPEAKER_LEFT", sDecoded)
    decodeFlag(nHoldFlags, #BASS_SPEAKER_RIGHT, "|BASS_SPEAKER_RIGHT", sDecoded)
  EndIf
  
  If nHoldFlags <> 0
    sDecoded + "|$" + Hex(nHoldFlags, #PB_Long)
    nHoldFlags = 0
  EndIf
  
  sDecoded + sMixerDecoded
  If Len(sDecoded) > 2
    sDecoded = Mid(sDecoded, 2)
  EndIf
  ProcedureReturn sDecoded
EndProcedure

Procedure.s decodeInitFlags(nInitFlags.l)
  ; PROCNAMEC()
  Protected nHoldFlags.l, nTmp.l
  Protected nTmpFlag.l
  Protected sDecoded.s
  
  nHoldFlags = nInitFlags
  If nHoldFlags = 0
    ProcedureReturn "0"
  EndIf
  
  decodeFlag(nHoldFlags, #BASS_DEVICE_MONO, "|BASS_DEVICE_MONO", sDecoded)
  decodeFlag(nHoldFlags, #BASS_DEVICE_STEREO, "|BASS_DEVICE_STEREO", sDecoded)
  decodeFlag(nHoldFlags, #BASS_DEVICE_NOSPEAKER, "|BASS_DEVICE_NOSPEAKER", sDecoded)
  decodeFlag(nHoldFlags, #BASS_DEVICE_FREQ, "|BASS_DEVICE_FREQ", sDecoded)
  decodeFlag(nHoldFlags, #BASS_DEVICE_DSOUND, "|BASS_DEVICE_DSOUND", sDecoded)
  
  If nHoldFlags <> 0
    sDecoded + "|$" + Hex(nHoldFlags)
    nHoldFlags = 0
  EndIf
  
  If Len(sDecoded) > 2
    sDecoded = Mid(sDecoded, 2)
  EndIf
  ProcedureReturn sDecoded
EndProcedure

Procedure.s decodeMixerChannelFlags(nMixerChannelFlags)
  PROCNAMEC()
  Protected nHoldFlags.l, nTmp.l
  Protected nTmpFlag.l
  Protected sMixerChannelFlags.s
  
  nHoldFlags = nMixerChannelFlags
  If nHoldFlags = 0
    ProcedureReturn "0"
  EndIf
  
  decodeFlag(nHoldFlags, #BASS_MIXER_CHAN_PAUSE, "|BASS_MIXER_CHAN_PAUSE", sMixerChannelFlags)  ; decode 'pause' first as this is the most significant during live running
  decodeFlag(nHoldFlags, #BASS_MIXER_CHAN_BUFFER, "|BASS_MIXER_CHAN_BUFFER", sMixerChannelFlags)
  decodeFlag(nHoldFlags, #BASS_MIXER_CHAN_LIMIT, "|BASS_MIXER_CHAN_LIMIT", sMixerChannelFlags)
  decodeFlag(nHoldFlags, #BASS_MIXER_CHAN_NORAMPIN, "|BASS_MIXER_CHAN_NORAMPIN", sMixerChannelFlags)
  decodeFlag(nHoldFlags, #BASS_STREAM_AUTOFREE, "|BASS_STREAM_AUTOFREE", sMixerChannelFlags)
  decodeFlag(nHoldFlags, #BASS_MIXER_CHAN_MATRIX, "|BASS_MIXER_CHAN_MATRIX", sMixerChannelFlags)
  decodeFlag(nHoldFlags, #BASS_MIXER_CHAN_DOWNMIX, "|BASS_MIXER_CHAN_DOWNMIX", sMixerChannelFlags)
  
  If nHoldFlags <> 0
    sMixerChannelFlags + "|$" + Hex(nHoldFlags, #PB_Long)
    nHoldFlags = 0
  EndIf
  
  If Len(sMixerChannelFlags) > 2
    sMixerChannelFlags = Mid(sMixerChannelFlags, 2)
  EndIf
  ProcedureReturn sMixerChannelFlags
EndProcedure

Procedure loadOutputArrayForDev(nPhysicalDevIndex)
  PROCNAMEC()
  Protected n, nMySpeakers
  Protected nNextIndex
  
  ; see also buildOutputArray()
  
  ; debugMsg(sProcName, #SCS_START + ", nPhysicalDevIndex=" + Str(nPhysicalDevIndex))
  
  With gaAudioDev(nPhysicalDevIndex)
    ; debugMsg(sProcName, "gaAudioDev(" + Str(nPhysicalDevIndex) + ")\sDesc=" + \sDesc + ", \bASIO=" + strB(\bASIO) + ", \nOutputs=" + Str(\nOutputs) + ", \nSpeakers=" + Str(\nSpeakers))
    For n = 0 To #SCS_MAX_OUTPUT_ARRAY_INDEX
      \nOutputArrayIndex[n] = -1
    Next n
    Select \nAudioDriver
      Case #SCS_DRV_BASS_ASIO  ; BASS_ASIO
        nMySpeakers = \nOutputs
        Select nMySpeakers
          Case 2
            \nOutputArrayIndex[0] = 17      ; outputs 1/2 (stereo)
            \nOutputArrayIndex[1] = 18      ; output 1 (mono)
            \nOutputArrayIndex[2] = 19      ; output 2 (mono)
            
          Case 4
            \nOutputArrayIndex[0] = 17      ; outputs 1/2 (stereo)
            \nOutputArrayIndex[1] = 18      ; output 1 (mono)
            \nOutputArrayIndex[2] = 19      ; output 2 (mono)
            \nOutputArrayIndex[3] = 20      ; outputs 3/4 (stereo)
            \nOutputArrayIndex[4] = 21      ; output 3 (mono)
            \nOutputArrayIndex[5] = 22      ; output 4 (mono)
            \nOutputArrayIndex[6] = 41      ; Quadraphonic (4 channels)
            
          Case 6
            \nOutputArrayIndex[0] = 17      ; outputs 1/2 (stereo)
            \nOutputArrayIndex[1] = 18      ; output 1 (mono)
            \nOutputArrayIndex[2] = 19      ; output 2 (mono)
            \nOutputArrayIndex[3] = 20      ; outputs 3/4 (stereo)
            \nOutputArrayIndex[4] = 21      ; output 3 (mono)
            \nOutputArrayIndex[5] = 22      ; output 4 (mono)
            \nOutputArrayIndex[6] = 23      ; outputs 5/6 (stereo)
            \nOutputArrayIndex[7] = 24      ; output 5 (mono)
            \nOutputArrayIndex[8] = 25      ; output 6 (mono)
            \nOutputArrayIndex[9] = 3       ; 5.1 surround (6 channels)
            
          Case 8 To 99
            \nOutputArrayIndex[0] = 17      ; outputs 1/2 (stereo)
            \nOutputArrayIndex[1] = 18      ; output 1 (mono)
            \nOutputArrayIndex[2] = 19      ; output 2 (mono)
            \nOutputArrayIndex[3] = 20      ; outputs 3/4 (stereo)
            \nOutputArrayIndex[4] = 21      ; output 3 (mono)
            \nOutputArrayIndex[5] = 22      ; output 4 (mono)
            \nOutputArrayIndex[6] = 23      ; outputs 5/6 (stereo)
            \nOutputArrayIndex[7] = 24      ; output 5 (mono)
            \nOutputArrayIndex[8] = 25     ; output 6 (mono)
            \nOutputArrayIndex[9] = 26     ; outputs 7/8 (stereo)
            \nOutputArrayIndex[10] = 27     ; output 7 (mono)
            \nOutputArrayIndex[11] = 28     ; output 8 (mono)
            If nMySpeakers >= 10
              \nOutputArrayIndex[12] = 29 ; outputs 9/10 (stereo)
              \nOutputArrayIndex[13] = 30 ; output 9 (mono)
              \nOutputArrayIndex[14] = 31 ; output 10 (mono)
            Else
              nNextIndex = 12
            EndIf
            If nMySpeakers >= 12
              \nOutputArrayIndex[15] = 32 ; outputs 11/12 (stereo)
              \nOutputArrayIndex[16] = 33 ; output 11 (mono)
              \nOutputArrayIndex[17] = 34 ; output 12 (mono)
            Else
              nNextIndex = 15
            EndIf
            If nMySpeakers >= 14
              \nOutputArrayIndex[18] = 35 ; outputs 13/14 (stereo)
              \nOutputArrayIndex[19] = 36 ; output 13 (mono)
              \nOutputArrayIndex[20] = 37 ; output 14 (mono)
            Else
              nNextIndex = 18
            EndIf
            If nMySpeakers >= 16
              \nOutputArrayIndex[21] = 38 ; outputs 15/16 (stereo)
              \nOutputArrayIndex[22] = 39 ; output 15 (mono)
              \nOutputArrayIndex[23] = 40 ; output 16 (mono)
              nNextIndex = 24
            Else
              nNextIndex = 21
            EndIf
            \nOutputArrayIndex[nNextIndex] = 3       ; 5.1 surround (6 channels)
            \nOutputArrayIndex[nNextIndex + 1] = 4  ; 7.1 surround (8 channels)
            
        EndSelect
        
      Case #SCS_DRV_BASS_DS, #SCS_DRV_BASS_WASAPI ; BASS_DS, BASS_WASAPI
        nMySpeakers = \nSpeakers
        Select nMySpeakers
          Case 0
            \nOutputArrayIndex[0] = 42      ; (device not available)
          Case 2
            \nOutputArrayIndex[0] = 0       ; left and right (stereo)
            \nOutputArrayIndex[1] = 1       ; left (mono)
            \nOutputArrayIndex[2] = 2       ; right (mono)
            
          Case 4
            \nOutputArrayIndex[0] = 17      ; outputs 1/2 (stereo)
            \nOutputArrayIndex[1] = 18      ; output 1 (mono)
            \nOutputArrayIndex[2] = 19      ; output 2 (mono)
            \nOutputArrayIndex[3] = 20      ; outputs 3/4 (stereo)
            \nOutputArrayIndex[4] = 21      ; output 3 (mono)
            \nOutputArrayIndex[5] = 22      ; output 4 (mono)
            \nOutputArrayIndex[6] = 41      ; Quadraphonic (4 channels)
            \nOutputArrayIndex[7] = 5       ; front (stereo)
            \nOutputArrayIndex[8] = 6       ; left-front (mono)
            \nOutputArrayIndex[9] = 7       ; right-front (mono)
            \nOutputArrayIndex[10] = 8      ; rear/side (stereo)
            \nOutputArrayIndex[11] = 9      ; left-rear/side (mono)
            \nOutputArrayIndex[12] = 10     ; right-rear/side (mono)
            
          Case 6
            \nOutputArrayIndex[0] = 17      ; outputs 1/2 (stereo)
            \nOutputArrayIndex[1] = 18      ; output 1 (mono)
            \nOutputArrayIndex[2] = 19      ; output 2 (mono)
            \nOutputArrayIndex[3] = 20      ; outputs 3/4 (stereo)
            \nOutputArrayIndex[4] = 21      ; output 3 (mono)
            \nOutputArrayIndex[5] = 22      ; output 4 (mono)
            \nOutputArrayIndex[6] = 23      ; outputs 5/6 (stereo)
            \nOutputArrayIndex[7] = 24      ; output 5 (mono)
            \nOutputArrayIndex[8] = 25      ; output 6 (mono)
            \nOutputArrayIndex[9] = 3       ; 5.1 surround (6 channels)
            \nOutputArrayIndex[10] = 5      ; front (stereo)
            \nOutputArrayIndex[11] = 6      ; left-front (mono)
            \nOutputArrayIndex[12] = 7      ; right-front (mono)
            \nOutputArrayIndex[13] = 11     ; center & LFE (stereo)
            \nOutputArrayIndex[14] = 12     ; center (mono)
            \nOutputArrayIndex[15] = 13     ; LFE (mono)
            \nOutputArrayIndex[16] = 8      ; rear/side (stereo)
            \nOutputArrayIndex[17] = 9      ; left-rear/side (mono)
            \nOutputArrayIndex[18] = 10     ; right-rear/side (mono)
            
          Case 8
            \nOutputArrayIndex[0] = 17      ; outputs 1/2 (stereo)
            \nOutputArrayIndex[1] = 18      ; output 1 (mono)
            \nOutputArrayIndex[2] = 19      ; output 2 (mono)
            \nOutputArrayIndex[3] = 20      ; outputs 3/4 (stereo)
            \nOutputArrayIndex[4] = 21      ; output 3 (mono)
            \nOutputArrayIndex[5] = 22      ; output 4 (mono)
            \nOutputArrayIndex[6] = 23      ; outputs 5/6 (stereo)
            \nOutputArrayIndex[7] = 24      ; output 5 (mono)
            \nOutputArrayIndex[8] = 25      ; output 6 (mono)
            \nOutputArrayIndex[9] = 26      ; outputs 7/8 (stereo)
            \nOutputArrayIndex[10] = 27     ; output 7 (mono)
            \nOutputArrayIndex[11] = 28     ; output 8 (mono)
            \nOutputArrayIndex[12] = 4      ; 7.1 surround (8 channels)
            \nOutputArrayIndex[13] = 5      ; front (stereo)
            \nOutputArrayIndex[14] = 6      ; left-front (mono)
            \nOutputArrayIndex[15] = 7      ; right-front (mono)
            \nOutputArrayIndex[16] = 11     ; center & LFE (stereo)
            \nOutputArrayIndex[17] = 12     ; center (mono)
            \nOutputArrayIndex[18] = 13     ; LFE (mono)
            \nOutputArrayIndex[19] = 8      ; rear/side (stereo)
            \nOutputArrayIndex[20] = 9      ; left-rear/side (mono)
            \nOutputArrayIndex[21] = 10     ; right-rear/side (mono)
            \nOutputArrayIndex[22] = 14     ; rear center (stereo)
            \nOutputArrayIndex[23] = 15     ; left-rear center (mono)
            \nOutputArrayIndex[24] = 16     ; right-rear center (mono)
            
          Case 10 To 99
            \nOutputArrayIndex[0] = 17      ; outputs 1/2 (stereo)
            \nOutputArrayIndex[1] = 18      ; output 1 (mono)
            \nOutputArrayIndex[2] = 19      ; output 2 (mono)
            \nOutputArrayIndex[3] = 20      ; outputs 3/4 (stereo)
            \nOutputArrayIndex[4] = 21      ; output 3 (mono)
            \nOutputArrayIndex[5] = 22      ; output 4 (mono)
            \nOutputArrayIndex[6] = 23      ; outputs 5/6 (stereo)
            \nOutputArrayIndex[7] = 24      ; output 5 (mono)
            \nOutputArrayIndex[8] = 25     ; output 6 (mono)
            \nOutputArrayIndex[9] = 26     ; outputs 7/8 (stereo)
            \nOutputArrayIndex[10] = 27     ; output 7 (mono)
            \nOutputArrayIndex[11] = 28     ; output 8 (mono)
            If nMySpeakers >= 10
              \nOutputArrayIndex[12] = 29 ; outputs 9/10 (stereo)
              \nOutputArrayIndex[13] = 30 ; output 9 (mono)
              \nOutputArrayIndex[14] = 31 ; output 10 (mono)
            Else
              nNextIndex = 12
            EndIf
            If nMySpeakers >= 12
              \nOutputArrayIndex[15] = 32 ; outputs 11/12 (stereo)
              \nOutputArrayIndex[16] = 33 ; output 11 (mono)
              \nOutputArrayIndex[17] = 34 ; output 12 (mono)
            Else
              nNextIndex = 15
            EndIf
            If nMySpeakers >= 14
              \nOutputArrayIndex[18] = 35 ; outputs 13/14 (stereo)
              \nOutputArrayIndex[19] = 36 ; output 13 (mono)
              \nOutputArrayIndex[20] = 37 ; output 14 (mono)
            Else
              nNextIndex = 18
            EndIf
            If nMySpeakers >= 16
              \nOutputArrayIndex[21] = 38 ; outputs 15/16 (stereo)
              \nOutputArrayIndex[22] = 39 ; output 15 (mono)
              \nOutputArrayIndex[23] = 40 ; output 16 (mono)
              nNextIndex = 24
            Else
              nNextIndex = 21
            EndIf
            \nOutputArrayIndex[nNextIndex] = 3       ; 5.1 surround (6 channels)
            \nOutputArrayIndex[nNextIndex + 1] = 4  ; 7.1 surround (8 channels)
            
        EndSelect
        
    EndSelect
    
  EndWith
EndProcedure

Procedure closeOneDevice(pPhysicalDevPtr)
  PROCNAMEC()
  Protected nBassResult.l
  
  debugMsg(sProcName, #SCS_START)
  
  With gaAudioDev(pPhysicalDevPtr)
    If \bInitialized
      debugMsg(sProcName, "closing " + \sDesc)
      If \bASIO
        nBassResult = BASS_ASIO_SetDevice(\nDevBassASIODevice)
        debugMsg2(sProcName, "BASS_ASIO_SetDevice(" + \nDevBassASIODevice + ")", nBassResult)
        If nBassResult = #BASSTRUE
          nBassResult = BASS_ASIO_Free()
          debugMsg2(sProcName, "BASS_ASIO_Free() for ASIO device " + \nDevBassASIODevice, nBassResult)
        EndIf
      Else
        nBassResult = BASS_SetDevice(\nBassDevice)
        debugMsg2(sProcName, "BASS_SetDevice(" + \nBassDevice + ")", nBassResult)
        If nBassResult = #BASSTRUE
          nBassResult = BASS_Free()
          debugMsg2(sProcName, "BASS_Free() for device " + \nBassDevice, nBassResult)
        EndIf
      EndIf
      \bInitialized = #False
    EndIf
  EndWith
  
EndProcedure

Procedure setRelCheckForEnd(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nDuration, nTimeBeforeEnd
  
  If pAudPtr >= 0
    With aAud(pAudPtr)
      nDuration = (\nRelEndAt - \nRelStartAt)
      nTimeBeforeEnd = nDuration / 20    ; = 5%
      If (nTimeBeforeEnd < 1000) And (nDuration > 1500)
        nTimeBeforeEnd = 1000
      EndIf
      \nRelCheckForEnd = \nRelEndAt - nTimeBeforeEnd
      debugMsg(sProcName, "\nRelStartAt=" + \nRelStartAt + ", \nRelEndAt=" + \nRelEndAt + ", \nRelCheckForEnd=" + \nRelCheckForEnd)
    EndWith
  EndIf
EndProcedure

Procedure getOutputArrayIndexForSpeakerDesc(sSpeakerDesc.s)
  PROCNAMEC()
  Protected nArrayIndex, d
  
  nArrayIndex = -1
  If Len(sSpeakerDesc) > 0
    For d = 0 To gnMaxOutputArrayIndex
      If gaOutputArray(d)\sDesc = sSpeakerDesc
        nArrayIndex = d
        Break
      EndIf
    Next d
  EndIf
  ProcedureReturn nArrayIndex
  
EndProcedure

Procedure setEditLogicalDevsDerivedFields()
  PROCNAMEC()
  Protected d
  Protected nDevCount, nMaxDevPtr, nDevMapDevPtr
  
  debugMsg(sProcName, #SCS_START)
  
  For d = 0 To grProdForDevChgs\nMaxAudioLogicalDev
    With grProdForDevChgs\aAudioLogicalDevs(d)
      If Trim(\sLogicalDev)
        nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMapsForDevChgs, #SCS_DEVGRP_AUDIO_OUTPUT, \sLogicalDev)
        If nDevMapDevPtr >= 0
          \nDevType = #SCS_DEVTYPE_AUDIO_OUTPUT
          \nPhysicalDevPtr = grMapsForDevChgs\aDev(nDevMapDevPtr)\nPhysicalDevPtr
        EndIf
      EndIf
    EndWith
  Next d
  
  For d = 0 To grProdForDevChgs\nMaxVidAudLogicalDev
    With grProdForDevChgs\aVidAudLogicalDevs(d)
      If Trim(\sVidAudLogicalDev)
        nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMapsForDevChgs, #SCS_DEVGRP_VIDEO_AUDIO, \sVidAudLogicalDev)
        If nDevMapDevPtr >= 0
          \nDevType = #SCS_DEVTYPE_VIDEO_AUDIO
          \nPhysicalDevPtr = grMapsForDevChgs\aDev(nDevMapDevPtr)\nPhysicalDevPtr
        EndIf
      EndIf
    EndWith
  Next d
  
  For d = 0 To grProdForDevChgs\nMaxVidCapLogicalDev
    With grProdForDevChgs\aVidCapLogicalDevs(d)
      If Trim(\sLogicalDev)
        nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMapsForDevChgs, #SCS_DEVGRP_VIDEO_CAPTURE, \sLogicalDev)
        If nDevMapDevPtr >= 0
          \nDevType = #SCS_DEVTYPE_VIDEO_CAPTURE
          \nPhysicalDevPtr = grMapsForDevChgs\aDev(nDevMapDevPtr)\nPhysicalDevPtr
        EndIf
      EndIf
    EndWith
  Next d
  
EndProcedure

Procedure.s get0BasedFrom1BasedChanString(s1BasedChanString.s)
  PROCNAMEC()
  Protected nHyphenPtr
  Protected s0BasedChanString.s
  Protected nDiff
  
  With grMMedia
    nHyphenPtr = FindString(s1BasedChanString, "-", 1)
    If nHyphenPtr = 0
      Select Trim(s1BasedChanString)
        Case "L"
          \nFirst0BasedChan = 0
        Case "R"
          \nFirst0BasedChan = 1
        Default
          \nFirst0BasedChan = Val(s1BasedChanString) - 1
      EndSelect
      \nFirst0BasedChan = adjust0BasedOutputChanIfReqd(\nFirst0BasedChan)
      \nLast0BasedChan = \nFirst0BasedChan
      s0BasedChanString = Str(\nFirst0BasedChan)
    Else
      If Trim(s1BasedChanString) = "L-R"
        \nFirst0BasedChan = 0
        \nLast0BasedChan = 1
      Else
        \nFirst0BasedChan = Val(Left(s1BasedChanString, (nHyphenPtr - 1))) - 1
        \nLast0BasedChan = Val(Mid(s1BasedChanString, (nHyphenPtr + 1))) - 1
      EndIf
      nDiff = \nLast0BasedChan - \nFirst0BasedChan
      \nFirst0BasedChan = adjust0BasedOutputChanIfReqd(\nFirst0BasedChan)
      \nLast0BasedChan = \nFirst0BasedChan + nDiff
      s0BasedChanString = Str(\nFirst0BasedChan) + "-" + Str(\nLast0BasedChan)
    EndIf
    
    \nFirst1BasedChan = \nFirst0BasedChan + 1
    \nLast1BasedChan = \nLast0BasedChan + 1
  EndWith
  
  ProcedureReturn s0BasedChanString
EndProcedure

Procedure sortAudioDevs(nAudioDriver)
  PROCNAMEC()
  Protected nMaxDev = -1
  Protected n1, n2, bSwapped
  Protected rAudioDev.tyAudioDevShort
  Protected sSortKey.s, sDefKey.s
  Protected sMsg.s
  Protected sPhysDevWithExpandedNumbers.s
  
  debugMsg(sProcName, #SCS_START + ", nAudioDriver=" + decodeDriver(nAudioDriver) + ", gnPhysicalAudDevs=" + Str(gnPhysicalAudDevs))
  
  If gnPhysicalAudDevs > 0
    
    ReDim gaAudioDevSorted(gnPhysicalAudDevs-1)
    
    ; populate gaAudioDevSorted from gaPhysicalDev, but only for the nominated audio driver
    n2 = -1
    For n1 = 0 To gnPhysicalAudDevs-1
      CheckSubInRange(n1, ArraySize(gaAudioDev()), "gaAudioDev(), gnPhysicalAudDevs=" + gnPhysicalAudDevs)
      If gaAudioDev(n1)\nAudioDriver = nAudioDriver
        n2 + 1
        With gaAudioDevSorted(n2)
          \nAudioDriver = gaAudioDev(n1)\nAudioDriver
          \sDesc = ""
          \sSortKey = ""
          \sDesc = gaAudioDev(n1)\sDesc
          \bNoDevice = gaAudioDev(n1)\bNoDevice
          \bNoSoundDevice = gaAudioDev(n1)\bNoSoundDevice
          \bDefaultDev = gaAudioDev(n1)\bDefaultDev
          \nOutputs = gaAudioDev(n1)\nOutputs
          \nInputs = gaAudioDev(n1)\nInputs
          \nPhysDevPtr = n1
          ; build sort key
          sSortKey = StrN(\nAudioDriver,2) ; primarily sort by audio driver
                                           ; within audio driver, force (a) default device to top, (b) <no device> to end, and (c) others in descending order of number of outputs
          If \bNoDevice
            sDefKey = "4"
          ElseIf \bNoSoundDevice
            sDefKey = "3"
          ElseIf \bDefaultDev
            sDefKey = "1"
          Else
            sDefKey = "2"
          EndIf
          If sDefKey = "1"
            If (nAudioDriver = #SCS_DRV_BASS_DS Or nAudioDriver = #SCS_DRV_BASS_WASAPI) And (gaAudioDev(n1)\nBassDevice > 1)
              sDefKey = "2"
            EndIf
          EndIf
          sSortKey + sDefKey
          If (nAudioDriver = #SCS_DRV_BASS_ASIO) Or (nAudioDriver = #SCS_DRV_SMS_ASIO)
            sSortKey + StrN((9999 - \nOutputs), 4) + StrN((9999 - \nInputs), 4)
          EndIf
          sPhysDevWithExpandedNumbers = expandNumbersInString(\sDesc, 4)  ; see comments in sortConnectedDevs() regarding the use of expandNumbersInString()
          sSortKey + UCase(sPhysDevWithExpandedNumbers)
          \sSortKey = sSortKey + StrN(n1, 4)
        EndWith
      EndIf
    Next n1
    nMaxDev = n2
    
    ; now sort gaAudioDevSorted, and force monitor device and no device to end of list
    For n1 = 0 To (nMaxDev - 1)
      bSwapped = #False
      For n2 = 0 To (nMaxDev - 1)
        If (gaAudioDevSorted(n2)\sSortKey > gaAudioDevSorted(n2 + 1)\sSortKey)
          ; exchange the items
          rAudioDev = gaAudioDevSorted(n2)
          gaAudioDevSorted(n2) = gaAudioDevSorted(n2 + 1)
          gaAudioDevSorted(n2 + 1) = rAudioDev
          bSwapped = #True
        EndIf
      Next n2
      If bSwapped = #False
        Break
      EndIf
    Next n1
    
    ; the following for debugging only
    For n1 = 0 To nMaxDev
      With gaAudioDevSorted(n1)
        sMsg = "gaAudioDevSorted(" + n1 + ")\sDesc=" + \sDesc + ", \nOutputs=" + \nOutputs + ", \nInputs=" + \nInputs +
               ", \bNodevice=" + strB(\bNoDevice) + ", \sSortKey=" + \sSortKey + ", \nPhysDevPtr=" + \nPhysDevPtr
        If \nPhysDevPtr >= 0
          sMsg + ", gaAudioDev(" + \nPhysDevPtr + ")\nBassDevice=" + gaAudioDev(\nPhysDevPtr)\nBassDevice + ", \nDevBassASIODevice=" + gaAudioDev(\nPhysDevPtr)\nDevBassASIODevice
        EndIf
        debugMsg(sProcName, sMsg)
      EndWith
    Next n1
    
  EndIf
  
  gnSortedAudioDevs = nMaxDev + 1
  debugMsg(sProcName, #SCS_END + ", gnSortedAudioDevs=" + Str(gnSortedAudioDevs))
  
EndProcedure

Procedure buildSortedInitializedAudDevsArray()
  PROCNAMEC()
  Protected d1, d2
  Protected nPhysDevPtr
  
  debugMsg(sProcName, #SCS_START + ", gnSortedAudioDevs=" + gnSortedAudioDevs)
  
  ReDim gaAudioInitializedDevSorted(gnSortedAudioDevs-1)
  
  gnSortedInitializedDevs = 0
  d2 = -1
  For d1 = 0 To (gnSortedAudioDevs-1)
    nPhysDevPtr = gaAudioDevSorted(d1)\nPhysDevPtr
    If nPhysDevPtr >= 0
      If gaAudioDev(nPhysDevPtr)\bInitialized
        d2 + 1
        CheckSubInRange(d1, ArraySize(gaAudioDevSorted()), "gaAudioDevSorted()")
        CheckSubInRange(d2, ArraySize(gaAudioInitializedDevSorted()), "gaAudioInitializedDevSorted()")
        gaAudioInitializedDevSorted(d2) = gaAudioDevSorted(d1)
        gnSortedInitializedDevs + 1
      EndIf
    EndIf
  Next d1
  
  debugMsg(sProcName, #SCS_END + ", gnSortedInitializedDevs=" + gnSortedInitializedDevs)
  
EndProcedure

Procedure setIgnoreDevInds(pAudPtr=-1, bUseAllDevs=#False)
  PROCNAMEC()
  Protected d, d2, i, j, k, n
  Protected nFirstAudPtr, nLastAudPtr
  Protected nSubPtr
  Protected bCheckThisAud, bIgnoreThisDev
  Protected nLogicalDevPtr, nNrOfOutputChans, nFirstOutputChan, nLastOutputChan
  Protected nLogicalDevPtr2, nNrOfOutputChans2, nFirstOutputChan2, nLastOutputChan2
  Protected nPhysicalDevPtr, nPhysicalDevPtr2
  Protected nDevMapDevPtr, nDevMapDevPtr2
  Protected nDevCount
  
  ; debugMsg(sProcName, #SCS_START)
  
  If pAudPtr = -1
    nFirstAudPtr = 1
    nLastAudPtr = gnLastAud
  Else
    nFirstAudPtr = pAudPtr
    nLastAudPtr = pAudPtr
  EndIf
  
  ; first of all set ALL bIgnoreDev flags to #False, so NO devices in Auds are ignored
  For k = nFirstAudPtr To nLastAudPtr
    For d = 0 To grLicInfo\nMaxAudDevPerAud
      aAud(k)\bIgnoreDev[d] = #False
    Next d
  Next k
  
  If gnOperMode = #SCS_OPERMODE_DESIGN
    ; do not ignore devices in design mode, so user can always drag a -INF fader up
    ProcedureReturn
  EndIf
  
  If bUseAllDevs = #False
    ; nb bUseAllDevs will be #True if NO devices are to be ignored, which is the case if the file is to be openeed in the Editor
    ; when all devices must be available during playback
    For k = nFirstAudPtr To nLastAudPtr
      If aAud(k)\bExists
        
        bCheckThisAud = #False
        ; look for a device in the Aud that has a nominated playback level of -INF
        For d = 0 To grLicInfo\nMaxAudDevPerAud
          If aAud(k)\bAudTypeF
            If aAud(k)\sLogicalDev[d]
              If aAud(k)\fBVLevel[d] = #SCS_MINVOLUME_SINGLE
                bCheckThisAud = #True
                aAud(k)\bIgnoreDev[d] = #True
                debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\bIgnoreDev[" + d + "]=" + strB(aAud(k)\bIgnoreDev[d]) + ", \bAudTypeF=#True, " + "\sLogicalDev[" + d + "]=" + aAud(k)\sLogicalDev[d] + ", \fBVLevel[" + d + "]=" + formatLevel(aAud(k)\fBVLevel[d]) + ", \sDBLevel[" + d + "]=" + aAud(k)\sDBLevel[d])
              EndIf
            EndIf
          ElseIf aAud(k)\bAudTypeP
            If aAud(k)\sLogicalDev[d]
              nSubPtr = aAud(k)\nSubIndex
              If aSub(nSubPtr)\fSubMastBVLevel[d] = #SCS_MINVOLUME_SINGLE
                bCheckThisAud = #True
                aAud(k)\bIgnoreDev[d] = #True
                debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\bIgnoreDev[" + d + "]=" + strB(aAud(k)\bIgnoreDev[d]) + ", \bAudTypeP=#True, " +
                                    "\sLogicalDev[" + d + "]=" + aAud(k)\sLogicalDev[d] + ", aSub(" + getSubLabel(nSubPtr) + ")\fSubMastBVLevel[" + d + "]=" + formatLevel(aSub(nSubPtr)\fSubMastBVLevel[d]) +
                                    ", \sPLMastDBLevel[" + d + "]=" + aSub(nSubPtr)\sPLMastDBLevel[d])
              EndIf
            EndIf
          EndIf
        Next d
        
        If bCheckThisAud
          ; at least one device in this Aud has a nominated playback level of -INF, so now search for a level change subcue that acts on this Aud and Device
          nSubPtr = aAud(k)\nSubIndex
          For i = 1 To gnLastCue
            j = aCue(i)\nFirstSubIndex
            While j >= 0
              If aSub(j)\bSubTypeL And aSub(j)\bSubEnabled
                If aSub(j)\nLCSubPtr = nSubPtr
                  ; level change does affect the Aud being checked
                  For d = 0 To grLicInfo\nMaxAudDevPerAud
                    If aAud(k)\bIgnoreDev[d]
                      Select aSub(j)\nLCAction
                        Case #SCS_LC_ACTION_ABSOLUTE
                          ; absolute level change
                          If aSub(j)\fLCReqdBVLevel[d] > #SCS_MINVOLUME_SINGLE
                            aAud(k)\bIgnoreDev[d] = #False
                          EndIf
                        Case #SCS_LC_ACTION_RELATIVE
                          ; relative level change
                          If Val(aSub(j)\sLCReqdDBLevel[d]) > 0
                            aAud(k)\bIgnoreDev[d] = #False
                          EndIf
                      EndSelect
                    EndIf
                  Next d
                EndIf
              EndIf
              j = aSub(j)\nNextSubIndex
            Wend
          Next i
        EndIf
        
        If gbUseSMS
          ; now check for duplicate output channel assignments (required for SM-S)
          For d = (aAud(k)\nFirstDev + 1) To aAud(k)\nLastDev    ; start from 2nd device (if present) as 'duplicates' cannot occur on 1st device
            If aAud(k)\sLogicalDev[d]
              If aAud(k)\bIgnoreDev[d] = #False
                bIgnoreThisDev = #False
                nLogicalDevPtr = getProdLogicalDevPtrForLogicalDev(aAud(k)\sLogicalDev[d])
                nNrOfOutputChans = grProd\aAudioLogicalDevs(nLogicalDevPtr)\nNrOfOutputChans
                nDevMapDevPtr = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_AUDIO_OUTPUT, aAud(k)\sLogicalDev[d])
                If nDevMapDevPtr >= 0
                  nPhysicalDevPtr = grMaps\aDev(nDevMapDevPtr)\nPhysicalDevPtr
                  nFirstOutputChan = grMaps\aDev(nDevMapDevPtr)\nFirst1BasedOutputChan + gaAudioDev(nPhysicalDevPtr)\nFirst0BasedOutputChanAG
                  nLastOutputChan = nFirstOutputChan + nNrOfOutputChans - 1
                  debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\sLogicalDev(" + d + ")=" + aAud(k)\sLogicalDev[d] +
                                      ", nNrOfOutputChans=" + nNrOfOutputChans + ", nFirstOutputChan=" + nFirstOutputChan + ", nLastOutputChan=" + nLastOutputChan)
                  ; check if this output range clashes with that of an earlier device in this Aud
                  For d2 = aAud(k)\nFirstDev To (d - 1)
                    If aAud(k)\bIgnoreDev[d2] = #False
                      nLogicalDevPtr2 = getProdLogicalDevPtrForLogicalDev(aAud(k)\sLogicalDev[d2])
                      nNrOfOutputChans2 = grProd\aAudioLogicalDevs(nLogicalDevPtr2)\nNrOfOutputChans
                      nDevMapDevPtr2 = getDevMapDevPtrForLogicalDev(@grMaps, #SCS_DEVGRP_AUDIO_OUTPUT, aAud(k)\sLogicalDev[d2])
                      If nDevMapDevPtr2 >= 0
                        nPhysicalDevPtr2 = grMaps\aDev(nDevMapDevPtr2)\nPhysicalDevPtr
                        nFirstOutputChan2 = grMaps\aDev(nDevMapDevPtr2)\nFirst1BasedOutputChan + gaAudioDev(nPhysicalDevPtr2)\nFirst0BasedOutputChanAG
                        nLastOutputChan2 = nFirstOutputChan2 + nNrOfOutputChans2 - 1
                        debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\sLogicalDev[" + d2 + "]=" + aAud(k)\sLogicalDev[d2] +
                                            ", nNrOfOutputChans2=" + nNrOfOutputChans2 + ", nFirstOutputChan2=" + nFirstOutputChan2 + ", nLastOutputChan2=" + nLastOutputChan2)
                        For n = nFirstOutputChan To nLastOutputChan
                          If (n >= nFirstOutputChan2) And (n <= nLastOutputChan2)
                            bIgnoreThisDev = #True
                            Break
                          EndIf
                        Next n
                      EndIf
                    EndIf
                    If bIgnoreThisDev
                      Break
                    EndIf
                  Next d2
                  If bIgnoreThisDev
                    aAud(k)\bIgnoreDev[d] = #True
                  EndIf
                  ; debugMsg(sProcName, "aAud(" + getAudLabel(k) + ")\bIgnoreDev(" + d + ")=" + strB(aAud(k)\bIgnoreDev[d]) + ", n=" + n)
                EndIf
              EndIf
            EndIf
          Next d
        EndIf
        
      EndIf
    Next k
  EndIf
  
  ; now make sure that every audio file cue has at least one device that is not ignored
  For k = nFirstAudPtr To nLastAudPtr
    With aAud(k)
      If \bAudTypeForP
        nDevCount = 0
        d2 = -1
        For d = 0 To grLicInfo\nMaxAudDevPerAud
          If \sLogicalDev[d]
            If d2 = -1
              d2 = d
            EndIf
            If \bIgnoreDev[d] = #False
              nDevCount + 1
            EndIf
          EndIf
        Next d
        If nDevCount = 0
          If d2 >= 0
            debugMsg(sProcName, "changing aAud(" + getAudLabel(k) + ")\bIgnoreDev[" + d2 + "] to #False")
            \bIgnoreDev[d2] = #False
          Else
            debugMsg(sProcName, "WARNING!!! No devices found in aAud(" + getAudLabel(k) + ")")
          EndIf
        EndIf
       EndIf
    EndWith
  Next k
  
  ; debugMsg(sProcName, "calling setFirstAndLastDev()")
  For k = nFirstAudPtr To nLastAudPtr
    setFirstAndLastDev(k)
  Next k
  
  ; debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure listIgnoreDevInds()
  PROCNAMEC()
  Protected d, i, j, k
  
  debugMsg(sProcName, #SCS_START)
  
  For i = 1 To gnLastCue
    j = aCue(i)\nFirstSubIndex
    While j >= 0
      If aSub(j)\bSubTypeF And aSub(j)\bSubEnabled
        k = aSub(j)\nFirstAudIndex
        While k >= 0
          For d = aAud(k)\nFirstDev To aAud(k)\nLastDev
            If aAud(k)\bIgnoreDev[d]
              debugMsg(sProcName, "bIgnoreDev set for " + getAudLabel(k) + ", " + aAud(k)\sLogicalDev[d])
            EndIf
          Next d
          k = aAud(k)\nNextAudIndex
        Wend
      EndIf
      j = aSub(j)\nNextSubIndex
    Wend
  Next i
  
EndProcedure

Procedure openFilesForCueIfReqd(pCuePtr)
  PROCNAMECQ(pCuePtr)
  Protected j, k, n
  Protected nPLFileOpenCount
  Protected bOpenInMainThread
  
  debugMsg(sProcName, #SCS_START)
  
  If gnThreadNo > #SCS_THREAD_MAIN
    ; modified 13May2017 11.6.1bh to force processing unconditionally to the main thread following a test in which an audio file
    ; couldn't be opened due to an unavailable device, which resulted in a call to OptionRequester, BUT OptionRequester uses
    ; OpenWindow() which PB says must be called from the main thread
    samAddRequest(#SCS_SAM_OPEN_FILES_FOR_CUE, pCuePtr)
    ProcedureReturn #False  ; #False indicates files not yet opened because we're not in the main thread and the cue requires main thread
  EndIf    
  
  debugMsg(sProcName, "aCue(" + getCueLabel(pCuePtr) + ")\nCueState=" + decodeCueState(aCue(pCuePtr)\nCueState))
  j = aCue(pCuePtr)\nFirstSubIndex
  While j >= 0
    If aSub(j)\bSubEnabled
      debugMsg(sProcName, "aSub(" + getSubLabel(j) + ")\nSubState=" + decodeCueState(aSub(j)\nSubState) + ", aSub(" + getSubLabel(j) + ")\bSubTypeF=" + strB(aSub(j)\bSubTypeF))
      If aSub(j)\nSubState = #SCS_CUE_NOT_LOADED
        If (aSub(j)\bSubTypeF) Or (aSub(j)\bSubTypeM)
          k = aSub(j)\nFirstAudIndex
          While k >= 0
            debugMsg(sProcName, "calling openMediaFile(" + getAudLabel(k) + ")")
            openMediaFile(k)
            k = aAud(k)\nNextAudIndex
          Wend
          
        ElseIf aSub(j)\bSubTypeAorP
          k = aSub(j)\nFirstPlayIndex
          nPLFileOpenCount = 0
          While (k >= 0) And (nPLFileOpenCount < 2)
            debugMsg(sProcName, "calling openMediaFile(" + getAudLabel(k) + ")")
            openMediaFile(k, #False, getVidPicTargetForOutputScreen(aSub(j)\nOutputScreen))
            nPLFileOpenCount + 1
            k = aAud(k)\nNextPlayIndex
          Wend
          
        EndIf
      EndIf
    EndIf
    j = aSub(j)\nNextSubIndex
  Wend
  
  debugMsg(sProcName, #SCS_END)
  ProcedureReturn #True   ; #True indicates file(s) opened if required
  
EndProcedure

Procedure reopenAudFileIfReqd(pAudPtr)
  PROCNAMECA(pAudPtr)
  
  debugMsg(sProcName, #SCS_START)
  
  If pAudPtr >= 0
    With aAud(pAudPtr)
      If \nFileState = #SCS_FILESTATE_CLOSED
        debugMsg(sProcName, "calling openMediaFile(" + getAudLabel(pAudPtr) + ", #True)")
        openMediaFile(pAudPtr, #True)
        debugMsg(sProcName, "\nFileState=" + decodeFileState(\nFileState))
      EndIf
    EndWith
  EndIf
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure reopenVidFilesForCueIfReqd(pCuePtr)
  PROCNAMECQ(pCuePtr)
  ; added 2Jun2017 for video/image cues to reopen the media files if any of the size, xpos, pos, etc has been changed in the editor
  Protected j, k, nVidPicTarget
  Protected bOpenMediaResult, nPhysicalDevPtr
  
  If pCuePtr >= 0
    If aCue(pCuePtr)\bCueCurrentlyEnabled
      If aCue(pCuePtr)\bSubTypeA And aSub(j)\bSubEnabled
        j = aCue(pCuePtr)\nFirstSubIndex
        While j >= 0
          k = aSub(j)\nFirstAudIndex
          While k >= 0
            With aAud(k)
              ; debugMsg0(sProcName, "aAud(" + getAudLabel(k) + ")\bReOpenVidFile=" + strB(\bReOpenVidFile))
              If \bReOpenVidFile
                If \nFileState = #SCS_FILESTATE_OPEN
                  debugMsg(sProcName, "calling closeAud(" + getAudLabel(k) + ")")
                  closeAud(k)
                  debugMsg(sProcName, "calling freeAudTVGControls(" + getAudLabel(k) + ")")
                  freeAudTVGControls(k)
                  nVidPicTarget = getVidPicTargetForOutputScreen(aSub(j)\nOutputScreen)
                  If \nVideoSource = #SCS_VID_SRC_CAPTURE
                    ; Added 11Jun2020 11.8.2.3aa (including the 'If' test above)
                    debugMsg(sProcName, "calling openVideoCaptureDevForTVG(" + getAudLabel(k) + ", " + decodeVidPicTarget(nVidPicTarget) + ")")
                    nPhysicalDevPtr = openVideoCaptureDevForTVG(k, nVidPicTarget)
                    debugMsg(sProcName, "openVideoCaptureDevForTVG(" + getAudLabel(k) + ", " + decodeVidPicTarget(nVidPicTarget) + ") returned nPhysicalDevPtr=" + nPhysicalDevPtr)
                    ; End added 11Jun2020 11.8.2.3aa
                  Else
                    debugMsg(sProcName, "calling openMediaFile(" + getAudLabel(k) + ", #False, " + decodeVidPicTarget(nVidPicTarget) + ")")
                    bOpenMediaResult = openMediaFile(k, #False, nVidPicTarget)
                    debugMsg(sProcName, "bOpenMediaResult=" + strB(bOpenMediaResult))
                  EndIf
                EndIf
                \bReOpenVidFile = #False
              EndIf
            EndWith
            k = aAud(k)\nNextAudIndex
          Wend
          j = aSub(j)\nNextSubIndex
        Wend  
      EndIf
    EndIf
  EndIf
  
EndProcedure

Procedure applyAudFade(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected d
  Protected nSubPtr
  Protected nFadePos, nLoopXFadePos, nLoopXFadeTime
  Protected bAllFadesCompleted
  Protected nReqdFadeTime
  Protected fReqdBVLevel.f, fReqdPan.f
  Protected fTrimFactor.f = 1.0
  Protected fChannelLevel.f, fAltChannelLevel.f
  Protected bInLoopXFade
  Protected nBassResult.l
  Protected nNextLevelNodeIndex
  Protected nLabel
  Protected nChannel.l, nAltChannel.l
  Protected fAdjBVLevel.f, nDevMapDevPtr, fOutputGain.f
  
  If pAudPtr >= 0
    With aAud(pAudPtr)
      If \bFadeInProgress
        nFadePos = gqTimeNow - \qTimeFadeStarted + gnTimerInterval
        ;debugMsg(sProcName, "gqTimeNow=" + gqTimeNow + ", \qTimeFadeStarted=" + \qTimeFadeStarted + ", gnTimerInterval=" + gnTimerInterval + ", nFadePos=" + nFadePos)
        bInLoopXFade = \bInLoopXFade
        If bInLoopXFade
          nLoopXFadeTime = \rCurrLoopInfo\nLoopXFadeTime
          If nLoopXFadeTime <= 0
            ; shouldn't get here
            bInLoopXFade = #False
          Else
            nLoopXFadePos = (\nAbsMin + \nCuePos) - (\rCurrLoopInfo\nAbsLoopEnd - nLoopXFadeTime) + gnTimerInterval
            debugMsg(sProcName, "nLoopXFadeTime=" + nLoopXFadeTime + ", nLoopXFadePos=" + nLoopXFadePos +
                                ", \nAbsMin=" + \nAbsMin + ", \nCuePos=" + \nCuePos + ", \rCurrLoopInfo\nAbsLoopEnd=" + \rCurrLoopInfo\nAbsLoopEnd + ", \rCurrLoopInfo\nLoopXFadeTime=" + \rCurrLoopInfo\nLoopXFadeTime)
            If nLoopXFadePos < 0
              nLoopXFadePos = 0
            ElseIf nLoopXFadePos > nLoopXFadeTime
              nLoopXFadePos = nLoopXFadeTime
            EndIf
            ;debugMsg(sProcName, "nLoopXFadeTime=" + nLoopXFadeTime + ", nLoopXFadePos=" + nLoopXFadePos)
          EndIf
        EndIf
        For d = 0 To #SCS_MAX_AUDIO_DEV_PER_AUD_OR_SUB
          If \sLogicalDev[d]
            ; debugMsg(sProcName, ">>>> aAud(" + getAudLabel(pAudPtr) + ")\sLogicalDev[" + d + "]=" + \sLogicalDev[d] + ", \bFadeCompleted[" + d + "]=" + strB(\bFadeCompleted[d]))
            If \bFadeCompleted[d] = #False
              ;debugMsg(sProcName, "\nReqdFadeTime[" + d + "]=" + \nReqdFadeTime[d] + ", \fPreFadeBVLevel[" + d + "]=" + formatLevel(\fPreFadeBVLevel[d]) + ", \fTargetBVLevel[" + d + "]=" + formatLevel(\fTargetBVLevel[d]))
              nReqdFadeTime = \nReqdFadeTime[d]
              If nFadePos >= nReqdFadeTime
                fReqdBVLevel = \fTargetBVLevel[d]
                fReqdPan = \fTargetPan[d]
                \bFadeCompleted[d] = #True
              Else
                fReqdBVLevel = calcBVLevel(\nFadeType, nReqdFadeTime, nFadePos, \fPreFadeBVLevel[d], \fTargetBVLevel[d], fTrimFactor)
                CompilerIf #cTraceSetLevels
                  ; debugMsg(sProcName, "fReqdBVLevel=" + formatLevel(fReqdBVLevel))
                  debugMsg(sProcName, "calcBVLevel(" + decodeFadeType(\nFadeType) + ", nTime=" + nReqdFadeTime + ", nPos=" + nFadePos +
                                      ", fOriginalBVLevel=" + formatLevel(\fPreFadeBVLevel[d]) + ", fTargetBVLevel=" + formatLevel(\fTargetBVLevel[d]) +
                                      ", fTrimFactor=" + formatTrim(fTrimFactor) + ") returned fReqdBVLevel=" + formatLevel(fReqdBVLevel))
                CompilerEndIf
                If \fTargetPan[d] <> #SCS_NOPANCHANGE_SINGLE
                  fReqdPan = calcPan(nReqdFadeTime, nFadePos, \fPreFadePan[d], \fTargetPan[d])
                Else
                  fReqdPan = #SCS_NOPANCHANGE_SINGLE
                EndIf
              EndIf
              ; added 9Jun2017 11.6.2RC5 following emails from John Zimmerman
              ; based on code in the procedure slideChannelAttributes()
              fAdjBVLevel = fReqdBVLevel
              If fReqdBVLevel <> #SCS_NOVOLCHANGE_SINGLE
                If gbUseBASSMixer = #False
                  nDevMapDevPtr = \nOutputDevMapDevPtr[d]
                  If nDevMapDevPtr >= 0
                    fOutputGain = grMaps\aDev(nDevMapDevPtr)\fDevOutputGain
                    If fOutputGain <> 1.0
                      fAdjBVLevel * fOutputGain
                    EndIf
                  EndIf
                EndIf
                CompilerIf #cTraceSetLevels
                  debugMsg(sProcName, "d=" + d + ", fReqdBVLevel=" + formatLevel(fReqdBVLevel) + ", fAdjBVLevel=" + formatLevel(fAdjBVLevel))
                  If nDevMapDevPtr >= 0
                    debugMsg(sProcName, "grMaps\aDev(" + nDevMapDevPtr + ")\fDevOutputGain=" + traceLevel(grMaps\aDev(nDevMapDevPtr)\fDevOutputGain))
                  EndIf
                CompilerEndIf
              EndIf
              fReqdBVLevel = fAdjBVLevel
              ; end added 9Jun2017 11.6.2RC5
              If fReqdBVLevel <= grLevels\fMinBVLevel
                fReqdBVLevel = #SCS_MINVOLUME_SINGLE
              ElseIf fReqdBVLevel > grLevels\fMaxBVLevel
                fReqdBVLevel = grLevels\fMaxBVLevel
              EndIf
              If fReqdPan <> #SCS_NOPANCHANGE_SINGLE
                If fReqdPan < #SCS_MINPAN_SINGLE
                  fReqdPan = #SCS_MINPAN_SINGLE
                ElseIf fReqdPan > #SCS_MAXPAN_SINGLE
                  fReqdPan = #SCS_MAXPAN_SINGLE
                EndIf
              EndIf
              If bInLoopXFade
                fAltChannelLevel = fReqdBVLevel * nLoopXFadePos / nLoopXFadeTime
                fChannelLevel = fReqdBVLevel - fAltChannelLevel
                debugMsg(sProcName, "bInLoopXFade=" + strB(bInLoopXFade) + ", fReqdBVLevel=" + traceLevel(fReqdBVLevel) + ", nLoopXFadeTime=" + nLoopXFadeTime + ", nLoopXFadePos" + nLoopXFadePos +
                                    ", fAltChannelLevel=" + traceLevel(fAltChannelLevel) + ", fChannelLevel=" + traceLevel(fChannelLevel))
              Else
                fChannelLevel = fReqdBVLevel
              EndIf
              If gbUseBASS
                ; Added 28Sep2022 11.9.6
                If fChannelLevel <= grLevels\fMinBVLevel
                  fChannelLevel = 0.0
                EndIf
                If fAltChannelLevel <= grLevels\fMinBVLevel
                  fAltChannelLevel = 0.0
                EndIf
                ; End added 28Sep2022 11.9.6
                nChannel = \nBassChannel[d]
                nAltChannel = \nBassAltChannel[d]
                nBassResult = BASS_ChannelSlideAttribute(nChannel, #BASS_ATTRIB_VOL, fChannelLevel, gnTimerInterval)
                CompilerIf #cTraceSetLevels
                  debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nChannel) + ", #BASS_ATTRIB_VOL, " + traceLevel(fChannelLevel) + ", " + gnTimerInterval + ")", nBassResult)
                CompilerEndIf
                If bInLoopXFade
                  nBassResult = BASS_ChannelSlideAttribute(\nBassAltChannel[d], #BASS_ATTRIB_VOL, fAltChannelLevel, gnTimerInterval)
                  CompilerIf #cTraceSetLevels
                    debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(\nBassAltChannel[d]) + ", #BASS_ATTRIB_VOL, " + traceLevel(fAltChannelLevel) + ", " + gnTimerInterval + ")", nBassResult)
                  CompilerEndIf
                EndIf
                If fReqdPan <> #SCS_NOPANCHANGE_SINGLE
                  nBassResult = BASS_ChannelSlideAttribute(nChannel, #BASS_ATTRIB_PAN, fReqdPan, gnTimerInterval)
                  CompilerIf #cTraceSetLevels
                    debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nChannel) + ", #BASS_ATTRIB_PAN, " + formatPan(fReqdPan) + ", " + gnTimerInterval + ")", nBassResult)
                  CompilerEndIf
                  If nAltChannel <> 0
                    nBassResult = BASS_ChannelSlideAttribute(nAltChannel, #BASS_ATTRIB_PAN, fReqdPan, gnTimerInterval)
                    CompilerIf #cTraceSetLevels
                      debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(nAltChannel) + ", #BASS_ATTRIB_PAN, " + formatPan(fReqdPan) + ", " + gnTimerInterval + ")", nBassResult)
                    CompilerEndIf
                  EndIf
                EndIf ; EndIf fReqdPan <> #SCS_NOPANCHANGE_SINGLE
              EndIf ; EndIf gbUseBASS
            EndIf ; EndIf \bFadeCompleted[d] = #False
          EndIf ; EndIf \sLogicalDev[d]
        Next d
        \qTimeForNextFadeCheck = gqTimeNow + (gnTimerInterval - 5)
      EndIf
    EndWith
  EndIf
  
EndProcedure

Procedure addLevelNodeItem(nNodeType, nNodeTime, nFadeType, nFilePos=-1)
  PROCNAMEC()
  
  CompilerIf 1=2
    ; NOT USED YET
    If nNodeTime >= 0
      If (nFilePos = -1) Or (nNodeTime > nFilePos)
        ; note: if nFilePos <> -1 then only FUTURE nodes are to be stored in the array
        gnMaxLevelNode + 1
        If gnMaxLevelNode > ArraySize(gaLevelNode())
          ReDim gaLevelNode(gnMaxLevelNode+10)
        EndIf
        With gaLevelNode(gnMaxLevelNode)
          \nNodeType = nNodeType
          \nNodeTime = nNodeTime
          \nFadeType = nFadeType
        EndWith
      EndIf
    EndIf
  CompilerEndIf
  
EndProcedure

Procedure getNextLevelNodeIndex(pAudPtr)
  PROCNAME(buildAudProcName(#PB_Compiler_Procedure, pAudPtr))
  Protected nNextLevelNodeTime, nNextLevelNodeIndex = -1
  Protected nFilePos
  Protected d, n
  
  CompilerIf 1=2
    ; NOT USED YET
    debugMsg(sProcName, #SCS_START)
    
    If pAudPtr >= 0
      gnMaxLevelNode = -1
      With aAud(pAudPtr)
        nFilePos = \nCuePos + \nAbsMin
        ; build array of future level nodes
        addLevelNodeItem(#SCS_LNT_END, \nAbsEndAt, \nFadeOutType, nFilePos)
        If \nFadeInTime > 0
          addLevelNodeItem(#SCS_LNT_FADE_IN_END, (\nAbsStartAt + \nFadeInTime), \nFadeInType, nFilePos)
        EndIf
        If \nFadeOutTime > 0
          addLevelNodeItem(#SCS_LNT_FADE_OUT_START, (\nAbsEndAt - \nFadeOutTime), -1, nFilePos)
        EndIf
        If \bContainsLoop
          If \nLoopXFadeTime > 0
            If \bLoopReleased = #False
              addLevelNodeItem(#SCS_LNT_XFADE_START, (\nAbsLoopEnd - \nLoopXFadeTime), -1, nFilePos)
              addLevelNodeItem(#SCS_LNT_XFADE_END, \nAbsLoopEnd, -1, nFilePos)
            EndIf
          EndIf
        EndIf
        If \bFadeRequested
          For d = 0 To grLicInfo\nMaxAudDevPerAud
            If \sLogicalDev[d]
              If \bFadeCompleted[d] = #False
                addLevelNodeItem(#SCS_LNT_REQD_FADE_END, (\nReqdFadeTime[d] + \nTimeFadeStarted), \nFadeType, nFilePos)
              EndIf
            EndIf
          Next d
        EndIf
        ; now find the earliest future level node
        nNextLevelNodeTime = \nAbsEndAtf
        For n = 0 To gnMaxLevelNode
          If gaLevelNode(n)\nNodeTime < nNextLevelNodeTime
            nNextLevelNodeTime = gaLevelNode(n)\nNodeTime
            nNextLevelNodeIndex = n
          EndIf
        Next n
      EndWith
    EndIf
    
    If nNextLevelNodeIndex >= 0
      With gaLevelNode(nNextLevelNodeIndex)
        debugMsg(sProcName, "nFilePos=" + nFilePos + ", nNextLevelNodeIndex=" + nNextLevelNodeIndex +
                            ", gaLevelNode(" + nNextLevelNodeIndex + ")\nNodeType=" + \nNodeType +
                            ", \nNodeTime=" + \nNodeTime + ", \nFadeType=" + decodeFadeType(\nFadeType))
      EndWith
    EndIf
    
    debugMsg(sProcName, #SCS_END + ", returning " + nNextLevelNodeIndex)
  CompilerEndIf
  ProcedureReturn nNextLevelNodeIndex
EndProcedure

Procedure restartASIO_original()
  PROCNAMEC()
  Protected d
  Protected nBassResult.l
  Protected nBufLen.l
  
  debugMsg(sProcName, #SCS_START)
  
  If gbAsioInitDone
    debugMsg3(sProcName, "stopping ASIO devices")
    For d = 0 To ArraySize(gaAudioDev())
      With gaAudioDev(d)
        If \bInitialized
          If \bASIO
             ; set the ASIO device to work with
            nBassResult = BASS_ASIO_SetDevice(\nDevBassASIODevice)
            debugMsg2(sProcName, "BASS_ASIO_SetDevice(" + \nDevBassASIODevice + ")", nBassResult)
            nBassResult = BASS_ASIO_IsStarted()
            debugMsg2(sProcName, "BASS_ASIO_IsStarted", nBassResult)
            If nBassResult = #BASSTRUE
              ; stop the device
              nBassResult = BASS_ASIO_Stop()
              debugMsg2(sProcName, "BASS_ASIO_Stop for ASIO device " + \nDevBassASIODevice, nBassResult)
              ; restart the device
              CompilerIf #cEnableASIOBufLen
                nBufLen = \nAsioBufLen
              CompilerElse
                nBufLen = 0
              CompilerEndIf
              nBassResult = BASS_ASIO_Start(nBufLen, 0)
              debugMsg2(sProcName, "BASS_ASIO_Start(" + nBufLen + ", 0) for ASIO device " + \nDevBassASIODevice, nBassResult)
              If nBassResult = #BASSFALSE
                debugMsg3(sProcName, "Error: " + getBassErrorDesc(BASS_ASIO_ErrorGetCode()))
              EndIf
            EndIf
          EndIf
        EndIf
      EndWith
    Next d
  EndIf
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure resetAudFlags(pAudPtr)
  PROCNAMECA(pAudPtr)
  
  debugMsg(sProcName, #SCS_START)
  
  With aAud(pAudPtr)
    \sDriver = "?"
    \bReOpenFile = #False
    \bReOpenVidFile = #False
    \bMediaStarted = #False
    \bMediaEnded = #False
    \bBassFloat = #False
    \bBlending = #False
    \bUsingSplitStream = #False
    \nSMSManualStartPos = grAudDef\nSMSManualStartPos
    \qInitialGetPosition = -1
    \bIgnoreInStatusCheck = #False
    ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\bIgnoreInStatusCheck=" + strB(aAud(pAudPtr)\bIgnoreInStatusCheck))
    \nVideoPlaybackLibrary = #SCS_VPL_NOT_SET
    \bInsufficientSMSPlaybacks = #False
    \bTVG_OpenPlayerFailed = #False
    \bUsingMemoryImage = #False
    \bResetFilePosToStartAtInMain = #False
    \bPlayNextAudRequested = #False
    \qFileBytes = grAudDef\qFileBytes
    \nPlayFromPos = grAudDef\nPlayFromPos
    \bFadeRequested = #False
    \bFadeInOneAudIssuedSlideChannelAttributes = #False
    \bMediaStarted = #False
    \bMediaEnded = #False
    \qEndAtTime = grAudDef\qEndAtTime
    \bBetweenMixAndHearSyncPoints = #False
    \bPlayEndSyncOccurred = #False
    \nLoopPassNo = grAudDef\nLoopPassNo
    If \rCurrLoopInfo\nLoopSyncIndex >= 0
      gaLoopSync(\rCurrLoopInfo\nLoopSyncIndex)\nLoopSyncPassNo = 1
    EndIf
    \bFinalFadeOut = #False
    \bFinalSlide = #False
    \bInLoopXFade = #False
  EndWith
  
EndProcedure

Procedure resetAudStateForPos(pAudPtr, pPos, bTrace=#False)
  PROCNAMECA(pAudPtr)
  Protected nCurrState, nReqdState, d, nCurrFadePos
  
  debugMsgC(sProcName, #SCS_START + ", pPos=" + pPos)
  
  If pAudPtr >= 0
    With aAud(pAudPtr)
      nCurrState = \nAudState
      debugMsgC(sProcName, "nCurrState=" + decodeCueState(nCurrState) + ", \nCuePos=" + \nCuePos + ", \nRelFilePos=" + \nRelFilePos + ", \nCuePosAtFadeStart=" + \nCuePosAtFadeStart + ", nCurrFadePos=" + nCurrFadePos)
      nCurrFadePos = pPos - \nCuePosAtFadeStart
      If (nCurrState >= #SCS_CUE_FADING_IN) And (nCurrState <= #SCS_CUE_FADING_OUT) And (nCurrState <> #SCS_CUE_PAUSED) And (nCurrState <> #SCS_CUE_HIBERNATING)
        
        If (\nFadeInTime > 0) And (nCurrFadePos < \nFadeInTime) ; changed pPos to nCurrFadePos 1Feb2022 11.9.0rc7
          ; fading in
          debugMsgC(sProcName, "fading in")
          If (nCurrState = #SCS_CUE_TRANS_FADING_IN) Or (nCurrState = #SCS_CUE_FADING_IN)
            nReqdState = nCurrState
          Else
            nReqdState = #SCS_CUE_FADING_IN
          EndIf
          If nReqdState <> nCurrState
            \qTimeFadeInStarted = ElapsedMilliseconds() - pPos
            \nCuePosAtFadeStart = pPos
            debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\qTimeFadeInStarted=" + traceTime(\qTimeFadeInStarted) + ", \nCuePosAtFadeStart=" + \nCuePosAtFadeStart)
            \bTimeFadeInStartedSet = #True
          EndIf
          
        ElseIf (\nFadeOutTime > 0) And (nCurrFadePos > (\nCueDuration - \nFadeOutTime)) ; changed pPos to nCurrFadePos 1Feb2022 11.9.0rc7
          ; fading out
          debugMsgC(sProcName, "fading out")
          If (nCurrState = #SCS_CUE_TRANS_FADING_OUT) Or (nCurrState = #SCS_CUE_TRANS_MIXING_OUT) Or (nCurrState = #SCS_CUE_FADING_OUT)
            nReqdState = nCurrState
          Else
            nReqdState = #SCS_CUE_FADING_OUT
          EndIf
          If nReqdState <> nCurrState
            For d = 0 To grLicInfo\nMaxAudDevPerAud
              If \sLogicalDev[d]
                \fBVLevelWhenFadeOutStarted[d] = \fCueTotalVolNow[d]          
              EndIf
            Next d
            \qTimeFadeOutStarted = ElapsedMilliseconds() - (pPos - (\nCueDuration - \nFadeOutTime))
            \bTimeFadeOutStartedSet = #True
            debugMsgC(sProcName, "\nCueDuration=" + \nCueDuration + ", \nFadeOutTime=" + \nFadeOutTime + ", \qTimeFadeOutStarted=" + traceTime(\qTimeFadeOutStarted))
          EndIf
          
        ElseIf (pPos < \nCueDuration)
          ; playing
          debugMsgC(sProcName, "playing")
          nReqdState = #SCS_CUE_PLAYING
          
        Else
          ; other
          debugMsgC(sProcName, "other")
          nReqdState = nCurrState
        EndIf
        
        If nReqdState <> nCurrState
          debugMsgC(sProcName, "changing \nAudState from " + decodeCueState(nCurrState) + " to " + decodeCueState(nReqdState))
          \nAudState = nReqdState
        EndIf
        
        debugMsgC(sProcName, "calling setCueState(" + getCueLabel(\nCueIndex) + ")")
        setCueState(\nCueIndex)
      EndIf
    EndWith
  EndIf
  
EndProcedure

Procedure getCurrLoopInfoIndexAndSetLoopReleasedIndsIfReqd(pAudPtr, nRelPos, bRepositioning=#False, bTrace=#False)
  PROCNAMECA(pAudPtr)
  Protected nLoopInfoIndex = -1, nCurrLoopInfoIndex = -1
  Protected n
  Protected l2
  
  debugMsgC(sProcName, #SCS_START + ", nRelPos=" + nRelPos + ", bRepositioning=" + strB(bRepositioning))
  
  With aAud(pAudPtr)
    If \nMaxLoopInfo >= 0
      For n = 0 To \nMaxLoopInfo
        ; Added 2Feb2022 11.9.0rc7
        If \rCurrLoopInfo\nAbsLoopStart = \aLoopInfo(n)\nAbsLoopStart
          nCurrLoopInfoIndex = n
        EndIf
        ; End added 2Feb2022 11.9.0rc7
        If nRelPos < \aLoopInfo(n)\nRelLoopEnd
          nLoopInfoIndex = n
          Break
        EndIf
      Next n
      ; nb if nRelPos as beyond the last loop end position then nLoopInfoIndex will still be it's initial value of -1
      debugMsgC(sProcName, "nCurrLoopInfoIndex=" + nCurrLoopInfoIndex + ", nLoopInfoIndex=" + nLoopInfoIndex)
      If nLoopInfoIndex <> nCurrLoopInfoIndex ; Test added 2Feb2022 11.9.0rc7
        For l2 = 0 To \nMaxLoopInfo
          If (l2 < nLoopInfoIndex) Or (nLoopInfoIndex = -1)
            \aLoopInfo(l2)\bLoopReleased = #True
            debugMsgC(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\aLoopInfo(" + l2 + ")\bLoopReleased=" + strB(\aLoopInfo(l2)\bLoopReleased))
          ElseIf (l2 >= nLoopInfoIndex) And (bRepositioning)
            \aLoopInfo(l2)\bLoopReleased = #False
            debugMsgC(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\aLoopInfo(" + l2 + ")\bLoopReleased=" + strB(\aLoopInfo(l2)\bLoopReleased))
          ; ElseIf l2 > nLoopInfoIndex
          ;   \aLoopInfo(l2)\bLoopReleased = #False
          EndIf
        Next l2
      EndIf
      If nLoopInfoIndex = -1
        nLoopInfoIndex = 100  ; indicates nRelPos is beyond the end of the last loop
      EndIf
    EndIf
  EndWith
  
  debugMsgC(sProcName, #SCS_END + ", returning " + nLoopInfoIndex)
  ProcedureReturn nLoopInfoIndex
  
EndProcedure

Procedure loadCurrLoopInfo(pAudPtr, nRelPos, bRepositioning=#False, bTrace=#False)
  PROCNAMECA(pAudPtr)
  Protected nLoopInfoIndex, bBeyondLastLoop
  Protected nPrevLoopInfoIndex
  
  debugMsgC(sProcName, #SCS_START + ", nRelPos=" + nRelPos + ", bRepositioning=" + strB(bRepositioning))
  
  With aAud(pAudPtr)
    nPrevLoopInfoIndex = \nCurrLoopInfoIndex
    nLoopInfoIndex = getCurrLoopInfoIndexAndSetLoopReleasedIndsIfReqd(pAudPtr, nRelPos, bRepositioning, bTrace)
    If nLoopInfoIndex >= 100
      nLoopInfoIndex = \nMaxLoopInfo
      bBeyondLastLoop = #True
    EndIf
    If nLoopInfoIndex >= 0
      \rCurrLoopInfo = \aLoopInfo(nLoopInfoIndex)
    Else
      \rCurrLoopInfo = grLoopInfoDef
    EndIf
    If nLoopInfoIndex <> \nCurrLoopInfoIndex
      \nCurrLoopInfoIndex = nLoopInfoIndex
      \nLoopPassNo = 0
    EndIf
    If nLoopInfoIndex <> nPrevLoopInfoIndex
      \nRelPassStart = \rCurrLoopInfo\nRelLoopStart
      \nRelPassEnd = \rCurrLoopInfo\nRelLoopEnd
      \nLoopPassNo = grAudDef\nLoopPassNo
      If \rCurrLoopInfo\nLoopSyncIndex >= 0
        gaLoopSync(\rCurrLoopInfo\nLoopSyncIndex)\nLoopSyncPassNo = 1
      EndIf
      \nCuePosAtLoopStart = \nRelPassStart
    ElseIf nRelPos < \rCurrLoopInfo\nLoopStart
      \nLoopPassNo = grAudDef\nLoopPassNo
      If \rCurrLoopInfo\nLoopSyncIndex >= 0
        gaLoopSync(\rCurrLoopInfo\nLoopSyncIndex)\nLoopSyncPassNo = 1
      EndIf
    EndIf
    If bBeyondLastLoop
      \nRelPassEnd = \nAbsEndAt - \nAbsMin
    EndIf
    debugMsgC(sProcName, #SCS_END + ", \nCurrLoopInfoIndex=" + \nCurrLoopInfoIndex + ", \nRelPassStart=" + \nRelPassStart + ", \nRelPassEnd=" + \nRelPassEnd +
                         ", \nLoopPassNo=" + \nLoopPassNo + ", \nCuePosAtLoopStart=" + \nCuePosAtLoopStart)
  EndWith
  
EndProcedure

Procedure setCurrLoopReleasedState(pAudPtr)
  ; PROCNAMECA(pAudPtr)
  Protected l2, nAbsPos, bLoopReased
  
  With aAud(pAudPtr)
    l2 = \nCurrLoopInfoIndex
    If l2 >= 0
      nAbsPos = \nCuePos + \nAbsMin
      If nAbsPos > \rCurrLoopInfo\nAbsLoopEnd
        bLoopReased = #True
      EndIf
      ; debugMsg(sProcName, "l2=" + l2 + ", nAbsPos=" + nAbsPos + ", bLoopReased=" + strB(bLoopReased))
      \aLoopInfo(l2)\bLoopReleased = bLoopReased
      \rCurrLoopInfo\bLoopReleased = bLoopReased
    EndIf
  EndWith
  
EndProcedure

Procedure usingLoopXFade(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected bUsingLoopXFade
  Protected l2, k
  
  ; debugMsg(sProcName, #SCS_START)
  
  With aAud(pAudPtr)
    For l2 = 0 To \nMaxLoopInfo
      If \aLoopInfo(l2)\nLoopXFadeTime >= 0
        bUsingLoopXFade = #True
        Break
      EndIf
    Next l2
    k = \nLinkedToAudPtr  ; used below
    If \nLinkedToAudPtr >= 0
      debugMsg(sProcName, "\nLinkedToAudPtr=" + getAudLabel(\nLinkedToAudPtr))
    EndIf
  EndWith
  
  If (bUsingLoopXFade = #False) And (k >= 0)
    With aAud(k)
      For l2 = 0 To \nMaxLoopInfo
        If \aLoopInfo(l2)\nLoopXFadeTime >= 0
          bUsingLoopXFade = #True
          Break
        EndIf
      Next l2
    EndWith
  EndIf
  
  If bUsingLoopXFade
    debugMsg(sProcName, #SCS_END + ", returning " + strB(bUsingLoopXFade))
  EndIf
  ProcedureReturn bUsingLoopXFade
  
EndProcedure

Procedure getLoopInfoIndexForAbsPos(pAudPtr, pAbsPos)
  PROCNAMECA(pAudPtr)
  Protected l2
  Protected nLoopInfoIndex = -1
  
  If pAudPtr >= 0
    With aAud(pAudPtr)
      If \nMaxLoopInfo >= 0
        nLoopInfoIndex = 0
        For l2 = 0 To \nMaxLoopInfo
          If pAbsPos >= \aLoopInfo(l2)\nAbsLoopStart
            nLoopInfoIndex = l2
          EndIf
        Next l2
      EndIf
    EndWith
  EndIf
  ProcedureReturn nLoopInfoIndex
EndProcedure

Procedure sortLoopInfoArray(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected l2, bReordered
  
  debugMsg(sProcName, #SCS_START)
  
  If pAudPtr >= 0
    With aAud(pAudPtr)
      If \nMaxLoopInfo >= 1
        For l2 = 0 To (\nMaxLoopInfo - 1)
          If \aLoopInfo(l2)\nAbsLoopStart > \aLoopInfo(l2+1)\nAbsLoopStart
            bReordered = #True
            Break
          EndIf
        Next l2
        If bReordered
          ; nb Redim array if necessary to remove any dead (null) entries at the end of the array, otherwise SortStructuredArray() would sort these to the start of the array
          If ArraySize(\aLoopInfo()) > \nMaxLoopInfo
            ReDim \aLoopInfo(\nMaxLoopInfo)
          EndIf
          SortStructuredArray(\aLoopInfo(), #PB_Sort_Ascending, OffsetOf(tyLoopInfo\nAbsLoopStart), TypeOf(tyLoopInfo\nAbsLoopStart))
        EndIf
      EndIf
    EndWith
  EndIf
  
  debugMsg(sProcName, #SCS_END + ", returning bReordered=" + strB(bReordered))
  ProcedureReturn bReordered
  
EndProcedure

Procedure listLoopInfoArray(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected l2
  
  If pAudPtr >= 0
    ; debugMsg(sProcName, "\nMaxLoopInfo=" + aAud(pAudPtr)\nMaxLoopInfo + ", \nCurrLoopInfoIndex=" + aAud(pAudPtr)\nCurrLoopInfoIndex)
    If aAud(pAudPtr)\nCurrLoopInfoIndex>= 0
      With aAud(pAudPtr)\rCurrLoopInfo
        debugMsg(sProcName, "\rCurrLoopInfo\nLoopStart=" + \nLoopStart + ", \nLoopEnd=" + \nLoopEnd + ", \nAbsLoopStart=" + \nAbsLoopStart + ", \nAbsLoopEnd=" + \nAbsLoopEnd +
                            ", \nLoopXFadeTime=" + \nLoopXFadeTime + ", \bLoopReleased=" + strB(\bLoopReleased))
      EndWith
    EndIf
    For l2 = 0 To aAud(pAudPtr)\nMaxLoopInfo
      With aAud(pAudPtr)\aLoopInfo(l2)
        debugMsg(sProcName, "\aLoopInfo(" + l2 + ")\nLoopStart=" + \nLoopStart + ", \nLoopEnd=" + \nLoopEnd + ", \nAbsLoopStart=" + \nAbsLoopStart + ", \nAbsLoopEnd=" + \nAbsLoopEnd +
                            ", \nLoopXFadeTime=" + \nLoopXFadeTime + ", \bLoopReleased=" + strB(\bLoopReleased))
        If gbUseBASS
          debugMsg(sProcName, "\aLoopInfo(" + l2 + ")\nBassLoopSyncStart=" + decodeHandle(\nBassLoopSyncStart) + ", \nBassLoopSyncMixTime=" + decodeHandle(\nBassLoopSyncMixTime) +
                              ", \nBassLoopSyncHearXFade=" + decodeHandle(\nBassLoopSyncHearXFade) + ", \nBassLoopSyncHearLE=" + decodeHandle(\nBassLoopSyncHearLE) +
                              ", \nBassLoopSyncHearBoth=" + decodeHandle(\nBassLoopSyncHearBoth))
          debugMsg(sProcName, "\aLoopInfo(" + l2 + ")\nBassAltLoopSyncStart=" + decodeHandle(\nBassAltLoopSyncStart) + ", \nBassAltLoopSyncMixTime=" + decodeHandle(\nBassAltLoopSyncMixTime) +
                              ", \nBassAltLoopSyncHearXFade=" + decodeHandle(\nBassAltLoopSyncHearXFade) + ", \nBassAltLoopSyncHearLE=" + decodeHandle(\nBassAltLoopSyncHearLE) +
                              ", \nBassAltLoopSyncHearBoth=" + decodeHandle(\nBassAltLoopSyncHearBoth))
        ElseIf gbUseSMS
          debugMsg(sProcName, "\nSMSLoopSyncPointIndex1=" + \nSMSLoopSyncPointIndex1 + ", \nSMSLoopSyncPointIndex2=" + \nSMSLoopSyncPointIndex2)
        EndIf
      EndWith
    Next l2
  EndIf
  
EndProcedure

Procedure anyAudPlaying()
  ; PROCNAMEC()
  Protected k, nAudState
  Protected nAudPtrPlaying = -1
  
  For k = 1 To gnLastAud
    nAudState = aAud(k)\nAudState
    If (nAudState >= #SCS_CUE_FADING_IN) And (nAudState <= #SCS_CUE_FADING_OUT)
      If (nAudState <> #SCS_CUE_HIBERNATING) And (nAudState <> #SCS_CUE_PAUSED)
        nAudPtrPlaying = k
        Break
      EndIf
    EndIf
  Next k
  
  ; debugMsg(sProcName, "nAudPtrPlaying=" + getAudLabel(nAudPtrPlaying))
  ProcedureReturn nAudPtrPlaying
EndProcedure

Procedure resetAndRestartSub(pSubPtr)
  PROCNAMECS(pSubPtr)
  Protected k
  Protected nStartTrackNo = -1
  
  debugMsg(sProcName, #SCS_START)
  
  debugMsg(sProcName, "calling stopOneSub(" + getSubLabel(pSubPtr) + ", 'ALL', #True, #False, #False)")
  stopOneSub(pSubPtr, "ALL", #True, #False, #False)
  
  With aSub(pSubPtr)
    k = \nFirstPlayIndex
    If k >= 0
      nStartTrackNo = aAud(k)\nAudNo
    EndIf
    debugMsg(sProcName, "aSub(pSubPtr)\nFirstPlayIndex=" + getAudLabel(\nFirstPlayIndex) + ", nStartTrackNo=" + nStartTrackNo)
;     debugMsg(sProcName, "setting \nCurrPlayIndex=" + getAudLabel(grSubDef\nCurrPlayIndex) + ", (was " + getAudLabel(\nCurrPlayIndex) + ")")
;     \nCurrPlayIndex = grSubDef\nCurrPlayIndex
  EndWith
  
  debugMsg(sProcName, "calling playSub(" + getSubLabel(pSubPtr) + ", 0, #False, #False, -1, -1, " + nStartTrackNo + ")")
  playSub(pSubPtr, 0, #False, #False, -1, -1, nStartTrackNo)
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure DevFailSyncProc(Handle.l, channel.l, nData, user)
  PROCNAME("DevFailSyncProc handle=" + decodeHandle(Handle) + ", channel=" + decodeHandle(channel) + ", user=" + getAudLabel(user))
  Protected nBassDevice.l, nBassResult.l
  
  debugMsg(sProcName, #SCS_START)
  
  nBassDevice = BASS_GetDevice()
  nBassResult = BASS_Start()
  debugMsg2(sProcName, "BASS_Start for device " + nBassDevice, nBassResult)
  
  debugMsg(sProcName, #SCS_END)
  
EndProcedure

Procedure countVidCapDevs(*rProd.tyProd)
  ; counts the number of video capture devices (eg video cameras) specified in production properties
  PROCNAMEC()
  Protected nVidCapDevs, d
  
  If grLicInfo\nMaxVidCapDevPerProd > 0
    For d = 0 To *rProd\nMaxVidCapLogicalDev
      If Trim(*rProd\aVidCapLogicalDevs(d)\sLogicalDev)
        nVidCapDevs + 1
      EndIf
    Next d
  EndIf
  ProcedureReturn nVidCapDevs
EndProcedure

Procedure.l getBassChannelForAud(pAudPtr)
  ; PROCNAMECA(pAudPtr)
  Protected nChannel.l
  
  If pAudPtr >= 0
    With aAud(pAudPtr)
      If gbUseBASSMixer
        If \bAudUseGaplessStream
          nChannel = \nSourceChannel
        Else
          nChannel = \nBassChannel[\nFirstSoundingDev]
        EndIf
      Else
        If \bUsingSplitStream
          nChannel = \nBassChannel[\nFirstSoundingDev]
        Else
          nChannel = \nSourceChannel
        EndIf
      EndIf
    EndWith
  EndIf
  ProcedureReturn nChannel
EndProcedure

Procedure getAudPlayingPos(pAudPtr)
  Protected nAudState, nPlayingPos
  
  With aAud(pAudPtr)
    If \bAudTypeF And \nPlayingPos >= 0 ; Added bAudTypeF test 28Aug2021 11.8.6ae
      ; \nPlayingPos is ONLY set after a call to BASS_ChannelGetPosition etc, so is always accurate
      nAudState = \nAudState
      If nAudState >= #SCS_CUE_FADING_IN And nAudState <= #SCS_CUE_FADING_OUT And nAudState <> #SCS_CUE_PAUSED And nAudState <> #SCS_CUE_HIBERNATING
        nPlayingPos = \nPlayingPos
      Else
        nPlayingPos = \nRelFilePos
      EndIf
    Else
      ; if \nPlayingPos < 0 (which is the default) then \nPlayingPos has not been set, eg because this is a live input aAud, so use \nRelFilePos which is an SCS-calculated position
      nPlayingPos = \nRelFilePos
    EndIf
  EndWith
  ProcedureReturn nPlayingPos
EndProcedure

Procedure isTempoEtcInUse()
  PROCNAMEC()
  Protected bTempoEtcInUse, i, j, k
  
  For i = 1 To gnLastCue
    If aCue(i)\bCueEnabled
      If aCue(i)\bSubTypeF Or aCue(i)\bSubTypeL
        j = aCue(i)\nFirstSubIndex
        While j >= 0
          If aSub(j)\bSubEnabled
            If aSub(j)\bSubTypeF
              k = aSub(j)\nFirstAudIndex
              If aAud(k)\nAudTempoEtcAction <> grAudDef\nAudTempoEtcAction Or aAud(k)\fAudTempoEtcValue <> grAudDef\fAudTempoEtcValue
                bTempoEtcInUse = #True
                debugMsg(sProcName, "bTempoEtcInUse=" + strB(bTempoEtcInUse) + ", aAud(" + getAudLabel(k) + ")\nAudTempoEtcAction=" + aAud(k)\nAudTempoEtcAction + ", \fAudTempoEtcValue=" + aAud(k)\fAudTempoEtcValue)
                Break 2 ; Break j, i
              EndIf
            ElseIf aSub(j)\bSubTypeL
              Select aSub(j)\nLCAction
                Case #SCS_LC_ACTION_TEMPO, #SCS_LC_ACTION_PITCH, #SCS_LC_ACTION_FREQ
                  bTempoEtcInUse = #True
                  debugMsg(sProcName, "bTempoEtcInUse=" + StrB(bTempoEtcInUse) + ", aSub(" + getSubLabel(j) + ")\nLCAction=" + decodeLCAction(aSub(j)\nLCAction))
                  Break 2 ; Break j, i
              EndSelect
            EndIf
          EndIf
          j = aSub(j)\nNextSubIndex
        Wend
      EndIf
    EndIf
  Next i
  ProcedureReturn bTempoEtcInUse
  
EndProcedure

Procedure setAudTempoChannelReqd(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected bTempoChannelReqd
  Protected i, j
  
  With aAud(pAudPtr)
    If \nAudTempoEtcAction <> grAudDef\nAudTempoEtcAction Or \fAudTempoEtcValue <> grAudDef\fAudTempoEtcValue
      bTempoChannelReqd = #True
      debugMsg(sProcName, "bTempoChannelReqd=" + strB(bTempoChannelReqd) + ", \nAudTempoEtcAction=" + \nAudTempoEtcAction + ", \fAudTempoEtcValue=" + \fAudTempoEtcValue)
    EndIf
    If bTempoChannelReqd = #False
      For i = 1 To gnLastCue
        If aCue(i)\bCueEnabled And aCue(i)\bSubTypeL
          j = aCue(i)\nFirstSubIndex
          While j >= 0
            If aSub(j)\bSubEnabled And aSub(j)\bSubTypeL
              Select aSub(j)\nLCAction
                Case #SCS_LC_ACTION_TEMPO, #SCS_LC_ACTION_PITCH, #SCS_LC_ACTION_FREQ
                  If aSub(j)\nLCAudPtr = pAudPtr
                    bTempoChannelReqd = #True
                    debugMsg(sProcName, "bTempoChannelReqd=" + StrB(bTempoChannelReqd) + ", aSub(" + getSubLabel(j) + ")\nLCAction=" + decodeLCAction(aSub(j)\nLCAction))
                    Break 2 ; Break j, i
                  EndIf
              EndSelect
            EndIf
            j = aSub(j)\nNextSubIndex
          Wend
        EndIf
      Next i
    EndIf
    \bTempoChannelReqd = bTempoChannelReqd
  EndWith
  
EndProcedure

Procedure setAudTempoEtcForLvlChgSub(pSubPtr, bIgnoreActionTime=#False)
  PROCNAMECS(pSubPtr)
  Protected nLCAudPtr, nLCAction, fLCActionValue.f, nLCActionTime.l
  Protected nBassResult.l, nErrorCode.l, nAttribute.l, sAttribute.s, fAttributeValue.f
  Protected nTempoEtcAction, fReqdSpeed.f, fFadeTime.f
  
  ; debugMsg(sProcName, #SCS_START + ", bIgnoreActionTime=" + strB(bIgnoreActionTime))
  
  With aSub(pSubPtr)
    nLCAudPtr = \nLCAudPtr
    nLCAction = \nLCAction
    fLCActionValue = \fLCActionValue
    If bIgnoreActionTime
      ; bIgnoreActionTime is set #True when called from the editor with WQL\chkPlayAtReqdLvlAndPan selected, ie 'play at required freq, tempo or pitch'
      nLCActionTime = 0
    Else
      nLCActionTime = \nLCActionTime
    EndIf
    debugMsg(sProcName, "nLCAudPtr=" + getAudLabel(nLCAudPtr) + ", nLCAction=" + decodeLCAction(nLCAction) + ", fLCActionValue=" + StrF(fLCActionValue,3) + ", nLCActionTime=" + nLCActionTime)
  EndWith
  
  If nLCAudPtr >= 0
    With aAud(nLCAudPtr)
      If gbUseBASS
        debugMsg(sProcName, "aAud(" + getAudLabel(nLCAudPtr) + ")\bTempoChannelCreated=" + strB(\bTempoChannelCreated))
        If \bTempoChannelCreated
          Select nLCAction
            Case #SCS_LC_ACTION_FREQ
              nAttribute = #BASS_ATTRIB_TEMPO_FREQ
              sAttribute = "#BASS_ATTRIB_TEMPO_FREQ"
              fAttributeValue = \nSampleRate * fLCActionValue
              ; Apply limits specified in BASS_FX documentation
              If fAttributeValue < (\nSampleRate / 20.0) ; ie 5% of the original sample rate
                fAttributeValue = (\nSampleRate / 20.0)
              ElseIf fAttributeValue > (\nSampleRate * 50.0) ; ie 5000% of the original sample rate
                fAttributeValue = (\nSampleRate * 50.0)
              EndIf
              
            Case #SCS_LC_ACTION_TEMPO
              nAttribute = #BASS_ATTRIB_TEMPO
              sAttribute = "#BASS_ATTRIB_TEMPO"
              ; Example from BASS_FX documentation: float tempo = (goalBPM / bpmValue - 1.0f) * 100.0f;
              ; fAttributeValue = ((fLCActionValue / 1.0) - 1.0) * 100.0
              fAttributeValue = (fLCActionValue - 1.0) * 100.0 ; not necessary to include "/ 1.0"!
              ; Apply limits specified in BASS_FX documentation
              If fAttributeValue < -95.0
                fAttributeValue = -95.0
              ElseIf fAttributeValue > 5000.0
                fAttributeValue = 5000.0
              EndIf
              
            Case #SCS_LC_ACTION_PITCH
              nAttribute = #BASS_ATTRIB_TEMPO_PITCH
              sAttribute = "#BASS_ATTRIB_TEMPO_PITCH"
              fAttributeValue = fLCActionValue
              ; Apply limits specified in BASS_FX documentation
              If fAttributeValue < -60.0
                fAttributeValue = -60.0
              ElseIf fAttributeValue > 60.0
                fAttributeValue = 60.0
              EndIf
              
          EndSelect
          If nLCActionTime <= 0
            nBassResult = BASS_ChannelSetAttribute(\nSourceChannel, nAttribute, fAttributeValue)
            debugMsg2(sProcName, "BASS_ChannelSetAttribute(" + decodeHandle(\nSourceChannel) + ", " + sAttribute + ", " + StrF(fAttributeValue) + ")", nBassResult)
            If nBassResult = 0
              nErrorCode = BASS_ErrorGetCode()
              debugMsg3(sProcName, "Error: " + getBassErrorDesc(nErrorCode))
            EndIf
          Else
            nBassResult = BASS_ChannelSlideAttribute(\nSourceChannel, nAttribute, fAttributeValue, nLCActionTime)
            debugMsg2(sProcName, "BASS_ChannelSlideAttribute(" + decodeHandle(\nSourceChannel) + ", " + sAttribute + ", " + StrF(fAttributeValue) + ", " + nLCActionTime + ")", nBassResult)
            If nBassResult = 0
              nErrorCode = BASS_ErrorGetCode()
              debugMsg3(sProcName, "Error: " + getBassErrorDesc(nErrorCode))
            EndIf
          EndIf
        EndIf ; EndIf \bTempoChannelCreated
        
      ElseIf gbUseSMS
        If nLCAction = #SCS_LC_ACTION_FREQ
          fReqdSpeed = fLCActionValue ; Speed is expressed in terms of fractions of the original playback speed. A value of 1.0 represents the original speed. 2.0 is double the original speed, and 0.5 is half the original speed.
          ; Apply abitrary limits that equate to the BASS_FX freq limits - same limits applied in openFileForSMS()
          If fReqdSpeed < 0.05
            fReqdSpeed = 0.05
          ElseIf fReqdSpeed > 50
            fReqdSpeed = 50
          EndIf
          If nLCActionTime <= 0
            sendSMSCommand("set chan " + \sSyncPChanList + " track speed " + StrF(fReqdSpeed,3))
          Else
            fFadeTime = nLCActionTime / 1000
            sendSMSCommand("set chan " + \sSyncPChanList + " track speed " + StrF(fReqdSpeed,3) + " fadetime " + StrF(fFadeTime,4))
          EndIf
        EndIf
      EndIf ; End ElseIf gbUseSMS
    EndWith
  EndIf ; EndIf nLCAudPtr >= 0
  
EndProcedure

Procedure setSubStateForEndOfSub(pSubPtr, nReqdNonLinearState)
  ; Procedure added 27Feb2022 11.9.1ac
  PROCNAMECS(pSubPtr)
  
  With aSub(pSubPtr)
    If \bStartedInEditor
      endOfSub(pSubPtr, #SCS_CUE_READY)
    ElseIf aCue(\nCueIndex)\bNonLinearCue
      endOfSub(pSubPtr, nReqdNonLinearState)
    Else
      If aCue(\nCueIndex)\nActivationMethod = #SCS_ACMETH_HK_STEP
        endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
      ElseIf \bHotkey Or \bExtAct Or \bCallableCue
        endOfSub(pSubPtr, #SCS_CUE_READY)
      Else
        endOfSub(pSubPtr, #SCS_CUE_COMPLETED)
      EndIf
    EndIf
  EndWith
  
EndProcedure

Procedure getCurrAudioDriver()
  Protected nDevMapPtr
  Protected nAudioDriver
  
  nDevMapPtr = grProd\nSelectedDevMapPtr
  If nDevMapPtr >= 0
    nAudioDriver = grMaps\aMap(nDevMapPtr)\nAudioDriver
  EndIf
  ProcedureReturn nAudioDriver
EndProcedure

Procedure setDeviceInitialTotalVolWorksIfReqd(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected nFirstSelectedDev, nDevNo, fBVLevel.f
  
  With aAud(pAudPtr)
    If \bDeviceInitialTotalVolWorksSet = #False
      ; only process the following of the initial \fCueTotalVolNow[] levels have not been saved
      nFirstSelectedDev = -1
      For nDevNo = 0 To #SCS_MAX_AUDIO_DEV_PER_AUD_OR_SUB
        If \bDeviceSelected[nDevNo]
          nFirstSelectedDev = nDevNo
          Break
        EndIf
      Next nDevNo
      If nFirstSelectedDev >= 0
        ; only process the following of the initial \fCueTotalVolNow[] levels have not been saved but should now be saved
        For nDevNo = 0 To #SCS_MAX_AUDIO_DEV_PER_AUD_OR_SUB
          ; Changed 6May2024 11.10.2cm
          fBVLevel = \fCueTotalVolNow[nDevNo]
          If fBVLevel < grLevels\fMinBVLevel
            fBVLevel = grLevels\fMinBVLevel
          EndIf
          \fDeviceTotalVolWork[nDevNo] = fBVLevel
          ; End changed 6May2024 11.10.2cm
          ; debugMsg(sProcName, "aAud(" + getAudLabel(pAudPtr) + ")\fDeviceTotalVolWork[" + nDevNo + "]=" + traceLevel(\fDeviceTotalVolWork[nDevNo]))
        Next nDevNo
        \bDeviceInitialTotalVolWorksSet = #True
      Else
        ; one or more devices were previously selected, but now no devices are selected
        \bDeviceInitialTotalVolWorksSet = #False
      EndIf
    EndIf
  EndWith
  
EndProcedure

Procedure listLinkedDevsForAud(pAudPtr)
  PROCNAMECA(pAudPtr)
  Protected d, nLinkedCount
  
  With aAud(pAudPtr)
    For d = 0 To #SCS_MAX_AUDIO_DEV_PER_AUD_OR_SUB
      If \bDeviceSelected[d] And \sLogicalDev[d]
        nLinkedCount + 1
        debugMsg(sProcName, "Linked device: " + \sLogicalDev[d])
      EndIf
    Next d
    If nLinkedCount = 0
      debugMsg(sProcName, "No linked devices")
    EndIf
  EndWith
  
EndProcedure

Procedure.s decodeWasapiNotify(notify.l)
  Protected sNotify.s
  
  Select notify
    Case #BASS_WASAPI_NOTIFY_ENABLED
      sNotify = "The device has been enabled."
    Case #BASS_WASAPI_NOTIFY_DISABLED
      sNotify = "The device has been disabled/disconnected."
    Case #BASS_WASAPI_NOTIFY_DEFINPUT
      sNotify = "The device is now the default input device."
    Case #BASS_WASAPI_NOTIFY_DEFOUTPUT
      sNotify = "The device is now the default output device."
    Case #BASS_WASAPI_NOTIFY_FAIL
      sNotify = "The device has failed and been stopped. If the device is still enabled and shared mode was being used, then it may be that the device's sample format has changed. It can be freed and reinitialized, with BASS_WASAPI_Free and BASS_WASAPI_Init, to resume in that case. "
    Default
      sNotify = Str(notify)
  EndSelect
  ProcedureReturn sNotify
EndProcedure

Procedure.s decodeWasapiDevType(type.l)
  Protected sType.s
  
  Select type
    Case #BASS_WASAPI_TYPE_NETWORKDEVICE
      sType = "Network Device"
    Case #BASS_WASAPI_TYPE_SPEAKERS
      sType = "Speakers"
    Case #BASS_WASAPI_TYPE_LINELEVEL
      sType = "Line-Level"
    Case #BASS_WASAPI_TYPE_HEADPHONES
      sType = "Headphones"
    Case #BASS_WASAPI_TYPE_MICROPHONE
      sType = "Microphone"
    Case #BASS_WASAPI_TYPE_HEADSET
      sType = "Headset"
    Case #BASS_WASAPI_TYPE_HANDSET
      sType = "Handset"
    Case #BASS_WASAPI_TYPE_DIGITAL
      sType = "Digital"
    Case #BASS_WASAPI_TYPE_SPDIF
      sType = "SPDIF"
    Case #BASS_WASAPI_TYPE_HDMI
      sType = "HDMI"
    Case #BASS_WASAPI_TYPE_UNKNOWN
      sType = "Unknown"
    Default
      sType = Str(type)
  EndSelect
  ProcedureReturn sType
EndProcedure

Procedure.s decodeDevFlags(nDevFlags.l)
  PROCNAMEC()
  Protected nHoldFlags.l, nTmp.l
  Protected nTmpFlag.l
  Protected sDevFlags.s
  
  nHoldFlags = nDevFlags
  If nHoldFlags = 0
    ProcedureReturn "0"
  EndIf
  
  decodeFlag(nHoldFlags, #BASS_DEVICE_ENABLED, "|BASS_DEVICE_ENABLED", sDevFlags)
  decodeFlag(nHoldFlags, #BASS_DEVICE_DEFAULT, "|BASS_DEVICE_DEFAULT", sDevFlags)
  decodeFlag(nHoldFlags, #BASS_DEVICE_INIT, "|BASS_DEVICE_INIT", sDevFlags)
  decodeFlag(nHoldFlags, #BASS_DEVICE_INPUT, "|BASS_DEVICE_INPUT", sDevFlags)
  decodeFlag(nHoldFlags, #BASS_DEVICE_LOOPBACK, "|BASS_DEVICE_LOOPBACK", sDevFlags)
  decodeFlag(nHoldFlags, #BASS_DEVICE_UNPLUGGED, "|BASS_DEVICE_UNPLUGGED", sDevFlags)
  decodeFlag(nHoldFlags, #BASS_DEVICE_DISABLED, "|BASS_DEVICE_DISABLED", sDevFlags)
  
  If nHoldFlags <> 0
    sDevFlags + "|$" + Hex(nHoldFlags, #PB_Long)
    nHoldFlags = 0
  EndIf
  
  If Len(sDevFlags) > 2
    sDevFlags = Mid(sDevFlags, 2)
  EndIf
  ProcedureReturn sDevFlags
EndProcedure

Procedure wasapiNotifyProc(notify.l, device.l, *user)
  ; Based on this PB Forum posting by Ian: https://www.un4seen.com/forum/?topic=19759.msg138285#msg138285
  PROCNAMEC()
  Protected wi.BASS_WASAPI_DEVICEINFO
  Protected di.BASS_DEVICEINFO
  Protected a, nBassResult.l
  Protected di_driver.s, di_name.s, wi_id.s, wi_name.s, wi_type.s
  Protected sNotify.s, sDevFlags.s
  
  sNotify = decodeWasapiNotify(notify)
  ; debugMsg0(sProcName, #SCS_START + ", notify=" + sNotify + ", device=" + device)
  
  nBassResult = BASS_WASAPI_GetDeviceInfo(device, @wi) ; get info on changed WASAPI device
  If nBassResult = #False
    debugMsg2(sProcName, "BASS_WASAPI_GetDeviceInfo(" + device + ", @wi)", nBassResult)
    debugMsg(sProcName, "Error: " + getBassErrorDesc(BASS_ErrorGetCode()))
  Else
    wi_id = PeekS(wi\id, -1, #PB_Ascii)
    wi_name = PeekS(wi\name, -1, #PB_Ascii)
    wi_type = decodeWasapiDevType(wi\type)
    ; debugMsg0(sProcName, "wi_id=" + wi_id + ", wi_name=" + wi_name)
    While #True
      a + 1
      nBassResult = BASS_GetDeviceInfo(a, @di)
      ; debugMsg2(sProcName, "BASS_GetDeviceInfo(" + a + ", @di)", nBassResult)
      If nBassResult = #False
        Break
      EndIf
      di_driver = PeekS(di\driver, -1, #PB_Ascii)
      ; debugMsg(sProcName, "di_driver=" + di_driver)
      If di_driver = wi_id
        ; found the corresponding BASS device
        di_name = PeekS(di\name, -1, #PB_Ascii)
        sDevFlags = decodeDevFlags(wi\flags)
        debugMsg0(sProcName, "WASAPI device: " + device + " (" + wi_type + ":" + wi_name + ", flags=" + sDevFlags + "), BASS device: " + a + " (" + di_name + "), notify: " + sNotify)
        ; do something With the notification here
        Break
      EndIf
    Wend
  EndIf
  
  ; debugMsg(sProcName, #SCS_END)
  
EndProcedure

; EOF